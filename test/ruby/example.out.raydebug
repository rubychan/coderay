reserved(module) class(CodeRay)
	reserved(module) class(Scanners)

reserved(class) class(Ruby) operator(<) constant(Scanner)

	constant(RESERVED_WORDS) operator(=) operator([)
		string<delimiter(')content(and)delimiter(')>operator(,) string<delimiter(')content(def)delimiter(')>operator(,) string<delimiter(')content(end)delimiter(')>operator(,) string<delimiter(')content(in)delimiter(')>operator(,) string<delimiter(')content(or)delimiter(')>operator(,) string<delimiter(')content(unless)delimiter(')>operator(,) string<delimiter(')content(begin)delimiter(')>operator(,)
		string<delimiter(')content(defined?)delimiter(')>operator(,) string<delimiter(')content(ensure)delimiter(')>operator(,) string<delimiter(')content(module)delimiter(')>operator(,) string<delimiter(')content(redo)delimiter(')>operator(,) string<delimiter(')content(super)delimiter(')>operator(,) string<delimiter(')content(until)delimiter(')>operator(,)
		string<delimiter(')content(BEGIN)delimiter(')>operator(,) string<delimiter(')content(break)delimiter(')>operator(,) string<delimiter(')content(do)delimiter(')>operator(,) string<delimiter(')content(next)delimiter(')>operator(,) string<delimiter(')content(rescue)delimiter(')>operator(,) string<delimiter(')content(then)delimiter(')>operator(,)
		string<delimiter(')content(when)delimiter(')>operator(,) string<delimiter(')content(END)delimiter(')>operator(,) string<delimiter(')content(case)delimiter(')>operator(,) string<delimiter(')content(else)delimiter(')>operator(,) string<delimiter(')content(for)delimiter(')>operator(,) string<delimiter(')content(retry)delimiter(')>operator(,)
		string<delimiter(')content(while)delimiter(')>operator(,) string<delimiter(')content(alias)delimiter(')>operator(,) string<delimiter(')content(class)delimiter(')>operator(,) string<delimiter(')content(elsif)delimiter(')>operator(,) string<delimiter(')content(if)delimiter(')>operator(,) string<delimiter(')content(not)delimiter(')>operator(,) string<delimiter(')content(return)delimiter(')>operator(,)
		string<delimiter(')content(undef)delimiter(')>operator(,) string<delimiter(')content(yield)delimiter(')>operator(,)
	operator(])

	constant(DEF_KEYWORDS) operator(=) operator([)string<delimiter(')content(def)delimiter(')>operator(])
	constant(MODULE_KEYWORDS) operator(=) operator([)string<delimiter(')content(class)delimiter(')>operator(,) string<delimiter(')content(module)delimiter(')>operator(])
	constant(DEF_NEW_STATE) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:initial)operator(\))operator(.)
		ident(add)operator(()constant(DEF_KEYWORDS)operator(,) symbol(:def_expected)operator(\))operator(.)
		ident(add)operator(()constant(MODULE_KEYWORDS)operator(,) symbol(:module_expected)operator(\))

	constant(WORDS_ALLOWING_REGEXP) operator(=) operator([)
		string<delimiter(')content(and)delimiter(')>operator(,) string<delimiter(')content(or)delimiter(')>operator(,) string<delimiter(')content(not)delimiter(')>operator(,) string<delimiter(')content(while)delimiter(')>operator(,) string<delimiter(')content(until)delimiter(')>operator(,) string<delimiter(')content(unless)delimiter(')>operator(,) string<delimiter(')content(if)delimiter(')>operator(,) string<delimiter(')content(elsif)delimiter(')>operator(,) string<delimiter(')content(when)delimiter(')>
	operator(])
	constant(REGEXP_ALLOWED) operator(=) constant(WordList)operator(.)ident(new)operator(()pre_constant(false)operator(\))operator(.)
		ident(add)operator(()constant(WORDS_ALLOWING_REGEXP)operator(,) symbol(:set)operator(\))

	constant(PREDEFINED_CONSTANTS) operator(=) operator([)
		string<delimiter(')content(nil)delimiter(')>operator(,) string<delimiter(')content(true)delimiter(')>operator(,) string<delimiter(')content(false)delimiter(')>operator(,) string<delimiter(')content(self)delimiter(')>operator(,)
		string<delimiter(')content(DATA)delimiter(')>operator(,) string<delimiter(')content(ARGV)delimiter(')>operator(,) string<delimiter(')content(ARGF)delimiter(')>operator(,) string<delimiter(')content(__FILE__)delimiter(')>operator(,) string<delimiter(')content(__LINE__)delimiter(')>operator(,)
	operator(])

	constant(IDENT_KIND) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)
		ident(add)operator(()constant(RESERVED_WORDS)operator(,) symbol(:reserved)operator(\))operator(.)
		ident(add)operator(()constant(PREDEFINED_CONSTANTS)operator(,) symbol(:pre_constant)operator(\))

	constant(METHOD_NAME) operator(=) regexp<delimiter(/)content( )inline<delimiter(#{)constant(IDENT)delimiter(})>content( [?!]? )delimiter(/)modifier(xo)>
	constant(METHOD_NAME_EX) operator(=) regexp<delimiter(/)content(
	 )inline<delimiter(#{)constant(METHOD_NAME)delimiter(})>content(  # common methods: split, foo=, empty?, gsub!
	 | )char(\\*)char(\\*)content(?         # multiplication and power
	 | [-+~]@?       # plus, minus
	 | [)char(\\/)content(%&|^`]     # division, modulo or format strings, &and, |or, ^xor, `system`
	 | )char(\\[)char(\\])content(=?        # array getter and setter
	 | <=?>? | >=?   # comparison, rocket operator
	 | << | >>       # append or shift left, shift right
	 | ===?          # simple equality and case equality
	)delimiter(/)modifier(ox)>
	constant(GLOBAL_VARIABLE) operator(=) regexp<delimiter(/)content( )char(\\$)content( (?: )inline<delimiter(#{)constant(IDENT)delimiter(})>content( | )char(\\d)content(+ | [~&+`'=)char(\\/)content(,;_.<>!@0$?*":F)char(\\\\)content(] | -[a-zA-Z_0-9] \) )delimiter(/)modifier(ox)>

	constant(DOUBLEQ) operator(=) regexp<delimiter(/)content( "  [^")char(\\#)char(\\\\)content(]*  (?: (?: )char(\\#)char(\\{)content(.*?)char(\\})content( | )char(\\#)content((?:$"\)?  | )char(\\\\)content(. \) [^")char(\\#)char(\\\\)content(]*  \)* "?  )delimiter(/)modifier(ox)>
	constant(SINGLEQ) operator(=) regexp<delimiter(/)content( '  [^')char(\\\\)content(]*    (?:                              )char(\\\\)content(.   [^')char(\\\\)content(]*    \)* '?  )delimiter(/)modifier(ox)>
	constant(STRING)  operator(=) regexp<delimiter(/)content( )inline<delimiter(#{)constant(SINGLEQ)delimiter(})>content( | )inline<delimiter(#{)constant(DOUBLEQ)delimiter(})>content( )delimiter(/)modifier(ox)>
	constant(SHELL)   operator(=) regexp<delimiter(/)content( `  [^`)char(\\#)char(\\\\)content(]*  (?: (?: )char(\\#)char(\\{)content(.*?)char(\\})content( | )char(\\#)content((?:$`\)?  | )char(\\\\)content(. \) [^`)char(\\#)char(\\\\)content(]*  \)* `?  )delimiter(/)modifier(ox)>
	constant(REGEXP)  operator(=) regexp<delimiter(/)content( )char(\\/)content( [^)char(\\/)char(\\#)char(\\\\)content(]* (?: (?: )char(\\#)char(\\{)content(.*?)char(\\})content( | )char(\\#)content((?:$)char(\\/)content(\)? | )char(\\\\)content(. \) [^)char(\\/)char(\\#)char(\\\\)content(]* \)* )char(\\/)content(? )delimiter(/)modifier(ox)>

	constant(DECIMAL) operator(=) regexp<delimiter(/)char(\\d)content(+(?:_)char(\\d)content(+\)*)delimiter(/)>  comment(# doesn't recognize 09 as octal error)
	constant(OCTAL) operator(=) regexp<delimiter(/)content(0_?[0-7]+(?:_[0-7]+\)*)delimiter(/)>
	constant(HEXADECIMAL) operator(=) regexp<delimiter(/)content(0x[0-9A-Fa-f]+(?:_[0-9A-Fa-f]+\)*)delimiter(/)>
	constant(BINARY) operator(=) regexp<delimiter(/)content(0b[01]+(?:_[01]+\)*)delimiter(/)>

	constant(EXPONENT) operator(=) regexp<delimiter(/)content( [eE] [+-]? )inline<delimiter(#{)constant(DECIMAL)delimiter(})>content( )delimiter(/)modifier(ox)>
	constant(FLOAT) operator(=) regexp<delimiter(/)content( )inline<delimiter(#{)constant(DECIMAL)delimiter(})>content( (?: )inline<delimiter(#{)constant(EXPONENT)delimiter(})>content( | )char(\\.)content( )inline<delimiter(#{)constant(DECIMAL)delimiter(})>content( )inline<delimiter(#{)constant(EXPONENT)delimiter(})>content(? \) )delimiter(/)>
	constant(INTEGER) operator(=) regexp<delimiter(/)inline<delimiter(#{)constant(OCTAL)delimiter(})>content(|)inline<delimiter(#{)constant(HEXADECIMAL)delimiter(})>content(|)inline<delimiter(#{)constant(BINARY)delimiter(})>content(|)inline<delimiter(#{)constant(DECIMAL)delimiter(})>delimiter(/)>

	reserved(def) method(reset)
		reserved(super)
		instance_variable(@regexp_allowed) operator(=) pre_constant(false)
	reserved(end)

	reserved(def) method(next_token)
		reserved(return) reserved(if) instance_variable(@scanner)operator(.)ident(eos?)

		ident(kind) operator(=) symbol(:error)
		reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(\))  comment(# in every state)
			ident(kind) operator(=) symbol(:space)
			instance_variable(@regexp_allowed) operator(=) symbol(:set) reserved(if) instance_variable(@regexp_allowed) reserved(or) instance_variable(@scanner)operator(.)ident(matched)operator(.)ident(index)operator(()integer(?\\n)operator(\))  comment(# delayed flag setting)

		reserved(elsif) instance_variable(@state) operator(==) symbol(:def_expected)
			reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( (?: (?:)inline<delimiter(#{)constant(IDENT)delimiter(})>content((?:)char(\\.)content(|::\)\)* | (?:@@?|$\)? )inline<delimiter(#{)constant(IDENT)delimiter(})>content((?:)char(\\.)content(|::\) \) )inline<delimiter(#{)constant(METHOD_NAME_EX)delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))
				ident(kind) operator(=) symbol(:method)
				instance_variable(@state) operator(=) symbol(:initial)
			reserved(else)
				instance_variable(@scanner)operator(.)ident(getch)
			reserved(end)
			instance_variable(@state) operator(=) symbol(:initial)

		reserved(elsif) instance_variable(@state) operator(==) symbol(:module_expected)
			reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(<<)delimiter(/)>operator(\))
				ident(kind) operator(=) symbol(:operator)
			reserved(else)
				reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( (?: )inline<delimiter(#{)constant(IDENT)delimiter(})>content( (?:)char(\\.)content(|::\)\)* )inline<delimiter(#{)constant(IDENT)delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))
					ident(kind) operator(=) symbol(:method)
				reserved(else)
					instance_variable(@scanner)operator(.)ident(getch)
				reserved(end)
				instance_variable(@state) operator(=) symbol(:initial)
			reserved(end)

		reserved(elsif) comment(# state == :initial)
			comment(# IDENTIFIERS, KEYWORDS)
			reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(GLOBAL_VARIABLE)operator(\))
				ident(kind) operator(=) symbol(:global_variable)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( @@ )inline<delimiter(#{)constant(IDENT)delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))
				ident(kind) operator(=) symbol(:class_variable)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( @ )inline<delimiter(#{)constant(IDENT)delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))
				ident(kind) operator(=) symbol(:instance_variable)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( __END__)char(\\n)content( ( (?!)char(\\#)content(CODE)char(\\#)content(\) .* \)? | )char(\\#)content([^)char(\\n)content(]* | =begin(?=)char(\\s)content(\).*? )char(\\n)content(=end(?=)char(\\s)content(|)char(\\z)content(\)(?:[^)char(\\n)content(]*\)? )delimiter(/)modifier(mx)>operator(\))
				ident(kind) operator(=) symbol(:comment)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(METHOD_NAME)operator(\))
				reserved(if) instance_variable(@last_token_dot)
					ident(kind) operator(=) symbol(:ident)
				reserved(else)
					ident(matched) operator(=) instance_variable(@scanner)operator(.)ident(matched)
					ident(kind) operator(=) constant(IDENT_KIND)operator([)ident(matched)operator(])
					reserved(if) ident(kind) operator(==) symbol(:ident) reserved(and) ident(matched) operator(=)operator(~) regexp<delimiter(/)content(^[A-Z])delimiter(/)>
						ident(kind) operator(=) symbol(:constant)
					reserved(elsif) ident(kind) operator(==) symbol(:reserved)
						instance_variable(@state) operator(=) constant(DEF_NEW_STATE)operator([)ident(matched)operator(])
						instance_variable(@regexp_allowed) operator(=) constant(REGEXP_ALLOWED)operator([)ident(matched)operator(])
					reserved(end)
				reserved(end)

			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(STRING)operator(\))
				ident(kind) operator(=) symbol(:string)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(SHELL)operator(\))
				ident(kind) operator(=) symbol(:shell)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(<<
				(?:
					([a-zA-Z_0-9]+\)
						(?: .*? ^)char(\\1)content($ | .* \)
				|
					-([a-zA-Z_0-9]+\)
						(?: .*? ^)char(\\s)content(*)char(\\2)content($ | .* \)
				|
					([")char(\\')content(`]\) (.+?\) )char(\\3)content(
						(?: .*? ^)char(\\4)content($ | .* \)
				|
					- ([")char(\\')content(`]\) (.+?\) )char(\\5)content(
						(?: .*? ^)char(\\s)content(*)char(\\6)content($ | .* \)
				\)
			)delimiter(/)modifier(mxo)>operator(\))
				ident(kind) operator(=) symbol(:string)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\/)delimiter(/)>operator(\)) reserved(and) instance_variable(@regexp_allowed)
				instance_variable(@scanner)operator(.)ident(unscan)
				instance_variable(@scanner)operator(.)ident(scan)operator(()constant(REGEXP)operator(\))
				ident(kind) operator(=) symbol(:regexp)
regexp<delimiter(/)content(%(?:[Qqxrw](?:)char(\\()content([^\)#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^\)#)char(\\\\)char(\\\\)content(]*\)*)char(\\\))content(?|)char(\\[)content([^)char(\\])content(#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^)char(\\])content(#)char(\\\\)char(\\\\)content(]*\)*)char(\\])content(?|)char(\\{)content([^}#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^}#)char(\\\\)char(\\\\)content(]*\)*)char(\\})content(?|<[^>#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^>#)char(\\\\)char(\\\\)content(]*\)*>?|([^a-zA-Z)char(\\\\)char(\\\\)content(]\)(?:(?!)char(\\1)content(\)[^#)char(\\\\)char(\\\\)content(]\)*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)(?:(?!)char(\\1)content(\)[^#)char(\\\\)char(\\\\)content(]\)*\)*)char(\\1)content(?\)|)char(\\()content([^\)#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^\)#)char(\\\\)char(\\\\)content(]*\)*)char(\\\))content(?|)char(\\[)content([^)char(\\])content(#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^)char(\\])content(#)char(\\\\)char(\\\\)content(]*\)*)char(\\])content(?|)char(\\{)content([^}#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^}#)char(\\\\)char(\\\\)content(]*\)*)char(\\})content(?|<[^>#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^>#)char(\\\\)char(\\\\)content(]*\)*>?|([^a-zA-Z)char(\\s)char(\\\\)char(\\\\)content(]\)(?:(?!)char(\\2)content(\)[^#)char(\\\\)char(\\\\)content(]\)*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)(?:(?!)char(\\2)content(\)[^#)char(\\\\)char(\\\\)content(]\)*\)*)char(\\2)content(?|)char(\\\\)char(\\\\)content([^#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#\)[^#)char(\\\\)char(\\\\)content(]*\)*)char(\\\\)char(\\\\)content(?\))delimiter(/)>
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(:(?:)inline<delimiter(#{)constant(GLOBAL_VARIABLE)delimiter(})>content(|)inline<delimiter(#{)constant(METHOD_NAME_EX)delimiter(})>content(|)inline<delimiter(#{)constant(STRING)delimiter(})>content(\))delimiter(/)modifier(ox)>operator(\))
				ident(kind) operator(=) symbol(:symbol)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(
				)char(\\?)content( (?:
					[^)char(\\s)char(\\\\)content(]
				|
					)char(\\\\)content( (?:M-)char(\\\\)content(C-|C-)char(\\\\)content(M-|M-)char(\\\\)content(c|c)char(\\\\)content(M-|c|C-|M-\)\)? (?: )char(\\\\)content( (?: . | [0-7]{3} | x[0-9A-Fa-f][0-9A-Fa-f] \)
				\)
			)delimiter(/)modifier(mox)>operator(\))
				ident(kind) operator(=) symbol(:integer)

			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( [-+*)char(\\/)content(%=<>;,|&!(\))char(\\[)char(\\])content({}~?] | )char(\\.)char(\\.)content(?)char(\\.)content(? | ::? )delimiter(/)modifier(x)>operator(\))
				ident(kind) operator(=) symbol(:operator)
				instance_variable(@regexp_allowed) operator(=) symbol(:set) reserved(if) instance_variable(@scanner)operator(.)ident(matched)operator([)operator(-)integer(1)operator(,)integer(1)operator(]) operator(=)operator(~) regexp<delimiter(/)content([~=!<>|&^,)char(\\()char(\\[)content(+)char(\\-)char(\\/)char(\\*)content(%])char(\\z)delimiter(/)>
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(FLOAT)operator(\))
				ident(kind) operator(=) symbol(:float)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(INTEGER)operator(\))
				ident(kind) operator(=) symbol(:integer)
			reserved(else)
				instance_variable(@scanner)operator(.)ident(getch)
			reserved(end)
		reserved(end)

		ident(token) operator(=) constant(Token)operator(.)ident(new) instance_variable(@scanner)operator(.)ident(matched)operator(,) ident(kind)

		reserved(if) ident(kind) operator(==) symbol(:regexp)
			ident(token)operator(.)ident(text) operator(<<) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content([eimnosux]*)delimiter(/)>operator(\))
		reserved(end)

		instance_variable(@regexp_allowed) operator(=) operator(()instance_variable(@regexp_allowed) operator(==) symbol(:set)operator(\))  comment(# delayed flag setting)

		ident(token)
	reserved(end)
reserved(end)

ident(register) constant(Ruby)operator(,) string<delimiter(')content(ruby)delimiter(')>operator(,) string<delimiter(')content(rb)delimiter(')>

	reserved(end)
reserved(end)
reserved(class) class(Set)
  ident(include) constant(Enumerable)

  comment(# Creates a new set containing the given objects.)
  reserved(def) pre_constant(self)operator(.)operator([])operator(()operator(*)ident(ary)operator(\))
    ident(new)operator(()ident(ary)operator(\))
  reserved(end)

  comment(# Creates a new set containing the elements of the given enumerable)
  comment(# object.)
  comment(#)
  comment(# If a block is given, the elements of enum are preprocessed by the)
  comment(# given block.)
  reserved(def) method(initialize)operator(()ident(enum) operator(=) pre_constant(nil)operator(,) operator(&)ident(block)operator(\)) comment(# :yields: o)
    instance_variable(@hash) operator(||=) constant(Hash)operator(.)ident(new)

    ident(enum)operator(.)ident(nil?) reserved(and) reserved(return)

    reserved(if) ident(block)
      ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) ident(add)operator(()ident(block)operator([)ident(o)operator(])operator(\)) operator(})
    reserved(else)
      ident(merge)operator(()ident(enum)operator(\))
    reserved(end)
  reserved(end)

  comment(# Copy internal hash.)
  reserved(def) method(initialize_copy)operator(()ident(orig)operator(\))
    instance_variable(@hash) operator(=) ident(orig)operator(.)ident(instance_eval)operator({)instance_variable(@hash)operator(})operator(.)ident(dup)
  reserved(end)

  comment(# Returns the number of elements.)
  reserved(def) method(size)
    instance_variable(@hash)operator(.)ident(size)
  reserved(end)
  reserved(alias) ident(length) ident(size)

  comment(# Returns true if the set contains no elements.)
  reserved(def) method(empty?)
    instance_variable(@hash)operator(.)ident(empty?)
  reserved(end)

  comment(# Removes all elements and returns self.)
  reserved(def) method(clear)
    instance_variable(@hash)operator(.)ident(clear)
    pre_constant(self)
  reserved(end)

  comment(# Replaces the contents of the set with the contents of the given)
  comment(# enumerable object and returns self.)
  reserved(def) method(replace)operator(()ident(enum)operator(\))
    reserved(if) ident(enum)operator(.)ident(class) operator(==) pre_constant(self)operator(.)ident(class)
      instance_variable(@hash)operator(.)ident(replace)operator(()ident(enum)operator(.)ident(instance_eval) operator({) instance_variable(@hash) operator(})operator(\))
    reserved(else)
      ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
      ident(clear)
      ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) ident(add)operator(()ident(o)operator(\)) operator(})
    reserved(end)

    pre_constant(self)
  reserved(end)

  comment(# Converts the set to an array.  The order of elements is uncertain.)
  reserved(def) method(to_a)
    instance_variable(@hash)operator(.)ident(keys)
  reserved(end)

  reserved(def) method(flatten_merge)operator(()ident(set)operator(,) ident(seen) operator(=) constant(Set)operator(.)ident(new)operator(\))
    ident(set)operator(.)ident(each) operator({) operator(|)ident(e)operator(|)
      reserved(if) ident(e)operator(.)ident(is_a?)operator(()constant(Set)operator(\))
	reserved(if) ident(seen)operator(.)ident(include?)operator(()ident(e_id) operator(=) ident(e)operator(.)ident(object_id)operator(\))
	  ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(tried to flatten recursive Set)delimiter(")>
	reserved(end)

	ident(seen)operator(.)ident(add)operator(()ident(e_id)operator(\))
	ident(flatten_merge)operator(()ident(e)operator(,) ident(seen)operator(\))
	ident(seen)operator(.)ident(delete)operator(()ident(e_id)operator(\))
      reserved(else)
	ident(add)operator(()ident(e)operator(\))
      reserved(end)
    operator(})

    pre_constant(self)
  reserved(end)
  ident(protected) symbol(:flatten_merge)

  comment(# Returns a new set that is a copy of the set, flattening each)
  comment(# containing set recursively.)
  reserved(def) method(flatten)
    pre_constant(self)operator(.)ident(class)operator(.)ident(new)operator(.)ident(flatten_merge)operator(()pre_constant(self)operator(\))
  reserved(end)

  comment(# Equivalent to Set#flatten, but replaces the receiver with the)
  comment(# result in place.  Returns nil if no modifications were made.)
  reserved(def) method(flatten!)
    reserved(if) ident(detect) operator({) operator(|)ident(e)operator(|) ident(e)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) operator(})
      ident(replace)operator(()ident(flatten)operator(()operator(\))operator(\))
    reserved(else)
      pre_constant(nil)
    reserved(end)
  reserved(end)

  comment(# Returns true if the set contains the given object.)
  reserved(def) method(include?)operator(()ident(o)operator(\))
    instance_variable(@hash)operator(.)ident(include?)operator(()ident(o)operator(\))
  reserved(end)
  reserved(alias) ident(member?) ident(include?)

  comment(# Returns true if the set is a superset of the given set.)
  reserved(def) method(superset?)operator(()ident(set)operator(\))
    ident(set)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be a set)delimiter(")>
    reserved(return) pre_constant(false) reserved(if) ident(size) operator(<) ident(set)operator(.)ident(size)
    ident(set)operator(.)ident(all?) operator({) operator(|)ident(o)operator(|) ident(include?)operator(()ident(o)operator(\)) operator(})
  reserved(end)

  comment(# Returns true if the set is a proper superset of the given set.)
  reserved(def) method(proper_superset?)operator(()ident(set)operator(\))
    ident(set)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be a set)delimiter(")>
    reserved(return) pre_constant(false) reserved(if) ident(size) operator(<=) ident(set)operator(.)ident(size)
    ident(set)operator(.)ident(all?) operator({) operator(|)ident(o)operator(|) ident(include?)operator(()ident(o)operator(\)) operator(})
  reserved(end)

  comment(# Returns true if the set is a subset of the given set.)
  reserved(def) method(subset?)operator(()ident(set)operator(\))
    ident(set)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be a set)delimiter(")>
    reserved(return) pre_constant(false) reserved(if) ident(set)operator(.)ident(size) operator(<) ident(size)
    ident(all?) operator({) operator(|)ident(o)operator(|) ident(set)operator(.)ident(include?)operator(()ident(o)operator(\)) operator(})
  reserved(end)

  comment(# Returns true if the set is a proper subset of the given set.)
  reserved(def) method(proper_subset?)operator(()ident(set)operator(\))
    ident(set)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be a set)delimiter(")>
    reserved(return) pre_constant(false) reserved(if) ident(set)operator(.)ident(size) operator(<=) ident(size)
    ident(all?) operator({) operator(|)ident(o)operator(|) ident(set)operator(.)ident(include?)operator(()ident(o)operator(\)) operator(})
  reserved(end)

  comment(# Calls the given block once for each element in the set, passing)
  comment(# the element as parameter.)
  reserved(def) method(each)
    instance_variable(@hash)operator(.)ident(each_key) operator({) operator(|)ident(o)operator(|) reserved(yield)operator(()ident(o)operator(\)) operator(})
    pre_constant(self)
  reserved(end)

  comment(# Adds the given object to the set and returns self.  Use +merge+ to)
  comment(# add several elements at once.)
  reserved(def) method(add)operator(()ident(o)operator(\))
    instance_variable(@hash)operator([)ident(o)operator(]) operator(=) pre_constant(true)
    pre_constant(self)
  reserved(end)
  reserved(alias) operator(<<) ident(add)

  comment(# Adds the given object to the set and returns self.  If the)
  comment(# object is already in the set, returns nil.)
  reserved(def) method(add?)operator(()ident(o)operator(\))
    reserved(if) ident(include?)operator(()ident(o)operator(\))
      pre_constant(nil)
    reserved(else)
      ident(add)operator(()ident(o)operator(\))
    reserved(end)
  reserved(end)

  comment(# Deletes the given object from the set and returns self.  Use +subtract+ to)
  comment(# delete several items at once.)
  reserved(def) method(delete)operator(()ident(o)operator(\))
    instance_variable(@hash)operator(.)ident(delete)operator(()ident(o)operator(\))
    pre_constant(self)
  reserved(end)

  comment(# Deletes the given object from the set and returns self.  If the)
  comment(# object is not in the set, returns nil.)
  reserved(def) method(delete?)operator(()ident(o)operator(\))
    reserved(if) ident(include?)operator(()ident(o)operator(\))
      ident(delete)operator(()ident(o)operator(\))
    reserved(else)
      pre_constant(nil)
    reserved(end)
  reserved(end)

  comment(# Deletes every element of the set for which block evaluates to)
  comment(# true, and returns self.)
  reserved(def) method(delete_if)
    instance_variable(@hash)operator(.)ident(delete_if) operator({) operator(|)ident(o)operator(,)operator(|) reserved(yield)operator(()ident(o)operator(\)) operator(})
    pre_constant(self)
  reserved(end)

  comment(# Do collect(\) destructively.)
  reserved(def) method(collect!)
    ident(set) operator(=) pre_constant(self)operator(.)ident(class)operator(.)ident(new)
    ident(each) operator({) operator(|)ident(o)operator(|) ident(set) operator(<<) reserved(yield)operator(()ident(o)operator(\)) operator(})
    ident(replace)operator(()ident(set)operator(\))
  reserved(end)
  reserved(alias) ident(map!) ident(collect!)

  comment(# Equivalent to Set#delete_if, but returns nil if no changes were)
  comment(# made.)
  reserved(def) method(reject!)
    ident(n) operator(=) ident(size)
    ident(delete_if) operator({) operator(|)ident(o)operator(|) reserved(yield)operator(()ident(o)operator(\)) operator(})
    ident(size) operator(==) ident(n) operator(?) pre_constant(nil) operator(:) pre_constant(self)
  reserved(end)

  comment(# Merges the elements of the given enumerable object to the set and)
  comment(# returns self.)
  reserved(def) method(merge)operator(()ident(enum)operator(\))
    reserved(if) ident(enum)operator(.)ident(is_a?)operator(()constant(Set)operator(\))
      instance_variable(@hash)operator(.)ident(update)operator(()ident(enum)operator(.)ident(instance_eval) operator({) instance_variable(@hash) operator(})operator(\))
    reserved(else)
      ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
      ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) ident(add)operator(()ident(o)operator(\)) operator(})
    reserved(end)

    pre_constant(self)
  reserved(end)

  comment(# Deletes every element that appears in the given enumerable object)
  comment(# and returns self.)
  reserved(def) method(subtract)operator(()ident(enum)operator(\))
    ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
    ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) ident(delete)operator(()ident(o)operator(\)) operator(})
    pre_constant(self)
  reserved(end)

  comment(# Returns a new set built by merging the set and the elements of the)
  comment(# given enumerable object.)
  reserved(def) method(|)operator(()ident(enum)operator(\))
    ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
    ident(dup)operator(.)ident(merge)operator(()ident(enum)operator(\))
  reserved(end)
  reserved(alias) operator(+) operator(|)		comment(##)
  reserved(alias) ident(union) operator(|)		comment(##)

  comment(# Returns a new set built by duplicating the set, removing every)
  comment(# element that appears in the given enumerable object.)
  reserved(def) method(-)operator(()ident(enum)operator(\))
    ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
    ident(dup)operator(.)ident(subtract)operator(()ident(enum)operator(\))
  reserved(end)
  reserved(alias) ident(difference) operator(-)	comment(##)

  comment(# Returns a new array containing elements common to the set and the)
  comment(# given enumerable object.)
  reserved(def) method(&)operator(()ident(enum)operator(\))
    ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
    ident(n) operator(=) pre_constant(self)operator(.)ident(class)operator(.)ident(new)
    ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) ident(n)operator(.)ident(add)operator(()ident(o)operator(\)) reserved(if) ident(include?)operator(()ident(o)operator(\)) operator(})
    ident(n)
  reserved(end)
  reserved(alias) ident(intersection) operator(&)	comment(##)

  comment(# Returns a new array containing elements exclusive between the set)
  comment(# and the given enumerable object.  (set ^ enum\) is equivalent to)
  comment(# ((set | enum\) - (set & enum\)\).)
  reserved(def) method(^)operator(()ident(enum)operator(\))
    ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
    ident(n) operator(=) ident(dup)
    ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) reserved(if) ident(n)operator(.)ident(include?)operator(()ident(o)operator(\)) reserved(then) ident(n)operator(.)ident(delete)operator(()ident(o)operator(\)) reserved(else) ident(n)operator(.)ident(add)operator(()ident(o)operator(\)) reserved(end) operator(})
    ident(n)
  reserved(end)

  comment(# Returns true if two sets are equal.  The equality of each couple)
  comment(# of elements is defined according to Object#eql?.)
  reserved(def) method(==)operator(()ident(set)operator(\))
    ident(equal?)operator(()ident(set)operator(\)) reserved(and) reserved(return) pre_constant(true)

    ident(set)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) operator(&&) ident(size) operator(==) ident(set)operator(.)ident(size) reserved(or) reserved(return) pre_constant(false)

    ident(hash) operator(=) instance_variable(@hash)operator(.)ident(dup)
    ident(set)operator(.)ident(all?) operator({) operator(|)ident(o)operator(|) ident(hash)operator(.)ident(include?)operator(()ident(o)operator(\)) operator(})
  reserved(end)

  reserved(def) method(hash)	comment(# :nodoc:)
    instance_variable(@hash)operator(.)ident(hash)
  reserved(end)

  reserved(def) method(eql?)operator(()ident(o)operator(\))	comment(# :nodoc:)
    reserved(return) pre_constant(false) reserved(unless) ident(o)operator(.)ident(is_a?)operator(()constant(Set)operator(\))
    instance_variable(@hash)operator(.)ident(eql?)operator(()ident(o)operator(.)ident(instance_eval)operator({)instance_variable(@hash)operator(})operator(\))
  reserved(end)

  comment(# Classifies the set by the return value of the given block and)
  comment(# returns a hash of {value => set of elements} pairs.  The block is)
  comment(# called once for each element of the set, passing the element as)
  comment(# parameter.)
  comment(#)
  comment(# e.g.:)
  comment(#)
  comment(#   require 'set')
  comment(#   files = Set.new(Dir.glob("*.rb"\)\))
  comment(#   hash = files.classify { |f| File.mtime(f\).year })
  comment(#   p hash    # => {2000=>#<Set: {"a.rb", "b.rb"}>,)
  comment(#             #     2001=>#<Set: {"c.rb", "d.rb", "e.rb"}>,)
  comment(#             #     2002=>#<Set: {"f.rb"}>})
  reserved(def) method(classify) comment(# :yields: o)
    ident(h) operator(=) operator({)operator(})

    ident(each) operator({) operator(|)ident(i)operator(|)
      ident(x) operator(=) reserved(yield)operator(()ident(i)operator(\))
      operator(()ident(h)operator([)ident(x)operator(]) operator(||=) pre_constant(self)operator(.)ident(class)operator(.)ident(new)operator(\))operator(.)ident(add)operator(()ident(i)operator(\))
    operator(})

    ident(h)
  reserved(end)

  comment(# Divides the set into a set of subsets according to the commonality)
  comment(# defined by the given block.)
  comment(#)
  comment(# If the arity of the block is 2, elements o1 and o2 are in common)
  comment(# if block.call(o1, o2\) is true.  Otherwise, elements o1 and o2 are)
  comment(# in common if block.call(o1\) == block.call(o2\).)
  comment(#)
  comment(# e.g.:)
  comment(#)
  comment(#   require 'set')
  comment(#   numbers = Set[1, 3, 4, 6, 9, 10, 11])
  comment(#   set = numbers.divide { |i,j| (i - j\).abs == 1 })
  comment(#   p set     # => #<Set: {#<Set: {1}>,)
  comment(#             #            #<Set: {11, 9, 10}>,)
  comment(#             #            #<Set: {3, 4}>,)
  comment(#             #            #<Set: {6}>}>)
  reserved(def) method(divide)operator(()operator(&)ident(func)operator(\))
    reserved(if) ident(func)operator(.)ident(arity) operator(==) integer(2)
      ident(require) string<delimiter(')content(tsort)delimiter(')>

      reserved(class) operator(<<) class(dig) operator(=) operator({)operator(})		comment(# :nodoc:)
	ident(include) constant(TSort)

	reserved(alias) ident(tsort_each_node) ident(each_key)
	reserved(def) method(tsort_each_child)operator(()ident(node)operator(,) operator(&)ident(block)operator(\))
	  ident(fetch)operator(()ident(node)operator(\))operator(.)ident(each)operator(()operator(&)ident(block)operator(\))
	reserved(end)
      reserved(end)

      ident(each) operator({) operator(|)ident(u)operator(|)
	ident(dig)operator([)ident(u)operator(]) operator(=) ident(a) operator(=) operator([)operator(])
	ident(each)operator({) operator(|)ident(v)operator(|) ident(func)operator(.)ident(call)operator(()ident(u)operator(,) ident(v)operator(\)) reserved(and) ident(a) operator(<<) ident(v) operator(})
      operator(})

      ident(set) operator(=) constant(Set)operator(.)ident(new)operator(()operator(\))
      ident(dig)operator(.)ident(each_strongly_connected_component) operator({) operator(|)ident(css)operator(|)
	ident(set)operator(.)ident(add)operator(()pre_constant(self)operator(.)ident(class)operator(.)ident(new)operator(()ident(css)operator(\))operator(\))
      operator(})
      ident(set)
    reserved(else)
      constant(Set)operator(.)ident(new)operator(()ident(classify)operator(()operator(&)ident(func)operator(\))operator(.)ident(values)operator(\))
    reserved(end)
  reserved(end)

  constant(InspectKey) operator(=) symbol(:__inspect_key__)         comment(# :nodoc:)

  comment(# Returns a string containing a human-readable representation of the)
  comment(# set. ("#<Set: {element1, element2, ...}>"\))
  reserved(def) method(inspect)
    ident(ids) operator(=) operator(()constant(Thread)operator(.)ident(current)operator([)constant(InspectKey)operator(]) operator(||=) operator([)operator(])operator(\))

    reserved(if) ident(ids)operator(.)ident(include?)operator(()ident(object_id)operator(\))
      reserved(return) ident(sprintf)operator(()string<delimiter(')content(#<%s: {...}>)delimiter(')>operator(,) pre_constant(self)operator(.)ident(class)operator(.)ident(name)operator(\))
    reserved(end)

    reserved(begin)
      ident(ids) operator(<<) ident(object_id)
      reserved(return) ident(sprintf)operator(()string<delimiter(')content(#<%s: {%s}>)delimiter(')>operator(,) pre_constant(self)operator(.)ident(class)operator(,) ident(to_a)operator(.)ident(inspect)operator([)integer(1)operator(..)operator(-)integer(2)operator(])operator(\))
    reserved(ensure)
      ident(ids)operator(.)ident(pop)
    reserved(end)
  reserved(end)

  reserved(def) method(pretty_print)operator(()ident(pp)operator(\))	comment(# :nodoc:)
    ident(pp)operator(.)ident(text) ident(sprintf)operator(()string<delimiter(')content(#<%s: {)delimiter(')>operator(,) pre_constant(self)operator(.)ident(class)operator(.)ident(name)operator(\))
    ident(pp)operator(.)ident(nest)operator(()integer(1)operator(\)) operator({)
      ident(pp)operator(.)ident(seplist)operator(()pre_constant(self)operator(\)) operator({) operator(|)ident(o)operator(|)
	ident(pp)operator(.)ident(pp) ident(o)
      operator(})
    operator(})
    ident(pp)operator(.)ident(text) string<delimiter(")content(}>)delimiter(")>
  reserved(end)

  reserved(def) method(pretty_print_cycle)operator(()ident(pp)operator(\))	comment(# :nodoc:)
    ident(pp)operator(.)ident(text) ident(sprintf)operator(()string<delimiter(')content(#<%s: {%s}>)delimiter(')>operator(,) pre_constant(self)operator(.)ident(class)operator(.)ident(name)operator(,) ident(empty?) operator(?) string<delimiter(')delimiter(')> operator(:) string<delimiter(')content(...)delimiter(')>operator(\))
  reserved(end)
reserved(end)

comment(# SortedSet implements a set which elements are sorted in order.  See Set.)
reserved(class) class(SortedSet) operator(<) constant(Set)
  class_variable(@@setup) operator(=) pre_constant(false)

  reserved(class) operator(<<) class(self)
    reserved(def) method([])operator(()operator(*)ident(ary)operator(\))	comment(# :nodoc:)
      ident(new)operator(()ident(ary)operator(\))
    reserved(end)

    reserved(def) method(setup)	comment(# :nodoc:)
      class_variable(@@setup) reserved(and) reserved(return)

      reserved(begin)
	ident(require) string<delimiter(')content(rbtree)delimiter(')>

	ident(module_eval) string<delimiter(%{)content(
	  def initialize(*args, &block\)
	    @hash = RBTree.new
	    super
	  end
	)delimiter(})>
      reserved(rescue) constant(LoadError)
	ident(module_eval) string<delimiter(%{)content(
	  def initialize(*args, &block\)
	    @keys = nil
	    super
	  end

	  def clear
	    @keys = nil
	    super
	  end

	  def replace(enum\)
	    @keys = nil
	    super
	  end

	  def add(o\)
	    @keys = nil
	    @hash[o] = true
	    self
	  end
	  alias << add

	  def delete(o\)
	    @keys = nil
	    @hash.delete(o\)
	    self
	  end

	  def delete_if
	    n = @hash.size
	    @hash.delete_if )nesting_delimiter({)content( |o,| yield(o\) )nesting_delimiter(})content(
	    @keys = nil if @hash.size != n
	    self
	  end

	  def merge(enum\)
	    @keys = nil
	    super
	  end

	  def each
	    to_a.each )nesting_delimiter({)content( |o| yield(o\) )nesting_delimiter(})content(
	  end

	  def to_a
	    (@keys = @hash.keys\).sort! unless @keys
	    @keys
	  end
	)delimiter(})>
      reserved(end)

      class_variable(@@setup) operator(=) pre_constant(true)
    reserved(end)
  reserved(end)

  reserved(def) method(initialize)operator(()operator(*)ident(args)operator(,) operator(&)ident(block)operator(\))	comment(# :nodoc:)
    constant(SortedSet)operator(.)ident(setup)
    ident(initialize)operator(()operator(*)ident(args)operator(,) operator(&)ident(block)operator(\))
  reserved(end)
reserved(end)

reserved(module) class(Enumerable)
  comment(# Makes a set from the enumerable object with given arguments.)
  reserved(def) method(to_set)operator(()ident(klass) operator(=) constant(Set)operator(,) operator(*)ident(args)operator(,) operator(&)ident(block)operator(\))
    ident(klass)operator(.)ident(new)operator(()pre_constant(self)operator(,) operator(*)ident(args)operator(,) operator(&)ident(block)operator(\))
  reserved(end)
reserved(end)

comment(# =begin)
comment(# == RestricedSet class)
comment(# RestricedSet implements a set with restrictions defined by a given)
comment(# block.)
comment(#)
comment(# === Super class)
comment(#     Set)
comment(#)
comment(# === Class Methods)
comment(# --- RestricedSet::new(enum = nil\) { |o| ... })
comment(# --- RestricedSet::new(enum = nil\) { |rset, o| ... })
comment(#     Creates a new restricted set containing the elements of the given)
comment(#     enumerable object.  Restrictions are defined by the given block.)
comment(#)
comment(#     If the block's arity is 2, it is called with the RestrictedSet)
comment(#     itself and an object to see if the object is allowed to be put in)
comment(#     the set.)
comment(#)
comment(#     Otherwise, the block is called with an object to see if the object)
comment(#     is allowed to be put in the set.)
comment(#)
comment(# === Instance Methods)
comment(# --- restriction_proc)
comment(#     Returns the restriction procedure of the set.)
comment(#)
comment(# =end)
comment(#)
comment(# class RestricedSet < Set)
comment(#   def initialize(*args, &block\))
comment(#     @proc = block or raise ArgumentError, "missing a block")
comment(#)
comment(#     if @proc.arity == 2)
comment(#       instance_eval %{)
comment(# 	def add(o\))
comment(# 	  @hash[o] = true if @proc.call(self, o\))
comment(# 	  self)
comment(# 	end)
comment(# 	alias << add)
comment(#)
comment(# 	def add?(o\))
comment(# 	  if include?(o\) || !@proc.call(self, o\))
comment(# 	    nil)
comment(# 	  else)
comment(# 	    @hash[o] = true)
comment(# 	    self)
comment(# 	  end)
comment(# 	end)
comment(#)
comment(# 	def replace(enum\))
comment(# 	  enum.is_a?(Enumerable\) or raise ArgumentError, "value must be enumerable")
comment(# 	  clear)
comment(# 	  enum.each { |o| add(o\) })
comment(#)
comment(# 	  self)
comment(# 	end)
comment(#)
comment(# 	def merge(enum\))
comment(# 	  enum.is_a?(Enumerable\) or raise ArgumentError, "value must be enumerable")
comment(# 	  enum.each { |o| add(o\) })
comment(#)
comment(# 	  self)
comment(# 	end)
comment(#       })
comment(#     else)
comment(#       instance_eval %{)
comment(# 	def add(o\))
comment(#         if @proc.call(o\))
comment(# 	    @hash[o] = true)
comment(#         end)
comment(# 	  self)
comment(# 	end)
comment(# 	alias << add)
comment(#)
comment(# 	def add?(o\))
comment(# 	  if include?(o\) || !@proc.call(o\))
comment(# 	    nil)
comment(# 	  else)
comment(# 	    @hash[o] = true)
comment(# 	    self)
comment(# 	  end)
comment(# 	end)
comment(#       })
comment(#     end)
comment(#)
comment(#     super(*args\))
comment(#   end)
comment(#)
comment(#   def restriction_proc)
comment(#     @proc)
comment(#   end)
comment(# end)

reserved(if) global_variable($0) operator(==) pre_constant(__FILE__)
  ident(eval) pre_constant(DATA)operator(.)ident(read)operator(,) pre_constant(nil)operator(,) global_variable($0)operator(,) pre_constant(__LINE__)operator(+)integer(4)
reserved(end)

comment(# = rweb - CGI Support Library)
comment(#)
comment(# Author:: Johannes Barre (mailto:rweb@igels.net\))
comment(# Copyright:: Copyright (c\) 2003, 04 by Johannes Barre)
comment(# License:: GNU Lesser General Public License (COPYING, http://www.gnu.org/copyleft/lesser.html\))
comment(# Version:: 0.1.0)
comment(# CVS-ID:: $Id: rweb.rb 6 2004-06-16 15:56:26Z igel $)
comment(#)
comment(# == What is Rweb?)
comment(# Rweb is a replacement for the cgi class included in the ruby distribution.)
comment(#)
comment(# == How to use)
comment(#)
comment(# === Basics)
comment(#)
comment(# This class is made to be as easy as possible to use. An example:)
comment(#)
comment(# 	require "rweb")
comment(#)
comment(# 	web = Rweb.new)
comment(# 	web.out do)
comment(# 		web.puts "Hello world!")
comment(# 	end)
comment(#)
comment(# The visitor will get a simple "Hello World!" in his browser. Please notice,)
comment(# that won't set html-tags for you, so you should better do something like this:)
comment(#)
comment(# 	require "rweb")
comment(#)
comment(# 	web = Rweb.new)
comment(# 	web.out do)
comment(# 		web.puts "<html><body>Hello world!</body></html>")
comment(# 	end)
comment(#)
comment(# === Set headers)
comment(# Of course, it's also possible to tell the browser, that the content of this)
comment(# page is plain text instead of html code:)
comment(#)
comment(# 	require "rweb")
comment(#)
comment(# 	web = Rweb.new)
comment(# 	web.out do)
comment(# 		web.header("content-type: text/plain"\))
comment(# 		web.puts "Hello plain world!")
comment(# 	end)
comment(#)
comment(# Please remember, headers can't be set after the page content has been send.)
comment(# You have to set all nessessary headers before the first puts oder print. It's)
comment(# possible to cache the content until everything is complete. Doing it this)
comment(# way, you can set headers everywhere.)
comment(#)
comment(# If you set a header twice, the second header will replace the first one. The)
comment(# header name is not casesensitive, it will allways converted in to the)
comment(# capitalised form suggested by the w3c (http://w3.org\))
comment(#)
comment(# === Set cookies)
comment(# Setting cookies is quite easy:)
comment(# 	include 'rweb')
comment(#)
comment(# 	web = Rweb.new)
comment(# 	Cookie.new("Visits", web.cookies['visits'].to_i +1\))
comment(# 	web.out do)
comment(# 		web.puts "Welcome back! You visited this page #{web.cookies['visits'].to_i +1} times")
comment(# 	end)
comment(#)
comment(# See the class Cookie for more details.)
comment(#)
comment(# === Get form and cookie values)
comment(# There are four ways to submit data from the browser to the server and your)
comment(# ruby script: via GET, POST, cookies and file upload. Rweb doesn't support)
comment(# file upload by now.)
comment(#)
comment(# 	include 'rweb')
comment(#)
comment(# 	web = Rweb.new)
comment(# 	web.out do)
comment(# 		web.print "action: #{web.get['action']} ")
comment(# 		web.puts "The value of the cookie 'visits' is #{web.cookies['visits']}")
comment(# 		web.puts "The post parameter 'test['x']' is #{web.post['test']['x']}")
comment(# 	end)

constant(RWEB_VERSION) operator(=) string<delimiter(")content(0.1.0)delimiter(")>
constant(RWEB) operator(=) string<delimiter(")content(rweb/)inline<delimiter(#{)constant(RWEB_VERSION)delimiter(})>delimiter(")>

comment(#require 'rwebcookie' -> edit by bunny :-\))

reserved(class) class(Rweb)
    comment(# All parameter submitted via the GET method are available in attribute)
		comment(# get. This is Hash, where every parameter is available as a key-value)
		comment(# pair.)
		comment(#)
		comment(# If your input tag has a name like this one, it's value will be available)
		comment(# as web.get["fieldname"])
		comment(#  <input name="fieldname">)
		comment(# You can submit values as a Hash)
		comment(#  <input name="text['index']">)
		comment(#  <input name="text['index2']">)
		comment(# will be available as)
		comment(#  web.get["text"]["index"])
		comment(#  web.get["text"]["index2"])
		comment(# Integers are also possible)
		comment(#  <input name="int[2]">)
		comment(#  <input name="int[3]['hi']>)
		comment(# will be available as)
		comment(#  web.get["int"][2])
		comment(#  web.get["int"][3]["hi"])
		comment(# If you specify no index, the lowest unused index will be used:)
		comment(#  <input name="int[]"><!-- First Field -->)
		comment(#  <input name="int[]"><!-- Second one -->)
		comment(# will be available as)
		comment(#  web.get["int"][0] # First Field)
		comment(#  web.get["int"][1] # Second one)
		comment(# Please notice, this doesn'd work like you might expect:)
		comment(#  <input name="text[index]">)
		comment(# It will not be available as web.get["text"]["index"] but)
		comment(#  web.get["text[index]"])
    ident(attr_reader) symbol(:get)

    comment(# All parameters submitted via POST are available in the attribute post. It)
		comment(# works like the get attribute.)
		comment(#  <input name="text[0]">)
		comment(# will be available as)
		comment(#  web.post["text"][0])
		ident(attr_reader) symbol(:post)

    comment(# All cookies submitted by the browser are available in cookies. This is a)
		comment(# Hash, where every cookie is a key-value pair.)
		ident(attr_reader) symbol(:cookies)

    comment(# The name of the browser identification is submitted as USER_AGENT and)
		comment(# available in this attribute.)
		ident(attr_reader) symbol(:user_agent)

    comment(# The IP address of the client.)
		ident(attr_reader) symbol(:remote_addr)

    comment(# Creates a new Rweb object. This should only done once. You can set various)
    comment(# options via the settings hash.)
    comment(#)
    comment(# "cache" => true: Everything you script send to the client will be cached)
    comment(# until the end of the out block or until flush is called. This way, you)
    comment(# can modify headers and cookies even after printing something to the client.)
    comment(#)
    comment(# "safe" => level: Changes the $SAFE attribute. By default, $SAFE will be set)
    comment(# to 1. If $SAFE is already higher than this value, it won't be changed.)
    comment(#)
    comment(# "silend" => true: Normaly, Rweb adds automaticly a header like this)
    comment(# "X-Powered-By: Rweb/x.x.x (Ruby/y.y.y\)". With the silend option you can)
    comment(# suppress this.)
    reserved(def) method(initialize) operator(()ident(settings) operator(=) operator({)operator(})operator(\))
        comment(# {{{)
        instance_variable(@header) operator(=) operator({)operator(})
        instance_variable(@cookies) operator(=) operator({)operator(})
        instance_variable(@get) operator(=) operator({)operator(})
        instance_variable(@post) operator(=) operator({)operator(})

        comment(# Internal attributes)
        instance_variable(@status) operator(=) pre_constant(nil)
        instance_variable(@reasonPhrase) operator(=) pre_constant(nil)
        instance_variable(@setcookies) operator(=) operator([)operator(])
        instance_variable(@output_started) operator(=) pre_constant(false)operator(;)
        instance_variable(@output_allowed) operator(=) pre_constant(false)operator(;)

        instance_variable(@mod_ruby) operator(=) pre_constant(false)
        instance_variable(@env) operator(=) constant(ENV)operator(.)ident(to_hash)

        reserved(if) reserved(defined?)operator(()constant(MOD_RUBY)operator(\))
            instance_variable(@output_method) operator(=) string<delimiter(")content(mod_ruby)delimiter(")>
            instance_variable(@mod_ruby) operator(=) pre_constant(true)
        reserved(elsif) instance_variable(@env)operator([)string<delimiter(')content(SERVER_SOFTWARE)delimiter(')>operator(]) operator(=)operator(~) regexp<delimiter(/)content(^Microsoft-IIS)delimiter(/)modifier(i)>
            instance_variable(@output_method) operator(=) string<delimiter(")content(nph)delimiter(")>
        reserved(else)
            instance_variable(@output_method) operator(=) string<delimiter(")content(ph)delimiter(")>
        reserved(end)

        reserved(unless) ident(settings)operator(.)ident(is_a?)operator(()constant(Hash)operator(\))
            ident(raise) constant(TypeError)operator(,) string<delimiter(")content(settings must be a Hash)delimiter(")>
        reserved(end)
        instance_variable(@settings) operator(=) ident(settings)

        reserved(unless) instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(safe)delimiter(")>operator(\))
            instance_variable(@settings)operator([)string<delimiter(")content(safe)delimiter(")>operator(]) operator(=) integer(1)
        reserved(end)

        reserved(if) global_variable($SAFE) operator(<) instance_variable(@settings)operator([)string<delimiter(")content(safe)delimiter(")>operator(])
            global_variable($SAFE) operator(=) instance_variable(@settings)operator([)string<delimiter(")content(safe)delimiter(")>operator(])
        reserved(end)

        reserved(unless) instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(cache)delimiter(")>operator(\))
            instance_variable(@settings)operator([)string<delimiter(")content(cache)delimiter(")>operator(]) operator(=) pre_constant(false)
        reserved(end)

        comment(# mod_ruby sets no QUERY_STRING variable, if no GET-Parameters are given)
        reserved(unless) instance_variable(@env)operator(.)ident(has_key?)operator(()string<delimiter(")content(QUERY_STRING)delimiter(")>operator(\))
            instance_variable(@env)operator([)string<delimiter(")content(QUERY_STRING)delimiter(")>operator(]) operator(=) string<delimiter(")delimiter(")>
        reserved(end)

        comment(# Now we split the QUERY_STRING by the seperators & and ; or, if)
        comment(# specified, settings['get seperator'])
        reserved(unless) instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(get seperator)delimiter(")>operator(\))
            ident(get_args) operator(=) instance_variable(@env)operator([)string<delimiter(')content(QUERY_STRING)delimiter(')>operator(])operator(.)ident(split)operator(()regexp<delimiter(/)content([&;])delimiter(/)>operator(\))
        reserved(else)
            ident(get_args) operator(=) instance_variable(@env)operator([)string<delimiter(')content(QUERY_STRING)delimiter(')>operator(])operator(.)ident(split)operator(()instance_variable(@settings)operator([)string<delimiter(')content(get seperator)delimiter(')>operator(])operator(\))
        reserved(end)

        ident(get_args)operator(.)ident(each) reserved(do) operator(|) ident(arg) operator(|)
            ident(arg_key)operator(,) ident(arg_val) operator(=) ident(arg)operator(.)ident(split)operator(()regexp<delimiter(/)content(=)delimiter(/)>operator(,) integer(2)operator(\))
            ident(arg_key) operator(=) constant(Rweb)operator(::)ident(unescape)operator(()ident(arg_key)operator(\))
            ident(arg_val) operator(=) constant(Rweb)operator(::)ident(unescape)operator(()ident(arg_val)operator(\))

            comment(# Parse names like name[0], name['text'] or name[])
            ident(pattern) operator(=) regexp<delimiter(/)content(^(.+\))char(\\[)content(("[^)char(\\])content(]*"|'[^)char(\\])content(]*'|[0-9]*\))char(\\])content($)delimiter(/)>
            ident(keys) operator(=) operator([)operator(])
            reserved(while) ident(match) operator(=) ident(pattern)operator(.)ident(match)operator(()ident(arg_key)operator(\))
                ident(arg_key) operator(=) ident(match)operator([)integer(1)operator(])
                ident(keys) operator(=) operator([)ident(match)operator([)integer(2)operator(])operator(]) operator(+) ident(keys)
            reserved(end)
            ident(keys) operator(=) operator([)ident(arg_key)operator(]) operator(+) ident(keys)

            ident(akt) operator(=) instance_variable(@get)
            ident(last) operator(=) pre_constant(nil)
            ident(lastkey) operator(=) pre_constant(nil)
            ident(keys)operator(.)ident(each) reserved(do) operator(|)ident(key)operator(|)
                reserved(if) ident(key) operator(==) string<delimiter(")delimiter(")>
                    comment(# No key specified (like in "test[]"\), so we use the)
                    comment(# lowerst unused Integer as key)
                    ident(key) operator(=) integer(0)
                    reserved(while) ident(akt)operator(.)ident(has_key?)operator(()ident(key)operator(\))
                        ident(key) operator(+=) integer(1)
                    reserved(end)
                reserved(elsif) regexp<delimiter(/)content(^[0-9]*$)delimiter(/)> operator(=)operator(~) ident(key)
                    comment(# If the index is numerical convert it to an Integer)
                    ident(key) operator(=) ident(key)operator(.)ident(to_i)
                reserved(elsif) ident(key)operator([)integer(0)operator(])operator(.)ident(chr) operator(==) string<delimiter(")content(')delimiter(")> operator(||) ident(key)operator([)integer(0)operator(])operator(.)ident(chr) operator(==) string<delimiter(')content(")delimiter(')>
                    ident(key) operator(=) ident(key)operator([)integer(1)operator(,) ident(key)operator(.)ident(length)operator(()operator(\)) operator(-)integer(2)operator(])
                reserved(end)
                reserved(if) operator(!)ident(akt)operator(.)ident(has_key?)operator(()ident(key)operator(\)) operator(||) operator(!)ident(akt)operator([)ident(key)operator(])operator(.)ident(class) operator(==) constant(Hash)
                    comment(# create an empty Hash if there isn't already one)
                    ident(akt)operator([)ident(key)operator(]) operator(=) operator({)operator(})
                reserved(end)
                ident(last) operator(=) ident(akt)
                ident(lastkey) operator(=) ident(key)
                ident(akt) operator(=) ident(akt)operator([)ident(key)operator(])
            reserved(end)
            ident(last)operator([)ident(lastkey)operator(]) operator(=) ident(arg_val)
        reserved(end)

        reserved(if) instance_variable(@env)operator([)string<delimiter(')content(REQUEST_METHOD)delimiter(')>operator(]) operator(==) string<delimiter(")content(POST)delimiter(")>
            reserved(if) instance_variable(@env)operator(.)ident(has_key?)operator(()string<delimiter(")content(CONTENT_TYPE)delimiter(")>operator(\)) operator(&&) instance_variable(@env)operator([)string<delimiter(')content(CONTENT_TYPE)delimiter(')>operator(]) operator(==) string<delimiter(")content(application/x-www-form-urlencoded)delimiter(")> operator(&&) instance_variable(@env)operator(.)ident(has_key?)operator(()string<delimiter(')content(CONTENT_LENGTH)delimiter(')>operator(\))
                reserved(unless) instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(post seperator)delimiter(")>operator(\))
                    ident(post_args) operator(=) global_variable($stdin)operator(.)ident(read)operator(()instance_variable(@env)operator([)string<delimiter(')content(CONTENT_LENGTH)delimiter(')>operator(])operator(.)ident(to_i)operator(\))operator(.)ident(split)operator(()regexp<delimiter(/)content([&;])delimiter(/)>operator(\))
                reserved(else)
                    ident(post_args) operator(=) global_variable($stdin)operator(.)ident(read)operator(()instance_variable(@env)operator([)string<delimiter(')content(CONTENT_LENGTH)delimiter(')>operator(])operator(.)ident(to_i)operator(\))operator(.)ident(split)operator(()instance_variable(@settings)operator([)string<delimiter(')content(post seperator)delimiter(')>operator(])operator(\))
                reserved(end)
                ident(post_args)operator(.)ident(each) reserved(do) operator(|) ident(arg) operator(|)
                    ident(arg_key)operator(,) ident(arg_val) operator(=) ident(arg)operator(.)ident(split)operator(()regexp<delimiter(/)content(=)delimiter(/)>operator(,) integer(2)operator(\))
                    ident(arg_key) operator(=) constant(Rweb)operator(::)ident(unescape)operator(()ident(arg_key)operator(\))
                    ident(arg_val) operator(=) constant(Rweb)operator(::)ident(unescape)operator(()ident(arg_val)operator(\))

                    comment(# Parse names like name[0], name['text'] or name[])
                    ident(pattern) operator(=) regexp<delimiter(/)content(^(.+\))char(\\[)content(("[^)char(\\])content(]*"|'[^)char(\\])content(]*'|[0-9]*\))char(\\])content($)delimiter(/)>
                    ident(keys) operator(=) operator([)operator(])
                    reserved(while) ident(match) operator(=) ident(pattern)operator(.)ident(match)operator(()ident(arg_key)operator(\))
                        ident(arg_key) operator(=) ident(match)operator([)integer(1)operator(])
                        ident(keys) operator(=) operator([)ident(match)operator([)integer(2)operator(])operator(]) operator(+) ident(keys)
                    reserved(end)
                    ident(keys) operator(=) operator([)ident(arg_key)operator(]) operator(+) ident(keys)

                    ident(akt) operator(=) instance_variable(@post)
                    ident(last) operator(=) pre_constant(nil)
                    ident(lastkey) operator(=) pre_constant(nil)
                    ident(keys)operator(.)ident(each) reserved(do) operator(|)ident(key)operator(|)
                        reserved(if) ident(key) operator(==) string<delimiter(")delimiter(")>
                            comment(# No key specified (like in "test[]"\), so we use)
                            comment(# the lowerst unused Integer as key)
                            ident(key) operator(=) integer(0)
                            reserved(while) ident(akt)operator(.)ident(has_key?)operator(()ident(key)operator(\))
                                ident(key) operator(+=) integer(1)
                            reserved(end)
                        reserved(elsif) regexp<delimiter(/)content(^[0-9]*$)delimiter(/)> operator(=)operator(~) ident(key)
                            comment(# If the index is numerical convert it to an Integer)
                            ident(key) operator(=) ident(key)operator(.)ident(to_i)
                        reserved(elsif) ident(key)operator([)integer(0)operator(])operator(.)ident(chr) operator(==) string<delimiter(")content(')delimiter(")> operator(||) ident(key)operator([)integer(0)operator(])operator(.)ident(chr) operator(==) string<delimiter(')content(")delimiter(')>
                            ident(key) operator(=) ident(key)operator([)integer(1)operator(,) ident(key)operator(.)ident(length)operator(()operator(\)) operator(-)integer(2)operator(])
                        reserved(end)
                        reserved(if) operator(!)ident(akt)operator(.)ident(has_key?)operator(()ident(key)operator(\)) operator(||) operator(!)ident(akt)operator([)ident(key)operator(])operator(.)ident(class) operator(==) constant(Hash)
                            comment(# create an empty Hash if there isn't already one)
                            ident(akt)operator([)ident(key)operator(]) operator(=) operator({)operator(})
                        reserved(end)
                        ident(last) operator(=) ident(akt)
                        ident(lastkey) operator(=) ident(key)
                        ident(akt) operator(=) ident(akt)operator([)ident(key)operator(])
                    reserved(end)
                    ident(last)operator([)ident(lastkey)operator(]) operator(=) ident(arg_val)
                reserved(end)
            reserved(else)
                comment(# Maybe we should print a warning here?)
                global_variable($stderr)operator(.)ident(print)operator(()string<delimiter(")content(Unidentified form data recived and discarded.)delimiter(")>operator(\))
            reserved(end)
        reserved(end)

        reserved(if) instance_variable(@env)operator(.)ident(has_key?)operator(()string<delimiter(")content(HTTP_COOKIE)delimiter(")>operator(\))
            ident(cookie) operator(=) instance_variable(@env)operator([)string<delimiter(')content(HTTP_COOKIE)delimiter(')>operator(])operator(.)ident(split)operator(()regexp<delimiter(/)content(; ?)delimiter(/)>operator(\))
            ident(cookie)operator(.)ident(each) reserved(do) operator(|) ident(c) operator(|)
                ident(cookie_key)operator(,) ident(cookie_val) operator(=) ident(c)operator(.)ident(split)operator(()regexp<delimiter(/)content(=)delimiter(/)>operator(,) integer(2)operator(\))

                instance_variable(@cookies) operator([)constant(Rweb)operator(::)ident(unescape)operator(()ident(cookie_key)operator(\))operator(]) operator(=) constant(Rweb)operator(::)ident(unescape)operator(()ident(cookie_val)operator(\))
            reserved(end)
        reserved(end)

        reserved(if) reserved(defined?)operator(()instance_variable(@env)operator([)string<delimiter(')content(HTTP_USER_AGENT)delimiter(')>operator(])operator(\))
            instance_variable(@user_agent) operator(=) instance_variable(@env)operator([)string<delimiter(')content(HTTP_USER_AGENT)delimiter(')>operator(])
        reserved(else)
            instance_variable(@user_agent) operator(=) pre_constant(nil)operator(;)
        reserved(end)

        reserved(if) reserved(defined?)operator(()instance_variable(@env)operator([)string<delimiter(')content(REMOTE_ADDR)delimiter(')>operator(])operator(\))
            instance_variable(@remote_addr) operator(=) instance_variable(@env)operator([)string<delimiter(')content(REMOTE_ADDR)delimiter(')>operator(])
        reserved(else)
            instance_variable(@remote_addr) operator(=) pre_constant(nil)
        reserved(end)
        comment(# }}})
    reserved(end)

    comment(# Prints a String to the client. If caching is enabled, the String will)
    comment(# buffered until the end of the out block ends.)
    reserved(def) method(print)operator(()ident(str) operator(=) string<delimiter(")delimiter(")>operator(\))
        comment(# {{{)
        reserved(unless) instance_variable(@output_allowed)
            ident(raise) string<delimiter(")content(You just can write to output inside of a Rweb::out-block)delimiter(")>
        reserved(end)

        reserved(if) instance_variable(@settings)operator([)string<delimiter(")content(cache)delimiter(")>operator(])
            instance_variable(@buffer) operator(+=) operator([)ident(str)operator(.)ident(to_s)operator(])
        reserved(else)
            reserved(unless) instance_variable(@output_started)
                ident(sendHeaders)
            reserved(end)
            global_variable($stdout)operator(.)ident(print)operator(()ident(str)operator(\))
        reserved(end)
        pre_constant(nil)
        comment(# }}})
    reserved(end)

    comment(# Prints a String to the client and adds a line break at the end. Please)
		comment(# remember, that a line break is not visible in HTML, use the <br> HTML-Tag)
		comment(# for this. If caching is enabled, the String will buffered until the end)
		comment(# of the out block ends.)
    reserved(def) method(puts)operator(()ident(str) operator(=) string<delimiter(")delimiter(")>operator(\))
        comment(# {{{)
        pre_constant(self)operator(.)ident(print)operator(()ident(str) operator(+) string<delimiter(")char(\\n)delimiter(")>operator(\))
        comment(# }}})
    reserved(end)

		comment(# Alias to print.)
    reserved(def) method(write)operator(()ident(str) operator(=) string<delimiter(")delimiter(")>operator(\))
        comment(# {{{)
        pre_constant(self)operator(.)ident(print)operator(()ident(str)operator(\))
        comment(# }}})
    reserved(end)

    comment(# If caching is enabled, all cached data are send to the cliend and the)
		comment(# cache emptied.)
    reserved(def) method(flush)
        comment(# {{{)
        reserved(unless) instance_variable(@output_allowed)
            ident(raise) string<delimiter(")content(You can't use flush outside of a Rweb::out-block)delimiter(")>
        reserved(end)
        ident(buffer) operator(=) instance_variable(@buffer)operator(.)ident(join)

        reserved(unless) instance_variable(@output_started)
            ident(sendHeaders)
        reserved(end)
        global_variable($stdout)operator(.)ident(print)operator(()ident(buffer)operator(\))

        instance_variable(@buffer) operator(=) operator([)operator(])
        comment(# }}})
    reserved(end)

    comment(# Sends one or more header to the client. All headers are cached just)
		comment(# before body data are send to the client. If the same header are set)
		comment(# twice, only the last value is send.)
		comment(#)
		comment(# Example:)
		comment(#  web.header("Last-Modified: Mon, 16 Feb 2004 20:15:41 GMT"\))
		comment(#  web.header("Location: http://www.ruby-lang.org"\))
		comment(#)
		comment(# You can specify more than one header at the time by doing something like)
		comment(# this:)
		comment(#  web.header("Content-Type: text/plain\\nContent-Length: 383"\))
		comment(# or)
		comment(#  web.header(["Content-Type: text/plain", "Content-Length: 383"]\))
    reserved(def) method(header)operator(()ident(str)operator(\))
        comment(# {{{)
        reserved(if) instance_variable(@output_started)
            ident(raise) string<delimiter(")content(HTTP-Headers are already send. You can't change them after output has started!)delimiter(")>
        reserved(end)
        reserved(unless) instance_variable(@output_allowed)
            ident(raise) string<delimiter(")content(You just can set headers inside of a Rweb::out-block)delimiter(")>
        reserved(end)
        reserved(if) ident(str)operator(.)ident(is_a?)constant(Array)
            ident(str)operator(.)ident(each) reserved(do) operator(|) ident(value) operator(|)
                pre_constant(self)operator(.)ident(header)operator(()ident(value)operator(\))
            reserved(end)

        reserved(elsif) ident(str)operator(.)ident(split)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))operator(.)ident(length) operator(>) integer(1)
            ident(str)operator(.)ident(split)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))operator(.)ident(each) reserved(do) operator(|) ident(value) operator(|)
                pre_constant(self)operator(.)ident(header)operator(()ident(value)operator(\))
            reserved(end)

        reserved(elsif) ident(str)operator(.)ident(is_a?) constant(String)
            ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\r)delimiter(/)>operator(,) string<delimiter(")delimiter(")>operator(\))

            reserved(if) operator(()ident(str) operator(=)operator(~) regexp<delimiter(/)content(^HTTP)char(\\/)content(1)char(\\.)content([01] [0-9]{3} ?.*$)delimiter(/)>operator(\)) operator(==) integer(0)
                ident(pattern) operator(=) regexp<delimiter(/)content(^HTTP)char(\\/)content(1.[01] ([0-9]{3}\) ?(.*\)$)delimiter(/)>

                ident(result) operator(=) ident(pattern)operator(.)ident(match)operator(()ident(str)operator(\))
                pre_constant(self)operator(.)ident(setstatus)operator(()ident(result)operator([)integer(0)operator(])operator(,) ident(result)operator([)integer(1)operator(])operator(\))
            reserved(elsif) operator(()ident(str) operator(=)operator(~) regexp<delimiter(/)content(^status: [0-9]{3} ?.*$)delimiter(/)modifier(i)>operator(\)) operator(==) integer(0)
                ident(pattern) operator(=) regexp<delimiter(/)content(^status: ([0-9]{3}\) ?(.*\)$)delimiter(/)modifier(i)>

                ident(result) operator(=) ident(pattern)operator(.)ident(match)operator(()ident(str)operator(\))
                pre_constant(self)operator(.)ident(setstatus)operator(()ident(result)operator([)integer(0)operator(])operator(,) ident(result)operator([)integer(1)operator(])operator(\))
            reserved(else)
                ident(a) operator(=) ident(str)operator(.)ident(split)operator(()regexp<delimiter(/)content(: ?)delimiter(/)>operator(,) integer(2)operator(\))

                instance_variable(@header)operator([)ident(a)operator([)integer(0)operator(])operator(.)ident(downcase)operator(]) operator(=) ident(a)operator([)integer(1)operator(])
            reserved(end)
        reserved(end)
        comment(# }}})
    reserved(end)

    comment(# Changes the status of this page. There are several codes like "200 OK",)
		comment(# "302 Found", "404 Not Found" or "500 Internal Server Error". A list of)
		comment(# all codes is available at)
		comment(# http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10)
		comment(#)
		comment(# You can just send the code number, the reason phrase will be added)
		comment(# automaticly with the recommendations from the w3c if not specified. If)
		comment(# you set the status twice or more, only the last status will be send.)
		comment(# Examples:)
		comment(#  web.status("401 Unauthorized"\))
		comment(#  web.status("410 Sad but true, this lonely page is gone :("\))
		comment(#  web.status(206\))
		comment(#  web.status("400"\))
		comment(#)
		comment(# The default status is "200 OK". If a "Location" header is set, the)
		comment(# default status is "302 Found".)
    reserved(def) method(status)operator(()ident(str)operator(\))
        comment(# {{{)
        reserved(if) instance_variable(@output_started)
            ident(raise) string<delimiter(")content(HTTP-Headers are already send. You can't change them after output has started!)delimiter(")>
        reserved(end)
        reserved(unless) instance_variable(@output_allowed)
            ident(raise) string<delimiter(")content(You just can set headers inside of a Rweb::out-block)delimiter(")>
        reserved(end)
        reserved(if) ident(str)operator(.)ident(is_a?)constant(Integer)
            instance_variable(@status) operator(=) ident(str)
        reserved(elsif) ident(str)operator(.)ident(is_a?)constant(String)
            ident(p1) operator(=) regexp<delimiter(/)content(^([0-9]{3}\) ?(.*\)$)delimiter(/)>
            ident(p2) operator(=) regexp<delimiter(/)content(^HTTP)char(\\/)content(1)char(\\.)content([01] ([0-9]{3}\) ?(.*\)$)delimiter(/)>
            ident(p3) operator(=) regexp<delimiter(/)content(^status: ([0-9]{3}\) ?(.*\)$)delimiter(/)modifier(i)>

            reserved(if) operator(()ident(a) operator(=) ident(p1)operator(.)ident(match)operator(()ident(str)operator(\))operator(\)) operator(==) pre_constant(nil)
                reserved(if) operator(()ident(a) operator(=) ident(p2)operator(.)ident(match)operator(()ident(str)operator(\))operator(\)) operator(==) pre_constant(nil)
                    reserved(if) operator(()ident(a) operator(=) ident(p3)operator(.)ident(match)operator(()ident(str)operator(\))operator(\)) operator(==) pre_constant(nil)
                        ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(Invalid argument)delimiter(")>operator(,) ident(caller)
                    reserved(end)
                reserved(end)
            reserved(end)
            instance_variable(@status) operator(=) ident(a)operator([)integer(1)operator(])operator(.)ident(to_i)
            reserved(if) ident(a)operator([)integer(2)operator(]) operator(!=) string<delimiter(")delimiter(")>
                instance_variable(@reasonPhrase) operator(=) ident(a)operator([)integer(2)operator(])
            reserved(else)
                instance_variable(@reasonPhrase) operator(=) ident(getReasonPhrase)operator(()instance_variable(@status)operator(\))
            reserved(end)
        reserved(else)
            ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(Argument of setstatus must be integer or string)delimiter(")>operator(,) ident(caller)
        reserved(end)
        comment(# }}})
    reserved(end)

    comment(# Handles the output of your content and rescues all exceptions. Send all)
		comment(# data in the block to this method. For example:)
		comment(#  web.out do)
		comment(#      web.header("Content-Type: text/plain"\))
		comment(#      web.puts("Hello, plain world!"\))
		comment(#  end)
    reserved(def) method(out)
        comment(# {{{)
        instance_variable(@output_allowed) operator(=) pre_constant(true)
        instance_variable(@buffer) operator(=) operator([)operator(])operator(;) comment(# We use an array as buffer, because it's more performant :\))

        reserved(begin)
            reserved(yield)
        reserved(rescue) constant(Exception) operator(=)operator(>) ident(exception)
            global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(Ruby exception rescued ()inline<delimiter(#{)ident(exception)operator(.)ident(class)delimiter(})>content(\): )inline<delimiter(#{)ident(exception)operator(.)ident(message)delimiter(})>delimiter(")>
            global_variable($stderr)operator(.)ident(puts) ident(exception)operator(.)ident(backtrace)operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))

            reserved(unless) instance_variable(@output_started)
                pre_constant(self)operator(.)ident(setstatus)operator(()integer(500)operator(\))
                instance_variable(@header) operator(=) operator({)operator(})
            reserved(end)

            reserved(unless) operator(()instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(hide errors)delimiter(")>operator(\)) reserved(and) instance_variable(@settings)operator([)string<delimiter(")content(hide errors)delimiter(")>operator(]) operator(==) pre_constant(true)operator(\))
                reserved(unless) instance_variable(@output_started)
                    pre_constant(self)operator(.)ident(header)operator(()string<delimiter(")content(Content-Type: text/html)delimiter(")>operator(\))
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<!DOCTYPE HTML PUBLIC )char(\\")content(-//W3C//DTD HTML 4.01 Strict//EN)char(\\")content( )char(\\")content(http://www.w3.org/TR/html4/strict.dtd)char(\\")content(>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<html>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<head>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<title>500 Internal Server Error</title>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(</head>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<body>)delimiter(")>
                reserved(end)
                reserved(if) instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(content-type)delimiter(")>operator(\)) reserved(and) operator(()instance_variable(@header)operator([)string<delimiter(")content(content-type)delimiter(")>operator(]) operator(=)operator(~) regexp<delimiter(/)content(^text)char(\\/)content(html)delimiter(/)modifier(i)>operator(\)) operator(==) integer(0)
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<h1>Internal Server Error</h1>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<p>The server encountered an exception and was unable to complete your request.</p>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<p>The exception has provided the following information:</p>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<pre style=)char(\\")content(background: #FFCCCC; border: black solid 2px; margin-left: 2cm; margin-right: 2cm; padding: 2mm;)char(\\")content(><b>)inline<delimiter(#{)ident(exception)operator(.)ident(class)delimiter(})>content(</b>: )inline<delimiter(#{)ident(exception)operator(.)ident(message)delimiter(})>content( <b>on</b>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts)
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")inline<delimiter(#{)ident(exception)operator(.)ident(backtrace)operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))delimiter(})>content(</pre>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(</body>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(</html>)delimiter(")>
                reserved(else)
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(The server encountered an exception and was unable to complete your request)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(The exception has provided the following information:)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")inline<delimiter(#{)ident(exception)operator(.)ident(class)delimiter(})>content(: )inline<delimiter(#{)ident(exception)operator(.)ident(message)delimiter(})>delimiter(")>
                    pre_constant(self)operator(.)ident(puts)
                    pre_constant(self)operator(.)ident(puts) ident(exception)operator(.)ident(backtrace)operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))
                reserved(end)
            reserved(end)
        reserved(end)

        reserved(if) instance_variable(@settings)operator([)string<delimiter(")content(cache)delimiter(")>operator(])
            ident(buffer) operator(=) instance_variable(@buffer)operator(.)ident(join)

            reserved(unless) instance_variable(@output_started)
                reserved(unless) instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(content-length)delimiter(")>operator(\))
                    pre_constant(self)operator(.)ident(header)operator(()string<delimiter(")content(content-length: )inline<delimiter(#{)ident(buffer)operator(.)ident(length)delimiter(})>delimiter(")>operator(\))
                reserved(end)

                ident(sendHeaders)
            reserved(end)
            global_variable($stdout)operator(.)ident(print)operator(()ident(buffer)operator(\))
        reserved(elsif) operator(!)instance_variable(@output_started)
            ident(sendHeaders)
        reserved(end)
        instance_variable(@output_allowed) operator(=) pre_constant(false)operator(;)
        comment(# }}})
    reserved(end)

    comment(# Decodes URL encoded data, %20 for example stands for a space.)
    reserved(def) constant(Rweb)operator(.)ident(unescape)operator(()ident(str)operator(\))
        comment(# {{{)
        reserved(if) reserved(defined?) ident(str) reserved(and) ident(str)operator(.)ident(is_a?) constant(String)
            ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\+)delimiter(/)>operator(,) string<delimiter(")content( )delimiter(")>operator(\))
            ident(str)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(%.{2})delimiter(/)>operator(\)) reserved(do) operator(|) ident(s) operator(|)
                ident(s)operator([)integer(1)operator(,)integer(2)operator(])operator(.)ident(hex)operator(.)ident(chr)
            reserved(end)
        reserved(end)
        comment(# }}})
    reserved(end)

    ident(protected)
    reserved(def) method(sendHeaders)
        comment(# {{{)

        constant(Cookie)operator(.)ident(disallow) comment(# no more cookies can be set or modified)
        reserved(if) operator(!)operator(()instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(silent)delimiter(")>operator(\)) reserved(and) instance_variable(@settings)operator([)string<delimiter(")content(silent)delimiter(")>operator(]) operator(==) pre_constant(true)operator(\)) reserved(and) operator(!)instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(x-powered-by)delimiter(")>operator(\))
            reserved(if) instance_variable(@mod_ruby)
                ident(header)operator(()string<delimiter(")content(x-powered-by: )inline<delimiter(#{)constant(RWEB)delimiter(})>content( (Ruby/)inline<delimiter(#{)constant(RUBY_VERSION)delimiter(})>content(, )inline<delimiter(#{)constant(MOD_RUBY)delimiter(})>content(\))delimiter(")>operator(\))operator(;)
            reserved(else)
                ident(header)operator(()string<delimiter(")content(x-powered-by: )inline<delimiter(#{)constant(RWEB)delimiter(})>content( (Ruby/)inline<delimiter(#{)constant(RUBY_VERSION)delimiter(})>content(\))delimiter(")>operator(\))operator(;)
            reserved(end)
        reserved(end)

        reserved(if) instance_variable(@output_method) operator(==) string<delimiter(")content(ph)delimiter(")>
            reserved(if) operator(()operator(()instance_variable(@status) operator(==) pre_constant(nil) reserved(or) instance_variable(@status) operator(==) integer(200)operator(\)) reserved(and) operator(!)instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(content-type)delimiter(")>operator(\)) reserved(and) operator(!)instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(location)delimiter(")>operator(\))operator(\))
                ident(header)operator(()string<delimiter(")content(content-type: text/html)delimiter(")>operator(\))
            reserved(end)

            reserved(if) instance_variable(@status) operator(!=) pre_constant(nil)
                global_variable($stdout)operator(.)ident(print) string<delimiter(")content(Status: )inline<delimiter(#{)instance_variable(@status)delimiter(})>content( )inline<delimiter(#{)instance_variable(@reasonPhrase)delimiter(})>char(\\r)char(\\n)delimiter(")>
            reserved(end)

            instance_variable(@header)operator(.)ident(each) reserved(do) operator(|)ident(key)operator(,) ident(value)operator(|)
                ident(key) operator(=) ident(key) operator(*)integer(1) comment(# "unfreeze" key :\))
                ident(key)operator([)integer(0)operator(]) operator(=) ident(key)operator([)integer(0)operator(,)integer(1)operator(])operator(.)ident(upcase!)operator([)integer(0)operator(])

                ident(key) operator(=) ident(key)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(-[a-z])delimiter(/)>operator(\)) reserved(do) operator(|)ident(char)operator(|)
                    string<delimiter(")content(-)delimiter(")> operator(+) ident(char)operator([)integer(1)operator(,)integer(1)operator(])operator(.)ident(upcase)
                reserved(end)

                global_variable($stdout)operator(.)ident(print) string<delimiter(")inline<delimiter(#{)ident(key)delimiter(})>content(: )inline<delimiter(#{)ident(value)delimiter(})>char(\\r)char(\\n)delimiter(")>
            reserved(end)
            ident(cookies) operator(=) constant(Cookie)operator(.)ident(getHttpHeader) comment(# Get all cookies as an HTTP Header)
            reserved(if) ident(cookies)
                global_variable($stdout)operator(.)ident(print) ident(cookies)
            reserved(end)

            global_variable($stdout)operator(.)ident(print) string<delimiter(")char(\\r)char(\\n)delimiter(")>

        reserved(elsif) instance_variable(@output_method) operator(==) string<delimiter(")content(nph)delimiter(")>
        reserved(elsif) instance_variable(@output_method) operator(==) string<delimiter(")content(mod_ruby)delimiter(")>
            ident(r) operator(=) constant(Apache)operator(.)ident(request)

            reserved(if) operator(()operator(()instance_variable(@status) operator(==) pre_constant(nil) reserved(or) instance_variable(@status) operator(==) integer(200)operator(\)) reserved(and) operator(!)instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(content-type)delimiter(")>operator(\)) reserved(and) operator(!)instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(location)delimiter(")>operator(\))operator(\))
                ident(header)operator(()string<delimiter(")content(text/html)delimiter(")>operator(\))
            reserved(end)

            reserved(if) instance_variable(@status) operator(!=) pre_constant(nil)
                ident(r)operator(.)ident(status_line) operator(=) string<delimiter(")inline<delimiter(#{)instance_variable(@status)delimiter(})>content( )inline<delimiter(#{)instance_variable(@reasonPhrase)delimiter(})>delimiter(")>
            reserved(end)

            ident(r)operator(.)ident(send_http_header)
            instance_variable(@header)operator(.)ident(each) reserved(do) operator(|)ident(key)operator(,) ident(value)operator(|)
                ident(key) operator(=) ident(key) operator(*)integer(1) comment(# "unfreeze" key :\))

                ident(key)operator([)integer(0)operator(]) operator(=) ident(key)operator([)integer(0)operator(,)integer(1)operator(])operator(.)ident(upcase!)operator([)integer(0)operator(])
                ident(key) operator(=) ident(key)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(-[a-z])delimiter(/)>operator(\)) reserved(do) operator(|)ident(char)operator(|)
                    string<delimiter(")content(-)delimiter(")> operator(+) ident(char)operator([)integer(1)operator(,)integer(1)operator(])operator(.)ident(upcase)
                reserved(end)
                ident(puts) string<delimiter(")inline<delimiter(#{)ident(key)delimiter(})>content(: )inline<delimiter(#{)ident(value)operator(.)ident(class)delimiter(})>delimiter(")>
                comment(#r.headers_out[key] = value)
            reserved(end)
        reserved(end)
        instance_variable(@output_started) operator(=) pre_constant(true)
        comment(# }}})
    reserved(end)

    reserved(def) method(getReasonPhrase) operator(()ident(status)operator(\))
        comment(# {{{)
        reserved(if) ident(status) operator(==) integer(100)
            string<delimiter(")content(Continue)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(101)
            string<delimiter(")content(Switching Protocols)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(200)
            string<delimiter(")content(OK)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(201)
            string<delimiter(")content(Created)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(202)
            string<delimiter(")content(Accepted)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(203)
            string<delimiter(")content(Non-Authoritative Information)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(204)
            string<delimiter(")content(No Content)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(205)
            string<delimiter(")content(Reset Content)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(206)
            string<delimiter(")content(Partial Content)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(300)
            string<delimiter(")content(Multiple Choices)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(301)
            string<delimiter(")content(Moved Permanently)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(302)
            string<delimiter(")content(Found)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(303)
            string<delimiter(")content(See Other)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(304)
            string<delimiter(")content(Not Modified)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(305)
            string<delimiter(")content(Use Proxy)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(307)
            string<delimiter(")content(Temporary Redirect)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(400)
            string<delimiter(")content(Bad Request)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(401)
            string<delimiter(")content(Unauthorized)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(402)
            string<delimiter(")content(Payment Required)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(403)
            string<delimiter(")content(Forbidden)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(404)
            string<delimiter(")content(Not Found)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(405)
            string<delimiter(")content(Method Not Allowed)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(406)
            string<delimiter(")content(Not Acceptable)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(407)
            string<delimiter(")content(Proxy Authentication Required)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(408)
            string<delimiter(")content(Request Time-out)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(409)
            string<delimiter(")content(Conflict)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(410)
            string<delimiter(")content(Gone)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(411)
            string<delimiter(")content(Length Required)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(412)
            string<delimiter(")content(Precondition Failed)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(413)
            string<delimiter(")content(Request Entity Too Large)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(414)
            string<delimiter(")content(Request-URI Too Large)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(415)
            string<delimiter(")content(Unsupported Media Type)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(416)
            string<delimiter(")content(Requested range not satisfiable)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(417)
            string<delimiter(")content(Expectation Failed)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(500)
            string<delimiter(")content(Internal Server Error)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(501)
            string<delimiter(")content(Not Implemented)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(502)
            string<delimiter(")content(Bad Gateway)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(503)
            string<delimiter(")content(Service Unavailable)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(504)
            string<delimiter(")content(Gateway Time-out)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(505)
            string<delimiter(")content(HTTP Version not supported)delimiter(")>
        reserved(else)
            ident(raise) string<delimiter(")content(Unknown Statuscode. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1 for more information.)delimiter(")>
        reserved(end)
        comment(# }}})
    reserved(end)
reserved(end)

reserved(class) class(Cookie)
	ident(attr_reader) symbol(:name)operator(,) symbol(:value)operator(,) symbol(:maxage)operator(,) symbol(:path)operator(,) symbol(:domain)operator(,) symbol(:secure)operator(,) symbol(:comment)

	comment(# Sets a cookie. Please see below for details of the attributes.)
	reserved(def) method(initialize) operator(()ident(name)operator(,) ident(value) operator(=) pre_constant(nil)operator(,) ident(maxage) operator(=) pre_constant(nil)operator(,) ident(path) operator(=) pre_constant(nil)operator(,) ident(domain) operator(=) pre_constant(nil)operator(,) ident(secure) operator(=) pre_constant(false)operator(\))
		comment(# {{{)
		comment(# HTTP headers (Cookies are a HTTP header\) can only set, while no content)
		comment(# is send. So an exception will be raised, when @@allowed is set to false)
		comment(# and a new cookie has set.)
		reserved(unless) reserved(defined?)operator(()class_variable(@@allowed)operator(\))
			class_variable(@@allowed) operator(=) pre_constant(true)
		reserved(end)
		reserved(unless) class_variable(@@allowed)
			ident(raise) string<delimiter(")content(You can't set cookies after the HTTP headers are send.)delimiter(")>
		reserved(end)

		reserved(unless) reserved(defined?)operator(()class_variable(@@list)operator(\))
			class_variable(@@list) operator(=) operator([)operator(])
		reserved(end)
		class_variable(@@list) operator(+=) operator([)pre_constant(self)operator(])

		reserved(unless) reserved(defined?)operator(()class_variable(@@type)operator(\))
			class_variable(@@type) operator(=) string<delimiter(")content(netscape)delimiter(")>
		reserved(end)

		reserved(unless) ident(name)operator(.)ident(class) operator(==) constant(String)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The name of a cookie must be a string)delimiter(")>operator(,) ident(caller)
		reserved(end)
		reserved(if) ident(value)operator(.)ident(class)operator(.)ident(superclass) operator(==) constant(Integer) operator(||) ident(value)operator(.)ident(class) operator(==) constant(Float)
			ident(value) operator(=) ident(value)operator(.)ident(to_s)
		reserved(elsif) ident(value)operator(.)ident(class) operator(!=) constant(String) operator(&&) ident(value) operator(!=) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The value of a cookie must be a string, integer, float or nil)delimiter(")>operator(,) ident(caller)
		reserved(end)
		reserved(if) ident(maxage)operator(.)ident(class) operator(==) constant(Time)
			ident(maxage) operator(=) ident(maxage) operator(-) constant(Time)operator(.)ident(now)
		reserved(elsif) operator(!)ident(maxage)operator(.)ident(class)operator(.)ident(superclass) operator(==) constant(Integer)  operator(||) operator(!)ident(maxage) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The maxage date of a cookie must be an Integer or Time object or nil.)delimiter(")>operator(,) ident(caller)
		reserved(end)
		reserved(unless) ident(path)operator(.)ident(class) operator(==) constant(String)  operator(||) ident(path) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The path of a cookie must be nil or a string)delimiter(")>operator(,) ident(caller)
		reserved(end)
		reserved(unless) ident(domain)operator(.)ident(class) operator(==) constant(String)  operator(||) ident(domain) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The value of a cookie must be nil or a string)delimiter(")>operator(,) ident(caller)
		reserved(end)
		reserved(unless) ident(secure) operator(==) pre_constant(true)  operator(||) ident(secure) operator(==) pre_constant(false)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The secure field of a cookie must be true or false)delimiter(")>operator(,) ident(caller)
		reserved(end)

		instance_variable(@name)operator(,) instance_variable(@value)operator(,) instance_variable(@maxage)operator(,) instance_variable(@path)operator(,) instance_variable(@domain)operator(,) instance_variable(@secure) operator(=) ident(name)operator(,) ident(value)operator(,) ident(maxage)operator(,) ident(path)operator(,) ident(domain)operator(,) ident(secure)
		instance_variable(@comment) operator(=) pre_constant(nil)
		comment(# }}})
	reserved(end)

	comment(# Modifies the value of this cookie. The information you want to store. If the)
	comment(# value is nil, the cookie will be deleted by the client.)
	comment(#)
	comment(# This attribute can be a String, Integer or Float object or nil.)
	reserved(def) method(value=)operator(()ident(value)operator(\))
		comment(# {{{)
		reserved(if) ident(value)operator(.)ident(class)operator(.)ident(superclass) operator(==) constant(Integer) operator(||) ident(value)operator(.)ident(class) operator(==) constant(Float)
			ident(value) operator(=) ident(value)operator(.)ident(to_s)
		reserved(elsif) ident(value)operator(.)ident(class) operator(!=) constant(String) operator(&&) ident(value) operator(!=) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The value of a cookie must be a string, integer, float or nil)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@value) operator(=) ident(value)
		comment(# }}})
	reserved(end)

	comment(# Modifies the maxage of this cookie. This attribute defines the lifetime of)
	comment(# the cookie, in seconds. A value of 0 means the cookie should be discarded)
	comment(# imediatly. If it set to nil, the cookie will be deleted when the browser)
	comment(# will be closed.)
	comment(#)
	comment(# Attention: This is different from other implementations like PHP, where you)
	comment(# gives the seconds since 1/1/1970 0:00:00 GMT.)
	comment(#)
	comment(# This attribute must be an Integer or Time object or nil.)
	reserved(def) method(maxage=)operator(()ident(maxage)operator(\))
		comment(# {{{)
		reserved(if) ident(maxage)operator(.)ident(class) operator(==) constant(Time)
			ident(maxage) operator(=) ident(maxage) operator(-) constant(Time)operator(.)ident(now)
		reserved(elsif) ident(maxage)operator(.)ident(class)operator(.)ident(superclass) operator(==) constant(Integer)  operator(||) operator(!)ident(maxage) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The maxage of a cookie must be an Interger or Time object or nil.)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@maxage) operator(=) ident(maxage)
		comment(# }}})
	reserved(end)

	comment(# Modifies the path value of this cookie. The client will send this cookie)
	comment(# only, if the requested document is this directory or a subdirectory of it.)
	comment(#)
	comment(# The value of the attribute must be a String object or nil.)
	reserved(def) method(path=)operator(()ident(path)operator(\))
		comment(# {{{)
		reserved(unless) ident(path)operator(.)ident(class) operator(==) constant(String)  operator(||) ident(path) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The path of a cookie must be nil or a string)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@path) operator(=) ident(path)
		comment(# }}})
	reserved(end)

	comment(# Modifies the domain value of this cookie. The client will send this cookie)
	comment(# only if it's connected with this domain (or a subdomain, if the first)
	comment(# character is a dot like in ".ruby-lang.org"\))
	comment(#)
	comment(# The value of this attribute must be a String or nil.)
	reserved(def) method(domain=)operator(()ident(domain)operator(\))
		comment(# {{{)
		reserved(unless) ident(domain)operator(.)ident(class) operator(==) constant(String)  operator(||) ident(domain) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The domain of a cookie must be a String or nil.)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@domain) operator(=) ident(domain)
		comment(# }}})
	reserved(end)

	comment(# Modifies the secure flag of this cookie. If it's true, the client will only)
	comment(# send this cookie if it is secured connected with us.)
	comment(#)
	comment(# The value od this attribute has to be true or false.)
	reserved(def) method(secure=)operator(()ident(secure)operator(\))
		comment(# {{{)
		reserved(unless) ident(secure) operator(==) pre_constant(true)  operator(||) ident(secure) operator(==) pre_constant(false)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The secure field of a cookie must be true or false)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@secure) operator(=) ident(secure)
		comment(# }}})
	reserved(end)

	comment(# Modifies the comment value of this cookie. The comment won't be send, if)
	comment(# type is "netscape".)
	reserved(def) method(comment=)operator(()ident(comment)operator(\))
		comment(# {{{)
		reserved(unless) ident(comment)operator(.)ident(class) operator(==) constant(String) operator(||) ident(comment) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The comment of a cookie must be a string or nil)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@comment) operator(=) ident(comment)
		comment(# }}})
	reserved(end)

	comment(# Changes the type of all cookies.)
	comment(# Allowed values are RFC2109 and netscape (default\).)
	reserved(def) constant(Cookie)operator(.)ident(type)operator(=)operator(()ident(type)operator(\))
		comment(# {{{)
		reserved(unless) class_variable(@@allowed)
			ident(raise) string<delimiter(")content(The cookies are allready send, so you can't change the type anymore.)delimiter(")>
		reserved(end)
		reserved(unless) ident(type)operator(.)ident(downcase) operator(==) string<delimiter(")content(rfc2109)delimiter(")> operator(&&) ident(type)operator(.)ident(downcase) operator(==) string<delimiter(")content(netscape)delimiter(")>
			ident(raise) string<delimiter(")content(The type of the cookies must be )char(\\")content(RFC2109)char(\\")content( or )char(\\")content(netscape)char(\\")content(.)delimiter(")>
		reserved(end)
		class_variable(@@type) operator(=) ident(type)operator(;)
		comment(# }}})
	reserved(end)

	comment(# After sending this message, no cookies can be set or modified. Use it, when)
	comment(# HTTP-Headers are send. Rweb does this for you.)
	reserved(def) constant(Cookie)operator(.)ident(disallow)
		comment(# {{{)
		class_variable(@@allowed) operator(=) pre_constant(false)
		pre_constant(true)
		comment(# }}})
	reserved(end)

	comment(# Returns a HTTP header (type String\) with all cookies. Rweb does this for)
	comment(# you.)
	reserved(def) constant(Cookie)operator(.)ident(getHttpHeader)
		comment(# {{{)
		reserved(if) reserved(defined?)operator(()class_variable(@@list)operator(\))
			reserved(if) class_variable(@@type) operator(==) string<delimiter(")content(netscape)delimiter(")>
				ident(str) operator(=) string<delimiter(")delimiter(")>
				class_variable(@@list)operator(.)ident(each) reserved(do) operator(|)ident(cookie)operator(|)
					reserved(if) ident(cookie)operator(.)ident(value) operator(==) pre_constant(nil)
						ident(cookie)operator(.)ident(maxage) operator(=) integer(0)
						ident(cookie)operator(.)ident(value) operator(=) string<delimiter(")delimiter(")>
					reserved(end)
					comment(# TODO: Name and value should be escaped!)
					ident(str) operator(+=) string<delimiter(")content(Set-Cookie: )inline<delimiter(#{)ident(cookie)operator(.)ident(name)delimiter(})>content(=)inline<delimiter(#{)ident(cookie)operator(.)ident(value)delimiter(})>delimiter(")>
					reserved(unless) ident(cookie)operator(.)ident(maxage) operator(==) pre_constant(nil)
						ident(expire) operator(=) constant(Time)operator(.)ident(now) operator(+) ident(cookie)operator(.)ident(maxage)
						ident(expire)operator(.)ident(gmtime)
						ident(str) operator(+=) string<delimiter(")content(; Expire=)inline<delimiter(#{)ident(expire)operator(.)ident(strftime)operator(()string<delimiter(")content(%a, %d-%b-%Y %H:%M:%S %Z)delimiter(")>operator(\))delimiter(})>delimiter(")>
					reserved(end)
					reserved(unless) ident(cookie)operator(.)ident(domain) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Domain=)inline<delimiter(#{)ident(cookie)operator(.)ident(domain)delimiter(})>delimiter(")>
					reserved(end)
					reserved(unless) ident(cookie)operator(.)ident(path) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Path=)inline<delimiter(#{)ident(cookie)operator(.)ident(path)delimiter(})>delimiter(")>
					reserved(end)
					reserved(if) ident(cookie)operator(.)ident(secure)
						ident(str) operator(+=) string<delimiter(")content(; Secure)delimiter(")>
					reserved(end)
					ident(str) operator(+=) string<delimiter(")char(\\r)char(\\n)delimiter(")>
				reserved(end)
				reserved(return) ident(str)
			reserved(else) comment(# type == "RFC2109")
				ident(str) operator(=) string<delimiter(")content(Set-Cookie: )delimiter(")>
				ident(comma) operator(=) pre_constant(false)operator(;)

				class_variable(@@list)operator(.)ident(each) reserved(do) operator(|)ident(cookie)operator(|)
					reserved(if) ident(cookie)operator(.)ident(value) operator(==) pre_constant(nil)
						ident(cookie)operator(.)ident(maxage) operator(=) integer(0)
						ident(cookie)operator(.)ident(value) operator(=) string<delimiter(")delimiter(")>
					reserved(end)
					reserved(if) ident(comma)
						ident(str) operator(+=) string<delimiter(")content(,)delimiter(")>
					reserved(end)
					ident(comma) operator(=) pre_constant(true)

					ident(str) operator(+=) string<delimiter(")inline<delimiter(#{)ident(cookie)operator(.)ident(name)delimiter(})>content(=)char(\\")inline<delimiter(#{)ident(cookie)operator(.)ident(value)delimiter(})>char(\\")delimiter(")>
					reserved(unless) ident(cookie)operator(.)ident(maxage) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Max-Age=)char(\\")inline<delimiter(#{)ident(cookie)operator(.)ident(maxage)delimiter(})>char(\\")delimiter(")>
					reserved(end)
					reserved(unless) ident(cookie)operator(.)ident(domain) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Domain=)char(\\")inline<delimiter(#{)ident(cookie)operator(.)ident(domain)delimiter(})>char(\\")delimiter(")>
					reserved(end)
					reserved(unless) ident(cookie)operator(.)ident(path) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Path=)char(\\")inline<delimiter(#{)ident(cookie)operator(.)ident(path)delimiter(})>char(\\")delimiter(")>
					reserved(end)
					reserved(if) ident(cookie)operator(.)ident(secure)
						ident(str) operator(+=) string<delimiter(")content(; Secure)delimiter(")>
					reserved(end)
					reserved(unless) ident(cookie)operator(.)ident(comment) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Comment=)char(\\")inline<delimiter(#{)ident(cookie)operator(.)ident(comment)delimiter(})>char(\\")delimiter(")>
					reserved(end)
					ident(str) operator(+=) string<delimiter(")content(; Version=)char(\\")content(1)char(\\")delimiter(")>
				reserved(end)
				ident(str)
			reserved(end)
		reserved(else)
			pre_constant(false)
		reserved(end)
		comment(# }}})
	reserved(end)
reserved(end)

ident(require) string<delimiter(')content(strscan)delimiter(')>

reserved(module) class(BBCode)
	constant(DEBUG) operator(=) pre_constant(true)

	ident(use) string<delimiter(')content(encoder)delimiter(')>operator(,) string<delimiter(')content(tags)delimiter(')>operator(,) string<delimiter(')content(tagstack)delimiter(')>operator(,) string<delimiter(')content(smileys)delimiter(')>

comment(=begin
	The Parser class takes care of the encoding.
	It scans the given BBCode (as plain text\), finds tags
	and smilies and also makes links of urls in text.

	Normal text is send directly to the encoder.

	If a tag was found, an instance of a Tag subclass is created
	to handle the case.

	The @tagstack manages tag nesting and ensures valid HTML.
=end)

	reserved(class) class(Parser)
		reserved(class) class(Attribute)
			comment(# flatten and use only one empty_arg)
			reserved(def) pre_constant(self)operator(.)ident(create) ident(attr)
				ident(attr) operator(=) ident(flatten) ident(attr)
				reserved(return) class_variable(@@empty_attr) reserved(if) ident(attr)operator(.)ident(empty?)
				ident(new) ident(attr)
			reserved(end)

			ident(private_class_method) symbol(:new)

			comment(# remove leading and trailing whitespace; concat lines)
			reserved(def) pre_constant(self)operator(.)ident(flatten) ident(attr)
				ident(attr)operator(.)ident(strip)operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(,) string<delimiter(')content( )delimiter(')>operator(\))
				comment(# -> ^ and $ can only match at begin and end now)
			reserved(end)

			constant(ATTRIBUTE_SCAN) operator(=) regexp<delimiter(/)content(
				(?!$\)  # don't match at end
				)char(\\s)content(*
				( # $1 = key
					[^=)char(\\s)char(\\])content(")char(\\\\)content(]*
					(?:
						(?: )char(\\\\)content(. | "[^")char(\\\\)content(]*(?:)char(\\\\)content(.[^")char(\\\\)content(]*\)*"? \)
						[^=)char(\\s)char(\\])content(")char(\\\\)content(]*
					\)*
				\)
				(?:
					=
					( # $2 = value
						[^)char(\\s)char(\\])content(")char(\\\\)content(]*
						(?:
							(?: )char(\\\\)content(. | "[^")char(\\\\)content(]*(?:)char(\\\\)content(.[^")char(\\\\)content(]*\)*"? \)
							[^)char(\\s)char(\\])content(")char(\\\\)content(]*
						\)*
					\)?
				\)?
				)char(\\s)content(*
			)delimiter(/)modifier(x)>

			reserved(def) pre_constant(self)operator(.)ident(parse) ident(source)
				ident(source) operator(=) ident(source)operator(.)ident(dup)
				comment(# empty_tag: the tag looks like [... /])
				comment(# slice!: this deletes the \\s*/] at the end)
				comment(# \\s+ because [url=http://rubybb.org/forum/] is NOT an empty tag.)
				comment(# In RubyBBCode, you can use [url=http://rubybb.org/forum/ /], and this has to be)
				comment(# interpreted correctly.)
				ident(empty_tag) operator(=) ident(source)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(^:)delimiter(/)>operator(,) string<delimiter(')content(=)delimiter(')>operator(\)) reserved(or) ident(source)operator(.)ident(slice!)operator(()regexp<delimiter(/)char(\\/)content($)delimiter(/)>operator(\))
				ident(debug) string<delimiter(')content(PARSE: )delimiter(')> operator(+) ident(source)operator(.)ident(inspect) operator(+) string<delimiter(')content( => )delimiter(')> operator(+) ident(empty_tag)operator(.)ident(inspect)
				comment(#-> we have now an attr that's EITHER empty OR begins and ends with non-whitespace.)

				ident(attr) operator(=) constant(Hash)operator(.)ident(new)
				ident(attr)operator([)symbol(:flags)operator(]) operator(=) operator([)operator(])
				ident(source)operator(.)ident(scan)operator(()constant(ATTRIBUTE_SCAN)operator(\)) operator({) operator(|)ident(key)operator(,) ident(value)operator(|)
					reserved(if) reserved(not) ident(value)
						ident(attr)operator([)symbol(:flags)operator(]) operator(<<) ident(unescape)operator(()ident(key)operator(\))
					reserved(else)
						reserved(next) reserved(if) ident(value)operator(.)ident(empty?) reserved(and) ident(key)operator(.)ident(empty?)
						ident(attr)operator([)ident(unescape)operator(()ident(key)operator(\))operator(]) operator(=) ident(unescape)operator(()ident(value)operator(\))
					reserved(end)
				operator(})
				ident(debug) ident(attr)operator(.)ident(inspect)

				reserved(return) ident(empty_tag)operator(,) ident(attr)
			reserved(end)

			reserved(def) pre_constant(self)operator(.)ident(unescape_char) ident(esc)
				ident(esc)operator([)integer(1)operator(])
			reserved(end)

			reserved(def) pre_constant(self)operator(.)ident(unquote) ident(qt)
				ident(qt)operator([)integer(1)operator(..)operator(-)integer(1)operator(])operator(.)ident(chomp)operator(()string<delimiter(')content(")delimiter(')>operator(\))operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\\\)content(.)delimiter(/)>operator(\)) operator({) operator(|)ident(esc)operator(|) ident(unescape_char) ident(esc) operator(})
			reserved(end)

			reserved(def) pre_constant(self)operator(.)ident(unescape) ident(str)
				ident(str)operator(.)ident(gsub)operator(()regexp<delimiter(/)content( ()char(\\\\)content(.\) | (" [^")char(\\\\)content(]* (?:)char(\\\\)content(.[^")char(\\\\)content(]*\)* "?\) )delimiter(/)modifier(x)>operator(\)) operator({)
					reserved(if) global_variable($1)
						ident(unescape_char) global_variable($1)
					reserved(else)
						ident(unquote) global_variable($2)
					reserved(end)
				operator(})
			reserved(end)

			ident(include) constant(Enumerable)
			reserved(def) method(each) operator(&)ident(block)
				instance_variable(@args)operator(.)ident(each)operator(()operator(&)ident(block)operator(\))
			reserved(end)

			ident(attr_reader) symbol(:source)operator(,) symbol(:args)operator(,) symbol(:value)

			reserved(def) method(initialize) ident(source)
				instance_variable(@source) operator(=) ident(source)
				ident(debug) string<delimiter(')content(Attribute#new(%p\))delimiter(')> operator(%) ident(source)
				instance_variable(@empty_tag)operator(,) instance_variable(@attr) operator(=) constant(Attribute)operator(.)ident(parse) ident(source)
				instance_variable(@value) operator(=) instance_variable(@attr)operator([)string<delimiter(')delimiter(')>operator(])operator(.)ident(to_s)
			reserved(end)

			reserved(def) method(empty?)
				pre_constant(self) operator(==) class_variable(@@empty_attr)
			reserved(end)

			reserved(def) method(empty_tag?)
				instance_variable(@empty_tag)
			reserved(end)

			reserved(def) method([]) operator(*)ident(keys)
				ident(res) operator(=) instance_variable(@attr)operator([)operator(*)ident(keys)operator(])
			reserved(end)

			reserved(def) method(flags)
				ident(attr)operator([)symbol(:flags)operator(])
			reserved(end)

			reserved(def) method(to_s)
				instance_variable(@attr)
			reserved(end)

			reserved(def) method(inspect)
				string<delimiter(')content(ATTR[)delimiter(')> operator(+) instance_variable(@attr)operator(.)ident(inspect) operator(+) operator(()instance_variable(@empty_tag) operator(?) string<delimiter(')content( | empty tag)delimiter(')> operator(:) string<delimiter(')delimiter(')>operator(\)) operator(+) string<delimiter(')content(])delimiter(')>
			reserved(end)
		reserved(end)
		reserved(class) class(Attribute)
			class_variable(@@empty_attr) operator(=) ident(new) string<delimiter(')delimiter(')>
		reserved(end)
	reserved(end)

	reserved(class) class(Parser)
		reserved(def) constant(Parser)operator(.)ident(flatten) ident(str)
			comment(# replace mac & dos newlines with unix style)
			ident(str)operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\r)char(\\n)content(?)delimiter(/)>operator(,) string<delimiter(")char(\\n)delimiter(")>operator(\))
		reserved(end)

		reserved(def) method(initialize) ident(input) operator(=) string<delimiter(')delimiter(')>
			comment(# input manager)
			instance_variable(@scanner) operator(=) constant(StringScanner)operator(.)ident(new) string<delimiter(')delimiter(')>
			comment(# output manager)
			instance_variable(@encoder) operator(=) constant(Encoder)operator(.)ident(new)
			instance_variable(@output) operator(=) string<delimiter(')delimiter(')>
			comment(# tag manager)
			instance_variable(@tagstack) operator(=) constant(TagStack)operator(.)ident(new)operator(()instance_variable(@encoder)operator(\))

			instance_variable(@do_magic) operator(=) pre_constant(true)
			comment(# set the input)
			ident(feed) ident(input)
		reserved(end)

		comment(# if you want, you can feed a parser instance after creating,)
		comment(# or even feed it repeatedly.)
		reserved(def) method(feed) ident(food)
			instance_variable(@scanner)operator(.)ident(string) operator(=) constant(Parser)operator(.)ident(flatten) ident(food)
		reserved(end)

		comment(# parse through the string using parse_token)
		reserved(def) method(parse)
			ident(parse_token) reserved(until) instance_variable(@scanner)operator(.)ident(eos?)
			instance_variable(@tagstack)operator(.)ident(close_all)
			instance_variable(@output) operator(=) ident(parse_magic) instance_variable(@encoder)operator(.)ident(output)
		reserved(end)

		reserved(def) method(output)
			instance_variable(@output)
		reserved(end)

	comment(# ok, internals start here)
	ident(private)
		comment(# the default output functions. everything should use them or the tags.)
		reserved(def) method(add_text) ident(text) operator(=) instance_variable(@scanner)operator(.)ident(matched)
			instance_variable(@encoder)operator(.)ident(add_text) ident(text)
		reserved(end)

		comment(# use this carefully)
		reserved(def) method(add_html) ident(html)
			instance_variable(@encoder)operator(.)ident(add_html) ident(html)
		reserved(end)

		comment(# highlights the text as error)
		reserved(def) method(add_garbage) ident(garbage)
			ident(add_html) string<delimiter(')content(<span class="error">)delimiter(')> reserved(if) constant(DEBUG)
			ident(add_text) ident(garbage)
			ident(add_html) string<delimiter(')content(</span>)delimiter(')> reserved(if) constant(DEBUG)
		reserved(end)

		comment(# unknown and incorrectly nested tags are ignored and)
		comment(# sent as plaintext (garbage in - garbage out\).)
		comment(# in debug mode, garbage is marked with lime background.)
		reserved(def) method(garbage_out) ident(start)
			instance_variable(@scanner)operator(.)ident(pos) operator(=) ident(start)
			ident(garbage) operator(=) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(.)delimiter(/)modifier(m)>operator(\))
			ident(debug) string<delimiter(')content(GARBAGE: )delimiter(')> operator(+) ident(garbage)
			ident(add_garbage) ident(garbage)
		reserved(end)

		comment(# simple text; everything but [, \\[ allowed)
		constant(SIMPLE_TEXT_SCAN_) operator(=) regexp<delimiter(/)content(
			[^)char(\\[)char(\\\\)content(]*    # normal*
			(?:         # (
			)char(\\\\)content(.?        #   special
			[^)char(\\[)char(\\\\)content(]*    #   normal*
			\)*          # \)*
		)delimiter(/)modifier(mx)>
		constant(SIMPLE_TEXT_SCAN) operator(=) regexp<delimiter(/)content([^)char(\\[)content(]+)delimiter(/)>

comment(=begin

	WHAT IS A TAG?
	==============

	Tags in BBCode can be much more than just a simple [b].
	I use many terms here to differ the parts of each tag.

	Basic scheme:
	    [         code        ]
	TAG START   TAG INFO   TAG END

	Most tags need a second tag to close the range it opened.
	This is done with CLOSING TAGS:
		[/code]
	or by using empty tags that have no content and close themselfes:
		[url=winamp.com /]
	You surely know this from HTML.
	These slashes define the TAG KIND = normal|closing|empty and
	cannot be	used together.

	Everything between [ and ] and expluding the slashes is called the
	TAG INFO.	This info may contain:
	- TAG ID
	- TAG NAME including the tag id
	- attributes

	The TAG ID is the first char of the info:

	TAG       | ID
	----------+----
	[quote]   | q
	[&plusmn] | &
	["[b]"]   | "
	[/url]    | u
	[---]     | -

	As you can see, the tag id shows the TAG TYPE, it can be a
	normal tag,	a formatting tag or an entity.
	Therefor, the parser first scans the id to decide how to go
	on with parsing.
=end)
		comment(# tag)
		comment(# TODO more complex expression allowing)
		comment(#   [quote="[ladico]"] and [quote=\\[ladico\\]] to be correct tags)
		constant(TAG_BEGIN_SCAN) operator(=) regexp<delimiter(/)content(
			)char(\\[)content(             # tag start
			( )char(\\/)content( \)?        # $1 = closing tag?
			( [^)char(\\])content(] \)      # $2 = tag id
		)delimiter(/)modifier(x)>
		constant(TAG_END_SCAN) operator(=) regexp<delimiter(/)content(
			[^)char(\\])content(]*         # rest that was not handled
			)char(\\])content(?            # tag end
		)delimiter(/)modifier(x)>
		constant(CLOSE_TAG_SCAN) operator(=) regexp<delimiter(/)content(
			( [^)char(\\])content(]* \)     # $1 = the rest of the tag info
			( )char(\\/)content( \)?        # $2 = empty tag?
			)char(\\])content(?            # tag end
		)delimiter(/)modifier(x)>
		constant(UNCLOSED_TAG_SCAN) operator(=) regexp<delimiter(/)content( )char(\\[)content( )delimiter(/)modifier(x)>

		constant(CLASSIC_TAG_SCAN) operator(=) regexp<delimiter(/)content( [a-z]* )delimiter(/)modifier(ix)>

		constant(SEPARATOR_TAG_SCAN) operator(=) regexp<delimiter(/)content( )char(\\*)content(* )delimiter(/)modifier(x)>

		constant(FORMAT_TAG_SCAN) operator(=) regexp<delimiter(/)content( -- -* )delimiter(/)modifier(x)>

		constant(QUOTED_SCAN) operator(=) regexp<delimiter(/)content(
			(            # $1 = quoted text
				[^")char(\\\\)content(]*    # normal*
				(?:        # (
					)char(\\\\)content(.      # 	special
					[^")char(\\\\)content(]*  # 	normal*
				\)*         # \)*
			\)
			"?           # end quote "
		)delimiter(/)modifier(mx)>

		constant(ENTITY_SCAN) operator(=) regexp<delimiter(/)content(
			( [^;)char(\\])content(]+ \)  # $1 = entity code
			;?           # optional ending semicolon
		)delimiter(/)modifier(ix)>

		constant(SMILEY_SCAN) operator(=) constant(Smileys)operator(::)constant(SMILEY_PATTERN)

		comment(# this is the main parser loop that separates)
		comment(#   text - everything until "[")
		comment(# from)
		comment(#   tags - starting with "[", ending with "]")
		reserved(def) method(parse_token)
			reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(SIMPLE_TEXT_SCAN)operator(\))
				ident(add_text)
			reserved(else)
				ident(handle_tag)
			reserved(end)
		reserved(end)

		reserved(def) method(handle_tag)
			ident(tag_start) operator(=) instance_variable(@scanner)operator(.)ident(pos)

			reserved(unless) instance_variable(@scanner)operator(.)ident(scan) constant(TAG_BEGIN_SCAN)
				ident(garbage_out) ident(tag_start)
				reserved(return)
			reserved(end)

			ident(closing)operator(,) ident(id) operator(=) instance_variable(@scanner)operator([)integer(1)operator(])operator(,) instance_variable(@scanner)operator([)integer(2)operator(])
			comment(#debug 'handle_tag(%p\)' % @scanner.matched)

			ident(handled) operator(=)
				reserved(case) ident(id)

					reserved(when) regexp<delimiter(/)content([a-z])delimiter(/)modifier(i)>
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(CLASSIC_TAG_SCAN)operator(\))
							reserved(if) ident(handle_classic_tag)operator(()ident(id) operator(+) instance_variable(@scanner)operator(.)ident(matched)operator(,) ident(closing)operator(\))
								ident(already_closed) operator(=) pre_constant(true)
							reserved(end)
						reserved(end)

					reserved(when) string<delimiter(')content(*)delimiter(')>
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(SEPARATOR_TAG_SCAN)operator(\))
							ident(handle_asterisk) ident(tag_start)operator(,) ident(id) operator(+) instance_variable(@scanner)operator(.)ident(matched)
							pre_constant(true)
						reserved(end)

					reserved(when) string<delimiter(')content(-)delimiter(')>
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(FORMAT_TAG_SCAN)operator(\))
							comment(#format = id + @scanner.matched)
							instance_variable(@encoder)operator(.)ident(add_html) string<delimiter(")char(\\n)content(<hr>)char(\\n)delimiter(")>
							pre_constant(true)
						reserved(end)

					reserved(when) string<delimiter(')content(")delimiter(')>
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(QUOTED_SCAN)operator(\))
							instance_variable(@encoder)operator(.)ident(add_text) ident(unescape)operator(()instance_variable(@scanner)operator([)integer(1)operator(])operator(\))
							pre_constant(true)
						reserved(end)

					reserved(when) string<delimiter(')content(&)delimiter(')>
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(ENTITY_SCAN)operator(\))
							instance_variable(@encoder)operator(.)ident(add_entity) instance_variable(@scanner)operator([)integer(1)operator(])
							pre_constant(true)
						reserved(end)

					reserved(when) constant(Smileys)operator(::)constant(SMILEY_START_CHARSET)
						instance_variable(@scanner)operator(.)ident(pos) operator(=) instance_variable(@scanner)operator(.)ident(pos) operator(-) integer(1)  comment(# (ungetch\))
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(SMILEY_SCAN)operator(\))
							instance_variable(@encoder)operator(.)ident(add_html) constant(Smileys)operator(.)ident(smiley_to_image)operator(()instance_variable(@scanner)operator(.)ident(matched)operator(\))
							pre_constant(true)
						reserved(end)

				reserved(end) comment(# case)

			reserved(return) ident(garbage_out)operator(()ident(tag_start)operator(\)) reserved(unless) ident(handled)

			instance_variable(@scanner)operator(.)ident(scan)operator(()constant(TAG_END_SCAN)operator(\)) reserved(unless) ident(already_closed)
		reserved(end)

		constant(ATTRIBUTES_SCAN) operator(=) regexp<delimiter(/)content(
			(
				[^)char(\\])content(")char(\\\\)content(]*
				(?:
					(?:
						)char(\\\\)content(.
					|
						"
						[^")char(\\\\)content(]*
						(?:
							)char(\\\\)content(.
							[^")char(\\\\)content(]*
						\)*
						"?
					\)
					[^)char(\\])content(")char(\\\\)content(]*
				\)*
			\)
			)char(\\])content(?
		)delimiter(/)modifier(x)>

		reserved(def) method(handle_classic_tag) ident(name)operator(,) ident(closing)
			ident(debug) string<delimiter(')content(TAG: )delimiter(')> operator(+) operator(()ident(closing) operator(?) string<delimiter(')content(/)delimiter(')> operator(:) string<delimiter(')delimiter(')>operator(\)) operator(+) ident(name)
			comment(# flatten)
			ident(name)operator(.)ident(downcase!)
			ident(tag_class) operator(=) constant(TAG_LIST)operator([)ident(name)operator(])
			reserved(return) reserved(unless) ident(tag_class)

			comment(#debug((opening ? 'OPEN ' : 'CLOSE '\) + tag_class.name\))

			comment(# create an attribute object to handle it)
			instance_variable(@scanner)operator(.)ident(scan)operator(()constant(ATTRIBUTES_SCAN)operator(\))
			comment(#debug name + ':' + @scanner[1])
			ident(attr) operator(=) constant(Attribute)operator(.)ident(create) instance_variable(@scanner)operator([)integer(1)operator(])
			comment(#debug 'ATTRIBUTES %p ' % attr #unless attr.empty?)

			comment(#debug 'closing: %p; name=%s, attr=%p' % [closing, name, attr])

			comment(# OPEN)
			reserved(if) reserved(not) ident(closing) reserved(and) ident(tag) operator(=) instance_variable(@tagstack)operator(.)ident(try_open_class)operator(()ident(tag_class)operator(,) ident(attr)operator(\))
				comment(#debug 'opening')
				ident(tag)operator(.)ident(do_open) instance_variable(@scanner)
				comment(# this should be done by the tag itself.)
				reserved(if) ident(attr)operator(.)ident(empty_tag?)
					ident(tag)operator(.)ident(handle_empty)
					instance_variable(@tagstack)operator(.)ident(close_tag)
				reserved(elsif) ident(tag)operator(.)ident(special_content?)
					ident(handle_special_content)operator(()ident(tag)operator(\))
					instance_variable(@tagstack)operator(.)ident(close_tag)
					comment(#        # ignore asterisks directly after the opening; these are phpBBCode)
					comment(#        elsif tag.respond_to? :asterisk)
					comment(#          debug 'SKIP ASTERISKS: ' if @scanner.skip(ASTERISK_TAGS_SCAN\))
				reserved(end)

			comment(# CLOSE)
			reserved(elsif) instance_variable(@tagstack)operator(.)ident(try_close_class)operator(()ident(tag_class)operator(\))
				comment(#debug 'closing')
				comment(# GARBAGE)
			reserved(else)
				reserved(return)
			reserved(end)

			pre_constant(true)
		reserved(end)

		reserved(def) method(handle_asterisk) ident(tag_start)operator(,) ident(stars)
			comment(#debug 'ASTERISK: ' + stars.to_s)
			comment(# rule for asterisk tags: they belong to the last tag)
			comment(# that handles them. tags opened after this tag are closed.)
			comment(# if no open tag uses them, all are closed.)
			ident(tag) operator(=) instance_variable(@tagstack)operator(.)ident(close_all_until) operator({) operator(|)ident(tag)operator(|) ident(tag)operator(.)ident(respond_to?) symbol(:asterisk) operator(})
			reserved(unless) ident(tag) reserved(and) ident(tag)operator(.)ident(asterisk) ident(stars)operator(,) instance_variable(@scanner)
				ident(garbage_out) ident(tag_start)
			reserved(end)
		reserved(end)

		reserved(def) method(handle_special_content) ident(tag)
			ident(scanned) operator(=) instance_variable(@scanner)operator(.)ident(scan_until)operator(()ident(tag)operator(.)ident(closing_tag)operator(\))
			reserved(if) ident(scanned)
				ident(scanned)operator(.)ident(slice!)operator(()operator(-)operator(()instance_variable(@scanner)operator(.)ident(matched)operator(.)ident(size)operator(\))operator(..)operator(-)integer(1)operator(\))
			reserved(else)
				ident(scanned) operator(=) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(.*)delimiter(/)modifier(m)>operator(\))operator(.)ident(to_s)
			reserved(end)
			comment(#debug 'SPECIAL CONTENT: ' + scanned)
			ident(tag)operator(.)ident(handle_content)operator(()ident(scanned)operator(\))
		reserved(end)

		reserved(def) method(unescape) ident(text)
			comment(# input: correctly formatted quoted string (without the quotes\))
			ident(text)operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\\\)content((?:([")char(\\\\)content(]\)|.\))delimiter(/)>operator(\)) operator({) global_variable($1) reserved(or) global_variable($&) operator(})
		reserved(end)


		comment(# MAGIC FEAUTURES)

		constant(URL_PATTERN) operator(=) regexp<delimiter(/)content((?:(?:www|ftp\))char(\\.)content(|(?>)char(\\w)content({3,}\):)char(\\/)char(\\/)content(\))char(\\S)content(+)delimiter(/)>
		constant(EMAIL_PATTERN) operator(=) regexp<delimiter(/)content((?>[)char(\\w)char(\\-)content(_.]+\)@[)char(\\w)char(\\-)char(\\.)content(]+)char(\\.)char(\\w)content(+)delimiter(/)>

		constant(HAS_MAGIC) operator(=) regexp<delimiter(/)content([&@)inline<delimiter(#{)constant(Smileys)operator(::)constant(SMILEY_START_CHARS)delimiter(})>content(]|(?i:www|ftp\))delimiter(/)>

		constant(MAGIC_PATTERN) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(()content(\\W)content(|^\)(%s\))delimiter(')> operator(%)
			operator([)constant(Smileys)operator(::)constant(MAGIC_SMILEY_PATTERN)operator(,) constant(URL_PATTERN)operator(,) constant(EMAIL_PATTERN)operator(])operator(.)ident(map) operator({) operator(|)ident(pattern)operator(|)
				ident(pattern)operator(.)ident(to_s)
			operator(})operator(.)ident(join)operator(()string<delimiter(')content(|)delimiter(')>operator(\)) operator(\))

		constant(IS_SMILEY_PATTERN) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(^%s)delimiter(')> operator(%) constant(Smileys)operator(::)constant(SMILEY_START_CHARSET)operator(.)ident(to_s) operator(\))
		constant(IS_URL_PATTERN) operator(=) regexp<delimiter(/)content(^(?:(?i:www|ftp\))char(\\.)content(|(?>)char(\\w)content(+\):)char(\\/)char(\\/)content(\))delimiter(/)>
		constant(URL_STARTS_WITH_PROTOCOL) operator(=) regexp<delimiter(/)content(^)char(\\w)content(+:)char(\\/)char(\\/)delimiter(/)>
		constant(IS_EMAIL_PATTERN) operator(=) regexp<delimiter(/)content(^[)char(\\w)char(\\-)content(_.]+@)delimiter(/)>

		reserved(def) method(to_magic) ident(text)
			comment(#      debug MAGIC_PATTERN.to_s)
			ident(text)operator(.)ident(gsub!)operator(()constant(MAGIC_PATTERN)operator(\)) operator({)
				ident(magic) operator(=) global_variable($2)
				global_variable($1) operator(+) reserved(case) ident(magic)
					reserved(when) constant(IS_SMILEY_PATTERN)
						constant(Smileys)operator(.)ident(smiley_to_img) ident(magic)
					reserved(when) constant(IS_URL_PATTERN)
						ident(last) operator(=) ident(magic)operator(.)ident(slice_punctation!)  comment(# no punctation in my URL)
						ident(href) operator(=) ident(magic)
						ident(href)operator(.)ident(insert)operator(()integer(0)operator(,) string<delimiter(')content(http://)delimiter(')>operator(\)) reserved(unless) ident(magic) operator(=)operator(~) constant(URL_STARTS_WITH_PROTOCOL)
						string<delimiter(')content(<a href=")delimiter(')> operator(+) ident(href) operator(+) string<delimiter(')content(">)delimiter(')> operator(+) ident(magic) operator(+) string<delimiter(')content(</a>)delimiter(')> operator(+) ident(last)
					reserved(when) constant(IS_EMAIL_PATTERN)
						ident(last) operator(=) ident(magic)operator(.)ident(slice_punctation!)
						string<delimiter(')content(<a href="mailto:)delimiter(')> operator(+) ident(magic) operator(+) string<delimiter(')content(">)delimiter(')> operator(+) ident(magic) operator(+) string<delimiter(')content(</a>)delimiter(')> operator(+) ident(last)
				reserved(else)
					ident(raise) string<delimiter(')content({{{)delimiter(')> operator(+) ident(magic) operator(+) string<delimiter(')content(}}})delimiter(')>
				reserved(end)
			operator(})
			ident(text)
		reserved(end)

		comment(# handles smileys and urls)
		reserved(def) method(parse_magic) ident(html)
			reserved(return) ident(html) reserved(unless) instance_variable(@do_magic)
			ident(scanner) operator(=) constant(StringScanner)operator(.)ident(new) ident(html)
			ident(out) operator(=) string<delimiter(')delimiter(')>
			reserved(while) ident(scanner)operator(.)ident(rest?)
				reserved(if) ident(scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( < (?: a)char(\\s)content( .*? <)char(\\/)content(a> | pre)char(\\W)content( .*? <)char(\\/)content(pre> | [^>]* > \) )delimiter(/)modifier(mx)>operator(\))
					ident(out) operator(<<) ident(scanner)operator(.)ident(matched)
				reserved(elsif) ident(scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( [^<]+ )delimiter(/)modifier(x)>operator(\))
					ident(out) operator(<<) ident(to_magic)operator(()ident(scanner)operator(.)ident(matched)operator(\))

				comment(# this should never happen)
				reserved(elsif) ident(scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(.)delimiter(/)modifier(m)>operator(\))
					ident(raise) string<delimiter(')content(ERROR: else case reached)delimiter(')>
				reserved(end)
			reserved(end)
			ident(out)
		reserved(end)
	reserved(end)  comment(# Parser)
reserved(end)

reserved(class) class(String)
	reserved(def) method(slice_punctation!)
		ident(slice!)operator(()regexp<delimiter(/)content([.:,!)char(\\?)content(]+$)delimiter(/)>operator(\))operator(.)ident(to_s)  comment(# return '' instead of nil)
	reserved(end)
reserved(end)

comment(#)
comment(# = Grammar)
comment(#)
comment(# An implementation of common algorithms on grammars.)
comment(#)
comment(# This is used by Shinobu, a visualization tool for educating compiler-building.)
comment(#)
comment(# Thanks to Andreas Kunert for his wonderful LR(k\) Pamphlet (German, see http://www.informatik.hu-berlin.de/~kunert/papers/lr-analyse\), and Aho/Sethi/Ullman for their Dragon Book.)
comment(#)
comment(# Homepage::  http://shinobu.cYcnus.de (not existing yet\))
comment(# Author::    murphy (Kornelius Kalnbach\))
comment(# Copyright:: (cc\) 2005 cYcnus)
comment(# License::   GPL)
comment(# Version:: 0.2.0 (2005-03-27\))

ident(require) string<delimiter(')content(set_hash)delimiter(')>
ident(require) string<delimiter(')content(ctype)delimiter(')>
ident(require) string<delimiter(')content(tools)delimiter(')>
ident(require) string<delimiter(')content(rules)delimiter(')>
ident(require) string<delimiter(')content(trace)delimiter(')>

ident(require) string<delimiter(')content(first)delimiter(')>
ident(require) string<delimiter(')content(follow)delimiter(')>

comment(# = Grammar)
comment(#)
comment(# == Syntax)
comment(#)
comment(# === Rules)
comment(#)
comment(# Each line is a rule.)
comment(# The syntax is)
comment(#)
comment(# 	left - right)
comment(#)
comment(# where +left+ and +right+ can be uppercase and lowercase letters,)
comment(# and <code>-</code> can be any combination of <, >, - or whitespace.)
comment(#)
comment(# === Symbols)
comment(#)
comment(# Uppercase letters stand for meta symbols, lowercase for terminals.)
comment(#)
comment(# You can make epsilon-derivations by leaving <code><right></code> empty.)
comment(#)
comment(# === Example)
comment(# 	S - Ac)
comment(# 	A - Sc)
comment(# 	A - b)
comment(# 	A -)
reserved(class) class(Grammar)

	ident(attr_reader) symbol(:tracer)
	comment(# Creates a new Grammar.)
	comment(# If $trace is true, the algorithms explain (textual\) what they do to $stdout.)
	reserved(def) method(initialize) ident(data)operator(,) ident(tracer) operator(=) constant(Tracer)operator(.)ident(new)
		instance_variable(@tracer) operator(=) ident(tracer)
		instance_variable(@rules) operator(=) constant(Rules)operator(.)ident(new)
		instance_variable(@terminals)operator(,) instance_variable(@meta_symbols) operator(=) constant(SortedSet)operator(.)ident(new)operator(,) constant(Array)operator(.)ident(new)
		instance_variable(@start_symbol) operator(=) pre_constant(nil)
		ident(add_rules) ident(data)
	reserved(end)

	ident(attr_reader) symbol(:meta_symbols)operator(,) symbol(:terminals)operator(,) symbol(:rules)operator(,) symbol(:start_symbol)

	ident(alias_method) symbol(:sigma)operator(,) symbol(:terminals)
	ident(alias_method) symbol(:alphabet)operator(,) symbol(:terminals)
	ident(alias_method) symbol(:variables)operator(,) symbol(:meta_symbols)
	ident(alias_method) symbol(:nonterminals)operator(,) symbol(:meta_symbols)

	comment(# A string representation of the grammar for debugging.)
	reserved(def) method(inspect) ident(productions_too) operator(=) pre_constant(false)
		string<delimiter(')content(Grammar(meta symbols: %s; alphabet: %s; productions: [%s]; start symbol: %s\))delimiter(')> operator(%)
			operator([)
				ident(meta_symbols)operator(.)ident(join)operator(()string<delimiter(')content(, )delimiter(')>operator(\))operator(,)
				ident(terminals)operator(.)ident(join)operator(()string<delimiter(')content(, )delimiter(')>operator(\))operator(,)
				reserved(if) ident(productions_too)
					instance_variable(@rules)operator(.)ident(inspect)
				reserved(else)
					instance_variable(@rules)operator(.)ident(size)
				reserved(end)operator(,)
				ident(start_symbol)
			operator(])
	reserved(end)

	comment(# Add rules to the grammar. +rules+ should be a String or respond to +scan+ in a similar way.)
	comment(#)
	comment(# Syntax: see Grammar.)
	reserved(def) method(add_rules) ident(grammar)
		instance_variable(@rules) operator(=) constant(Rules)operator(.)ident(parse) ident(grammar) reserved(do) operator(|)ident(rule)operator(|)
			instance_variable(@start_symbol) operator(||=) ident(rule)operator(.)ident(left)
			instance_variable(@meta_symbols) operator(<<) ident(rule)operator(.)ident(left)
			instance_variable(@terminals)operator(.)ident(merge) ident(rule)operator(.)ident(right)operator(.)ident(split)operator(()string<delimiter(')delimiter(')>operator(\))operator(.)ident(select) operator({) operator(|)ident(s)operator(|) ident(terminal?) ident(s) operator(})
		reserved(end)
		instance_variable(@meta_symbols)operator(.)ident(uniq!)
		ident(update)
	reserved(end)

	comment(# Returns a hash acting as FIRST operator, so that)
	comment(# <code>first["ABC"]</code> is FIRST(ABC\).)
	comment(# See http://en.wikipedia.org/wiki/LL_parser "Constructing an LL(1\) parsing table" for details.)
	reserved(def) method(first)
		ident(first_operator)
	reserved(end)

	comment(# Returns a hash acting as FOLLOW operator, so that)
	comment(# <code>first["A"]</code> is FOLLOW(A\).)
	comment(# See http://en.wikipedia.org/wiki/LL_parser "Constructing an LL(1\) parsing table" for details.)
	reserved(def) method(follow)
		ident(follow_operator)
	reserved(end)

	constant(LLError) operator(=) constant(Class)operator(.)ident(new)operator(()constant(Exception)operator(\))
	constant(LLErrorType1) operator(=) constant(Class)operator(.)ident(new)operator(()constant(LLError)operator(\))
	constant(LLErrorType2) operator(=) constant(Class)operator(.)ident(new)operator(()constant(LLError)operator(\))

	comment(# Tests if the grammar is LL(1\).)
	reserved(def) method(ll1?)
		reserved(begin)
			reserved(for) ident(meta) reserved(in) instance_variable(@meta_symbols)
				ident(first_sets) operator(=) instance_variable(@rules)operator([)ident(meta)operator(])operator(.)ident(map) operator({) operator(|)ident(alpha)operator(|) ident(first)operator([)ident(alpha)operator(]) operator(})
				ident(first_sets)operator(.)ident(inject)operator(()constant(Set)operator([)operator(])operator(\)) reserved(do) operator(|)ident(already_used)operator(,) ident(another_first_set)operator(|)
					reserved(unless) ident(already_used)operator(.)ident(disjoint?) ident(another_first_set)
						ident(raise) constant(LLErrorType1)
					reserved(end)
					ident(already_used)operator(.)ident(merge) ident(another_first_set)
				reserved(end)

				reserved(if) ident(first)operator([)ident(meta)operator(])operator(.)ident(include?) constant(EPSILON) reserved(and) reserved(not) ident(first)operator([)ident(meta)operator(])operator(.)ident(disjoint?) ident(follow)operator([)ident(meta)operator(])
					ident(raise) constant(LLErrorType2)
				reserved(end)
			reserved(end)
		reserved(rescue) constant(LLError)
			pre_constant(false)
		reserved(else)
			pre_constant(true)
		reserved(end)
	reserved(end)

ident(private)

	reserved(def) method(first_operator)
		instance_variable(@first) operator(||=) constant(FirstOperator)operator(.)ident(new) pre_constant(self)
	reserved(end)

	reserved(def) method(follow_operator)
		instance_variable(@follow) operator(||=) constant(FollowOperator)operator(.)ident(new) pre_constant(self)
	reserved(end)

	reserved(def) method(update)
		instance_variable(@first) operator(=) instance_variable(@follow) operator(=) pre_constant(nil)
	reserved(end)

reserved(end)

reserved(if) global_variable($0) operator(==) pre_constant(__FILE__)
  ident(eval) pre_constant(DATA)operator(.)ident(read)operator(,) pre_constant(nil)operator(,) global_variable($0)operator(,) pre_constant(__LINE__)operator(+)integer(4)
reserved(end)

ident(require) string<delimiter(')content(test/unit)delimiter(')>

reserved(class) class(TestCaseGrammar) operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)

	ident(include) constant(Grammar)operator(::)constant(Symbols)

	reserved(def) method(fifo) ident(s)
		constant(Set)operator([)operator(*)ident(s)operator(.)ident(split)operator(()string<delimiter(')delimiter(')>operator(\))operator(])
	reserved(end)

	reserved(def) method(test_fifo)
		ident(assert_equal) constant(Set)operator([)operator(])operator(,) ident(fifo)operator(()string<delimiter(')delimiter(')>operator(\))
		ident(assert_equal) constant(Set)operator([)constant(EPSILON)operator(,) constant(END_OF_INPUT)operator(,) string<delimiter(')content(x)delimiter(')>operator(,) string<delimiter(')content(Y)delimiter(')>operator(])operator(,) ident(fifo)operator(()string<delimiter(')content(?xY$)delimiter(')>operator(\))
	reserved(end)

	constant(TEST_GRAMMAR_1) operator(=) string<delimiter(<<-EOG)>string<content(
S - ABCD
A - a
A -
B - b
B -
C - c
C -
D - S
D -)delimiter(
	EOG)>

	reserved(def) method(test_symbols)
		ident(assert) constant(EPSILON)
		ident(assert) constant(END_OF_INPUT)
	reserved(end)

	reserved(def) method(test_first_1)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_1)

		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(first) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) constant(EPSILON)operator(])operator(,) ident(f)operator([)string<delimiter(')content(A)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(b)delimiter(')>operator(,) constant(EPSILON)operator(])operator(,) ident(f)operator([)string<delimiter(')content(B)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(c)delimiter(')>operator(,) constant(EPSILON)operator(])operator(,) ident(f)operator([)string<delimiter(')content(C)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(b)delimiter(')>operator(,) string<delimiter(')content(c)delimiter(')>operator(,) constant(EPSILON)operator(])operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
	reserved(end)

	reserved(def) method(test_follow_1)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_1)

		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(follow) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(b)delimiter(')>operator(,) string<delimiter(')content(c)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(A)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(b)delimiter(')>operator(,) string<delimiter(')content(c)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(B)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(b)delimiter(')>operator(,) string<delimiter(')content(c)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(C)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
	reserved(end)


	constant(TEST_GRAMMAR_2) operator(=) string<delimiter(<<-EOG)>string<content(
S - Ed
E - EpT
E - EmT
E - T
T - TuF
T - TdF
T - F
F - i
F - n
F - aEz)delimiter(
	EOG)>

	reserved(def) method(test_first_2)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_2)

		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(first) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(n)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(n)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(n)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(n)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
	reserved(end)

	reserved(def) method(test_follow_2)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_2)

		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(follow) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(m)delimiter(')>operator(,) string<delimiter(')content(d)delimiter(')>operator(,) string<delimiter(')content(z)delimiter(')>operator(,) string<delimiter(')content(p)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(m)delimiter(')>operator(,) string<delimiter(')content(d)delimiter(')>operator(,) string<delimiter(')content(z)delimiter(')>operator(,) string<delimiter(')content(p)delimiter(')>operator(,) string<delimiter(')content(u)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(m)delimiter(')>operator(,) string<delimiter(')content(d)delimiter(')>operator(,) string<delimiter(')content(z)delimiter(')>operator(,) string<delimiter(')content(p)delimiter(')>operator(,) string<delimiter(')content(u)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
	reserved(end)

	constant(LLError) operator(=) constant(Grammar)operator(::)constant(LLError)

	constant(TEST_GRAMMAR_3) operator(=) string<delimiter(<<-EOG)>string<content(
E - TD
D - pTD
D -
T - FS
S - uFS
S -
S - p
F - aEz
F - i)delimiter(
	EOG)>

	constant(NoError) operator(=) constant(Class)operator(.)ident(new)operator(()constant(Exception)operator(\))

	reserved(def) method(test_first_3)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_3)

		comment(# Grammar 3 is LL(1\), so all first-sets must be disjoint.)
		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(first) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(EPSILON)operator(,) string<delimiter(')content(p)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(EPSILON)operator(,) string<delimiter(')content(u)delimiter(')>operator(,) string<delimiter(')content(p)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
		reserved(for) ident(m) reserved(in) ident(g)operator(.)ident(meta_symbols)
			ident(r) operator(=) ident(g)operator(.)ident(rules)operator([)ident(m)operator(])
			ident(firsts) operator(=) ident(r)operator(.)ident(map) operator({) operator(|)ident(x)operator(|) ident(f)operator([)ident(x)operator(]) operator(})operator(.)ident(to_set)
			ident(assert_nothing_raised) reserved(do)
				ident(firsts)operator(.)ident(inject)operator(()constant(Set)operator(.)ident(new)operator(\)) reserved(do) operator(|)ident(already_used)operator(,) ident(another_first_set)operator(|)
					ident(raise) constant(LLError)operator(,) string<delimiter(')content(not disjoint!)delimiter(')> reserved(unless) ident(already_used)operator(.)ident(disjoint?) ident(another_first_set)
					ident(already_used)operator(.)ident(merge) ident(another_first_set)
				reserved(end)
			reserved(end)
		reserved(end)
	reserved(end)

	reserved(def) method(test_follow_3)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_3)

		comment(# Grammar 3 is not LL(1\), because epsilon is in FIRST(S\),)
		comment(# but FIRST(S\) and FOLLOW(S\) are not disjoint.)
		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(follow) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(z)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(z)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(z)delimiter(')>operator(,) string<delimiter(')content(p)delimiter(')>operator(,) string<delimiter(')content(u)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(p)delimiter(')>operator(,) string<delimiter(')content(z)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(p)delimiter(')>operator(,) string<delimiter(')content(z)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
		reserved(for) ident(m) reserved(in) ident(g)operator(.)ident(meta_symbols)
			ident(first_m) operator(=) ident(g)operator(.)ident(first)operator([)ident(m)operator(])
			reserved(next) reserved(unless) ident(first_m)operator(.)ident(include?) constant(EPSILON)
			ident(assert_raise)operator(()ident(m) operator(==) string<delimiter(')content(S)delimiter(')> operator(?) constant(LLError) operator(:) constant(NoError)operator(\)) reserved(do)
				reserved(if) ident(first_m)operator(.)ident(disjoint?) ident(f)operator([)ident(m)operator(])
					ident(raise) constant(NoError)  comment(# this is fun :D)
				reserved(else)
					ident(raise) constant(LLError)
				reserved(end)
			reserved(end)
		reserved(end)
	reserved(end)

	constant(TEST_GRAMMAR_3b) operator(=) string<delimiter(<<-EOG)>string<content(
E - TD
D - pTD
D - PTD
D -
T - FS
S - uFS
S -
F - aEz
F - i
P - p)delimiter(
	EOG)>

	reserved(def) method(test_first_3b)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_3b)

		comment(# Grammar 3b is NOT LL(1\), since not all first-sets are disjoint.)
		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(first) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(EPSILON)operator(,) string<delimiter(')content(p)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(p)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(P)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(EPSILON)operator(,) string<delimiter(')content(u)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
		reserved(for) ident(m) reserved(in) ident(g)operator(.)ident(meta_symbols)
			ident(r) operator(=) ident(g)operator(.)ident(rules)operator([)ident(m)operator(])
			ident(firsts) operator(=) ident(r)operator(.)ident(map) operator({) operator(|)ident(x)operator(|) ident(f)operator([)ident(x)operator(]) operator(})
			ident(assert_raise)operator(()ident(m) operator(==) string<delimiter(')content(D)delimiter(')> operator(?) constant(LLError) operator(:) constant(NoError)operator(\)) reserved(do)
				ident(firsts)operator(.)ident(inject)operator(()constant(Set)operator(.)ident(new)operator(\)) reserved(do) operator(|)ident(already_used)operator(,) ident(another_first_set)operator(|)
					ident(raise) constant(LLError)operator(,) string<delimiter(')content(not disjoint!)delimiter(')> reserved(unless) ident(already_used)operator(.)ident(disjoint?) ident(another_first_set)
					ident(already_used)operator(.)ident(merge) ident(another_first_set)
				reserved(end)
				ident(raise) constant(NoError)
			reserved(end)
		reserved(end)
	reserved(end)

	reserved(def) method(test_follow_3b)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_3b)

		comment(# Although Grammar 3b is NOT LL(1\), the FOLLOW-condition is satisfied.)
		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(follow) operator(})
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(z$)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(,) string<delimiter(')content(E)delimiter(')>operator(\))
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(z$)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(,) string<delimiter(')content(D)delimiter(')>operator(\))
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(ai)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(P)delimiter(')>operator(])operator(,) string<delimiter(')content(P)delimiter(')>operator(\))
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(z$pu)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(,) string<delimiter(')content(F)delimiter(')>operator(\))
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(z$p)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(,) string<delimiter(')content(T)delimiter(')>operator(\))
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(z$p)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(,) string<delimiter(')content(S)delimiter(')>operator(\))
		reserved(for) ident(m) reserved(in) ident(g)operator(.)ident(meta_symbols)
			ident(first_m) operator(=) ident(g)operator(.)ident(first)operator([)ident(m)operator(])
			reserved(next) reserved(unless) ident(first_m)operator(.)ident(include?) constant(EPSILON)
			ident(assert_raise)operator(()constant(NoError)operator(\)) reserved(do)
				reserved(if) ident(first_m)operator(.)ident(disjoint?) ident(f)operator([)ident(m)operator(])
					ident(raise) constant(NoError)  comment(# this is fun :D)
				reserved(else)
					ident(raise) constant(LLError)
				reserved(end)
			reserved(end)
		reserved(end)
	reserved(end)

	reserved(def) method(test_ll1?)
		ident(assert_equal) pre_constant(false)operator(,) constant(Grammar)operator(.)ident(new)operator(()constant(TEST_GRAMMAR_3)operator(\))operator(.)ident(ll1?)operator(,) string<delimiter(')content(Grammar 3)delimiter(')>
		ident(assert_equal) pre_constant(false)operator(,) constant(Grammar)operator(.)ident(new)operator(()constant(TEST_GRAMMAR_3b)operator(\))operator(.)ident(ll1?)operator(,) string<delimiter(')content(Grammar 3b)delimiter(')>
	reserved(end)

	reserved(def) method(test_new)
		ident(assert_nothing_raised) operator({) constant(Grammar)operator(.)ident(new) string<delimiter(')delimiter(')> operator(})
		ident(assert_nothing_raised) operator({) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_1) operator(})
		ident(assert_nothing_raised) operator({) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_2) operator(})
		ident(assert_nothing_raised) operator({) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_3) operator(})
		ident(assert_nothing_raised) operator({) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_1) operator(+) constant(TEST_GRAMMAR_2) operator(+) constant(TEST_GRAMMAR_3) operator(})
		ident(assert_raise)operator(()constant(ArgumentError)operator(\)) operator({) constant(Grammar)operator(.)ident(new) string<delimiter(')content(S - ?)delimiter(')> operator(})
	reserved(end)
reserved(end)

comment(# vim:foldmethod=syntax)

comment(#!/usr/bin/env ruby)

ident(require) string<delimiter(')content(fox12)delimiter(')>

ident(include) constant(Fox)

reserved(class) class(Window) operator(<) constant(FXMainWindow)
	reserved(def) method(initialize)operator(()ident(app)operator(\))
		reserved(super)operator(()ident(app)operator(,) ident(app)operator(.)ident(appName) operator(+) string<delimiter(")content(: First Set Calculation)delimiter(")>operator(,) pre_constant(nil)operator(,) pre_constant(nil)operator(,) constant(DECOR_ALL)operator(,) integer(0)operator(,) integer(0)operator(,) integer(800)operator(,) integer(600)operator(,) integer(0)operator(,) integer(0)operator(\))

		comment(# {{{ menubar)
		ident(menubar) operator(=) constant(FXMenuBar)operator(.)ident(new)operator(()pre_constant(self)operator(,) constant(LAYOUT_SIDE_TOP)operator(|)constant(LAYOUT_FILL_X)operator(\))

		ident(filemenu) operator(=) constant(FXMenuPane)operator(.)ident(new)operator(()pre_constant(self)operator(\))

		constant(FXMenuCommand)operator(.)ident(new)operator(()ident(filemenu)operator(,) string<delimiter(")content(&Start)char(\\t)content(Ctl-S)char(\\t)content(Start the application.)delimiter(")>operator(,) pre_constant(nil)operator(,) ident(getApp)operator(()operator(\))operator(\))operator(.)ident(connect)operator(()constant(SEL_COMMAND)operator(,) ident(method)operator(()symbol(:start)operator(\))operator(\))
		constant(FXMenuCommand)operator(.)ident(new)operator(()ident(filemenu)operator(,) string<delimiter(")content(&Quit)char(\\t)content(Alt-F4)char(\\t)content(Quit the application.)delimiter(")>operator(,) pre_constant(nil)operator(,) ident(getApp)operator(()operator(\))operator(,) constant(FXApp)operator(::)constant(ID_QUIT)operator(\))
		constant(FXMenuTitle)operator(.)ident(new)operator(()ident(menubar)operator(,) string<delimiter(")content(&File)delimiter(")>operator(,) pre_constant(nil)operator(,) ident(filemenu)operator(\))
		comment(# }}} menubar)

		comment(# {{{ statusbar)
		instance_variable(@statusbar) operator(=) constant(FXStatusBar)operator(.)ident(new)operator(()pre_constant(self)operator(,) constant(LAYOUT_SIDE_BOTTOM)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(STATUSBAR_WITH_DRAGCORNER)operator(\))
		comment(# }}} statusbar)

		comment(# {{{ window content)
		ident(horizontalsplitt) operator(=) constant(FXSplitter)operator(.)ident(new)operator(()pre_constant(self)operator(,) constant(SPLITTER_VERTICAL)operator(|)constant(LAYOUT_SIDE_TOP)operator(|)constant(LAYOUT_FILL)operator(\))


		instance_variable(@productions) operator(=) constant(FXList)operator(.)ident(new)operator(()ident(horizontalsplitt)operator(,) pre_constant(nil)operator(,) integer(0)operator(,) constant(LAYOUT_SIDE_TOP)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FIX_HEIGHT)operator(|)constant(LIST_SINGLESELECT)operator(\))
		instance_variable(@productions)operator(.)ident(height) operator(=) integer(100)

		instance_variable(@result) operator(=) constant(FXTable)operator(.)ident(new)operator(()ident(horizontalsplitt)operator(,) pre_constant(nil)operator(,) integer(0)operator(,) constant(LAYOUT_FILL)operator(\))
		instance_variable(@result)operator(.)ident(height) operator(=) integer(200)
		instance_variable(@result)operator(.)ident(setTableSize)operator(()integer(2)operator(,) integer(2)operator(,) pre_constant(false)operator(\))
		instance_variable(@result)operator(.)ident(rowHeaderWidth) operator(=) integer(0)

		ident(header) operator(=) instance_variable(@result)operator(.)ident(columnHeader)
		ident(header)operator(.)ident(setItemText) integer(0)operator(,) string<delimiter(')content(X)delimiter(')>
		ident(header)operator(.)ident(setItemText) integer(1)operator(,) string<delimiter(')content(FIRST(X\))delimiter(')>
		reserved(for) ident(item) reserved(in) ident(header)
			ident(item)operator(.)ident(justification) operator(=) constant(FXHeaderItem)operator(::)constant(CENTER_X)
		reserved(end)

		instance_variable(@debug) operator(=) constant(FXText)operator(.)ident(new)operator(()ident(horizontalsplitt)operator(,) pre_constant(nil)operator(,) integer(0)operator(,) constant(LAYOUT_SIDE_BOTTOM)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FIX_HEIGHT)operator(\))
		instance_variable(@debug)operator(.)ident(height) operator(=) integer(200)

		comment(# }}} window content)
	reserved(end)

	reserved(def) method(load_grammar) ident(grammar)
		instance_variable(@tracer) operator(=) constant(FirstTracer)operator(.)ident(new)operator(()pre_constant(self)operator(\))
		instance_variable(@grammar) operator(=) constant(Grammar)operator(.)ident(new) ident(grammar)operator(,) instance_variable(@tracer)
		instance_variable(@rules_indexes) operator(=) constant(Hash)operator(.)ident(new)
		instance_variable(@grammar)operator(.)ident(rules)operator(.)ident(each_with_index) reserved(do) operator(|)ident(rule)operator(,) ident(i)operator(|)
			instance_variable(@productions)operator(.)ident(appendItem) ident(rule)operator(.)ident(inspect)
			instance_variable(@rules_indexes)operator([)ident(rule)operator(]) operator(=) ident(i)
		reserved(end)
	reserved(end)

	reserved(def) method(create)
		reserved(super)
		ident(show)operator(()constant(PLACEMENT_SCREEN)operator(\))
	reserved(end)

	reserved(def) method(rule) ident(rule)
		instance_variable(@productions)operator(.)ident(selectItem) instance_variable(@rules_indexes)operator([)ident(rule)operator(])
		ident(sleep) float(0.1)
	reserved(end)

	reserved(def) method(iterate) ident(i)
		ident(setTitle) ident(i)operator(.)ident(to_s)
		ident(sleep) float(0.1)
	reserved(end)

	reserved(def) method(missing) ident(what)
		instance_variable(@debug)operator(.)ident(appendText) ident(what) operator(+) string<delimiter(")char(\\n)delimiter(")>
		ident(sleep) float(0.1)
	reserved(end)

	reserved(def) method(start) ident(sender)operator(,) ident(sel)operator(,) ident(pointer)
		constant(Thread)operator(.)ident(new) reserved(do)
			reserved(begin)
				instance_variable(@grammar)operator(.)ident(first)
			reserved(rescue) operator(=)operator(>) ident(boom)
				instance_variable(@debug)operator(.)ident(appendText) operator([)ident(boom)operator(.)ident(to_s)operator(,) operator(*)ident(boom)operator(.)ident(backtrace)operator(])operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))
			reserved(end)
		reserved(end)
	reserved(end)

reserved(end)

global_variable($:) operator(<<) string<delimiter(')content(grammar)delimiter(')>
ident(require) string<delimiter(')content(grammar)delimiter(')>

ident(require) string<delimiter(')content(first_tracer)delimiter(')>

ident(app) operator(=) constant(FXApp)operator(.)ident(new)operator(()string<delimiter(")content(Shinobu)delimiter(")>operator(,) string<delimiter(")content(cYcnus)delimiter(")>operator(\))

comment(# fenster erzeugen)
ident(window) operator(=) constant(Window)operator(.)ident(new) ident(app)

reserved(unless) pre_constant(ARGV)operator(.)ident(empty?)
	ident(grammar) operator(=) constant(File)operator(.)ident(read)operator(()pre_constant(ARGV)operator(.)ident(first)operator(\))
reserved(else)
	ident(grammar) operator(=) string<delimiter(<<-EOG1)>string<content(
Z --> S
S --> Sb
S --> bAa
A --> aSc
A --> a
A --> aSb)delimiter(
	EOG1)>
reserved(end)

ident(window)operator(.)ident(load_grammar) ident(grammar)

ident(app)operator(.)ident(create)
ident(app)operator(.)ident(run)

ident(require) string<delimiter(')content(erb)delimiter(')>
ident(require) string<delimiter(')content(ftools)delimiter(')>
ident(require) string<delimiter(')content(yaml)delimiter(')>
ident(require) string<delimiter(')content(redcloth)delimiter(')>

reserved(module) class(WhyTheLuckyStiff)
	reserved(class) class(Book)
		ident(attr_accessor) symbol(:author)operator(,) symbol(:title)operator(,) symbol(:terms)operator(,) symbol(:image)operator(,) symbol(:teaser)operator(,)
			symbol(:chapters)operator(,) symbol(:expansion_paks)operator(,) symbol(:encoding)operator(,) symbol(:credits)
		reserved(def) method([]) ident(x)
			instance_variable(@lang)operator(.)ident(fetch)operator(()ident(x)operator(\)) reserved(do)
				ident(warn) ident(warning) operator(=) string<delimiter(")content([not translated: ')inline<delimiter(#{)ident(x)delimiter(})>content('!])delimiter(")>
				ident(warning)
			reserved(end)
		reserved(end)
	reserved(end)

	reserved(def) constant(Book)operator(::)ident(load)operator(() ident(file_name) operator(\))
		constant(YAML)operator(::)ident(load)operator(() constant(File)operator(.)ident(open)operator(() ident(file_name) operator(\)) operator(\))
	reserved(end)

	reserved(class) class(Section)
		ident(attr_accessor) symbol(:index)operator(,) symbol(:header)operator(,) symbol(:content)
		reserved(def) method(initialize)operator(() ident(i)operator(,) ident(h)operator(,) ident(c) operator(\))
			instance_variable(@index)operator(,) instance_variable(@header)operator(,) instance_variable(@content) operator(=) ident(i)operator(,) ident(h)operator(,) constant(RedCloth)operator(::)ident(new)operator(() ident(c)operator(.)ident(to_s) operator(\))
		reserved(end)
	reserved(end)

	reserved(class) class(Sidebar)
		ident(attr_accessor) symbol(:title)operator(,) symbol(:content)
	reserved(end)

	constant(YAML)operator(::)ident(add_domain_type)operator(() string<delimiter(')content(whytheluckystiff.net,2003)delimiter(')>operator(,) string<delimiter(')content(sidebar)delimiter(')> operator(\)) reserved(do) operator(|)ident(taguri)operator(,) ident(val)operator(|)
		constant(YAML)operator(::)ident(object_maker)operator(() constant(Sidebar)operator(,) string<delimiter(')content(title)delimiter(')> operator(=)operator(>) ident(val)operator(.)ident(keys)operator(.)ident(first)operator(,) string<delimiter(')content(content)delimiter(')> operator(=)operator(>) constant(RedCloth)operator(::)ident(new)operator(() ident(val)operator(.)ident(values)operator(.)ident(first) operator(\)) operator(\))
	reserved(end)
	reserved(class) class(Chapter)
		ident(attr_accessor) symbol(:index)operator(,) symbol(:title)operator(,) symbol(:sections)
		reserved(def) method(initialize)operator(() ident(i)operator(,) ident(t)operator(,) ident(sects) operator(\))
			instance_variable(@index) operator(=) ident(i)
			instance_variable(@title) operator(=) ident(t)
			ident(i) operator(=) integer(0)
			instance_variable(@sections) operator(=) ident(sects)operator(.)ident(collect) reserved(do) operator(|)ident(s)operator(|)
				reserved(if) ident(s)operator(.)ident(respond_to?)operator(() symbol(:keys) operator(\))
					ident(i) operator(+=) integer(1)
					constant(Section)operator(.)ident(new)operator(() ident(i)operator(,) ident(s)operator(.)ident(keys)operator(.)ident(first)operator(,) ident(s)operator(.)ident(values)operator(.)ident(first) operator(\))
				reserved(else)
					ident(s)
				reserved(end)
			reserved(end)
		reserved(end)
	reserved(end)

	constant(YAML)operator(::)ident(add_domain_type)operator(() string<delimiter(')content(whytheluckystiff.net,2003)delimiter(')>operator(,) string<delimiter(')content(book)delimiter(')> operator(\)) reserved(do) operator(|)ident(taguri)operator(,) ident(val)operator(|)
		operator([)string<delimiter(')content(chapters)delimiter(')>operator(,) string<delimiter(')content(expansion_paks)delimiter(')>operator(])operator(.)ident(each) reserved(do) operator(|)ident(chaptype)operator(|)
			ident(i) operator(=) integer(0)
			ident(val)operator([)ident(chaptype)operator(])operator(.)ident(collect!) reserved(do) operator(|)ident(c)operator(|)
				ident(i) operator(+=) integer(1)
				constant(Chapter)operator(::)ident(new)operator(() ident(i)operator(,) ident(c)operator(.)ident(keys)operator(.)ident(first)operator(,) ident(c)operator(.)ident(values)operator(.)ident(first) operator(\))
			reserved(end)
		reserved(end)
		ident(val)operator([)string<delimiter(')content(teaser)delimiter(')>operator(])operator(.)ident(collect!) reserved(do) operator(|)ident(t)operator(|)
			constant(Section)operator(::)ident(new)operator(() integer(1)operator(,) ident(t)operator(.)ident(keys)operator(.)ident(first)operator(,) ident(t)operator(.)ident(values)operator(.)ident(first) operator(\))
		reserved(end)
		ident(val)operator([)string<delimiter(')content(terms)delimiter(')>operator(]) operator(=) constant(RedCloth)operator(::)ident(new)operator(() ident(val)operator([)string<delimiter(')content(terms)delimiter(')>operator(]) operator(\))
		constant(YAML)operator(::)ident(object_maker)operator(() constant(Book)operator(,) ident(val) operator(\))
	reserved(end)

	reserved(class) class(Image)
		ident(attr_accessor) symbol(:file_name)
	reserved(end)

	constant(YAML)operator(::)ident(add_domain_type)operator(() string<delimiter(')content(whytheluckystiff.net,2003)delimiter(')>operator(,) string<delimiter(')content(img)delimiter(')> operator(\)) reserved(do) operator(|)ident(taguri)operator(,) ident(val)operator(|)
		constant(YAML)operator(::)ident(object_maker)operator(() constant(Image)operator(,) string<delimiter(')content(file_name)delimiter(')> operator(=)operator(>) string<delimiter(")content(i/)delimiter(")> operator(+) ident(val) operator(\))
	reserved(end)
reserved(end)

comment(#)
comment(# Convert the book to HTML)
comment(#)
reserved(if) pre_constant(__FILE__) operator(==) global_variable($0)
	reserved(unless) pre_constant(ARGV)operator([)integer(0)operator(])
		ident(puts) string<delimiter(")content(Usage: )inline<delimiter(#{)global_variable($0)delimiter(})>content( [/path/to/save/html])delimiter(")>
		ident(exit)
	reserved(end)

	ident(site_path) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
	ident(book) operator(=) constant(WhyTheLuckyStiff)operator(::)constant(Book)operator(::)ident(load)operator(() string<delimiter(')content(poignant.yml)delimiter(')> operator(\))
	ident(chapter) operator(=) pre_constant(nil)

	comment(# Write index page)
	ident(index_tpl) operator(=) constant(ERB)operator(::)ident(new)operator(() constant(File)operator(.)ident(open)operator(() string<delimiter(')content(index.erb)delimiter(')> operator(\))operator(.)ident(read) operator(\))
	constant(File)operator(.)ident(open)operator(() constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) string<delimiter(')content(index.html)delimiter(')> operator(\))operator(,) string<delimiter(')content(w)delimiter(')> operator(\)) reserved(do) operator(|)ident(out)operator(|)
		ident(out) operator(<<) ident(index_tpl)operator(.)ident(result)
	reserved(end)

	ident(book)operator(.)ident(chapters) operator(=) ident(book)operator(.)ident(chapters)operator([)integer(0)operator(,)integer(3)operator(]) reserved(if) pre_constant(ARGV)operator(.)ident(include?) string<delimiter(')content(-fast)delimiter(')>

	comment(# Write chapter pages)
	ident(chapter_tpl) operator(=) constant(ERB)operator(::)ident(new)operator(() constant(File)operator(.)ident(open)operator(() string<delimiter(')content(chapter.erb)delimiter(')> operator(\))operator(.)ident(read) operator(\))
	ident(book)operator(.)ident(chapters)operator(.)ident(each) reserved(do) operator(|)ident(chapter)operator(|)
		constant(File)operator(.)ident(open)operator(() constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) string<delimiter(")content(chapter-)inline<delimiter(#{) ident(chapter)operator(.)ident(index) delimiter(})>content(.html)delimiter(")> operator(\))operator(,) string<delimiter(')content(w)delimiter(')> operator(\)) reserved(do) operator(|)ident(out)operator(|)
			ident(out) operator(<<) ident(chapter_tpl)operator(.)ident(result)
		reserved(end)
	reserved(end)
	ident(exit) reserved(if) pre_constant(ARGV)operator(.)ident(include?) string<delimiter(')content(-fast)delimiter(')>

	comment(# Write expansion pak pages)
	ident(expak_tpl) operator(=) constant(ERB)operator(::)ident(new)operator(() constant(File)operator(.)ident(open)operator(() string<delimiter(')content(expansion-pak.erb)delimiter(')> operator(\))operator(.)ident(read) operator(\))
	ident(book)operator(.)ident(expansion_paks)operator(.)ident(each) reserved(do) operator(|)ident(pak)operator(|)
		constant(File)operator(.)ident(open)operator(() constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) string<delimiter(")content(expansion-pak-)inline<delimiter(#{) ident(pak)operator(.)ident(index) delimiter(})>content(.html)delimiter(")> operator(\))operator(,) string<delimiter(')content(w)delimiter(')> operator(\)) reserved(do) operator(|)ident(out)operator(|)
			ident(out) operator(<<) ident(expak_tpl)operator(.)ident(result)operator(() ident(binding) operator(\))
		reserved(end)
	reserved(end)

	comment(# Write printable version)
	ident(print_tpl) operator(=) constant(ERB)operator(::)ident(new)operator(() constant(File)operator(.)ident(open)operator(() string<delimiter(')content(print.erb)delimiter(')> operator(\))operator(.)ident(read) operator(\))
	constant(File)operator(.)ident(open)operator(() constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) string<delimiter(")content(print.html)delimiter(")> operator(\))operator(,) string<delimiter(')content(w)delimiter(')> operator(\)) reserved(do) operator(|)ident(out)operator(|)
		ident(out) operator(<<) ident(print_tpl)operator(.)ident(result)
	reserved(end)

	comment(# Copy css + images into site)
	ident(copy_list) operator(=) operator([)string<delimiter(")content(guide.css)delimiter(")>operator(]) operator(+)
		constant(Dir)operator([)string<delimiter(")content(i/*)delimiter(")>operator(])operator(.)ident(find_all) operator({) operator(|)ident(image)operator(|) ident(image) operator(=)operator(~) regexp<delimiter(/)char(\\.)content((gif|jpg|png\)$)delimiter(/)> operator(})

	constant(File)operator(.)ident(makedirs)operator(() constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) string<delimiter(")content(i)delimiter(")> operator(\)) operator(\))
	ident(copy_list)operator(.)ident(each) reserved(do) operator(|)ident(copy_file)operator(|)
		constant(File)operator(.)ident(copy)operator(() ident(copy_file)operator(,) constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) ident(copy_file) operator(\)) operator(\))
	reserved(end)
reserved(end)

comment(#!/usr/bin/env ruby)

ident(require) string<delimiter(')content(fox)delimiter(')>
reserved(begin)
  ident(require) string<delimiter(')content(opengl)delimiter(')>
reserved(rescue) constant(LoadError)
  ident(require) string<delimiter(')content(fox/missingdep)delimiter(')>
  constant(MSG) operator(=) string<delimiter(<<EOM)>string<content(
  Sorry, this example depends on the OpenGL extension. Please
  check the Ruby Application Archives for an appropriate
  download site.)delimiter(
EOM)>
  ident(missingDependency)operator(()constant(MSG)operator(\))
reserved(end)


ident(include) constant(Fox)
ident(include) constant(Math)

constant(Deg2Rad) operator(=) constant(Math)operator(::)constant(PI) operator(/) integer(180)

constant(D_MAX) operator(=) integer(6)
constant(SQUARE_SIZE) operator(=) float(2.0) operator(/) constant(D_MAX)
constant(SQUARE_DISTANCE) operator(=) float(4.0) operator(/) constant(D_MAX)
constant(AMPLITUDE) operator(=) constant(SQUARE_SIZE)
constant(LAMBDA) operator(=) constant(D_MAX)operator(.)ident(to_f) operator(/) integer(2)

reserved(class) class(GLTestWindow) operator(<) constant(FXMainWindow)

  comment(# How often our timer will fire (in milliseconds\))
  constant(TIMER_INTERVAL) operator(=) integer(500)

  comment(# Rotate the boxes when a timer message is received)
  reserved(def) method(onTimeout)operator(()ident(sender)operator(,) ident(sel)operator(,) ident(ptr)operator(\))
    instance_variable(@angle) operator(+=) float(10.0)
comment(#    @size = 0.5 + 0.2 * Math.cos(Deg2Rad * @angle\))
    ident(drawScene)operator(()operator(\))
    instance_variable(@timer) operator(=) ident(getApp)operator(()operator(\))operator(.)ident(addTimeout)operator(()constant(TIMER_INTERVAL)operator(,) ident(method)operator(()symbol(:onTimeout)operator(\))operator(\))
  reserved(end)

  comment(# Rotate the boxes when a chore message is received)
  reserved(def) method(onChore)operator(()ident(sender)operator(,) ident(sel)operator(,) ident(ptr)operator(\))
    instance_variable(@angle) operator(+=) float(10.0)
comment(#    @angle %= 360.0)
comment(#    @size = 0.5 + 0.2 * Math.cos(Deg2Rad * @angle\))
    ident(drawScene)operator(()operator(\))
    instance_variable(@chore) operator(=) ident(getApp)operator(()operator(\))operator(.)ident(addChore)operator(()ident(method)operator(()symbol(:onChore)operator(\))operator(\))
  reserved(end)

  comment(# Draw the GL scene)
  reserved(def) method(drawScene)
    ident(lightPosition) operator(=) operator([)float(15.0)operator(,) float(10.0)operator(,) float(5.0)operator(,) float(1.0)operator(])
    ident(lightAmbient)  operator(=) operator([) float(0.1)operator(,)  float(0.1)operator(,) float(0.1)operator(,) float(1.0)operator(])
    ident(lightDiffuse)  operator(=) operator([) float(0.9)operator(,)  float(0.9)operator(,) float(0.9)operator(,) float(1.0)operator(])
    ident(redMaterial)   operator(=) operator([) float(0.0)operator(,)  float(0.0)operator(,) float(1.0)operator(,) float(1.0)operator(])
    ident(blueMaterial)  operator(=) operator([) float(0.0)operator(,)  float(1.0)operator(,) float(0.0)operator(,) float(1.0)operator(])

    ident(width) operator(=) instance_variable(@glcanvas)operator(.)ident(width)operator(.)ident(to_f)
    ident(height) operator(=) instance_variable(@glcanvas)operator(.)ident(height)operator(.)ident(to_f)
    ident(aspect) operator(=) ident(width)operator(/)ident(height)

    comment(# Make context current)
    instance_variable(@glcanvas)operator(.)ident(makeCurrent)operator(()operator(\))

    constant(GL)operator(.)constant(Viewport)operator(()integer(0)operator(,) integer(0)operator(,) instance_variable(@glcanvas)operator(.)ident(width)operator(,) instance_variable(@glcanvas)operator(.)ident(height)operator(\))

    constant(GL)operator(.)constant(ClearColor)operator(()float(1.0)operator(/)integer(256)operator(,) float(0.0)operator(,) float(5.0)operator(/)integer(256)operator(,) float(1.0)operator(\))
    constant(GL)operator(.)constant(Clear)operator(()constant(GL)operator(::)constant(COLOR_BUFFER_BIT)operator(|)constant(GL)operator(::)constant(DEPTH_BUFFER_BIT)operator(\))
    constant(GL)operator(.)constant(Enable)operator(()constant(GL)operator(::)constant(DEPTH_TEST)operator(\))

    constant(GL)operator(.)constant(Disable)operator(()constant(GL)operator(::)constant(DITHER)operator(\))

    constant(GL)operator(.)constant(MatrixMode)operator(()constant(GL)operator(::)constant(PROJECTION)operator(\))
    constant(GL)operator(.)constant(LoadIdentity)operator(()operator(\))
    constant(GLU)operator(.)constant(Perspective)operator(()float(30.0)operator(,) ident(aspect)operator(,) float(1.0)operator(,) float(100.0)operator(\))

    constant(GL)operator(.)constant(MatrixMode)operator(()constant(GL)operator(::)constant(MODELVIEW)operator(\))
    constant(GL)operator(.)constant(LoadIdentity)operator(()operator(\))
    constant(GLU)operator(.)constant(LookAt)operator(()float(5.0)operator(,) float(10.0)operator(,) float(15.0)operator(,) float(0.0)operator(,) float(0.0)operator(,) float(0.0)operator(,) float(0.0)operator(,) float(1.0)operator(,) float(0.0)operator(\))

    constant(GL)operator(.)constant(ShadeModel)operator(()constant(GL)operator(::)constant(SMOOTH)operator(\))
    constant(GL)operator(.)constant(Light)operator(()constant(GL)operator(::)constant(LIGHT0)operator(,) constant(GL)operator(::)constant(POSITION)operator(,) ident(lightPosition)operator(\))
    constant(GL)operator(.)constant(Light)operator(()constant(GL)operator(::)constant(LIGHT0)operator(,) constant(GL)operator(::)constant(AMBIENT)operator(,) ident(lightAmbient)operator(\))
    constant(GL)operator(.)constant(Light)operator(()constant(GL)operator(::)constant(LIGHT0)operator(,) constant(GL)operator(::)constant(DIFFUSE)operator(,) ident(lightDiffuse)operator(\))
    constant(GL)operator(.)constant(Enable)operator(()constant(GL)operator(::)constant(LIGHT0)operator(\))
    constant(GL)operator(.)constant(Enable)operator(()constant(GL)operator(::)constant(LIGHTING)operator(\))

    constant(GL)operator(.)constant(Rotated)operator(()float(0.1)operator(*)instance_variable(@angle)operator(,) float(0.0)operator(,) float(1.0)operator(,) float(0.0)operator(\))
    reserved(for) ident(x) reserved(in) operator(-)constant(D_MAX)operator(..)constant(D_MAX)
      reserved(for) ident(y) reserved(in) operator(-)constant(D_MAX)operator(..)constant(D_MAX)
        ident(h1) operator(=) operator(()ident(x) operator(+) ident(y) operator(-) integer(2)operator(\))operator(.)ident(abs)
        ident(h2) operator(=) operator(()ident(y) operator(-) ident(x) operator(+) integer(1)operator(\))operator(.)ident(abs)
        constant(GL)operator(.)constant(PushMatrix)
        ident(c) operator(=) operator([)integer(1)operator(,) integer(0)operator(,) integer(0)operator(,) integer(1)operator(])
        constant(GL)operator(.)constant(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(AMBIENT)operator(,) ident(c)operator(\))
        constant(GL)operator(.)constant(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(DIFFUSE)operator(,) ident(c)operator(\))

        constant(GL)operator(.)constant(Translated)operator(()
          ident(y) operator(*) constant(SQUARE_DISTANCE)operator(,)
          constant(AMPLITUDE) operator(*) ident(h1)operator(,)
          ident(x) operator(*) constant(SQUARE_DISTANCE)
        operator(\))

        constant(GL)operator(.)constant(Begin)operator(()constant(GL)operator(::)constant(TRIANGLE_STRIP)operator(\))
          constant(GL)operator(.)constant(Normal)operator(()float(1.0)operator(,) float(0.0)operator(,) float(0.0)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
        constant(GL)operator(.)constant(End)

        constant(GL)operator(.)constant(PopMatrix)

        constant(GL)operator(.)constant(PushMatrix)
        ident(c) operator(=) operator([)integer(0)operator(,) integer(0)operator(,) integer(1)operator(,) integer(1)operator(])
        constant(GL)operator(.)constant(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(AMBIENT)operator(,) ident(c)operator(\))
        constant(GL)operator(.)constant(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(DIFFUSE)operator(,) ident(c)operator(\))

        constant(GL)operator(.)constant(Translated)operator(()
          ident(y) operator(*) constant(SQUARE_DISTANCE)operator(,)
          constant(AMPLITUDE) operator(*) ident(h2)operator(,)
          ident(x) operator(*) constant(SQUARE_DISTANCE)
        operator(\))

        constant(GL)operator(.)constant(Begin)operator(()constant(GL)operator(::)constant(TRIANGLE_STRIP)operator(\))
          constant(GL)operator(.)constant(Normal)operator(()float(1.0)operator(,) float(0.0)operator(,) float(0.0)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
        constant(GL)operator(.)constant(End)

        constant(GL)operator(.)constant(PopMatrix)

        constant(GL)operator(.)constant(PushMatrix)
        ident(c) operator(=) operator([)float(0.0) operator(+) operator(()ident(x)operator(/)float(10.0)operator(\))operator(,) float(0.0) operator(+) operator(()ident(y)operator(/)float(10.0)operator(\))operator(,) integer(0)operator(,) integer(1)operator(])
        constant(GL)operator(.)constant(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(AMBIENT)operator(,) ident(c)operator(\))
        constant(GL)operator(.)constant(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(DIFFUSE)operator(,) ident(c)operator(\))

        constant(GL)operator(.)constant(Translated)operator(()
          ident(y) operator(*) constant(SQUARE_DISTANCE)operator(,)
          integer(0)operator(,)
          ident(x) operator(*) constant(SQUARE_DISTANCE)
        operator(\))

        constant(GL)operator(.)constant(Begin)operator(()constant(GL)operator(::)constant(TRIANGLE_STRIP)operator(\))
          constant(GL)operator(.)constant(Normal)operator(()float(1.0)operator(,) float(0.0)operator(,) float(0.0)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)constant(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
        constant(GL)operator(.)constant(End)

        constant(GL)operator(.)constant(PopMatrix)
      reserved(end)
    reserved(end)

    comment(# Swap if it is double-buffered)
    reserved(if) instance_variable(@glvisual)operator(.)ident(isDoubleBuffer)
      instance_variable(@glcanvas)operator(.)ident(swapBuffers)
    reserved(end)

    comment(# Make context non-current)
    instance_variable(@glcanvas)operator(.)ident(makeNonCurrent)
  reserved(end)

  reserved(def) method(initialize)operator(()ident(app)operator(\))
    comment(# Invoke the base class initializer)
    reserved(super)operator(()ident(app)operator(,) string<delimiter(")content(OpenGL Test Application)delimiter(")>operator(,) pre_constant(nil)operator(,) pre_constant(nil)operator(,) constant(DECOR_ALL)operator(,) integer(0)operator(,) integer(0)operator(,) integer(1024)operator(,) integer(768)operator(\))

    comment(# Construct the main window elements)
    ident(frame) operator(=) constant(FXHorizontalFrame)operator(.)ident(new)operator(()pre_constant(self)operator(,) constant(LAYOUT_SIDE_TOP)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FILL_Y)operator(\))
    ident(frame)operator(.)ident(padLeft)operator(,) ident(frame)operator(.)ident(padRight) operator(=) integer(0)operator(,) integer(0)
    ident(frame)operator(.)ident(padTop)operator(,) ident(frame)operator(.)ident(padBottom) operator(=) integer(0)operator(,) integer(0)

    comment(# Left pane to contain the glcanvas)
    ident(glcanvasFrame) operator(=) constant(FXVerticalFrame)operator(.)ident(new)operator(()ident(frame)operator(,)
      constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FILL_Y)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(glcanvasFrame)operator(.)ident(padLeft)operator(,) ident(glcanvasFrame)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(glcanvasFrame)operator(.)ident(padTop)operator(,) ident(glcanvasFrame)operator(.)ident(padBottom) operator(=) integer(10)operator(,) integer(10)

    comment(# Label above the glcanvas)
    constant(FXLabel)operator(.)ident(new)operator(()ident(glcanvasFrame)operator(,) string<delimiter(")content(OpenGL Canvas Frame)delimiter(")>operator(,) pre_constant(nil)operator(,)
      constant(JUSTIFY_CENTER_X)operator(|)constant(LAYOUT_FILL_X)operator(\))

    comment(# Horizontal divider line)
    constant(FXHorizontalSeparator)operator(.)ident(new)operator(()ident(glcanvasFrame)operator(,) constant(SEPARATOR_GROOVE)operator(|)constant(LAYOUT_FILL_X)operator(\))

    comment(# Drawing glcanvas)
    ident(glpanel) operator(=) constant(FXVerticalFrame)operator(.)ident(new)operator(()ident(glcanvasFrame)operator(,) operator(()constant(FRAME_SUNKEN)operator(|)constant(FRAME_THICK)operator(|)
      constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FILL_Y)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))operator(\))
    ident(glpanel)operator(.)ident(padLeft)operator(,) ident(glpanel)operator(.)ident(padRight) operator(=) integer(0)operator(,) integer(0)
    ident(glpanel)operator(.)ident(padTop)operator(,) ident(glpanel)operator(.)ident(padBottom) operator(=) integer(0)operator(,) integer(0)

    comment(# A visual to draw OpenGL)
    instance_variable(@glvisual) operator(=) constant(FXGLVisual)operator(.)ident(new)operator(()ident(getApp)operator(()operator(\))operator(,) constant(VISUAL_DOUBLEBUFFER)operator(\))

    comment(# Drawing glcanvas)
    instance_variable(@glcanvas) operator(=) constant(FXGLCanvas)operator(.)ident(new)operator(()ident(glpanel)operator(,) instance_variable(@glvisual)operator(,) pre_constant(nil)operator(,) integer(0)operator(,)
      constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FILL_Y)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    instance_variable(@glcanvas)operator(.)ident(connect)operator(()constant(SEL_PAINT)operator(\)) operator({)
      ident(drawScene)
    operator(})
    instance_variable(@glcanvas)operator(.)ident(connect)operator(()constant(SEL_CONFIGURE)operator(\)) operator({)
      reserved(if) instance_variable(@glcanvas)operator(.)ident(makeCurrent)
        constant(GL)operator(.)constant(Viewport)operator(()integer(0)operator(,) integer(0)operator(,) instance_variable(@glcanvas)operator(.)ident(width)operator(,) instance_variable(@glcanvas)operator(.)ident(height)operator(\))
        instance_variable(@glcanvas)operator(.)ident(makeNonCurrent)
      reserved(end)
    operator(})

    comment(# Right pane for the buttons)
    ident(buttonFrame) operator(=) constant(FXVerticalFrame)operator(.)ident(new)operator(()ident(frame)operator(,) constant(LAYOUT_FILL_Y)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(buttonFrame)operator(.)ident(padLeft)operator(,) ident(buttonFrame)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(buttonFrame)operator(.)ident(padTop)operator(,) ident(buttonFrame)operator(.)ident(padBottom) operator(=) integer(10)operator(,) integer(10)

    comment(# Label above the buttons)
    constant(FXLabel)operator(.)ident(new)operator(()ident(buttonFrame)operator(,) string<delimiter(")content(Button Frame)delimiter(")>operator(,) pre_constant(nil)operator(,)
      constant(JUSTIFY_CENTER_X)operator(|)constant(LAYOUT_FILL_X)operator(\))

    comment(# Horizontal divider line)
    constant(FXHorizontalSeparator)operator(.)ident(new)operator(()ident(buttonFrame)operator(,) constant(SEPARATOR_RIDGE)operator(|)constant(LAYOUT_FILL_X)operator(\))

    comment(# Spin according to timer)
    ident(spinTimerBtn) operator(=) constant(FXButton)operator(.)ident(new)operator(()ident(buttonFrame)operator(,)
      string<delimiter(")content(Spin &Timer)char(\\t)content(Spin using interval timers)char(\\n)content(Note the app
      blocks until the interal has elapsed...)delimiter(")>operator(,) pre_constant(nil)operator(,)
      pre_constant(nil)operator(,) integer(0)operator(,) constant(FRAME_THICK)operator(|)constant(FRAME_RAISED)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(spinTimerBtn)operator(.)ident(padLeft)operator(,) ident(spinTimerBtn)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(spinTimerBtn)operator(.)ident(padTop)operator(,) ident(spinTimerBtn)operator(.)ident(padBottom) operator(=) integer(5)operator(,) integer(5)
    ident(spinTimerBtn)operator(.)ident(connect)operator(()constant(SEL_COMMAND)operator(\)) operator({)
      instance_variable(@spinning) operator(=) pre_constant(true)
      instance_variable(@timer) operator(=) ident(getApp)operator(()operator(\))operator(.)ident(addTimeout)operator(()constant(TIMER_INTERVAL)operator(,) ident(method)operator(()symbol(:onTimeout)operator(\))operator(\))
    operator(})
    ident(spinTimerBtn)operator(.)ident(connect)operator(()constant(SEL_UPDATE)operator(\)) operator({) operator(|)ident(sender)operator(,) ident(sel)operator(,) ident(ptr)operator(|)
      instance_variable(@spinning) operator(?) ident(sender)operator(.)ident(disable) operator(:) ident(sender)operator(.)ident(enable)
    operator(})

    comment(# Spin according to chore)
    ident(spinChoreBtn) operator(=) constant(FXButton)operator(.)ident(new)operator(()ident(buttonFrame)operator(,)
      string<delimiter(")content(Spin &Chore)char(\\t)content(Spin as fast as possible using chores)char(\\n)content(Note even though the
      app is very responsive, it never blocks;)char(\\n)content(there is always something to
      do...)delimiter(")>operator(,) pre_constant(nil)operator(,)
      pre_constant(nil)operator(,) integer(0)operator(,) constant(FRAME_THICK)operator(|)constant(FRAME_RAISED)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(spinChoreBtn)operator(.)ident(padLeft)operator(,) ident(spinChoreBtn)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(spinChoreBtn)operator(.)ident(padTop)operator(,) ident(spinChoreBtn)operator(.)ident(padBottom) operator(=) integer(5)operator(,) integer(5)
    ident(spinChoreBtn)operator(.)ident(connect)operator(()constant(SEL_COMMAND)operator(\)) operator({)
      instance_variable(@spinning) operator(=) pre_constant(true)
      instance_variable(@chore) operator(=) ident(getApp)operator(()operator(\))operator(.)ident(addChore)operator(()ident(method)operator(()symbol(:onChore)operator(\))operator(\))
    operator(})
    ident(spinChoreBtn)operator(.)ident(connect)operator(()constant(SEL_UPDATE)operator(\)) operator({) operator(|)ident(sender)operator(,) ident(sel)operator(,) ident(ptr)operator(|)
      instance_variable(@spinning) operator(?) ident(sender)operator(.)ident(disable) operator(:) ident(sender)operator(.)ident(enable)
    operator(})

    comment(# Stop spinning)
    ident(stopBtn) operator(=) constant(FXButton)operator(.)ident(new)operator(()ident(buttonFrame)operator(,)
      string<delimiter(")content(&Stop Spin)char(\\t)content(Stop this mad spinning, I'm getting dizzy)delimiter(")>operator(,) pre_constant(nil)operator(,)
      pre_constant(nil)operator(,) integer(0)operator(,) constant(FRAME_THICK)operator(|)constant(FRAME_RAISED)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(stopBtn)operator(.)ident(padLeft)operator(,) ident(stopBtn)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(stopBtn)operator(.)ident(padTop)operator(,) ident(stopBtn)operator(.)ident(padBottom) operator(=) integer(5)operator(,) integer(5)
    ident(stopBtn)operator(.)ident(connect)operator(()constant(SEL_COMMAND)operator(\)) operator({)
      instance_variable(@spinning) operator(=) pre_constant(false)
      reserved(if) instance_variable(@timer)
        ident(getApp)operator(()operator(\))operator(.)ident(removeTimeout)operator(()instance_variable(@timer)operator(\))
        instance_variable(@timer) operator(=) pre_constant(nil)
      reserved(end)
      reserved(if) instance_variable(@chore)
        ident(getApp)operator(()operator(\))operator(.)ident(removeChore)operator(()instance_variable(@chore)operator(\))
        instance_variable(@chore) operator(=) pre_constant(nil)
      reserved(end)
    operator(})
    ident(stopBtn)operator(.)ident(connect)operator(()constant(SEL_UPDATE)operator(\)) operator({) operator(|)ident(sender)operator(,) ident(sel)operator(,) ident(ptr)operator(|)
      instance_variable(@spinning) operator(?) ident(sender)operator(.)ident(enable) operator(:) ident(sender)operator(.)ident(disable)
    operator(})

    comment(# Exit button)
    ident(exitBtn) operator(=) constant(FXButton)operator(.)ident(new)operator(()ident(buttonFrame)operator(,) string<delimiter(")content(&Exit)char(\\t)content(Exit the application)delimiter(")>operator(,) pre_constant(nil)operator(,)
      ident(getApp)operator(()operator(\))operator(,) constant(FXApp)operator(::)constant(ID_QUIT)operator(,)
      constant(FRAME_THICK)operator(|)constant(FRAME_RAISED)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(exitBtn)operator(.)ident(padLeft)operator(,) ident(exitBtn)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(exitBtn)operator(.)ident(padTop)operator(,) ident(exitBtn)operator(.)ident(padBottom) operator(=) integer(5)operator(,) integer(5)

    comment(# Make a tooltip)
    constant(FXTooltip)operator(.)ident(new)operator(()ident(getApp)operator(()operator(\))operator(\))

    comment(# Initialize private variables)
    instance_variable(@spinning) operator(=) pre_constant(false)
    instance_variable(@chore) operator(=) pre_constant(nil)
    instance_variable(@timer) operator(=) pre_constant(nil)
    instance_variable(@angle) operator(=) float(0.0)
    instance_variable(@size) operator(=) float(0.5)
  reserved(end)

  comment(# Create and initialize)
  reserved(def) method(create)
    reserved(super)
    ident(show)operator(()constant(PLACEMENT_SCREEN)operator(\))
  reserved(end)
reserved(end)

reserved(if) pre_constant(__FILE__) operator(==) global_variable($0)
  comment(# Construct the application)
  ident(application) operator(=) constant(FXApp)operator(.)ident(new)operator(()string<delimiter(")content(GLTest)delimiter(")>operator(,) string<delimiter(")content(FoxTest)delimiter(")>operator(\))

  comment(# To ensure that the chores-based spin will run as fast as possible,)
  comment(# we can disable the chore in FXRuby's event loop that tries to schedule)
  comment(# other threads. This is OK for this program because there aren't any)
  comment(# other Ruby threads running.)

  comment(#application.disableThreads)

  comment(# Construct the main window)
  constant(GLTestWindow)operator(.)ident(new)operator(()ident(application)operator(\))

  comment(# Create the app's windows)
  ident(application)operator(.)ident(create)

  comment(# Run the application)
  ident(application)operator(.)ident(run)
reserved(end)

reserved(class) class(Facelet)
  ident(attr_accessor) symbol(:color)
  reserved(def) method(initialize)operator(()ident(color)operator(\))
    instance_variable(@color) operator(=) ident(color)
  reserved(end)

  reserved(def) method(to_s)
    instance_variable(@color)
  reserved(end)
reserved(end)

reserved(class) class(Edge)
  ident(attr_accessor) symbol(:facelets)operator(,) symbol(:colors)

  reserved(def) method(initialize)operator(()ident(facelets)operator(\))
    instance_variable(@facelets) operator(=) ident(facelets)
    instance_variable(@colors) operator(=) instance_variable(@facelets)operator(.)ident(map) operator({) operator(|)ident(fl)operator(|) ident(fl)operator(.)ident(color) operator(})
  reserved(end)

  reserved(def) method(apply)operator(()ident(edge)operator(\))
    instance_variable(@facelets)operator(.)ident(each_with_index) operator({) operator(|)ident(fl)operator(,) ident(i)operator(|)
      ident(fl)operator(.)ident(color) operator(=) ident(edge)operator(.)ident(colors)operator([)ident(i)operator(])
    operator(})
  reserved(end)

  reserved(def) method(inspect)
    string<delimiter(")char(\\n)content(%s %s)char(\\n)content(%s %s %s)delimiter(")> operator(%) ident(facelets)
  reserved(end)
reserved(end)

reserved(class) class(Side)
  ident(attr_reader) symbol(:num)operator(,) symbol(:facelets)
  ident(attr_accessor) symbol(:sides)

  reserved(def) method(initialize)operator(()ident(num)operator(\))
    instance_variable(@num) operator(=) ident(num)
    instance_variable(@sides) operator(=) operator([)operator(])
    instance_variable(@facelets) operator(=) operator([)operator(])
    instance_variable(@fl_by_side) operator(=) operator({)operator(})
  reserved(end)

  comment(# facelets & sides)
  comment(#     0)
  comment(#   0 1 2)
  comment(# 3 3 4 5 1)
  comment(#   6 7 8)
  comment(#     2)

  reserved(def) method(facelets=)operator(()ident(facelets)operator(\))
    instance_variable(@facelets) operator(=) ident(facelets)operator(.)ident(map) operator({) operator(|)ident(c)operator(|) constant(Facelet)operator(.)ident(new)operator(()ident(c)operator(\)) operator(})
    ident(init_facelet) integer(0)operator(,) integer(3)operator(,)integer(0)
    ident(init_facelet) integer(1)operator(,) integer(0)
    ident(init_facelet) integer(2)operator(,) integer(0)operator(,)integer(1)
    ident(init_facelet) integer(3)operator(,) integer(3)
    ident(init_facelet) integer(5)operator(,) integer(1)
    ident(init_facelet) integer(6)operator(,) integer(2)operator(,)integer(3)
    ident(init_facelet) integer(7)operator(,) integer(2)
    ident(init_facelet) integer(8)operator(,) integer(1)operator(,)integer(2)
  reserved(end)

  reserved(def) method(<=>)operator(()ident(side)operator(\))
    pre_constant(self)operator(.)ident(num) operator(<=>) ident(side)operator(.)ident(num)
  reserved(end)

  reserved(def) method(init_facelet)operator(()ident(pos)operator(,) operator(*)ident(side_nums)operator(\))
    ident(sides) operator(=) ident(side_nums)operator(.)ident(map) operator({) operator(|)ident(num)operator(|) instance_variable(@sides)operator([)ident(num)operator(]) operator(})operator(.)ident(sort)
    instance_variable(@fl_by_side)operator([)ident(sides)operator(]) operator(=) ident(pos)
  reserved(end)

  reserved(def) method([]=)operator(()ident(color)operator(,) operator(*)ident(sides)operator(\))
    instance_variable(@facelets)operator([)instance_variable(@fl_by_side)operator([)ident(sides)operator(.)ident(sort)operator(])operator(])operator(.)ident(color) operator(=) ident(color)
  reserved(end)

  reserved(def) method(values_at)operator(()operator(*)ident(sides)operator(\))
    ident(sides)operator(.)ident(map) operator({) operator(|)ident(sides)operator(|) instance_variable(@facelets)operator([)instance_variable(@fl_by_side)operator([)ident(sides)operator(.)ident(sort)operator(])operator(]) operator(})
  reserved(end)

  reserved(def) method(inspect)operator(()ident(range)operator(=)pre_constant(nil)operator(\))
    reserved(if) ident(range)
      instance_variable(@facelets)operator(.)ident(values_at)operator(()operator(*)operator(()ident(range)operator(.)ident(to_a)operator(\))operator(\))operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))
    reserved(else)
      string<delimiter(<<-EOS)>operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\d)delimiter(/)>operator(\)) operator({) operator(|)ident(num)operator(|) instance_variable(@facelets)operator([)ident(num)operator(.)ident(to_i)operator(]) operator(})operator(.)ident(gsub)operator(()regexp<delimiter(/)content([ABCD])delimiter(/)>operator(\)) operator({) operator(|)ident(side)operator(|) instance_variable(@sides)operator([)ident(side)operator([)integer(0)operator(])operator(-)integer(?A)operator(])operator(.)ident(num)operator(.)ident(to_s) operator(})string<content(
           A
         0 1 2
       D 3 4 5 B
         6 7 8
           C)delimiter(
      EOS)>
    reserved(end)
  reserved(end)

  reserved(def) method(get_edge)operator(()ident(side)operator(\))
    ident(trio) operator(=) operator(()operator(-)integer(1)operator(..)integer(1)operator(\))operator(.)ident(map) operator({) operator(|)ident(x)operator(|) operator(()ident(side) operator(+) ident(x)operator(\)) operator(%) integer(4) operator(})
    ident(prev_side)operator(,) ident(this_side)operator(,) ident(next_side) operator(=) instance_variable(@sides)operator(.)ident(values_at)operator(()operator(*)ident(trio)operator(\))
    ident(e) operator(=) constant(Edge)operator(.)ident(new)operator(()
      pre_constant(self)     operator(.)ident(values_at)operator(()                    operator([)ident(this_side)operator(])operator(,) operator([)ident(this_side)operator(,) ident(next_side)operator(]) operator(\)) operator(+)
      ident(this_side)operator(.)ident(values_at)operator(() operator([)pre_constant(self)operator(,) ident(prev_side)operator(])operator(,) operator([)pre_constant(self)     operator(])operator(,) operator([)pre_constant(self)operator(,)      ident(next_side)operator(]) operator(\))
    operator(\))
    comment(#puts 'Edge created for side %d: ' % side + e.inspect)
    ident(e)
  reserved(end)

  reserved(def) method(turn)operator(()ident(dir)operator(\))
    comment(#p 'turn side %d in %d' % [num, dir])
    ident(edges) operator(=) operator(()integer(0)operator(..)integer(3)operator(\))operator(.)ident(map) operator({) operator(|)ident(n)operator(|) ident(get_edge) ident(n) operator(})
    reserved(for) ident(i) reserved(in) integer(0)operator(..)integer(3)
      ident(edges)operator([)ident(i)operator(])operator(.)ident(apply) ident(edges)operator([)operator(()ident(i)operator(-)ident(dir)operator(\)) operator(%) integer(4)operator(])
    reserved(end)
  reserved(end)
reserved(end)

reserved(class) class(Cube)
  reserved(def) method(initialize)
    instance_variable(@sides) operator(=) operator([)operator(])
    string<delimiter(%w()content(left front right back top bottom)delimiter(\))>operator(.)ident(each_with_index) operator({) operator(|)ident(side)operator(,) ident(i)operator(|)
      ident(eval)operator(()string<delimiter(")content(@sides[)inline<delimiter(#{)ident(i)delimiter(})>content(] = @)inline<delimiter(#{)ident(side)delimiter(})>content( = Side.new()inline<delimiter(#{)ident(i)delimiter(})>content(\))delimiter(")>operator(\))
    operator(})
    instance_variable(@left)operator(.)ident(sides) operator(=) operator([)instance_variable(@top)operator(,) instance_variable(@front)operator(,) instance_variable(@bottom)operator(,) instance_variable(@back)operator(])
    instance_variable(@front)operator(.)ident(sides) operator(=) operator([)instance_variable(@top)operator(,) instance_variable(@right)operator(,) instance_variable(@bottom)operator(,) instance_variable(@left)operator(])
    instance_variable(@right)operator(.)ident(sides) operator(=) operator([)instance_variable(@top)operator(,) instance_variable(@back)operator(,) instance_variable(@bottom)operator(,) instance_variable(@front)operator(])
    instance_variable(@back)operator(.)ident(sides) operator(=) operator([)instance_variable(@top)operator(,) instance_variable(@left)operator(,) instance_variable(@bottom)operator(,) instance_variable(@right)operator(])
    instance_variable(@top)operator(.)ident(sides) operator(=) operator([)instance_variable(@back)operator(,) instance_variable(@right)operator(,) instance_variable(@front)operator(,) instance_variable(@left)operator(])
    instance_variable(@bottom)operator(.)ident(sides) operator(=) operator([)instance_variable(@front)operator(,) instance_variable(@right)operator(,) instance_variable(@back)operator(,) instance_variable(@left)operator(])
  reserved(end)

  reserved(def) method(read_facelets)operator(()ident(fs)operator(\))
    ident(pattern) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(<<-EOP)>operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\w)delimiter(/)>operator(,) string<delimiter(')content(\\w)delimiter(')>operator(\))operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(,) string<delimiter(')content(\\s)content(*)delimiter(')>operator(\))operator(\))string<content(
        (w w w\)
        (w w w\)
        (w w w\)
(r r r\) (g g g\) (b b b\) (o o o\)
(r r r\) (g g g\) (b b b\) (o o o\)
(r r r\) (g g g\) (b b b\) (o o o\)
        (y y y\)
        (y y y\)
        (y y y\))delimiter(
    EOP)>
    ident(md) operator(=) ident(pattern)operator(.)ident(match)operator(()ident(fs)operator(\))operator(.)ident(to_a)

    instance_variable(@top)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(1)operator(,)integer(2)operator(,)integer(3)operator(\))operator(\))
    instance_variable(@left)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(4)operator(,)integer(8)operator(,)integer(12)operator(\))operator(\))
    instance_variable(@front)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(5)operator(,)integer(9)operator(,)integer(13)operator(\))operator(\))
    instance_variable(@right)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(6)operator(,)integer(10)operator(,)integer(14)operator(\))operator(\))
    instance_variable(@back)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(7)operator(,)integer(11)operator(,)integer(15)operator(\))operator(\))
    instance_variable(@bottom)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(16)operator(,)integer(17)operator(,)integer(18)operator(\))operator(\))
  reserved(end)

  reserved(def) method(turn)operator(()ident(side)operator(,) ident(dir)operator(\))
    comment(#p 'turn %d in %d' % [side, dir])
    instance_variable(@sides)operator([)ident(side)operator(])operator(.)ident(turn)operator(()ident(dir)operator(\))
    comment(#puts inspect)
  reserved(end)

  reserved(def) method(inspect)
    string<delimiter(<<-EOF)>operator(.)ident(gsub)operator(()regexp<delimiter(/)content(()char(\\d)content(\):()char(\\d)content(\)-()char(\\d)content(\))delimiter(/)>operator(\)) operator({) instance_variable(@sides)operator([)global_variable($1)operator(.)ident(to_i)operator(])operator(.)ident(inspect)operator(()constant(Range)operator(.)ident(new)operator(()global_variable($2)operator(.)ident(to_i)operator(,) global_variable($3)operator(.)ident(to_i)operator(\))operator(\)) operator(})string<content(
      4:0-2
      4:3-5
      4:6-8
0:0-2 1:0-2 2:0-2 3:0-2
0:3-5 1:3-5 2:3-5 3:3-5
0:6-8 1:6-8 2:6-8 3:6-8
      5:0-2
      5:3-5
      5:6-8)delimiter(
    EOF)>
  reserved(end)

ident(private)
  reserved(def) method(parse_facelets)operator(()ident(rows)operator(\))
    ident(rows)operator(.)ident(join)operator(.)ident(delete)operator(()string<delimiter(')content( )delimiter(')>operator(\))operator(.)ident(split)operator(()regexp<delimiter(/)delimiter(/)>operator(\))
  reserved(end)
reserved(end)

comment(#$stdin = DATA)

ident(gets)operator(.)ident(to_i)operator(.)ident(times) reserved(do) operator(|)ident(i)operator(|)
  ident(puts) string<delimiter(")content(Scenario #)inline<delimiter(#{)ident(i)operator(+)integer(1)delimiter(})>content(:)delimiter(")>
  ident(fs) operator(=) string<delimiter(')delimiter(')>
  integer(9)operator(.)ident(times) operator({) ident(fs) operator(<<) ident(gets) operator(})
  ident(cube) operator(=) constant(Cube)operator(.)ident(new)
  ident(cube)operator(.)ident(read_facelets) ident(fs)
  ident(gets)operator(.)ident(to_i)operator(.)ident(times) reserved(do) operator(|)ident(t)operator(|)
    ident(side)operator(,) ident(dir) operator(=) ident(gets)operator(.)ident(split)operator(.)ident(map) operator({)operator(|)ident(s)operator(|) ident(s)operator(.)ident(to_i)operator(})
    ident(cube)operator(.)ident(turn)operator(()ident(side)operator(,) ident(dir)operator(\))
  reserved(end)
  ident(puts) ident(cube)operator(.)ident(inspect)
  ident(puts)
reserved(end)

comment(# 2004 by murphy <korny@cYcnus.de>)
comment(# GPL)
reserved(class) class(Scenario)
	reserved(class) class(TimePoint)
		ident(attr_reader) symbol(:data)
		reserved(def) method(initialize) operator(*)ident(data)
			instance_variable(@data) operator(=) ident(data)
		reserved(end)

		reserved(def) method([]) ident(i)
			instance_variable(@data)operator([)ident(i)operator(]) reserved(or) integer(0)
		reserved(end)

		ident(include) constant(Comparable)
		reserved(def) method(<=>) ident(tp)
			ident(r) operator(=) integer(0)
			operator([)instance_variable(@data)operator(.)ident(size)operator(,) ident(tp)operator(.)ident(data)operator(.)ident(size)operator(])operator(.)ident(max)operator(.)ident(times) reserved(do) operator(|)ident(i)operator(|)
				ident(r) operator(=) pre_constant(self)operator([)ident(i)operator(]) operator(<=>) ident(tp)operator([)ident(i)operator(])
				reserved(return) ident(r) reserved(if) ident(r)operator(.)ident(nonzero?)
			reserved(end)
			integer(0)
		reserved(end)

		reserved(def) method(-) ident(tp)
			ident(r) operator(=) operator([)operator(])
			operator([)instance_variable(@data)operator(.)ident(size)operator(,) ident(tp)operator(.)ident(data)operator(.)ident(size)operator(])operator(.)ident(max)operator(.)ident(times) reserved(do) operator(|)ident(i)operator(|)
				ident(r) operator(<<) pre_constant(self)operator([)ident(i)operator(]) operator(-) ident(tp)operator([)ident(i)operator(])
			reserved(end)
			ident(r)
		reserved(end)

		reserved(def) method(inspect)
			comment(# 01/01/1800 00:00:00)
			string<delimiter(')content(%02d/%02d/%04d %02d:%02d:%02d)delimiter(')> operator(%) instance_variable(@data)operator(.)ident(values_at)operator(()integer(1)operator(,) integer(2)operator(,) integer(0)operator(,) integer(3)operator(,) integer(4)operator(,) integer(5)operator(\))
		reserved(end)
	reserved(end)

	constant(ONE_HOUR) operator(=) constant(TimePoint)operator(.)ident(new) integer(0)operator(,) integer(0)operator(,) integer(0)operator(,) integer(1)operator(,) integer(0)operator(,) integer(0)

	constant(APPOINTMENT_PATTERN) operator(=) regexp<delimiter(/)content(
		( )char(\\d)content({4} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content(
		( )char(\\d)content({4} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \)
	)delimiter(/)modifier(x)>

	reserved(def) method(initialize) ident(io)
		instance_variable(@team_size) operator(=) ident(io)operator(.)ident(gets)operator(.)ident(to_i)
		instance_variable(@data) operator(=) operator([) operator([)constant(TimePoint)operator(.)ident(new)operator(()integer(1800)operator(,) integer(01)operator(,) integer(01)operator(,) integer(00)operator(,) integer(00)operator(,) integer(00)operator(\))operator(,) instance_variable(@team_size)operator(]) operator(])
		instance_variable(@team_size)operator(.)ident(times) reserved(do)  comment(# each team member)
			ident(io)operator(.)ident(gets)operator(.)ident(to_i)operator(.)ident(times) reserved(do)  comment(# each appointment)
				ident(m) operator(=) constant(APPOINTMENT_PATTERN)operator(.)ident(match) ident(io)operator(.)ident(gets)
				instance_variable(@data) operator(<<) operator([)constant(TimePoint)operator(.)ident(new)operator(()operator(*)ident(m)operator(.)ident(captures)operator([)integer(0)operator(,)integer(6)operator(])operator(.)ident(map) operator({) operator(|)ident(x)operator(|) ident(x)operator(.)ident(to_i) operator(})operator(\))operator(,) operator(-)integer(1)operator(])
				instance_variable(@data) operator(<<) operator([)constant(TimePoint)operator(.)ident(new)operator(()operator(*)ident(m)operator(.)ident(captures)operator([)integer(6)operator(,)integer(6)operator(])operator(.)ident(map) operator({) operator(|)ident(x)operator(|) ident(x)operator(.)ident(to_i) operator(})operator(\))operator(,) operator(+)integer(1)operator(])
			reserved(end)
		reserved(end)
		instance_variable(@data) operator(<<) operator([)constant(TimePoint)operator(.)ident(new)operator(()integer(2200)operator(,) integer(01)operator(,) integer(01)operator(,) integer(00)operator(,) integer(00)operator(,) integer(00)operator(\))operator(,) operator(-)instance_variable(@team_size)operator(])
	reserved(end)

	reserved(def) method(print_time_plan)
		ident(n) operator(=) integer(0)
		ident(appointment) operator(=) pre_constant(nil)
		ident(no_appointment) operator(=) pre_constant(true)
		instance_variable(@data)operator(.)ident(sort_by) operator({) operator(|)ident(x)operator(|) ident(x)operator([)integer(0)operator(]) operator(})operator(.)ident(each) reserved(do) operator(|)ident(x)operator(|)
			ident(tp)operator(,) ident(action) operator(=) operator(*)ident(x)
			ident(n) operator(+=) ident(action)
			comment(# at any time during the meeting, at least two team members need to be there)
			comment(# and at most one team member is allowed to be absent)
			reserved(if) ident(n) operator(>)operator(=) integer(2) reserved(and) operator(()instance_variable(@team_size) operator(-) ident(n)operator(\)) operator(<=) integer(1)
				ident(appointment) operator(||=) ident(tp)
			reserved(else)
				reserved(if) ident(appointment)
					comment(# the meeting should be at least one hour in length)
					reserved(if) constant(TimePoint)operator(.)ident(new)operator(()operator(*)operator(()ident(tp) operator(-) ident(appointment)operator(\))operator(\)) operator(>)operator(=) constant(ONE_HOUR)
						ident(puts) string<delimiter(')content(appointment possible from %p to %p)delimiter(')> operator(%) operator([)ident(appointment)operator(,) ident(tp)operator(])
						ident(no_appointment) operator(=) pre_constant(false)
					reserved(end)
					ident(appointment) operator(=) pre_constant(false)
				reserved(end)
			reserved(end)
		reserved(end)
		ident(puts) string<delimiter(')content(no appointment possible)delimiter(')> reserved(if) ident(no_appointment)
	reserved(end)
reserved(end)

comment(# read the data)
pre_constant(DATA)operator(.)ident(gets)operator(.)ident(to_i)operator(.)ident(times) reserved(do) operator(|)ident(si)operator(|) comment(# each scenario)
	ident(puts) string<delimiter(')content(Scenario #%d:)delimiter(')> operator(%) operator(()ident(si) operator(+) integer(1)operator(\))
	ident(sc) operator(=) constant(Scenario)operator(.)ident(new) pre_constant(DATA)
	ident(sc)operator(.)ident(print_time_plan)
	ident(puts)
reserved(end)

comment(#__END__)
integer(2)
integer(3)
integer(3)
integer(2002) integer(06) integer(28) integer(15) integer(00) integer(00) integer(2002) integer(06) integer(28) integer(18) integer(00) integer(00) constant(TUD) constant(Contest) constant(Practice) constant(Session)
integer(2002) integer(06) integer(29) integer(10) integer(00) integer(00) integer(2002) integer(06) integer(29) integer(15) integer(00) integer(00) constant(TUD) constant(Contest)
integer(2002) integer(11) integer(15) integer(15) integer(00) integer(00) integer(2002) integer(11) integer(17) integer(23) integer(00) integer(00) constant(NWERC) constant(Delft)
integer(4)
integer(2002) integer(06) integer(25) integer(13) integer(30) integer(00) integer(2002) integer(06) integer(25) integer(15) integer(30) integer(00) constant(FIFA) constant(World) constant(Cup) constant(Semifinal) constant(I)
integer(2002) integer(06) integer(26) integer(13) integer(30) integer(00) integer(2002) integer(06) integer(26) integer(15) integer(30) integer(00) constant(FIFA) constant(World) constant(Cup) constant(Semifinal) constant(II)
integer(2002) integer(06) integer(29) integer(13) integer(00) integer(00) integer(2002) integer(06) integer(29) integer(15) integer(00) integer(00) constant(FIFA) constant(World) constant(Cup) constant(Third) constant(Place)
integer(2002) integer(06) integer(30) integer(13) integer(00) integer(00) integer(2002) integer(06) integer(30) integer(15) integer(00) integer(00) constant(FIFA) constant(World) constant(Cup) constant(Final)
integer(1)
integer(2002) integer(06) integer(01) integer(00) integer(00) integer(00) integer(2002) integer(06) integer(29) integer(18) integer(00) integer(00) constant(Preparation) ident(of) constant(Problem) constant(Set)
integer(2)
integer(1)
integer(1800) integer(01) integer(01) integer(00) integer(00) integer(00) integer(2200) integer(01) integer(01) integer(00) integer(00) integer(00) constant(Solving) constant(Problem) integer(8)
integer(0)

ident(require) string<delimiter(')content(token_consts)delimiter(')>
ident(require) string<delimiter(')content(symbol)delimiter(')>
ident(require) string<delimiter(')content(ctype)delimiter(')>
ident(require) string<delimiter(')content(error)delimiter(')>

reserved(class) class(Fixnum)
	comment(# Treat char as a digit and return it's value as Fixnum.)
	comment(# Returns nonsense for non-digits.)
	comment(# Examples:)
	comment(# <code>)
	comment(# RUBY_VERSION[0].digit == '1.8.2'[0].digit == 1)
	comment(# </code>)
	comment(#)
	comment(# <code>)
	comment(# ?6.digit == 6)
	comment(# </code>)
	comment(#)
	comment(# <code>)
	comment(# ?A.digit == 17)
	comment(# </code>)
	reserved(def) method(digit)
		pre_constant(self) operator(-) integer(?0)
	reserved(end)
reserved(end)

comment(##)
comment(# Stellt einen einfachen Scanner fr die lexikalische Analyse der Sprache Pas-0 dar.)
comment(#)
comment(# @author Andreas Kunert)
comment(# Ruby port by murphy)
reserved(class) class(Scanner)

	ident(include) constant(TokenConsts)

	ident(attr_reader) symbol(:line)operator(,) symbol(:pos)

	comment(# To allow Scanner.new without parameters.)
	constant(DUMMY_INPUT) operator(=) string<delimiter(')content(dummy file)delimiter(')>
	reserved(def) constant(DUMMY_INPUT)operator(.)ident(getc)
		pre_constant(nil)
	reserved(end)

	comment(##)
	comment(# Erzeugt einen Scanner, der als Eingabe das bergebene IO benutzt.)
	reserved(def) method(initialize) ident(input) operator(=) constant(DUMMY_INPUT)
		instance_variable(@line) operator(=) integer(1)
		instance_variable(@pos) operator(=) integer(0)

		reserved(begin)
			instance_variable(@input) operator(=) ident(input)
			instance_variable(@next_char) operator(=) instance_variable(@input)operator(.)ident(getc)
		reserved(rescue) constant(IOError)  comment(# TODO show the reason!)
			constant(Error)operator(.)ident(ioError)
			ident(raise)
		reserved(end)
	reserved(end)

	comment(##)
	comment(# Liest das n chste Zeichen von der Eingabe.)
	reserved(def) method(read_next_char)
		reserved(begin)
			instance_variable(@pos) operator(+=) integer(1)
			instance_variable(@current_char) operator(=) instance_variable(@next_char)
			instance_variable(@next_char) operator(=) instance_variable(@input)operator(.)ident(getc)
		reserved(rescue) constant(IOError)
			constant(Error)operator(.)ident(ioError)
			ident(raise)
		reserved(end)
	reserved(end)

	comment(##)
	comment(# Sucht das nchste Symbol, identifiziert es, instantiiert ein entsprechendes)
	comment(# PascalSymbol-Objekt und gibt es zurck.)
	comment(# @see Symbol)
	comment(# @return das gefundene Symbol als PascalSymbol-Objekt)
	reserved(def) method(get_symbol)
		ident(current_symbol) operator(=) pre_constant(nil)
		reserved(until) ident(current_symbol)
			ident(read_next_char)

			reserved(if) instance_variable(@current_char)operator(.)ident(alpha?)
				ident(identifier) operator(=) instance_variable(@current_char)operator(.)ident(chr)
				reserved(while) instance_variable(@next_char)operator(.)ident(alpha?) reserved(or) instance_variable(@next_char)operator(.)ident(digit?)
					ident(identifier) operator(<<) instance_variable(@next_char)
					ident(read_next_char)
				reserved(end)
				ident(current_symbol) operator(=) ident(handle_identifier)operator(()ident(identifier)operator(.)ident(upcase)operator(\))
			reserved(elsif) instance_variable(@current_char)operator(.)ident(digit?)
				ident(current_symbol) operator(=) ident(number)
			reserved(else)
				reserved(case) instance_variable(@current_char)
				reserved(when) integer(?\\s)
					comment(# ignore)
				reserved(when) integer(?\\n)
					ident(new_line)
				reserved(when) pre_constant(nil)
					ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(EOP)
				reserved(when) integer(?{)
					ident(comment)

				reserved(when) integer(?:)
					reserved(if) instance_variable(@next_char) operator(==) integer(?=)
						ident(read_next_char)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(BECOMES)
					reserved(else)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(COLON)
					reserved(end)

				reserved(when) integer(?<)
					reserved(if) operator(()instance_variable(@next_char) operator(==) integer(?=)operator(\))
						ident(read_next_char)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(LEQSY)
					reserved(elsif) operator(()instance_variable(@next_char) operator(==) integer(?>)operator(\))
						ident(read_next_char)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(NEQSY)
					reserved(else)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(LSSSY)
					reserved(end)

				reserved(when) integer(?>)
					reserved(if) operator(()instance_variable(@next_char) operator(==) integer(?=)operator(\))
						ident(read_next_char)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(GEQSY)
					reserved(else)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(GRTSY)
					reserved(end)

				reserved(when) integer(?.) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(PERIOD)
				reserved(when) integer(?() reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(LPARENT)
				reserved(when) integer(?,) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(COMMA)
				reserved(when) integer(?*) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(TIMES)
				reserved(when) integer(?/) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(SLASH)
				reserved(when) integer(?+) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(PLUS)
				reserved(when) integer(?-) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(MINUS)
				reserved(when) integer(?=) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(EQLSY)
				reserved(when) integer(?\)) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(RPARENT)
				reserved(when) integer(?;) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(SEMICOLON)
				reserved(else)
					constant(Error)operator(.)ident(error)operator(()integer(100)operator(,) instance_variable(@line)operator(,) instance_variable(@pos)operator(\)) reserved(if) instance_variable(@current_char) operator(>) integer(?\\s)
				reserved(end)
			reserved(end)
		reserved(end)
		ident(current_symbol)
	reserved(end)

ident(private)
	comment(##)
	comment(# Versucht, in dem gegebenen String ein Schlsselwort zu erkennen.)
	comment(# Sollte dabei ein Keyword gefunden werden, so gibt er ein PascalSymbol-Objekt zurck, das)
	comment(# das entsprechende Keyword reprsentiert. Ansonsten besteht die Rckgabe aus)
	comment(# einem SymbolIdent-Objekt (abgeleitet von PascalSymbol\), das den String 1:1 enthlt)
	comment(# @see symbol)
	comment(# @return falls Keyword gefunden, zugehriges PascalSymbol, sonst SymbolIdent)
	reserved(def) method(handle_identifier) ident(identifier)
		reserved(if) ident(sym) operator(=) constant(KEYWORD_SYMBOLS)operator([)ident(identifier)operator(])
			constant(PascalSymbol)operator(.)ident(new) ident(sym)
		reserved(else)
			constant(SymbolIdent)operator(.)ident(new) ident(identifier)
		reserved(end)
	reserved(end)

	constant(MAXINT) operator(=) integer(2)operator(**)integer(31) operator(-) integer(1)
	constant(MAXINT_DIV_10)  operator(=) constant(MAXINT) operator(/) integer(10)
	constant(MAXINT_MOD_10)  operator(=) constant(MAXINT) operator(%) integer(10)
	comment(##)
	comment(# Versucht, aus dem gegebenen Zeichen und den folgenden eine Zahl zusammenzusetzen.)
	comment(# Dabei wird der relativ intuitive Algorithmus benutzt, die endgltige Zahl bei)
	comment(# jeder weiteren Ziffer mit 10 zu multiplizieren und diese dann mit der Ziffer zu)
	comment(# addieren. Sonderflle bestehen dann nur noch in der Behandlung von reellen Zahlen.)
	comment(# <BR>)
	comment(# Treten dabei kein Punkt oder ein E auf, so gibt diese Methode ein SymbolIntCon-Objekt)
	comment(# zurck, ansonsten (reelle Zahl\) ein SymbolRealCon-Objekt. Beide Symbole enthalten)
	comment(# jeweils die Zahlwerte.)
	comment(# <BR>)
	comment(# Anmerkung: Diese Funktion ist mit Hilfe der Java/Ruby-API deutlich leichter zu realisieren.)
	comment(# Sie wurde dennoch so implementiert, um den Algorithmus zu demonstrieren)
	comment(# @see symbol)
	comment(# @return SymbolIntcon- oder SymbolRealcon-Objekt, das den Zahlwert enthlt)
	reserved(def) method(number)
		ident(is_integer) operator(=) pre_constant(true)
		ident(integer_too_long) operator(=) pre_constant(false)
		ident(exponent) operator(=) integer(0)
		ident(exp_counter) operator(=) operator(-)integer(1)
		ident(exp_sign) operator(=) integer(1)

		ident(integer_mantisse) operator(=) instance_variable(@current_char)operator(.)ident(digit)

		reserved(while) operator(()instance_variable(@next_char)operator(.)ident(digit?) reserved(and) ident(integer_mantisse) operator(<) constant(MAXINT_DIV_10)operator(\)) reserved(or)
		 operator(()ident(integer_mantisse) operator(==) constant(MAXINT_DIV_10) reserved(and) instance_variable(@next_char)operator(.)ident(digit) operator(<=) constant(MAXINT_MOD_10)operator(\))
			ident(integer_mantisse) operator(*=) integer(10)
			ident(integer_mantisse) operator(+=) instance_variable(@next_char)operator(.)ident(digit)
			ident(read_next_char)
		reserved(end)

		ident(real_mantisse) operator(=) ident(integer_mantisse)

		reserved(while) instance_variable(@next_char)operator(.)ident(digit?)
			ident(integer_too_long) operator(=) pre_constant(true)
			ident(real_mantisse) operator(*=) integer(10)
			ident(real_mantisse) operator(+=) instance_variable(@next_char)operator(.)ident(digit)
			ident(read_next_char)
		reserved(end)
		reserved(if) instance_variable(@next_char) operator(==) integer(?.)
			ident(read_next_char)
			ident(is_integer) operator(=) pre_constant(false)
			reserved(unless) instance_variable(@next_char)operator(.)ident(digit?)
				constant(Error)operator(.)ident(error) integer(101)operator(,) instance_variable(@line)operator(,) instance_variable(@pos)
			reserved(end)
			reserved(while) instance_variable(@next_char)operator(.)ident(digit?)
				ident(real_mantisse) operator(+=) instance_variable(@next_char)operator(.)ident(digit) operator(*) operator(()integer(10) operator(**) ident(exp_counter)operator(\))
				ident(read_next_char)
				ident(exp_counter) operator(-=) integer(1)
			reserved(end)
		reserved(end)
		reserved(if) instance_variable(@next_char) operator(==) integer(?E)
			ident(is_integer) operator(=) pre_constant(false)
			ident(read_next_char)
			reserved(if) instance_variable(@next_char) operator(==) integer(?-)
				ident(exp_sign) operator(=) operator(-)integer(1)
				ident(read_next_char)
			reserved(end)
			reserved(unless) instance_variable(@next_char)operator(.)ident(digit?)
				constant(Error)operator(.)ident(error) integer(101)operator(,) instance_variable(@line)operator(,) instance_variable(@pos)
			reserved(end)
			reserved(while) instance_variable(@next_char)operator(.)ident(digit?)
				ident(exponent) operator(*=) integer(10)
				ident(exponent) operator(+=) instance_variable(@next_char)operator(.)ident(digit)
				ident(read_next_char)
			reserved(end)
		reserved(end)

		reserved(if) ident(is_integer)
			reserved(if) ident(integer_too_long)
				constant(Error)operator(.)ident(error) integer(102)operator(,) instance_variable(@line)operator(,) instance_variable(@pos)
			reserved(end)
			constant(SymbolIntcon)operator(.)ident(new) ident(integer_mantisse)
		reserved(else)
			constant(SymbolRealcon)operator(.)ident(new) ident(real_mantisse) operator(*) operator(()integer(10) operator(**) operator(()ident(exp_sign) operator(*) ident(exponent)operator(\))operator(\))
		reserved(end)
	reserved(end)

	comment(##)
	comment(# Sorgt fr ein berlesen von Kommentaren.)
	comment(# Es werden einfach alle Zeichen bis zu einer schlieenden Klammer eingelesen)
	comment(# und verworfen.)
	reserved(def) method(comment)
		reserved(while) instance_variable(@current_char) operator(!=) integer(?})
			ident(forbid_eop)
			ident(new_line) reserved(if) instance_variable(@current_char) operator(==) integer(?\\n)
			ident(read_next_char)
		reserved(end)
	reserved(end)

	reserved(def) method(new_line)
		instance_variable(@line) operator(+=) integer(1)
		instance_variable(@pos) operator(=) integer(0)
	reserved(end)

	reserved(def) method(forbid_eop)
		reserved(if) ident(eop?)
			constant(Error)operator(.)ident(error) integer(103)operator(,) instance_variable(@line)operator(,) instance_variable(@pos)
		reserved(end)
		ident(exit)
	reserved(end)

	reserved(def) method(eop?)
		instance_variable(@current_char)operator(.)ident(nil?)
	reserved(end)
reserved(end)

comment(##)
comment(# Lt ein Testprogramm ablaufen.)
comment(# Dieses erzeugt sich ein Scanner-Objekt und ruft an diesem kontinuierlich bis zum Dateiende)
comment(# get_symbol auf.)
reserved(if) global_variable($0) operator(==) pre_constant(__FILE__)
	ident(scan) operator(=) constant(Scanner)operator(.)ident(new)operator(()constant(File)operator(.)ident(new)operator(()pre_constant(ARGV)operator([)integer(0)operator(]) operator(||) string<delimiter(')content(test.pas)delimiter(')>operator(\))operator(\))
	ident(loop) reserved(do)
		ident(c) operator(=) ident(scan)operator(.)ident(get_symbol)
		ident(puts) ident(c)
		reserved(break) reserved(if) ident(c)operator(.)ident(typ) operator(==) constant(TokenConsts)operator(::)constant(EOP)
	reserved(end)
reserved(end)
comment(# -*- ruby -*-)

comment(# Local variables:)
comment(#  indent-tabs-mode: nil)
comment(#  ruby-indent-level: 4)
comment(# End:)

comment(# @@PLEAC@@_NAME)
comment(# @@SKIP@@ Ruby)

comment(# @@PLEAC@@_WEB)
comment(# @@SKIP@@ http://www.ruby-lang.org)


comment(# @@PLEAC@@_1.0)
ident(string) operator(=) string<delimiter(')content(\\n)delimiter(')>                     comment(# two characters, \\ and an n)
ident(string) operator(=) string<delimiter(')content(Jon )char(\\')content(Maddog)char(\\')content( Orwant)delimiter(')>  comment(# literal single quotes)

ident(string) operator(=) string<delimiter(")char(\\n)delimiter(")>                     comment(# a "newline" character)
ident(string) operator(=) string<delimiter(")content(Jon )char(\\")content(Maddog)char(\\")content( Orwant)delimiter(")>  comment(# literal double quotes)

ident(string) operator(=) string<delimiter(%q/)content(Jon 'Maddog' Orwant)delimiter(/)>  comment(# literal single quotes)

ident(string) operator(=) string<delimiter(%q[)content(Jon 'Maddog' Orwant)delimiter(])>  comment(# literal single quotes)
ident(string) operator(=) string<delimiter(%q{)content(Jon 'Maddog' Orwant)delimiter(})>  comment(# literal single quotes)
ident(string) operator(=) string<delimiter(%q()content(Jon 'Maddog' Orwant)delimiter(\))>  comment(# literal single quotes)
ident(string) operator(=) string<delimiter(%q<)content(Jon 'Maddog' Orwant)delimiter(>)>  comment(# literal single quotes)

ident(a) operator(=) string<delimiter(<<"EOF")>string<content(
This is a multiline here document
terminated by EOF on a line by itself)delimiter(
EOF)>


comment(# @@PLEAC@@_1.1)
ident(value) operator(=) ident(string)operator([)ident(offset)operator(,)ident(count)operator(])
ident(value) operator(=) ident(string)operator([)ident(offset)operator(..)operator(-)integer(1)operator(])

ident(string)operator([)ident(offset)operator(,)ident(count)operator(]) operator(=) ident(newstring)
ident(string)operator([)ident(offset)operator(..)operator(-)integer(1)operator(])   operator(=) ident(newtail)

comment(# in Ruby we can also specify intervals by their two offsets)
ident(value) operator(=) ident(string)operator([)ident(offset)operator(..)ident(offs2)operator(])
ident(string)operator([)ident(offset)operator(..)ident(offs2)operator(]) operator(=) ident(newstring)

ident(leading)operator(,) ident(s1)operator(,) ident(s2)operator(,) ident(trailing) operator(=) ident(data)operator(.)ident(unpack)operator(()string<delimiter(")content(A5 x3 A8 A8 A*)delimiter(")>operator(\))

ident(fivers) operator(=) ident(string)operator(.)ident(unpack)operator(()string<delimiter(")content(A5)delimiter(")> operator(*) operator(()ident(string)operator(.)ident(length)operator(/)integer(5)operator(\))operator(\))

ident(chars) operator(=) ident(string)operator(.)ident(unpack)operator(()string<delimiter(")content(A1)delimiter(")> operator(*) ident(string)operator(.)ident(length)operator(\))

ident(string) operator(=) string<delimiter(")content(This is what you have)delimiter(")>
comment(#        +012345678901234567890  Indexing forwards  (left to right\))
comment(#         109876543210987654321- Indexing backwards (right to left\))
comment(#          note that 0 means 10 or 20, etc. above)

ident(first)  operator(=) ident(string)operator([)integer(0)operator(,) integer(1)operator(])       comment(# "T")
ident(start)  operator(=) ident(string)operator([)integer(5)operator(,) integer(2)operator(])       comment(# "is")
ident(rest)   operator(=) ident(string)operator([)integer(13)operator(..)operator(-)integer(1)operator(])     comment(# "you have")
ident(last)   operator(=) ident(string)operator([)operator(-)integer(1)operator(,) integer(1)operator(])      comment(# "e")
ident(end_)   operator(=) ident(string)operator([)operator(-)integer(4)operator(..)operator(-)integer(1)operator(])     comment(# "have")
ident(piece)  operator(=) ident(string)operator([)operator(-)integer(8)operator(,) integer(3)operator(])      comment(# "you")

ident(string)operator([)integer(5)operator(,) integer(2)operator(]) operator(=) string<delimiter(")content(wasn't)delimiter(")>     comment(# change "is" to "wasn't")
ident(string)operator([)operator(-)integer(12)operator(..)operator(-)integer(1)operator(]) operator(=) string<delimiter(")content(ondrous)delimiter(")> comment(# "This wasn't wondrous")
ident(string)operator([)integer(0)operator(,) integer(1)operator(]) operator(=) string<delimiter(")delimiter(")>           comment(# delete first character)
ident(string)operator([)operator(-)integer(10)operator(..)operator(-)integer(1)operator(])  operator(=) string<delimiter(")delimiter(")>       comment(# delete last 10 characters)

reserved(if) ident(string)operator([)operator(-)integer(10)operator(..)operator(-)integer(1)operator(]) operator(=)operator(~) regexp<delimiter(/)content(pattern)delimiter(/)>
    ident(puts) string<delimiter(")content(Pattern matches in last 10 characters)delimiter(")>
reserved(end)

ident(string)operator([)integer(0)operator(,) integer(5)operator(])operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(is)delimiter(/)>operator(,) string<delimiter(')content(at)delimiter(')>operator(\))

ident(a) operator(=) string<delimiter(")content(make a hat)delimiter(")>
ident(a)operator([)integer(0)operator(,) integer(1)operator(])operator(,) ident(a)operator([)operator(-)integer(1)operator(,) integer(1)operator(]) operator(=) ident(a)operator([)operator(-)integer(1)operator(,) integer(1)operator(])operator(,) ident(a)operator([)integer(0)operator(,) integer(1)operator(])

ident(a) operator(=) string<delimiter(")content(To be or not to be)delimiter(")>
ident(b) operator(=) ident(a)operator(.)ident(unpack)operator(()string<delimiter(")content(x6 A6)delimiter(")>operator(\))

ident(b)operator(,) ident(c) operator(=) ident(a)operator(.)ident(unpack)operator(()string<delimiter(")content(x6 A2 X5 A2)delimiter(")>operator(\))
ident(puts) string<delimiter(")inline<delimiter(#{)ident(b)delimiter(})>char(\\n)inline<delimiter(#{)ident(c)delimiter(})>char(\\n)delimiter(")>

reserved(def) method(cut2fmt)operator(()operator(*)ident(args)operator(\))
    ident(template) operator(=) string<delimiter(')delimiter(')>
    ident(lastpos)  operator(=) integer(1)
    reserved(for) ident(place) reserved(in) ident(args)
        ident(template) operator(+=) string<delimiter(")content(A)delimiter(")> operator(+) operator(()ident(place) operator(-) ident(lastpos)operator(\))operator(.)ident(to_s) operator(+) string<delimiter(")content( )delimiter(")>
        ident(lastpos)   operator(=) ident(place)
    reserved(end)
    ident(template) operator(+=) string<delimiter(")content(A*)delimiter(")>
    reserved(return) ident(template)
reserved(end)

ident(fmt) operator(=) ident(cut2fmt)operator(()integer(8)operator(,) integer(14)operator(,) integer(20)operator(,) integer(26)operator(,) integer(30)operator(\))


comment(# @@PLEAC@@_1.2)
comment(# careful! "b is true" doesn't mean "b != 0" (0 is true in Ruby\))
comment(# thus no problem of "defined" later since only nil is false)
comment(# the following sets to `c' if `b' is nil or false)
ident(a) operator(=) ident(b) operator(||) ident(c)

comment(# if you need Perl's behaviour (setting to `c' if `b' is 0\) the most)
comment(# effective way is to use Numeric#nonzero? (thanks to Dave Thomas!\))
ident(a) operator(=) ident(b)operator(.)ident(nonzero?) operator(||) ident(c)

comment(# you will still want to use defined? in order to test)
comment(# for scope existence of a given object)
ident(a) operator(=) reserved(defined?)operator(()ident(b)operator(\)) operator(?) ident(b) operator(:) ident(c)

ident(dir) operator(=) pre_constant(ARGV)operator(.)ident(shift) operator(||) string<delimiter(")content(/tmp)delimiter(")>


comment(# @@PLEAC@@_1.3)
ident(v1)operator(,) ident(v2) operator(=) ident(v2)operator(,) ident(v1)

ident(alpha)operator(,) ident(beta)operator(,) ident(production) operator(=) string<delimiter(%w()content(January March August)delimiter(\))>
ident(alpha)operator(,) ident(beta)operator(,) ident(production) operator(=) ident(beta)operator(,) ident(production)operator(,) ident(alpha)


comment(# @@PLEAC@@_1.4)
ident(num) operator(=) ident(char)operator([)integer(0)operator(])
ident(char) operator(=) ident(num)operator(.)ident(chr)

comment(# Ruby also supports having a char from character constant)
ident(num) operator(=) integer(?r)

ident(char) operator(=) ident(sprintf)operator(()string<delimiter(")content(%c)delimiter(")>operator(,) ident(num)operator(\))
ident(printf)operator(()string<delimiter(")content(Number %d is character %c)char(\\n)delimiter(")>operator(,) ident(num)operator(,) ident(num)operator(\))

ident(ascii) operator(=) ident(string)operator(.)ident(unpack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))
ident(string) operator(=) ident(ascii)operator(.)ident(pack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))

ident(hal) operator(=) string<delimiter(")content(HAL)delimiter(")>
ident(ascii) operator(=) ident(hal)operator(.)ident(unpack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))
comment(# We can't use Array#each since we can't mutate a Fixnum)
ident(ascii)operator(.)ident(collect!) operator({) operator(|)ident(i)operator(|)
    ident(i) operator(+) integer(1)                         comment(# add one to each ASCII value)
operator(})
ident(ibm) operator(=) ident(ascii)operator(.)ident(pack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))
ident(puts) ident(ibm)


comment(# @@PLEAC@@_1.5)
ident(array) operator(=) ident(string)operator(.)ident(split)operator(()string<delimiter(')delimiter(')>operator(\))

ident(array) operator(=) ident(string)operator(.)ident(unpack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))

ident(string)operator(.)ident(scan)operator(()regexp<delimiter(/)content(.)delimiter(/)>operator(\)) operator({) operator(|)ident(b)operator(|)
    comment(# do something with b)
operator(})

ident(string) operator(=) string<delimiter(")content(an apple a day)delimiter(")>
ident(print) string<delimiter(")content(unique chars are: )delimiter(")>operator(,) ident(string)operator(.)ident(split)operator(()string<delimiter(')delimiter(')>operator(\))operator(.)ident(uniq)operator(.)ident(sort)operator(,) string<delimiter(")char(\\n)delimiter(")>

ident(sum) operator(=) integer(0)
reserved(for) ident(ascval) reserved(in) ident(string)operator(.)ident(unpack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\)) comment(# or use Array#each for a pure OO style :\))
    ident(sum) operator(+=) ident(ascval)
reserved(end)
ident(puts) string<delimiter(")content(sum is )inline<delimiter(#{)ident(sum) operator(&) integer(0xffffffff)delimiter(})>delimiter(")> comment(# since Ruby will go Bignum if necessary)

comment(# @@INCLUDE@@ include/ruby/slowcat.rb)


comment(# @@PLEAC@@_1.6)
ident(revbytes) operator(=) ident(string)operator(.)ident(reverse)

ident(revwords) operator(=) ident(string)operator(.)ident(split)operator(()string<delimiter(")content( )delimiter(")>operator(\))operator(.)ident(reverse)operator(.)ident(join)operator(()string<delimiter(")content( )delimiter(")>operator(\))

ident(revwords) operator(=) ident(string)operator(.)ident(split)operator(()regexp<delimiter(/)content(()char(\\s)content(+\))delimiter(/)>operator(\))operator(.)ident(reverse)operator(.)ident(join)

comment(# using the fact that IO is Enumerable, you can directly "select" it)
ident(long_palindromes) operator(=) constant(File)operator(.)ident(open)operator(()string<delimiter(")content(/usr/share/dict/words)delimiter(")>operator(\))operator(.)
    ident(select) operator({) operator(|)ident(w)operator(|) ident(w)operator(.)ident(chomp!)operator(;) ident(w)operator(.)ident(reverse) operator(==) ident(w) operator(&&) ident(w)operator(.)ident(length) operator(>) integer(5) operator(})


comment(# @@PLEAC@@_1.7)
reserved(while) ident(string)operator(.)ident(sub!)operator(()string<delimiter(")char(\\t)content(+)delimiter(")>operator(\)) operator({) string<delimiter(')content( )delimiter(')> operator(*) operator(()global_variable($&)operator(.)ident(length) operator(*) integer(8) operator(-) global_variable($`)operator(.)ident(length) operator(%) integer(8)operator(\)) operator(})
reserved(end)


comment(# @@PLEAC@@_1.8)
string<delimiter(')content(You owe #{debt} to me)delimiter(')>operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\#)content({()char(\\w)content(+\)})delimiter(/)>operator(\)) operator({) ident(eval)operator(()global_variable($1)operator(\)) operator(})

ident(rows)operator(,) ident(cols) operator(=) integer(24)operator(,) integer(80)
ident(text) operator(=) string<delimiter(%q()content(I am #{rows} high and #{cols} long)delimiter(\))>
ident(text)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\#)content({()char(\\w)content(+\)})delimiter(/)>operator(\)) operator({) ident(eval)operator(()string<delimiter(")inline<delimiter(#{)global_variable($1)delimiter(})>delimiter(")>operator(\)) operator(})
ident(puts) ident(text)

string<delimiter(')content(I am 17 years old)delimiter(')>operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\d)content(+)delimiter(/)>operator(\)) operator({) integer(2) operator(*) global_variable($&)operator(.)ident(to_i) operator(})


comment(# @@PLEAC@@_1.9)
ident(e) operator(=) string<delimiter(")content(bo peep)delimiter(")>operator(.)ident(upcase)
ident(e)operator(.)ident(downcase!)
ident(e)operator(.)ident(capitalize!)

string<delimiter(")content(thIS is a loNG liNE)delimiter(")>operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\w)content(+)delimiter(/)>operator(\)) operator({) global_variable($&)operator(.)ident(capitalize) operator(})


comment(# @@PLEAC@@_1.10)
string<delimiter(")content(I have )inline<delimiter(#{)ident(n)operator(+)integer(1)delimiter(})>content( guanacos.)delimiter(")>
ident(print) string<delimiter(")content(I have )delimiter(")>operator(,) ident(n)operator(+)integer(1)operator(,) string<delimiter(")content( guanacos.)delimiter(")>


comment(# @@PLEAC@@_1.11)
ident(var) operator(=) string<delimiter(<<'EOF')>operator(.)ident(gsub)operator(()regexp<delimiter(/)content(^)char(\\s)content(+)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))string<content(
    your text
    goes here)delimiter(
EOF)>


comment(# @@PLEAC@@_1.12)
ident(string) operator(=) string<delimiter(")content(Folding and splicing is the work of an editor,)char(\\n)delimiter(")>operator(+)
    string<delimiter(")content(not a mere collection of silicon)char(\\n)delimiter(")>operator(+)
    string<delimiter(")content(and)char(\\n)delimiter(")>operator(+)
    string<delimiter(")content(mobile electrons!)delimiter(")>

reserved(def) method(wrap)operator(()ident(str)operator(,) ident(max_size)operator(\))
    ident(all) operator(=) operator([)operator(])
    ident(line) operator(=) string<delimiter(')delimiter(')>
    reserved(for) ident(l) reserved(in) ident(str)operator(.)ident(split)
        reserved(if) operator(()ident(line)operator(+)ident(l)operator(\))operator(.)ident(length) operator(>)operator(=) ident(max_size)
            ident(all)operator(.)ident(push)operator(()ident(line)operator(\))
            ident(line) operator(=) string<delimiter(')delimiter(')>
        reserved(end)
        ident(line) operator(+=) ident(line) operator(==) string<delimiter(')delimiter(')> operator(?) ident(l) operator(:) string<delimiter(')content( )delimiter(')> operator(+) ident(l)
    reserved(end)
    ident(all)operator(.)ident(push)operator(()ident(line)operator(\))operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))
reserved(end)

ident(print) ident(wrap)operator(()ident(string)operator(,) integer(20)operator(\))
comment(#=> Folding and)
comment(#=> splicing is the)
comment(#=> work of an editor,)
comment(#=> not a mere)
comment(#=> collection of)
comment(#=> silicon and mobile)
comment(#=> electrons!)


comment(# @@PLEAC@@_1.13)
ident(string) operator(=) string<delimiter(%q()content(Mom said, "Don't do that.")delimiter(\))>
ident(string)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(['"])delimiter(/)>operator(\)) operator({) string<delimiter(')char(\\\\)delimiter(')>operator(+)global_variable($&) operator(})
ident(string)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(['"])delimiter(/)>operator(,) string<delimiter(')content(\\&)content(\\&)delimiter(')>operator(\))
ident(string)operator(.)ident(gsub)operator(()regexp<delimiter(/)content([^A-Z])delimiter(/)>operator(\)) operator({) string<delimiter(')char(\\\\)delimiter(')>operator(+)global_variable($&) operator(})
string<delimiter(")content(is a test!)delimiter(")>operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\W)delimiter(/)>operator(\)) operator({) string<delimiter(')char(\\\\)delimiter(')>operator(+)global_variable($&) operator(})  comment(# no function like quotemeta?)


comment(# @@PLEAC@@_1.14)
ident(string)operator(.)ident(strip!)


comment(# @@PLEAC@@_1.15)
reserved(def) method(parse_csv)operator(()ident(text)operator(\))
    ident(new) operator(=) ident(text)operator(.)ident(scan)operator(()regexp<delimiter(/)content("([^)char(\\")char(\\\\)content(]*(?:)char(\\\\)content(.[^)char(\\")char(\\\\)content(]*\)*\)",?|([^,]+\),?|,)delimiter(/)>operator(\))
    ident(new) operator(<<) pre_constant(nil) reserved(if) ident(text)operator([)operator(-)integer(1)operator(]) operator(==) integer(?,)
    ident(new)operator(.)ident(flatten)operator(.)ident(compact)
reserved(end)

ident(line) operator(=) string<delimiter(%q<)content(XYZZY,"","O'Reilly, Inc","Wall, Larry","a )content(\\")content(glug)content(\\")content( bit,",5,"Error, Core Dumped")delimiter(>)>
ident(fields) operator(=) ident(parse_csv)operator(()ident(line)operator(\))
ident(fields)operator(.)ident(each_with_index) operator({) operator(|)ident(v)operator(,)ident(i)operator(|)
    ident(print) string<delimiter(")inline<delimiter(#{)ident(i)delimiter(})>content( : )inline<delimiter(#{)ident(v)delimiter(})>char(\\n)delimiter(")>operator(;)
operator(})


comment(# @@PLEAC@@_1.16)
comment(# Use the soundex.rb Library from Michael Neumann.)
comment(# http://www.s-direktnet.de/homepages/neumann/rb_prgs/Soundex.rb)
ident(require) string<delimiter(')content(Soundex)delimiter(')>

ident(code) operator(=) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(string)operator(\))
ident(codes) operator(=) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(array)operator(\))

comment(# substitution function for getpwent(\):)
comment(# returns an array of user entries,)
comment(# each entry contains the username and the full name)
reserved(def) method(login_names)
    ident(result) operator(=) operator([)operator(])
    constant(File)operator(.)ident(open)operator(()string<delimiter(")content(/etc/passwd)delimiter(")>operator(\)) operator({) operator(|)ident(file)operator(|)
        ident(file)operator(.)ident(each_line) operator({) operator(|)ident(line)operator(|)
            reserved(next) reserved(if) ident(line)operator(.)ident(match)operator(()regexp<delimiter(/)content(^#)delimiter(/)>operator(\))
            ident(cols) operator(=) ident(line)operator(.)ident(split)operator(()string<delimiter(")content(:)delimiter(")>operator(\))
            ident(result)operator(.)ident(push)operator(()operator([)ident(cols)operator([)integer(0)operator(])operator(,) ident(cols)operator([)integer(4)operator(])operator(])operator(\))
        operator(})
    operator(})
    ident(result)
reserved(end)

ident(puts) string<delimiter(")content(Lookup user: )delimiter(")>
ident(user) operator(=) constant(STDIN)operator(.)ident(gets)
ident(user)operator(.)ident(chomp!)
ident(exit) reserved(unless) ident(user)
ident(name_code) operator(=) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(user)operator(\))

ident(splitter) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(()content(\\w)content(+\)[^,]*)content(\\b)content(()content(\\w)content(+\))delimiter(')>operator(\))
reserved(for) ident(username)operator(,) ident(fullname) reserved(in) ident(login_names) reserved(do)
    ident(firstname)operator(,) ident(lastname) operator(=) ident(splitter)operator(.)ident(match)operator(()ident(fullname)operator(\))operator([)integer(1)operator(,)integer(2)operator(])
    reserved(if) ident(name_code) operator(==) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(username)operator(\))
        operator(||) ident(name_code) operator(==) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(firstname)operator(\))
        operator(||) ident(name_code) operator(==) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(lastname)operator(\))
    reserved(then)
        ident(puts) string<delimiter(")inline<delimiter(#{)ident(username)delimiter(})>content(: )inline<delimiter(#{)ident(firstname)delimiter(})>content( )inline<delimiter(#{)ident(lastname)delimiter(})>delimiter(")>
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_1.17)
comment(# @@INCLUDE@@ include/ruby/fixstyle.rb)


comment(# @@PLEAC@@_1.18)
comment(# @@INCLUDE@@ include/ruby/psgrep.rb)


comment(# @@PLEAC@@_2.1)
comment(# Matz tells that you can use Integer(\) for strict checked conversion.)
constant(Integer)operator(()string<delimiter(")content(abc)delimiter(")>operator(\))
comment(#=> `Integer': invalid value for Integer: "abc" (ArgumentError\))
constant(Integer)operator(()string<delimiter(")content(567)delimiter(")>operator(\))
comment(#=> 567)

comment(# You may use Float(\) for floating point stuff)
constant(Integer)operator(()string<delimiter(")content(56.7)delimiter(")>operator(\))
comment(#=> `Integer': invalid value for Integer: "56.7" (ArgumentError\))
constant(Float)operator(()string<delimiter(")content(56.7)delimiter(")>operator(\))
comment(#=> 56.7)

comment(# You may also use a regexp for that)
reserved(if) ident(string) operator(=)operator(~) regexp<delimiter(/)content(^[+-]?)char(\\d)content(+$)delimiter(/)>
    ident(p) string<delimiter(')content(is an integer)delimiter(')>
reserved(else)
    ident(p) string<delimiter(')content(is not)delimiter(')>
reserved(end)

reserved(if) ident(string) operator(=)operator(~) regexp<delimiter(/)content(^-?(?:)char(\\d)content(+(?:)char(\\.)char(\\d)content(*\)?|)char(\\.)char(\\d)content(+\)$)delimiter(/)>
    ident(p) string<delimiter(')content(is a decimal number)delimiter(')>
reserved(else)
    ident(p) string<delimiter(')content(is not)delimiter(')>
reserved(end)


comment(# @@PLEAC@@_2.2)
comment(# equal(num1, num2, accuracy\) : returns true if num1 and num2 are)
comment(#   equal to accuracy number of decimal places)
reserved(def) method(equal)operator(()ident(i)operator(,) ident(j)operator(,) ident(a)operator(\))
    ident(sprintf)operator(()string<delimiter(")content(%.)inline<delimiter(#{)ident(a)delimiter(})>content(g)delimiter(")>operator(,) ident(i)operator(\)) operator(==) ident(sprintf)operator(()string<delimiter(")content(%.)inline<delimiter(#{)ident(a)delimiter(})>content(g)delimiter(")>operator(,) ident(j)operator(\))
reserved(end)

ident(wage) operator(=) integer(536)                        comment(# $5.36/hour)
ident(week) operator(=) integer(40) operator(*) ident(wage)                  comment(# $214.40)
ident(printf)operator(()string<delimiter(")content(One week's wage is: )char(\\$)content(%.2f)char(\\n)delimiter(")>operator(,) ident(week)operator(/)float(100.0)operator(\))


comment(# @@PLEAC@@_2.3)
ident(num)operator(.)ident(round)                         comment(# rounds to integer)

ident(a) operator(=) float(0.255)
ident(b) operator(=) ident(sprintf)operator(()string<delimiter(")content(%.2f)delimiter(")>operator(,) ident(a)operator(\))
ident(print)  string<delimiter(")content(Unrounded: )inline<delimiter(#{)ident(a)delimiter(})>char(\\n)content(Rounded: )inline<delimiter(#{)ident(b)delimiter(})>char(\\n)delimiter(")>
ident(printf) string<delimiter(")content(Unrounded: )inline<delimiter(#{)ident(a)delimiter(})>char(\\n)content(Rounded: %.2f)char(\\n)delimiter(")>operator(,) ident(a)

ident(print) string<delimiter(")content(number)char(\\t)content(int)char(\\t)content(floor)char(\\t)content(ceil)char(\\n)delimiter(")>
ident(a) operator(=) operator([) float(3.3) operator(,) float(3.5) operator(,) float(3.7)operator(,) operator(-)float(3.3) operator(])
reserved(for) ident(n) reserved(in) ident(a)
    ident(printf)operator(()string<delimiter(")content(% .1f)char(\\t)content(% .1f)char(\\t)content(% .1f)char(\\t)content(% .1f)char(\\n)delimiter(")>operator(,)  comment(# at least I don't fake my output :\))
           ident(n)operator(,) ident(n)operator(.)ident(to_i)operator(,) ident(n)operator(.)ident(floor)operator(,) ident(n)operator(.)ident(ceil)operator(\))
reserved(end)


comment(# @@PLEAC@@_2.4)
reserved(def) method(dec2bin)operator(()ident(n)operator(\))
    operator([)ident(n)operator(])operator(.)ident(pack)operator(()string<delimiter(")content(N)delimiter(")>operator(\))operator(.)ident(unpack)operator(()string<delimiter(")content(B32)delimiter(")>operator(\))operator([)integer(0)operator(])operator(.)ident(sub)operator(()regexp<delimiter(/)content(^0+(?=)char(\\d)content(\))delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))
reserved(end)

reserved(def) method(bin2dec)operator(()ident(n)operator(\))
    operator([)operator(()string<delimiter(")content(0)delimiter(")>operator(*)integer(32)operator(+)ident(n)operator(.)ident(to_s)operator(\))operator([)operator(-)integer(32)operator(..)operator(-)integer(1)operator(])operator(])operator(.)ident(pack)operator(()string<delimiter(")content(B32)delimiter(")>operator(\))operator(.)ident(unpack)operator(()string<delimiter(")content(N)delimiter(")>operator(\))operator([)integer(0)operator(])
reserved(end)


comment(# @@PLEAC@@_2.5)
reserved(for) ident(i) reserved(in) ident(x) operator(..) ident(y)
    comment(# i is set to every integer from x to y, inclusive)
reserved(end)

ident(x)operator(.)ident(step)operator(()ident(y)operator(,)integer(7)operator(\)) operator({) operator(|)ident(i)operator(|)
    comment(# i is set to every integer from x to y, stepsize = 7)
operator(})

ident(print) string<delimiter(")content(Infancy is: )delimiter(")>
operator(()integer(0)operator(..)integer(2)operator(\))operator(.)ident(each) operator({) operator(|)ident(i)operator(|)
    ident(print) ident(i)operator(,) string<delimiter(")content( )delimiter(")>
operator(})
ident(print) string<delimiter(")char(\\n)delimiter(")>


comment(# @@PLEAC@@_2.6)
comment(# We can add conversion methods to the Integer class,)
comment(# this makes a roman number just a representation for normal numbers.)
reserved(class) class(Integer)

    class_variable(@@romanlist) operator(=) operator([)operator([)string<delimiter(")content(M)delimiter(")>operator(,) integer(1000)operator(])operator(,)
                   operator([)string<delimiter(")content(CM)delimiter(")>operator(,) integer(900)operator(])operator(,)
                   operator([)string<delimiter(")content(D)delimiter(")>operator(,)  integer(500)operator(])operator(,)
                   operator([)string<delimiter(")content(CD)delimiter(")>operator(,) integer(400)operator(])operator(,)
                   operator([)string<delimiter(")content(C)delimiter(")>operator(,)  integer(100)operator(])operator(,)
                   operator([)string<delimiter(")content(XC)delimiter(")>operator(,)  integer(90)operator(])operator(,)
                   operator([)string<delimiter(")content(L)delimiter(")>operator(,)   integer(50)operator(])operator(,)
                   operator([)string<delimiter(")content(XL)delimiter(")>operator(,)  integer(40)operator(])operator(,)
                   operator([)string<delimiter(")content(X)delimiter(")>operator(,)   integer(10)operator(])operator(,)
                   operator([)string<delimiter(")content(IX)delimiter(")>operator(,)   integer(9)operator(])operator(,)
                   operator([)string<delimiter(")content(V)delimiter(")>operator(,)    integer(5)operator(])operator(,)
                   operator([)string<delimiter(")content(IV)delimiter(")>operator(,)   integer(4)operator(])operator(,)
                   operator([)string<delimiter(")content(I)delimiter(")>operator(,)    integer(1)operator(])operator(])

    reserved(def) method(to_roman)
        ident(remains) operator(=) pre_constant(self)
        ident(roman) operator(=) string<delimiter(")delimiter(")>
        reserved(for) ident(sym)operator(,) ident(num) reserved(in) class_variable(@@romanlist)
            reserved(while) ident(remains) operator(>)operator(=) ident(num)
                ident(remains) operator(-=) ident(num)
                ident(roman) operator(<<) ident(sym)
            reserved(end)
        reserved(end)
        ident(roman)
    reserved(end)

    reserved(def) constant(Integer)operator(.)ident(from_roman)operator(()ident(roman)operator(\))
        ident(ustr) operator(=) ident(roman)operator(.)ident(upcase)
        ident(sum) operator(=) integer(0)
        reserved(for) ident(entry) reserved(in) class_variable(@@romanlist)
            ident(sym)operator(,) ident(num) operator(=) ident(entry)operator([)integer(0)operator(])operator(,) ident(entry)operator([)integer(1)operator(])
            reserved(while) ident(sym) operator(==) ident(ustr)operator([)integer(0)operator(,) ident(sym)operator(.)ident(length)operator(])
                ident(sum) operator(+=) ident(num)
                ident(ustr)operator(.)ident(slice!)operator(()integer(0)operator(,) ident(sym)operator(.)ident(length)operator(\))
            reserved(end)
        reserved(end)
        ident(sum)
    reserved(end)

reserved(end)


ident(roman_fifteen) operator(=) integer(15)operator(.)ident(to_roman)
ident(puts) string<delimiter(")content(Roman for fifteen is )inline<delimiter(#{)ident(roman_fifteen)delimiter(})>delimiter(")>
ident(i) operator(=) constant(Integer)operator(.)ident(from_roman)operator(()ident(roman_fifteen)operator(\))
ident(puts) string<delimiter(")content(Converted back, )inline<delimiter(#{)ident(roman_fifteen)delimiter(})>content( is )inline<delimiter(#{)ident(i)delimiter(})>delimiter(")>

comment(# check)
reserved(for) ident(i) reserved(in) operator(()integer(1)operator(..)integer(3900)operator(\))
    ident(r) operator(=) ident(i)operator(.)ident(to_roman)
    ident(j) operator(=) constant(Integer)operator(.)ident(from_roman)operator(()ident(r)operator(\))
    reserved(if) ident(i) operator(!=) ident(j)
        ident(puts) string<delimiter(")content(error: )inline<delimiter(#{)ident(i)delimiter(})>content( : )inline<delimiter(#{)ident(r)delimiter(})>content( - )inline<delimiter(#{)ident(j)delimiter(})>delimiter(")>
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_2.7)
ident(random) operator(=) ident(rand)operator(()ident(y)operator(-)ident(x)operator(+)integer(1)operator(\))operator(+)ident(x)

ident(chars) operator(=) operator([)string<delimiter(")content(A)delimiter(")>operator(..)string<delimiter(")content(Z)delimiter(")>operator(,)string<delimiter(")content(a)delimiter(")>operator(..)string<delimiter(")content(z)delimiter(")>operator(,)string<delimiter(")content(0)delimiter(")>operator(..)string<delimiter(")content(9)delimiter(")>operator(])operator(.)ident(collect) operator({) operator(|)ident(r)operator(|) ident(r)operator(.)ident(to_a) operator(})operator(.)ident(join) operator(+) string<delimiter(%q()content(!@$%^&*)delimiter(\))>
ident(password) operator(=) operator(()integer(1)operator(..)integer(8)operator(\))operator(.)ident(collect) operator({) ident(chars)operator([)ident(rand)operator(()ident(chars)operator(.)ident(size)operator(\))operator(]) operator(})operator(.)ident(pack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))


comment(# @@PLEAC@@_2.8)
ident(srand)        comment(# uses a combination of the time, the process id, and a sequence number)
ident(srand)operator(()ident(val)operator(\))   comment(# for repeatable behaviour)


comment(# @@PLEAC@@_2.9)
comment(# from the randomr lib:)
comment(# http://raa.ruby-lang.org/project/randomr/)
operator(-)operator(-)operator(-)operator(-)operator(>) ident(http)symbol(:/)operator(/)ident(raa)operator(.)ident(ruby)operator(-)ident(lang)operator(.)ident(org)operator(/)ident(project)operator(/)ident(randomr)operator(/)

ident(require) string<delimiter(')content(random/mersenne_twister)delimiter(')>
ident(mers) operator(=) constant(Random)operator(::)constant(MersenneTwister)operator(.)ident(new) integer(123456789)
ident(puts) ident(mers)operator(.)ident(rand)operator(()integer(0)operator(\))    comment(# 0.550321932544541)
ident(puts) ident(mers)operator(.)ident(rand)operator(()integer(10)operator(\))   comment(# 2)

comment(# using online sources of random data via the realrand package:)
comment(# http://raa.ruby-lang.org/project/realrand/)
comment(# **Note**)
comment(# The following online services are used in this package:)
comment(#   http://www.random.org - source: atmospheric noise)
comment(#   http://www.fourmilab.ch/hotbits - source: radioactive decay timings)
comment(#   http://random.hd.org - source: entropy from local and network noise)
comment(# Please visit the sites and respect the rules of each service.)

ident(require) string<delimiter(')content(random/online)delimiter(')>

ident(generator1) operator(=) constant(Random)operator(::)constant(RandomOrg)operator(.)ident(new)
ident(puts) ident(generator1)operator(.)ident(randbyte)operator(()integer(5)operator(\))operator(.)ident(join)operator(()string<delimiter(")content(,)delimiter(")>operator(\))
ident(puts) ident(generator1)operator(.)ident(randnum)operator(()integer(10)operator(,) integer(1)operator(,) integer(6)operator(\))operator(.)ident(join)operator(()string<delimiter(")content(,)delimiter(")>operator(\))  comment(# Roll dice 10 times.)

ident(generator2) operator(=) constant(Random)operator(::)constant(FourmiLab)operator(.)ident(new)
ident(puts) ident(generator2)operator(.)ident(randbyte)operator(()integer(5)operator(\))operator(.)ident(join)operator(()string<delimiter(")content(,)delimiter(")>operator(\))
comment(# randnum is not supported.)

ident(generator3) operator(=) constant(Random)operator(::)constant(EntropyPool)operator(.)ident(new)
ident(puts) ident(generator3)operator(.)ident(randbyte)operator(()integer(5)operator(\))operator(.)ident(join)operator(()string<delimiter(")content(,)delimiter(")>operator(\))
comment(# randnum is not supported.)


comment(# @@PLEAC@@_2.10)
reserved(def) method(gaussian_rand)
    reserved(begin)
        ident(u1) operator(=) integer(2) operator(*) ident(rand)operator(()operator(\)) operator(-) integer(1)
        ident(u2) operator(=) integer(2) operator(*) ident(rand)operator(()operator(\)) operator(-) integer(1)
        ident(w) operator(=) ident(u1)operator(*)ident(u1) operator(+) ident(u2)operator(*)ident(u2)
    reserved(end) reserved(while) operator(()ident(w) operator(>)operator(=) integer(1)operator(\))
    ident(w) operator(=) constant(Math)operator(.)ident(sqrt)operator(()operator(()operator(-)integer(2)operator(*)constant(Math)operator(.)ident(log)operator(()ident(w)operator(\))operator(\))operator(/)ident(w)operator(\))
    operator([) ident(u2)operator(*)ident(w)operator(,) ident(u1)operator(*)ident(w) operator(])
reserved(end)

ident(mean) operator(=) integer(25)
ident(sdev) operator(=) integer(2)
ident(salary) operator(=) ident(gaussian_rand)operator([)integer(0)operator(]) operator(*) ident(sdev) operator(+) ident(mean)
ident(printf)operator(()string<delimiter(")content(You have been hired at )char(\\$)content(%.2f)char(\\n)delimiter(")>operator(,) ident(salary)operator(\))


comment(# @@PLEAC@@_2.11)
reserved(def) method(deg2rad)operator(()ident(d)operator(\))
    operator(()ident(d)operator(/)float(180.0)operator(\))operator(*)constant(Math)operator(::)constant(PI)
reserved(end)

reserved(def) method(rad2deg)operator(()ident(r)operator(\))
    operator(()ident(r)operator(/)constant(Math)operator(::)constant(PI)operator(\))operator(*)integer(180)
reserved(end)


comment(# @@PLEAC@@_2.12)
ident(sin_val) operator(=) constant(Math)operator(.)ident(sin)operator(()ident(angle)operator(\))
ident(cos_val) operator(=) constant(Math)operator(.)ident(cos)operator(()ident(angle)operator(\))
ident(tan_val) operator(=) constant(Math)operator(.)ident(tan)operator(()ident(angle)operator(\))

comment(# AFAIK Ruby's Math module doesn't provide acos/asin)
comment(# While we're at it, let's also define missing hyperbolic functions)
reserved(module) class(Math)
    reserved(def) constant(Math)operator(.)ident(asin)operator(()ident(x)operator(\))
        ident(atan2)operator(()ident(x)operator(,) ident(sqrt)operator(()integer(1) operator(-) ident(x)operator(**)integer(2)operator(\))operator(\))
    reserved(end)
    reserved(def) constant(Math)operator(.)ident(acos)operator(()ident(x)operator(\))
        ident(atan2)operator(()ident(sqrt)operator(()integer(1) operator(-) ident(x)operator(**)integer(2)operator(\))operator(,) ident(x)operator(\))
    reserved(end)
    reserved(def) constant(Math)operator(.)ident(atan)operator(()ident(x)operator(\))
        ident(atan2)operator(()ident(x)operator(,) integer(1)operator(\))
    reserved(end)
    reserved(def) constant(Math)operator(.)ident(sinh)operator(()ident(x)operator(\))
        operator(()ident(exp)operator(()ident(x)operator(\)) operator(-) ident(exp)operator(()operator(-)ident(x)operator(\))operator(\)) operator(/) integer(2)
    reserved(end)
    reserved(def) constant(Math)operator(.)ident(cosh)operator(()ident(x)operator(\))
        operator(()ident(exp)operator(()ident(x)operator(\)) operator(+) ident(exp)operator(()operator(-)ident(x)operator(\))operator(\)) operator(/) integer(2)
    reserved(end)
    reserved(def) constant(Math)operator(.)ident(tanh)operator(()ident(x)operator(\))
        ident(sinh)operator(()ident(x)operator(\)) operator(/) ident(cosh)operator(()ident(x)operator(\))
    reserved(end)
reserved(end)

comment(# The support for Complex numbers is not built-in)
ident(y) operator(=) constant(Math)operator(.)ident(acos)operator(()float(3.7)operator(\))
comment(#=> in `sqrt': square root for negative number (ArgumentError\))

comment(# There is an implementation of Complex numbers in 'complex.rb' in current)
comment(# Ruby distro, but it doesn't support atan2 with complex args, so it doesn't)
comment(# solve this problem.)


comment(# @@PLEAC@@_2.13)
ident(log_e) operator(=) constant(Math)operator(.)ident(log)operator(()ident(val)operator(\))
ident(log_10) operator(=) constant(Math)operator(.)ident(log10)operator(()ident(val)operator(\))

reserved(def) method(log_base)operator(()ident(base)operator(,) ident(val)operator(\))
    constant(Math)operator(.)ident(log)operator(()ident(val)operator(\))operator(/)constant(Math)operator(.)ident(log)operator(()ident(base)operator(\))
reserved(end)

ident(answer) operator(=) ident(log_base)operator(()integer(10)operator(,) integer(10_000)operator(\))
ident(puts) string<delimiter(")content(log10(10,000\) = )inline<delimiter(#{)ident(answer)delimiter(})>delimiter(")>


comment(# @@PLEAC@@_2.14)
ident(require) string<delimiter(')content(matrix.rb)delimiter(')>

ident(a) operator(=) constant(Matrix)operator([)operator([)integer(3)operator(,) integer(2)operator(,) integer(3)operator(])operator(,) operator([)integer(5)operator(,) integer(9)operator(,) integer(8)operator(])operator(])
ident(b) operator(=) constant(Matrix)operator([)operator([)integer(4)operator(,) integer(7)operator(])operator(,) operator([)integer(9)operator(,) integer(3)operator(])operator(,) operator([)integer(8)operator(,) integer(1)operator(])operator(])
ident(c) operator(=) ident(a) operator(*) ident(b)

ident(a)operator(.)ident(row_size)
ident(a)operator(.)ident(column_size)

ident(c)operator(.)ident(det)
ident(a)operator(.)ident(transpose)


comment(# @@PLEAC@@_2.15)
ident(require) string<delimiter(')content(complex.rb)delimiter(')>
ident(require) string<delimiter(')content(rational.rb)delimiter(')>

ident(a) operator(=) constant(Complex)operator(()integer(3)operator(,) integer(5)operator(\))              comment(# 3 + 5i)
ident(b) operator(=) constant(Complex)operator(()integer(2)operator(,) operator(-)integer(2)operator(\))             comment(# 2 - 2i)
ident(puts) string<delimiter(")content(c = )inline<delimiter(#{)ident(a)operator(*)ident(b)delimiter(})>delimiter(")>

ident(c) operator(=) ident(a) operator(*) ident(b)
ident(d) operator(=) integer(3) operator(+) integer(4)operator(*)constant(Complex)operator(::)constant(I)

ident(printf) string<delimiter(")content(sqrt()inline<delimiter(#{)ident(d)delimiter(})>content(\) = %s)char(\\n)delimiter(")>operator(,) constant(Math)operator(.)ident(sqrt)operator(()ident(d)operator(\))


comment(# @@PLEAC@@_2.16)
ident(number) operator(=) ident(hexadecimal)operator(.)ident(hex)
ident(number) operator(=) ident(octal)operator(.)ident(oct)

ident(print) string<delimiter(")content(Gimme a number in decimal, octal, or hex: )delimiter(")>
ident(num) operator(=) ident(gets)operator(.)ident(chomp)
ident(exit) reserved(unless) reserved(defined?)operator(()ident(num)operator(\))
ident(num) operator(=) ident(num)operator(.)ident(oct) reserved(if) ident(num) operator(=)operator(~) regexp<delimiter(/)content(^0)delimiter(/)>  comment(# does both oct and hex)
ident(printf) string<delimiter(")content(%d %x %o)char(\\n)delimiter(")>operator(,) ident(num)operator(,) ident(num)operator(,) ident(num)

ident(print) string<delimiter(")content(Enter file permission in octal: )delimiter(")>
ident(permissions) operator(=) ident(gets)operator(.)ident(chomp)
ident(raise) string<delimiter(")content(Exiting ...)char(\\n)delimiter(")> reserved(unless) reserved(defined?)operator(()ident(permissions)operator(\))
ident(puts) string<delimiter(")content(The decimal value is )inline<delimiter(#{)ident(permissions)operator(.)ident(oct)delimiter(})>delimiter(")>


comment(# @@PLEAC@@_2.17)
reserved(def) method(commify)operator(()ident(n)operator(\))
    ident(n)operator(.)ident(to_s) operator(=)operator(~) regexp<delimiter(/)content(([^)char(\\.)content(]*\)()char(\\.)content(.*\)?)delimiter(/)>
    ident(int)operator(,) ident(dec) operator(=) global_variable($1)operator(.)ident(reverse)operator(,) global_variable($2) operator(?) global_variable($2) operator(:) string<delimiter(")delimiter(")>
    reserved(while) ident(int)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content((,|)char(\\.)content(|^\)()char(\\d)content({3}\)()char(\\d)content(\))delimiter(/)>operator(,) string<delimiter(')content(\\1)content(\\2)content(,)content(\\3)delimiter(')>operator(\))
    reserved(end)
    ident(int)operator(.)ident(reverse) operator(+) ident(dec)
reserved(end)


comment(# @@PLEAC@@_2.18)
ident(printf) string<delimiter(")content(It took %d hour%s)char(\\n)delimiter(")>operator(,) ident(time)operator(,) ident(time) operator(==) integer(1) operator(?) string<delimiter(")delimiter(")> operator(:) string<delimiter(")content(s)delimiter(")>

comment(# dunno if an equivalent to Lingua::EN::Inflect exists...)


comment(# @@PLEAC@@_2.19)
comment(#-----------------------------)
comment(#!/usr/bin/ruby)
comment(# bigfact - calculating prime factors)
reserved(def) method(factorize)operator(()ident(orig)operator(\))
    ident(factors) operator(=) operator({)operator(})
    ident(factors)operator(.)ident(default) operator(=) integer(0)     comment(# return 0 instead nil if key not found in hash)
    ident(n) operator(=) ident(orig)
    ident(i) operator(=) integer(2)
    ident(sqi) operator(=) integer(4)                 comment(# square of i)
    reserved(while) ident(sqi) operator(<=) ident(n) reserved(do)
        reserved(while) ident(n)operator(.)ident(modulo)operator(()ident(i)operator(\)) operator(==) integer(0) reserved(do)
            ident(n) regexp<delimiter(/)content(= i
            factors[i] += 1
            # puts "Found factor )inline<delimiter(#{)ident(i)delimiter(})>content("
        end
        # we take advantage of the fact that (i +1\)**2 = i**2 + 2*i +1
        sqi += 2 * i + 1
        i += 1
    end

    if (n != 1\) && (n != orig\)
        factors[n] += 1
    end
    factors
end

def printfactorhash(orig, factorcount\)
    print format("%-10d ", orig\)
    if factorcount.length == 0
        print "PRIME"
    else
        # sorts after number, because the hash keys are numbers
        factorcount.sort.each { |factor,exponent|
            print factor
            if exponent > 1
                print "**", exponent
            end
            print " "
        }
    end
    puts
end

for arg in ARGV
    n = arg.to_i
    mfactors = factorize(n\)
    printfactorhash(n, mfactors\)
end
#-----------------------------


# @@PLEAC@@_3.0
puts Time.now

print "Today is day ", Time.now.yday, " of the current year.)char(\\n)content("
print "Today is day ", Time.now.day, " of the current month.)char(\\n)content("


# @@PLEAC@@_3.1
day, month, year = Time.now.day, Time.now.month, Time.now.year
# or
day, month, year = Time.now.to_a[3..5]

tl = Time.now.localtime
printf("The current date is %04d %02d %02d)char(\\n)content(", tl.year, tl.month, tl.day\)

Time.now.localtime.strftime("%Y-%m-%d"\)


# @@PLEAC@@_3.2
Time.local(year, month, day, hour, minute, second\).tv_sec
Time.gm(year, month, day, hour, minute, second\).tv_sec


# @@PLEAC@@_3.3
sec, min, hour, day, month, year, wday, yday, isdst, zone = Time.at(epoch_secs\).to_a


# @@PLEAC@@_3.4
when_ = now + difference         # now -> Time ; difference -> Numeric (delta in seconds\)
then_ = now - difference


# @@PLEAC@@_3.5
bree = 361535725
nat  =  96201950

difference = bree - nat
puts "There were )inline<delimiter(#{)ident(difference)delimiter(})>content( seconds between Nat and Bree"

seconds    =  difference % 60
difference = (difference - seconds\) )delimiter(/)> integer(60)
ident(minutes)    operator(=)  ident(difference) operator(%) integer(60)
ident(difference) operator(=) operator(()ident(difference) operator(-) ident(minutes)operator(\)) operator(/) integer(60)
ident(hours)      operator(=)  ident(difference) operator(%) integer(24)
ident(difference) operator(=) operator(()ident(difference) operator(-) ident(hours)operator(\))   operator(/) integer(24)
ident(days)       operator(=)  ident(difference) operator(%) integer(7)
ident(weeks)      operator(=) operator(()ident(difference) operator(-) ident(days)operator(\))    operator(/)  integer(7)

ident(puts) string<delimiter(")content(()inline<delimiter(#{)ident(weeks)delimiter(})>content( weeks, )inline<delimiter(#{)ident(days)delimiter(})>content( days, )inline<delimiter(#{)ident(hours)delimiter(})>content(:)inline<delimiter(#{)ident(minutes)delimiter(})>content(:)inline<delimiter(#{)ident(seconds)delimiter(})>content(\))delimiter(")>


comment(# @@PLEAC@@_3.6)
ident(monthday)operator(,) ident(weekday)operator(,) ident(yearday) operator(=) ident(date)operator(.)ident(mday)operator(,) ident(date)operator(.)ident(wday)operator(,) ident(date)operator(.)ident(yday)

comment(# AFAIK the week number is not just a division since week boundaries are on sundays)
ident(weeknum) operator(=) ident(d)operator(.)ident(strftime)operator(()string<delimiter(")content(%U)delimiter(")>operator(\))operator(.)ident(to_i) operator(+) integer(1)

ident(year)  operator(=) integer(1981)
ident(month) operator(=) string<delimiter(")content(jun)delimiter(")>                     comment(# or `6' if you want to emulate a broken language)
ident(day)   operator(=) integer(16)
ident(t) operator(=) constant(Time)operator(.)ident(mktime)operator(()ident(year)operator(,) ident(month)operator(,) ident(day)operator(\))
ident(print) string<delimiter(")inline<delimiter(#{)ident(month)delimiter(})>content(/)inline<delimiter(#{)ident(day)delimiter(})>content(/)inline<delimiter(#{)ident(year)delimiter(})>content( was a )delimiter(")>operator(,) ident(t)operator(.)ident(strftime)operator(()string<delimiter(")content(%A)delimiter(")>operator(\))operator(,) string<delimiter(")char(\\n)delimiter(")>


comment(# @@PLEAC@@_3.7)
ident(yyyy)operator(,) ident(mm)operator(,) ident(dd) operator(=) global_variable($1)operator(,) global_variable($2)operator(,) global_variable($3) reserved(if) string<delimiter(")content(1998-06-25)delimiter(")> operator(=)operator(~) regexp<delimiter(/)content(()char(\\d)content(+\)-()char(\\d)content(+\)-()char(\\d)content(+\))delimiter(/)>

ident(epoch_seconds) operator(=) constant(Time)operator(.)ident(mktime)operator(()ident(yyyy)operator(,) ident(mm)operator(,) ident(dd)operator(\))operator(.)ident(tv_sec)

comment(# dunno an equivalent to Date::Manip#ParseDate)


comment(# @@PLEAC@@_3.8)
ident(string) operator(=) constant(Time)operator(.)ident(at)operator(()ident(epoch_secs)operator(\))
constant(Time)operator(.)ident(at)operator(()integer(1234567890)operator(\))operator(.)ident(gmtime)        comment(# gives: Fri Feb 13 23:31:30 UTC 2009)

ident(time) operator(=) constant(Time)operator(.)ident(mktime)operator(()integer(1973)operator(,) string<delimiter(")content(jan)delimiter(")>operator(,) integer(18)operator(,) integer(3)operator(,) integer(45)operator(,) integer(50)operator(\))
ident(print) string<delimiter(")content(In localtime it gives: )delimiter(")>operator(,) ident(time)operator(.)ident(localtime)operator(,) string<delimiter(")char(\\n)delimiter(")>


comment(# @@PLEAC@@_3.9)
comment(# Ruby provides micro-seconds in Time object)
constant(Time)operator(.)ident(now)operator(.)ident(usec)

comment(# Ruby gives the seconds in floating format when substracting two Time objects)
ident(before) operator(=) constant(Time)operator(.)ident(now)
ident(line) operator(=) ident(gets)
ident(elapsed) operator(=) constant(Time)operator(.)ident(now) operator(-) ident(before)
ident(puts) string<delimiter(")content(You took )inline<delimiter(#{)ident(elapsed)delimiter(})>content( seconds.)delimiter(")>

comment(# On my Celeron-400 with Linux-2.2.19-14mdk, average for three execs are:)
comment(#   This Ruby version:       average 0.00321 sec)
comment(#   Cookbook's Perl version: average 0.00981 sec)
ident(size) operator(=) integer(500)
ident(number_of_times) operator(=) integer(100)
ident(total_time) operator(=) integer(0)
ident(number_of_times)operator(.)ident(times) operator({)
    comment(# populate array)
    ident(array) operator(=) operator([)operator(])
    ident(size)operator(.)ident(times) operator({) ident(array) operator(<<) ident(rand) operator(})
    comment(# sort it)
    ident(begin_) operator(=) constant(Time)operator(.)ident(now)
    ident(array)operator(.)ident(sort!)
    ident(time) operator(=) constant(Time)operator(.)ident(now) operator(-) ident(begin_)
    ident(total_time) operator(+=) ident(time)
operator(})
ident(printf) string<delimiter(")content(On average, sorting %d random numbers takes %.5f seconds)char(\\n)delimiter(")>operator(,)
    ident(size)operator(,) operator(()ident(total_time)operator(/)constant(Float)operator(()ident(number_of_times)operator(\))operator(\))


comment(# @@PLEAC@@_3.10)
ident(sleep)operator(()float(0.005)operator(\))                      comment(# Ruby is definitely not as broken as Perl :\))
comment(# (may be interrupted by sending the process a SIGALRM\))


comment(# @@PLEAC@@_3.11)
comment(#!/usr/bin/ruby -w)
comment(# hopdelta - feed mail header, produce lines)
comment(#            showing delay at each hop.)
ident(require) string<delimiter(')content(time)delimiter(')>
reserved(class) class(MailHopDelta)

    reserved(def) method(initialize)operator(()ident(mail)operator(\))
        instance_variable(@head) operator(=) ident(mail)operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\n)char(\\s)content(+)delimiter(/)>operator(,)string<delimiter(')content( )delimiter(')>operator(\))
        instance_variable(@topline) operator(=) string<delimiter(%w-)content(Sender Recipient Time Delta)delimiter(-)>
        instance_variable(@start_from) operator(=) ident(mail)operator(.)ident(match)operator(()regexp<delimiter(/)content(^From.*)char(\\@)content(([^)char(\\s)content(>]*\))delimiter(/)>operator(\))operator([)integer(1)operator(])
        instance_variable(@date) operator(=) constant(Time)operator(.)ident(parse)operator(()ident(mail)operator(.)ident(match)operator(()regexp<delimiter(/)content(^Date:)char(\\s)content(+(.*\))delimiter(/)>operator(\))operator([)integer(1)operator(])operator(\))
    reserved(end)

    reserved(def) method(out)operator(()ident(line)operator(\))
         string<delimiter(")content(%-20.20s %-20.20s %-20.20s  %s)delimiter(")> operator(%) ident(line)
    reserved(end)

    reserved(def) method(hop_date)operator(()ident(day)operator(\))
        ident(day)operator(.)ident(strftime)operator(()string<delimiter(")content(%I:%M:%S %Y/%m/%d)delimiter(")>operator(\))
    reserved(end)

    reserved(def) method(puts_hops)
        ident(puts) ident(out)operator(()instance_variable(@topline)operator(\))
        ident(puts) ident(out)operator(()operator([)string<delimiter(')content(Start)delimiter(')>operator(,) instance_variable(@start_from)operator(,) ident(hop_date)operator(()instance_variable(@date)operator(\))operator(,)string<delimiter(')delimiter(')>operator(])operator(\))
        instance_variable(@head)operator(.)ident(split)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))operator(.)ident(reverse)operator(.)ident(grep)operator(()regexp<delimiter(/)content(^Received:)delimiter(/)>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(hop)operator(|)
            ident(hop)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\b)content(on (.*?\) (id.*\))delimiter(/)>operator(,)string<delimiter(')content(; )content(\\1)delimiter(')>operator(\))
            ident(whence) operator(=) ident(hop)operator(.)ident(match)operator(()regexp<delimiter(/)content(;)char(\\s)content(+(.*\)$)delimiter(/)>operator(\))operator([)integer(1)operator(])
            reserved(unless) ident(whence)
                ident(warn) string<delimiter(")content(Bad received line: )inline<delimiter(#{)ident(hop)delimiter(})>delimiter(")>
                reserved(next)
            reserved(end)
            ident(from) operator(=) global_variable($+) reserved(if) ident(hop) operator(=)operator(~) regexp<delimiter(/)content(from)char(\\s)content(+()char(\\S)content(+\)|)char(\\()content((.*?\))char(\\\))delimiter(/)>
            ident(by)   operator(=) global_variable($1) reserved(if) ident(hop) operator(=)operator(~) regexp<delimiter(/)content(by)char(\\s)content(+()char(\\S)content(+)char(\\.)char(\\S)content(+\))delimiter(/)>
            reserved(next) reserved(unless) ident(now) operator(=) constant(Time)operator(.)ident(parse)operator(()ident(whence)operator(\))operator(.)ident(localtime)
            ident(delta) operator(=) ident(now) operator(-) instance_variable(@date)
            ident(puts) ident(out)operator(()operator([)ident(from)operator(,) ident(by)operator(,) ident(hop_date)operator(()ident(now)operator(\))operator(,) ident(hop_time)operator(()ident(delta)operator(\))operator(])operator(\))
            instance_variable(@date) operator(=) ident(now)
        reserved(end)
    reserved(end)

    reserved(def) method(hop_time)operator(()ident(secs)operator(\))
        ident(sign) operator(=) ident(secs) operator(<) integer(0) operator(?) operator(-)integer(1) operator(:) integer(1)
        ident(days)operator(,) ident(secs) operator(=) ident(secs)operator(.)ident(abs)operator(.)ident(divmod)operator(()integer(60) operator(*) integer(60) operator(*) integer(24)operator(\))
        ident(hours)operator(,)ident(secs) operator(=) ident(secs)operator(.)ident(abs)operator(.)ident(divmod)operator(()integer(60) operator(*) integer(60)operator(\))
        ident(mins)operator(,) ident(secs) operator(=) ident(secs)operator(.)ident(abs)operator(.)ident(divmod)operator(()integer(60)operator(\))
        ident(rtn) operator(=)  string<delimiter(")content(%3ds)delimiter(")> operator(%) operator([)ident(secs)  operator(*) ident(sign)operator(])
        ident(rtn) operator(<<) string<delimiter(")content(%3dm)delimiter(")> operator(%) operator([)ident(mins)  operator(*) ident(sign)operator(]) reserved(if) ident(mins)  operator(!=) integer(0)
        ident(rtn) operator(<<) string<delimiter(")content(%3dh)delimiter(")> operator(%) operator([)ident(hours) operator(*) ident(sign)operator(]) reserved(if) ident(hours) operator(!=) integer(0)
        ident(rtn) operator(<<) string<delimiter(")content(%3dd)delimiter(")> operator(%) operator([)ident(days)  operator(*) ident(sign)operator(]) reserved(if) ident(days)  operator(!=) integer(0)
        ident(rtn)
    reserved(end)
reserved(end)

global_variable($/) operator(=) string<delimiter(")delimiter(")>
ident(mail) operator(=) constant(MailHopDelta)operator(.)ident(new)operator(()pre_constant(ARGF)operator(.)ident(gets)operator(\))operator(.)ident(puts_hops)


comment(# @@PLEAC@@_4.0)
ident(single_level) operator(=) operator([) string<delimiter(")content(this)delimiter(")>operator(,) string<delimiter(")content(that)delimiter(")>operator(,) string<delimiter(")content(the)delimiter(")>operator(,) string<delimiter(")content(other)delimiter(")> operator(])

comment(# Ruby directly supports nested arrays)
ident(double_level) operator(=) operator([) string<delimiter(")content(this)delimiter(")>operator(,) string<delimiter(")content(that)delimiter(")>operator(,) operator([) string<delimiter(")content(the)delimiter(")>operator(,) string<delimiter(")content(other)delimiter(")> operator(]) operator(])
ident(still_single_level) operator(=) operator([) string<delimiter(")content(this)delimiter(")>operator(,) string<delimiter(")content(that)delimiter(")>operator(,) operator([) string<delimiter(")content(the)delimiter(")>operator(,) string<delimiter(")content(other)delimiter(")> operator(]) operator(])operator(.)ident(flatten)


comment(# @@PLEAC@@_4.1)
ident(a) operator(=) operator([) string<delimiter(")content(quick)delimiter(")>operator(,) string<delimiter(")content(brown)delimiter(")>operator(,) string<delimiter(")content(fox)delimiter(")> operator(])
ident(a) operator(=) string<delimiter(%w()content(Why are you teasing me?)delimiter(\))>

ident(lines) operator(=) string<delimiter(<<"END_OF_HERE_DOC")>operator(.)ident(gsub)operator(()regexp<delimiter(/)content(^)char(\\s)content(*(.+\))delimiter(/)>operator(,) string<delimiter(')content(\\1)delimiter(')>operator(\))string<content(
    The boy stood on the burning deck,
    It was as hot as glass.)delimiter(
END_OF_HERE_DOC)>

ident(bigarray) operator(=) constant(IO)operator(.)ident(readlines)operator(()string<delimiter(")content(mydatafile)delimiter(")>operator(\))operator(.)ident(collect) operator({) operator(|)ident(l)operator(|) ident(l)operator(.)ident(chomp) operator(})

ident(name) operator(=) string<delimiter(")content(Gandalf)delimiter(")>
ident(banner) operator(=) string<delimiter(%Q()content(Speak, )inline<delimiter(#{)ident(name)delimiter(})>content(, and welcome!)delimiter(\))>

ident(host_info)  operator(=) shell<delimiter(`)content(host )inline<delimiter(#{)ident(his_host)delimiter(})>delimiter(`)>

shell<delimiter(%x()content(ps )inline<delimiter(#{)global_variable($$)delimiter(})>delimiter(\))>

ident(banner) operator(=) string<delimiter(')content(Costs only $4.95)delimiter(')>operator(.)ident(split)operator(()string<delimiter(')content( )delimiter(')>operator(\))

ident(rax) operator(=) string<delimiter(%w!)content( ( \) < > { } [ ] )delimiter(!)>


comment(# @@PLEAC@@_4.2)
reserved(def) method(commify_series)operator(()ident(a)operator(\))
    ident(a)operator(.)ident(size) operator(==) integer(0) operator(?) string<delimiter(')delimiter(')> operator(:)
        ident(a)operator(.)ident(size) operator(==) integer(1) operator(?) ident(a)operator([)integer(0)operator(]) operator(:)
        ident(a)operator(.)ident(size) operator(==) integer(2) operator(?) ident(a)operator(.)ident(join)operator(()string<delimiter(')content( and )delimiter(')>operator(\)) operator(:)
        ident(a)operator([)integer(0)operator(..)operator(-)integer(2)operator(])operator(.)ident(join)operator(()string<delimiter(')content(, )delimiter(')>operator(\)) operator(+) string<delimiter(')content(, and )delimiter(')> operator(+) ident(a)operator([)operator(-)integer(1)operator(])
reserved(end)

ident(array) operator(=) operator([) string<delimiter(")content(red)delimiter(")>operator(,) string<delimiter(")content(yellow)delimiter(")>operator(,) string<delimiter(")content(green)delimiter(")> operator(])

ident(print) string<delimiter(")content(I have )delimiter(")>operator(,) ident(array)operator(,) string<delimiter(")content( marbles)char(\\n)delimiter(")>
comment(# -> I have redyellowgreen marbles)

comment(# But unlike Perl:)
ident(print) string<delimiter(")content(I have )inline<delimiter(#{)ident(array)delimiter(})>content( marbles)char(\\n)delimiter(")>
comment(# -> I have redyellowgreen marbles)
comment(# So, needs:)
ident(print) string<delimiter(")content(I have )inline<delimiter(#{)ident(array)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>content( marbles)char(\\n)delimiter(")>
comment(# -> I have red yellow green marbles)

reserved(def) method(commify_series)operator(()ident(a)operator(\))
    ident(sepchar) operator(=) ident(a)operator(.)ident(select) operator({) operator(|)ident(p)operator(|) ident(p) operator(=)operator(~) regexp<delimiter(/)content(,)delimiter(/)> operator(}) operator(!=) operator([)operator(]) operator(?) string<delimiter(')content(; )delimiter(')> operator(:) string<delimiter(')content(, )delimiter(')>
    ident(a)operator(.)ident(size) operator(==) integer(0) operator(?) string<delimiter(')delimiter(')> operator(:)
        ident(a)operator(.)ident(size) operator(==) integer(1) operator(?) ident(a)operator([)integer(0)operator(]) operator(:)
        ident(a)operator(.)ident(size) operator(==) integer(2) operator(?) ident(a)operator(.)ident(join)operator(()string<delimiter(')content( and )delimiter(')>operator(\)) operator(:)
        ident(a)operator([)integer(0)operator(..)operator(-)integer(2)operator(])operator(.)ident(join)operator(()ident(sepchar)operator(\)) operator(+) ident(sepchar) operator(+) string<delimiter(')content(and )delimiter(')> operator(+) ident(a)operator([)operator(-)integer(1)operator(])
reserved(end)


comment(# @@PLEAC@@_4.3)
comment(#   (note: AFAIK Ruby doesn't allow gory change of Array length\))
comment(# grow the array by assigning nil to past the end of array)
ident(ary)operator([)ident(new_size)operator(-)integer(1)operator(]) operator(=) pre_constant(nil)
comment(# shrink the array by slicing it down)
ident(ary)operator(.)ident(slice!)operator(()ident(new_size)operator(..)operator(-)integer(1)operator(\))
comment(# init the array with given size)
constant(Array)operator(.)ident(new)operator(()ident(number_of_elems)operator(\))
comment(# assign to an element past the original end enlarges the array)
ident(ary)operator([)ident(index_new_last_elem)operator(]) operator(=) ident(value)

reserved(def) method(what_about_that_array)operator(()ident(a)operator(\))
    ident(print) string<delimiter(")content(The array now has )delimiter(")>operator(,) ident(a)operator(.)ident(size)operator(,) string<delimiter(")content( elements.)char(\\n)delimiter(")>
    comment(# Index of last element is not really interesting in Ruby)
    ident(print) string<delimiter(")content(Element #3 is `)inline<delimiter(#{)ident(a)operator([)integer(3)operator(])delimiter(})>content('.)char(\\n)delimiter(")>
reserved(end)
ident(people) operator(=) string<delimiter(%w()content(Crosby Stills Nash Young)delimiter(\))>
ident(what_about_that_array)operator(()ident(people)operator(\))


comment(# @@PLEAC@@_4.4)
comment(# OO style)
ident(bad_users)operator(.)ident(each) operator({) operator(|)ident(user)operator(|)
    ident(complain)operator(()ident(user)operator(\))
operator(})
comment(# or, functional style)
reserved(for) ident(user) reserved(in) ident(bad_users)
    ident(complain)operator(()ident(user)operator(\))
reserved(end)

reserved(for) ident(var) reserved(in) constant(ENV)operator(.)ident(keys)operator(.)ident(sort)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(var)delimiter(})>content(=)inline<delimiter(#{)constant(ENV)operator([)ident(var)operator(])delimiter(})>delimiter(")>
reserved(end)

reserved(for) ident(user) reserved(in) ident(all_users)
    ident(disk_space) operator(=) ident(get_usage)operator(()ident(user)operator(\))
    reserved(if) operator(()ident(disk_space) operator(>) constant(MAX_QUOTA)operator(\))
        ident(complain)operator(()ident(user)operator(\))
    reserved(end)
reserved(end)

reserved(for) ident(l) reserved(in) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(who)delimiter(")>operator(\))operator(.)ident(readlines)
    ident(print) ident(l) reserved(if) ident(l) operator(=)operator(~) regexp<delimiter(/)content(^gc)delimiter(/)>
reserved(end)

comment(# we can mimic the obfuscated Perl way)
reserved(while) ident(fh)operator(.)ident(gets)               comment(# $_ is set to the line just read)
    ident(chomp)                   comment(# $_ has a trailing \\n removed, if it had one)
    ident(split)operator(.)ident(each) operator({) operator(|)ident(w)operator(|)        comment(# $_ is split on whitespace)
                            comment(# but $_ is not set to each chunk as in Perl)
        ident(print) ident(w)operator(.)ident(reverse)
    operator(})
reserved(end)
comment(# ...or use a cleaner way)
reserved(for) ident(l) reserved(in) ident(fh)operator(.)ident(readlines)
    ident(l)operator(.)ident(chomp)operator(.)ident(split)operator(.)ident(each) operator({) operator(|)ident(w)operator(|) ident(print) ident(w)operator(.)ident(reverse) operator(})
reserved(end)

comment(# same drawback as in problem 1.4, we can't mutate a Numeric...)
ident(array)operator(.)ident(collect!) operator({) operator(|)ident(v)operator(|) ident(v) operator(-) integer(1) operator(})

ident(a) operator(=) operator([) operator(.)integer(5)operator(,) integer(3) operator(])operator(;) ident(b) operator(=) operator([) integer(0)operator(,) integer(1) operator(])
reserved(for) ident(ary) reserved(in) operator([) ident(a)operator(,) ident(b) operator(])
    ident(ary)operator(.)ident(collect!) operator({) operator(|)ident(v)operator(|) ident(v) operator(*) integer(7) operator(})
reserved(end)
ident(puts) string<delimiter(")inline<delimiter(#{)ident(a)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>content( )inline<delimiter(#{)ident(b)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>delimiter(")>

comment(# we can mutate Strings, cool; we need a trick for the scalar)
reserved(for) ident(ary) reserved(in) operator([) operator([) ident(scalar) operator(])operator(,) ident(array)operator(,) ident(hash)operator(.)ident(values) operator(])
    ident(ary)operator(.)ident(each) operator({) operator(|)ident(v)operator(|) ident(v)operator(.)ident(strip!) operator(})     comment(# String#strip rules :\))
reserved(end)


comment(# @@PLEAC@@_4.5)
comment(# not relevant in Ruby since we have always references)
reserved(for) ident(item) reserved(in) ident(array)
    comment(# do somethingh with item)
reserved(end)


comment(# @@PLEAC@@_4.6)
ident(unique) operator(=) ident(list)operator(.)ident(uniq)

comment(# generate a list of users logged in, removing duplicates)
ident(users) operator(=) shell<delimiter(`)content(who)delimiter(`)>operator(.)ident(collect) operator({) operator(|)ident(l)operator(|) ident(l) operator(=)operator(~) regexp<delimiter(/)content(()char(\\w)content(+\))delimiter(/)>operator(;) global_variable($1) operator(})operator(.)ident(sort)operator(.)ident(uniq)
ident(puts)operator(()string<delimiter(")content(users logged in: )inline<delimiter(#{)ident(commify_series)operator(()ident(users)operator(\))delimiter(})>delimiter(")>operator(\))  comment(# see 4.2 for commify_series)


comment(# @@PLEAC@@_4.7)
ident(a) operator(-) ident(b)
comment(# [ 1, 1, 2, 2, 3, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  ->  [3, 5])


comment(# @@PLEAC@@_4.8)
ident(union) operator(=) ident(a) operator(|) ident(b)
ident(intersection) operator(=) ident(a) operator(&) ident(b)
ident(difference) operator(=) ident(a) operator(-) ident(b)


comment(# @@PLEAC@@_4.9)
ident(array1)operator(.)ident(concat)operator(()ident(array2)operator(\))
comment(# if you will assign to another object, better use:)
ident(new_ary) operator(=) ident(array1) operator(+) ident(array2)

ident(members) operator(=) operator([) string<delimiter(")content(Time)delimiter(")>operator(,) string<delimiter(")content(Flies)delimiter(")> operator(])
ident(initiates) operator(=)  operator([) string<delimiter(")content(An)delimiter(")>operator(,) string<delimiter(")content(Arrow)delimiter(")> operator(])
ident(members) operator(+=) ident(initiates)

ident(members) operator(=) operator([) string<delimiter(")content(Time)delimiter(")>operator(,) string<delimiter(")content(Flies)delimiter(")> operator(])
ident(initiates) operator(=) operator([) string<delimiter(")content(An)delimiter(")>operator(,) string<delimiter(")content(Arrow)delimiter(")> operator(])
ident(members)operator([)integer(2)operator(,)integer(0)operator(]) operator(=) operator([) string<delimiter(")content(Like)delimiter(")>operator(,) ident(initiates) operator(])operator(.)ident(flatten)

ident(members)operator([)integer(0)operator(]) operator(=) string<delimiter(")content(Fruit)delimiter(")>
ident(members)operator([)integer(3)operator(,)integer(2)operator(]) operator(=) string<delimiter(")content(A)delimiter(")>operator(,) string<delimiter(")content(Banana)delimiter(")>


comment(# @@PLEAC@@_4.10)
ident(reversed) operator(=) ident(ary)operator(.)ident(reverse)

ident(ary)operator(.)ident(reverse_each) operator({) operator(|)ident(e)operator(|)
    comment(# do something with e)
operator(})

ident(descending) operator(=) ident(ary)operator(.)ident(sort)operator(.)ident(reverse)
ident(descending) operator(=) ident(ary)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(b) operator(<=>) ident(a) operator(})


comment(# @@PLEAC@@_4.11)
comment(# remove n elements from front of ary (shift n\))
ident(front) operator(=) ident(ary)operator(.)ident(slice!)operator(()integer(0)operator(,) ident(n)operator(\))

comment(# remove n elements from the end of ary (pop n\))
ident(end_) operator(=) ident(ary)operator(.)ident(slice!)operator(()operator(-)ident(n) operator(..) operator(-)integer(1)operator(\))

comment(# let's extend the Array class, to make that useful)
reserved(class) class(Array)
    reserved(def) method(shift2)operator(()operator(\))
        ident(slice!)operator(()integer(0) operator(..) integer(1)operator(\))     comment(# more symetric with pop2...)
    reserved(end)
    reserved(def) method(pop2)operator(()operator(\))
        ident(slice!)operator(()operator(-)integer(2) operator(..) operator(-)integer(1)operator(\))
    reserved(end)
reserved(end)

ident(friends) operator(=) string<delimiter(%w()content(Peter Paul Mary Jim Tim)delimiter(\))>
ident(this)operator(,) ident(that) operator(=) ident(friends)operator(.)ident(shift2)

ident(beverages) operator(=) string<delimiter(%w()content(Dew Jolt Cola Sprite Fresca)delimiter(\))>
ident(pair) operator(=) ident(beverages)operator(.)ident(pop2)


comment(# @@PLEAC@@_4.12)
comment(# use Enumerable#detect (or the synonym Enumerable#find\))
ident(highest_eng) operator(=) ident(employees)operator(.)ident(detect) operator({) operator(|)ident(emp)operator(|) ident(emp)operator(.)ident(category) operator(==) string<delimiter(')content(engineer)delimiter(')> operator(})


comment(# @@PLEAC@@_4.13)
comment(# use Enumerable#select (or the synonym Enumerable#find_all\))
ident(bigs) operator(=) ident(nums)operator(.)ident(select) operator({) operator(|)ident(i)operator(|) ident(i) operator(>) integer(1_000_000) operator(})
ident(pigs) operator(=) ident(users)operator(.)ident(keys)operator(.)ident(select) operator({) operator(|)ident(k)operator(|) ident(users)operator([)ident(k)operator(]) operator(>) float(1e7) operator(})

ident(matching) operator(=) shell<delimiter(`)content(who)delimiter(`)>operator(.)ident(select) operator({) operator(|)ident(u)operator(|) ident(u) operator(=)operator(~) regexp<delimiter(/)content(^gnat )delimiter(/)> operator(})

ident(engineers) operator(=) ident(employees)operator(.)ident(select) operator({) operator(|)ident(e)operator(|) ident(e)operator(.)ident(position) operator(==) string<delimiter(')content(Engineer)delimiter(')> operator(})

ident(secondary_assistance) operator(=) ident(applicants)operator(.)ident(select) operator({) operator(|)ident(a)operator(|)
    ident(a)operator(.)ident(income) operator(>)operator(=) integer(26_000) operator(&&) ident(a)operator(.)ident(income) operator(<) integer(30_000)
operator(})


comment(# @@PLEAC@@_4.14)
comment(# normally you would have an array of Numeric (Float or)
comment(# Fixnum or Bignum\), so you would use:)
ident(sorted) operator(=) ident(unsorted)operator(.)ident(sort)
comment(# if you have strings representing Integers or Floats)
comment(# you may specify another sort method:)
ident(sorted) operator(=) ident(unsorted)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator(.)ident(to_f) operator(<=>) ident(b)operator(.)ident(to_f) operator(})

comment(# let's use the list of my own PID's)
shell<delimiter(`)content(ps ux)delimiter(`)>operator(.)ident(split)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))operator([)integer(1)operator(..)operator(-)integer(1)operator(])operator(.)
    ident(select) operator({) operator(|)ident(i)operator(|) ident(i) operator(=)operator(~) regexp<delimiter(/)content(^)inline<delimiter(#{)constant(ENV)operator([)string<delimiter(')content(USER)delimiter(')>operator(])delimiter(})>delimiter(/)> operator(})operator(.)
    ident(collect) operator({) operator(|)ident(i)operator(|) ident(i)operator(.)ident(split)operator([)integer(1)operator(]) operator(})operator(.)
    ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator(.)ident(to_i) operator(<=>) ident(b)operator(.)ident(to_i) operator(})operator(.)ident(each) operator({) operator(|)ident(i)operator(|) ident(puts) ident(i) operator(})
ident(puts) string<delimiter(")content(Select a process ID to kill:)delimiter(")>
ident(pid) operator(=) ident(gets)operator(.)ident(chomp)
ident(raise) string<delimiter(")content(Exiting ... )char(\\n)delimiter(")> reserved(unless) ident(pid) operator(&&) ident(pid) operator(=)operator(~) regexp<delimiter(/)content(^)char(\\d)content(+$)delimiter(/)>
constant(Process)operator(.)ident(kill)operator(()string<delimiter(')content(TERM)delimiter(')>operator(,) ident(pid)operator(.)ident(to_i)operator(\))
ident(sleep) integer(2)
constant(Process)operator(.)ident(kill)operator(()string<delimiter(')content(KILL)delimiter(')>operator(,) ident(pid)operator(.)ident(to_i)operator(\))

ident(descending) operator(=) ident(unsorted)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(b)operator(.)ident(to_f) operator(<=>) ident(a)operator(.)ident(to_f) operator(})


comment(# @@PLEAC@@_4.15)
ident(ordered) operator(=) ident(unordered)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(compare)operator(()ident(a)operator(,)ident(b)operator(\)) operator(})

ident(precomputed) operator(=) ident(unordered)operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) operator([)ident(compute)operator(,) ident(e)operator(]) operator(})
ident(ordered_precomputed) operator(=) ident(precomputed)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})
ident(ordered) operator(=) ident(ordered_precomputed)operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) ident(e)operator([)integer(1)operator(]) operator(})

ident(ordered) operator(=) ident(unordered)operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) operator([)ident(compute)operator(,) ident(e)operator(]) operator(})operator(.)
    ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})operator(.)
    ident(collect) operator({) operator(|)ident(e)operator(|) ident(e)operator([)integer(1)operator(]) operator(})

reserved(for) ident(employee) reserved(in) ident(employees)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator(.)ident(name) operator(<=>) ident(b)operator(.)ident(name) operator(})
    ident(print) ident(employee)operator(.)ident(name)operator(,) string<delimiter(")content( earns )char(\\$)content( )delimiter(")>operator(,) ident(employee)operator(.)ident(salary)operator(,) string<delimiter(")char(\\n)delimiter(")>
reserved(end)

comment(# Beware! `0' is true in Ruby.)
comment(# For chaining comparisons, you may use Numeric#nonzero?, which)
comment(# returns num if num is not zero, nil otherwise)
ident(sorted) operator(=) ident(employees)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) operator(()ident(a)operator(.)ident(name) operator(<=>) ident(b)operator(.)ident(name)operator(\))operator(.)ident(nonzero?) operator(||) ident(b)operator(.)ident(age) operator(<=>) ident(a)operator(.)ident(age) operator(})

ident(users) operator(=) operator([)operator(])
comment(# getpwent is not wrapped in Ruby... let's fallback)
constant(IO)operator(.)ident(readlines)operator(()string<delimiter(')content(/etc/passwd)delimiter(')>operator(\))operator(.)ident(each) operator({) operator(|)ident(u)operator(|) ident(users) operator(<<) ident(u)operator(.)ident(split)operator(()string<delimiter(')content(:)delimiter(')>operator(\)) operator(})
ident(users)operator(.)ident(sort!) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})
reserved(for) ident(user) reserved(in) ident(users)
    ident(puts) ident(user)operator([)integer(0)operator(])
reserved(end)

ident(sorted) operator(=) ident(names)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(1)operator(,) integer(1)operator(]) operator(<=>) ident(b)operator([)integer(1)operator(,) integer(1)operator(]) operator(})
ident(sorted) operator(=) ident(strings)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator(.)ident(length) operator(<=>) ident(b)operator(.)ident(length) operator(})

comment(# let's show only the compact version)
ident(ordered) operator(=) ident(strings)operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) operator([)ident(e)operator(.)ident(length)operator(,) ident(e)operator(]) operator(})operator(.)
    ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})operator(.)
    ident(collect) operator({) operator(|)ident(e)operator(|) ident(e)operator([)integer(1)operator(]) operator(})

ident(ordered) operator(=) ident(strings)operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) operator([)regexp<delimiter(/)char(\\d)content(+)delimiter(/)>operator(.)ident(match)operator(()ident(e)operator(\))operator([)integer(0)operator(])operator(.)ident(to_i)operator(,) ident(e)operator(]) operator(})operator(.)
    ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})operator(.)
    ident(collect) operator({) operator(|)ident(e)operator(|) ident(e)operator([)integer(1)operator(]) operator(})

ident(print) shell<delimiter(`)content(cat /etc/passwd)delimiter(`)>operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) operator([)ident(e)operator(,) ident(e)operator(.)ident(split)operator(()string<delimiter(')content(:)delimiter(')>operator(\))operator(.)ident(indexes)operator(()integer(3)operator(,)integer(2)operator(,)integer(0)operator(\))operator(])operator(.)ident(flatten) operator(})operator(.)
    ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) operator(()ident(a)operator([)integer(1)operator(]) operator(<=>) ident(b)operator([)integer(1)operator(])operator(\))operator(.)ident(nonzero?) operator(||) operator(()ident(a)operator([)integer(2)operator(]) operator(<=>) ident(b)operator([)integer(2)operator(])operator(\))operator(.)ident(nonzero?) operator(||) ident(a)operator([)integer(3)operator(]) operator(<=>) ident(b)operator([)integer(3)operator(]) operator(})operator(.)
    ident(collect) operator({) operator(|)ident(e)operator(|) ident(e)operator([)integer(0)operator(]) operator(})


comment(# @@PLEAC@@_4.16)
ident(circular)operator(.)ident(unshift)operator(()ident(circular)operator(.)ident(pop)operator(\))        comment(# the last shall be first)
ident(circular)operator(.)ident(push)operator(()ident(circular)operator(.)ident(shift)operator(\))         comment(# and vice versa)

reserved(def) method(grab_and_rotate)operator(()ident(l)operator(\))
    ident(l)operator(.)ident(push)operator(()ident(ret) operator(=) ident(l)operator(.)ident(shift)operator(\))
    ident(ret)
reserved(end)

ident(processes) operator(=) operator([)integer(1)operator(,) integer(2)operator(,) integer(3)operator(,) integer(4)operator(,) integer(5)operator(])
reserved(while) operator(()integer(1)operator(\))
    ident(process) operator(=) ident(grab_and_rotate)operator(()ident(processes)operator(\))
    ident(puts) string<delimiter(")content(Handling process )inline<delimiter(#{)ident(process)delimiter(})>delimiter(")>
    ident(sleep) integer(1)
reserved(end)


comment(# @@PLEAC@@_4.17)
reserved(def) method(fisher_yates_shuffle)operator(()ident(a)operator(\))
    operator(()ident(a)operator(.)ident(size)operator(-)integer(1)operator(\))operator(.)ident(downto)operator(()integer(1)operator(\)) operator({) operator(|)ident(i)operator(|)
        ident(j) operator(=) ident(rand)operator(()ident(i)operator(+)integer(1)operator(\))
        ident(a)operator([)ident(i)operator(])operator(,) ident(a)operator([)ident(j)operator(]) operator(=) ident(a)operator([)ident(j)operator(])operator(,) ident(a)operator([)ident(i)operator(]) reserved(if) ident(i) operator(!=) ident(j)
    operator(})
reserved(end)

reserved(def) method(naive_shuffle)operator(()ident(a)operator(\))
    reserved(for) ident(i) reserved(in) integer(0)operator(...)ident(a)operator(.)ident(size)
        ident(j) operator(=) ident(rand)operator(()ident(a)operator(.)ident(size)operator(\))
        ident(a)operator([)ident(i)operator(])operator(,) ident(a)operator([)ident(j)operator(]) operator(=) ident(a)operator([)ident(j)operator(])operator(,) ident(a)operator([)ident(i)operator(])
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_4.18)
comment(#!/usr/bin/env ruby)
comment(# example 4-2 words)
comment(# words - gather lines, present in colums)

comment(# class to encapsulate the word formatting from the input)
reserved(class) class(WordFormatter)
    reserved(def) method(initialize)operator(()ident(cols)operator(\))
        instance_variable(@cols) operator(=) ident(cols)
    reserved(end)

    comment(# helper to return the length of the longest word in the wordlist)
    reserved(def) method(maxlen)operator(()ident(wordlist)operator(\))
        ident(max) operator(=) integer(1)
        reserved(for) ident(word) reserved(in) ident(wordlist)
            reserved(if) ident(word)operator(.)ident(length) operator(>) ident(max)
                ident(max) operator(=) ident(word)operator(.)ident(length)
            reserved(end)
        reserved(end)
        ident(max)
    reserved(end)

    comment(# process the wordlist and print it formmated into columns)
    reserved(def) method(output)operator(()ident(wordlist)operator(\))
        ident(collen) operator(=) ident(maxlen)operator(()ident(wordlist)operator(\)) operator(+) integer(1)
        ident(columns) operator(=) instance_variable(@cols) operator(/) ident(collen)
        ident(columns) operator(=) integer(1) reserved(if) ident(columns) operator(==) integer(0)
        ident(rows) operator(=) operator(()ident(wordlist)operator(.)ident(length) operator(+) ident(columns) operator(-) integer(1)operator(\)) operator(/) ident(columns)
        comment(# now process each item, picking out proper piece for this position)
        integer(0)operator(.)ident(upto)operator(()ident(rows) operator(*) ident(columns) operator(-) integer(1)operator(\)) operator({) operator(|)ident(item)operator(|)
            ident(target) operator(=) operator(()ident(item) operator(%) ident(columns)operator(\)) operator(*) ident(rows) operator(+) operator(()ident(item) operator(/) ident(columns)operator(\))
            ident(eol) operator(=) operator(()operator(()ident(item)operator(+)integer(1)operator(\)) operator(%) ident(columns) operator(==) integer(0)operator(\))
            ident(piece) operator(=) ident(wordlist)operator([)ident(target)operator(]) operator(||) string<delimiter(")delimiter(")>
            ident(piece) operator(=) ident(piece)operator(.)ident(ljust)operator(()ident(collen)operator(\)) reserved(unless) ident(eol)
            ident(print) ident(piece)
            ident(puts) reserved(if) ident(eol)
        operator(})
        comment(# no need to finish it up, because eol is always true for the last element)
    reserved(end)
reserved(end)

comment(# get nr of chars that fit in window or console, see PLEAC 15.4)
comment(# not portable -- linux only (?\))
reserved(def) method(getWinCharWidth)operator(()operator(\))
    ident(buf) operator(=) string<delimiter(")char(\\0)delimiter(")> operator(*) integer(8)
    global_variable($stdout)operator(.)ident(ioctl)operator(()integer(0x5413)operator(,) ident(buf)operator(\))
    ident(ws_row)operator(,) ident(ws_col)operator(,) ident(ws_xpixel)operator(,) ident(ws_ypixel) operator(=) ident(buf)operator(.)ident(unpack)operator(()string<delimiter(")content($4)delimiter(")>operator(\))
    ident(ws_col) operator(||) integer(80)
reserved(rescue)
    integer(80)
reserved(end)

comment(# main program)
ident(cols) operator(=) ident(getWinCharWidth)operator(()operator(\))
ident(formatter) operator(=) constant(WordFormatter)operator(.)ident(new)operator(()ident(cols)operator(\))
ident(words) operator(=) ident(readlines)operator(()operator(\))
ident(words)operator(.)ident(collect!) operator({) operator(|)ident(line)operator(|)
    ident(line)operator(.)ident(chomp)
operator(})
ident(formatter)operator(.)ident(output)operator(()ident(words)operator(\))


comment(# @@PLEAC@@_4.19)
comment(# In ruby, Fixnum's are automatically converted to Bignum's when)
comment(# needed, so there is no need for an extra module)
reserved(def) method(factorial)operator(()ident(n)operator(\))
    ident(s) operator(=) integer(1)
    reserved(while) ident(n) operator(>) integer(0)
        ident(s) operator(*=) ident(n)
        ident(n) operator(-=) integer(1)
    reserved(end)
    ident(s)
reserved(end)

ident(puts) ident(factorial)operator(()integer(500)operator(\))

comment(#---------------------------------------------------------)
comment(# Example 4-3. tsc-permute)
comment(# tsc_permute: permute each word of input)
reserved(def) method(permute)operator(()ident(items)operator(,) ident(perms)operator(\))
    reserved(unless) ident(items)operator(.)ident(length) operator(>) integer(0)
        ident(puts) ident(perms)operator(.)ident(join)operator(()string<delimiter(")content( )delimiter(")>operator(\))
    reserved(else)
        reserved(for) ident(i) reserved(in) ident(items)
            ident(newitems) operator(=) ident(items)operator(.)ident(dup)
            ident(newperms) operator(=) ident(perms)operator(.)ident(dup)
            ident(newperms)operator(.)ident(unshift)operator(()ident(newitems)operator(.)ident(delete)operator(()ident(i)operator(\))operator(\))
            ident(permute)operator(()ident(newitems)operator(,) ident(newperms)operator(\))
        reserved(end)
    reserved(end)
reserved(end)
comment(# In ruby the main program must be after all definitions it is using)
ident(permute)operator(()pre_constant(ARGV)operator(,) operator([)operator(])operator(\))

comment(#---------------------------------------------------------)
comment(# mjd_permute: permute each word of input)

reserved(def) method(factorial)operator(()ident(n)operator(\))
    ident(s) operator(=) integer(1)
    reserved(while) ident(n) operator(>) integer(0)
        ident(s) operator(*=) ident(n)
        ident(n) operator(-=) integer(1)
    reserved(end)
    ident(s)
reserved(end)

comment(# we use a class with a class variable store the private cache)
comment(# for the results of the factorial function.)
reserved(class) class(Factorial)
    class_variable(@@fact) operator(=) operator([) integer(1) operator(])
    reserved(def) constant(Factorial)operator(.)ident(compute)operator(()ident(n)operator(\))
        reserved(if) class_variable(@@fact)operator([)ident(n)operator(])
            class_variable(@@fact)operator([)ident(n)operator(])
        reserved(else)
            class_variable(@@fact)operator([)ident(n)operator(]) operator(=) ident(n) operator(*) constant(Factorial)operator(.)ident(compute)operator(()ident(n) operator(-) integer(1)operator(\))
        reserved(end)
    reserved(end)
reserved(end)

comment(#---------------------------------------------------------)
comment(# Example 4-4- mjd-permute)
comment(# n2pat(n, len\): produce the N-th pattern of length len)

comment(# We must use a lower case letter as parameter N, otherwise it is)
comment(# handled as constant Length is the length of the resulting)
comment(# array, not the index of the last element (length -1\) like in)
comment(# the perl example.)
reserved(def) method(n2pat)operator(()ident(n)operator(,) ident(length)operator(\))
    ident(pat) operator(=) operator([)operator(])
    ident(i) operator(=) integer(1)
    reserved(while) ident(i) operator(<=) ident(length)
        ident(pat)operator(.)ident(push)operator(()ident(n) operator(%) ident(i)operator(\))
        ident(n) regexp<delimiter(/)content(= i
        i += 1
    end
    pat
end

# pat2perm(pat\): turn pattern returned by n2pat(\) into
# permutation of integers.
def pat2perm(pat\)
    source = (0 .. pat.length - 1\).to_a
    perm = []
    perm.push(source.slice!(pat.pop\)\) while pat.length > 0
    perm
end

def n2perm(n, len\)
    pat2perm(n2pat(n,len\)\)
end

# In ruby the main program must be after all definitions
while gets
    data = split
    # the perl solution has used $#data, which is length-1
    num_permutations = Factorial.compute(data.length(\)\)
    0.upto(num_permutations - 1\) do |i|
        # in ruby we can not use an array as selector for an array
        # but by exchanging the two arrays, we can use the collect method
        # which returns an array with the result of all block invocations
        permutation = n2perm(i, data.length\).collect {
            |j| data[j]
        }
        puts permutation.join(" "\)
    end
end


# @@PLEAC@@_5.0
age = { "Nat",   24,
        "Jules", 25,
        "Josh",  17  }

age["Nat"]   = 24
age["Jules"] = 25
age["Josh"]  = 17

food_color = {
    "Apple"  => "red",
    "Banana" => "yellow",
    "Lemon"  => "yellow",
    "Carrot" => "orange"
             }

# In Ruby, you cannot avoid the double or simple quoting
# while manipulatin hashes


# @@PLEAC@@_5.1
hash[key] = value

food_color["Raspberry"] = "pink"
puts "Known foods:", food_color.keys


# @@PLEAC@@_5.2
# does hash have a value for key ?
if (hash.has_key?(key\)\)
    # it exists
else
    # it doesn't
end

[ "Banana", "Martini" ].each { |name|
    print name, " is a ", food_color.has_key?(name\) ? "food" : "drink", ")char(\\n)content("
}

age = {}
age['Toddler'] = 3
age['Unborn'] = 0
age['Phantasm'] = nil

for thing in ['Toddler', 'Unborn', 'Phantasm', 'Relic']
    print ")inline<delimiter(#{)ident(thing)delimiter(})>content(: "
    print "Has-key " if age.has_key?(thing\)
    print "True " if age[thing]
    print "Nonzero " if age[thing] && age[thing].nonzero?
    print ")char(\\n)content("
end

#=>
# Toddler: Has-key True Nonzero
# Unborn: Has-key True
# Phantasm: Has-key
# Relic:

# You use Hash#has_key? when you use Perl's exists -> it checks
# for existence of a key in a hash.
# All Numeric are "True" in ruby, so the test doesn't have the
# same semantics as in Perl; you would use Numeric#nonzero? to
# achieve the same semantics (false if 0, true otherwise\).


# @@PLEAC@@_5.3
food_color.delete("Banana"\)


# @@PLEAC@@_5.4
hash.each { |key, value|
    # do something with key and value
}

hash.each_key { |key|
    # do something with key
}

food_color.each { |food, color|
    puts ")inline<delimiter(#{)ident(food)delimiter(})>content( is )inline<delimiter(#{)ident(color)delimiter(})>content("
}

food_color.each_key { |food|
    puts ")inline<delimiter(#{)ident(food)delimiter(})>content( is )inline<delimiter(#{)ident(food_color)operator([)ident(food)operator(])delimiter(})>content("
}

# IMO this demonstrates that OO style is by far more readable
food_color.keys.sort.each { |food|
    puts ")inline<delimiter(#{)ident(food)delimiter(})>content( is )inline<delimiter(#{)ident(food_color)operator([)ident(food)operator(])delimiter(})>content(."
}

#-----------------------------
#!)delimiter(/)modifier(us)>ident(r)operator(/)ident(bin)operator(/)ident(ruby)
comment(# countfrom - count number of messages from each sender)

comment(# Default value is 0)
ident(from) operator(=) constant(Hash)operator(.)ident(new)operator(()integer(0)operator(\))
reserved(while) ident(gets)
    regexp<delimiter(/)content(^From: (.*\))delimiter(/)> reserved(and) ident(from)operator([)global_variable($1)operator(]) operator(+=) integer(1)
reserved(end)

comment(# More useful to sort by number of received mail by person)
ident(from)operator(.)ident(sort) operator({)operator(|)ident(a)operator(,)ident(b)operator(|) ident(b)operator([)integer(1)operator(])operator(<=>)ident(a)operator([)integer(1)operator(])operator(})operator(.)ident(each) operator({) operator(|)ident(v)operator(|)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(v)operator([)integer(1)operator(])delimiter(})>content(: )inline<delimiter(#{)ident(v)operator([)integer(0)operator(])delimiter(})>delimiter(")>
operator(})
comment(#-----------------------------)


comment(# @@PLEAC@@_5.5)
comment(# You may use the built-in 'inspect' method this way:)
ident(p) ident(hash)

comment(# Or do it the Cookbook way:)
ident(hash)operator(.)ident(each) operator({) operator(|)ident(k)operator(,)ident(v)operator(|) ident(puts) string<delimiter(")inline<delimiter(#{)ident(k)delimiter(})>content( => )inline<delimiter(#{)ident(v)delimiter(})>delimiter(")> operator(})

comment(# Sorted by keys)
ident(hash)operator(.)ident(sort)operator(.)ident(each) operator({) operator(|)ident(e)operator(|) ident(puts) string<delimiter(")inline<delimiter(#{)ident(e)operator([)integer(0)operator(])delimiter(})>content( => )inline<delimiter(#{)ident(e)operator([)integer(1)operator(])delimiter(})>delimiter(")> operator(})
comment(# Sorted by values)
ident(hash)operator(.)ident(sort)operator({)operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(1)operator(])operator(<=>)ident(b)operator([)integer(1)operator(])operator(})operator(.)ident(each) operator({) operator(|)ident(e)operator(|) ident(puts) string<delimiter(")inline<delimiter(#{)ident(e)operator([)integer(0)operator(])delimiter(})>content( => )inline<delimiter(#{)ident(e)operator([)integer(1)operator(])delimiter(})>delimiter(")> operator(})


comment(# @@PLEAC@@_5.7)
ident(ttys) operator(=) constant(Hash)operator(.)ident(new)
reserved(for) ident(i) reserved(in) shell<delimiter(`)content(who)delimiter(`)>
    ident(user)operator(,) ident(tty) operator(=) ident(i)operator(.)ident(split)
    operator(()ident(ttys)operator([)ident(user)operator(]) operator(||=) operator([)operator(])operator(\)) operator(<<) ident(tty)               comment(# see problems_ruby for more infos)
reserved(end)
ident(ttys)operator(.)ident(keys)operator(.)ident(sort)operator(.)ident(each) operator({) operator(|)ident(k)operator(|)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(k)delimiter(})>content(: )inline<delimiter(#{)ident(commify_series)operator(()ident(ttys)operator([)ident(k)operator(])operator(\))delimiter(})>delimiter(")>  comment(# from 4.2)
operator(})


comment(# @@PLEAC@@_5.8)
ident(surname) operator(=) operator({) string<delimiter(")content(Mickey)delimiter(")> operator(=)operator(>) string<delimiter(")content(Mantle)delimiter(")>operator(,) string<delimiter(")content(Babe)delimiter(")> operator(=)operator(>) string<delimiter(")content(Ruth)delimiter(")> operator(})
ident(puts) ident(surname)operator(.)ident(index)operator(()string<delimiter(")content(Mantle)delimiter(")>operator(\))

comment(# If you really needed to 'invert' the whole hash, use Hash#invert)

comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# foodfind - find match for food or color)

ident(given) operator(=) pre_constant(ARGV)operator(.)ident(shift) reserved(or) ident(raise) string<delimiter(")content(usage: foodfind food_or_color)delimiter(")>

ident(color) operator(=) operator({)
    string<delimiter(")content(Apple)delimiter(")>  operator(=)operator(>) string<delimiter(")content(red)delimiter(")>operator(,)
    string<delimiter(")content(Banana)delimiter(")> operator(=)operator(>) string<delimiter(")content(yellow)delimiter(")>operator(,)
    string<delimiter(")content(Lemon)delimiter(")>  operator(=)operator(>) string<delimiter(")content(yellow)delimiter(")>operator(,)
    string<delimiter(")content(Carrot)delimiter(")> operator(=)operator(>) string<delimiter(")content(orange)delimiter(")>operator(,)
operator(})

reserved(if) operator(()ident(color)operator(.)ident(has_key?)operator(()ident(given)operator(\))operator(\))
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(given)delimiter(})>content( is a food with color )inline<delimiter(#{)ident(color)operator([)ident(given)operator(])delimiter(})>content(.)delimiter(")>
reserved(end)
reserved(if) operator(()ident(color)operator(.)ident(has_value?)operator(()ident(given)operator(\))operator(\))
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(color)operator(.)ident(index)operator(()ident(given)operator(\))delimiter(})>content( is a food with color )inline<delimiter(#{)ident(given)delimiter(})>content(.)delimiter(")>
reserved(end)
comment(#-----------------------------)


comment(# @@PLEAC@@_5.9)
comment(# Sorted by keys (Hash#sort gives an Array of pairs made of each key,value\))
ident(food_color)operator(.)ident(sort)operator(.)ident(each) operator({) operator(|)ident(f)operator(|)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(f)operator([)integer(0)operator(])delimiter(})>content( is )inline<delimiter(#{)ident(f)operator([)integer(1)operator(])delimiter(})>content(.)delimiter(")>
operator(})

comment(# Sorted by values)
ident(food_color)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(1)operator(]) operator(<=>) ident(b)operator([)integer(1)operator(]) operator(})operator(.)ident(each) operator({) operator(|)ident(f)operator(|)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(f)operator([)integer(0)operator(])delimiter(})>content( is )inline<delimiter(#{)ident(f)operator([)integer(1)operator(])delimiter(})>content(.)delimiter(")>
operator(})

comment(# Sorted by length of values)
ident(food_color)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(1)operator(])operator(.)ident(length) operator(<=>) ident(b)operator([)integer(1)operator(])operator(.)ident(length) operator(})operator(.)ident(each) operator({) operator(|)ident(f)operator(|)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(f)operator([)integer(0)operator(])delimiter(})>content( is )inline<delimiter(#{)ident(f)operator([)integer(1)operator(])delimiter(})>content(.)delimiter(")>
operator(})


comment(# @@PLEAC@@_5.10)
ident(merged) operator(=) ident(a)operator(.)ident(clone)operator(.)ident(update)operator(()ident(b)operator(\))        comment(# because Hash#update changes object in place)

ident(drink_color) operator(=) operator({) string<delimiter(")content(Galliano)delimiter(")>  operator(=)operator(>) string<delimiter(")content(yellow)delimiter(")>operator(,) string<delimiter(")content(Mai Tai)delimiter(")> operator(=)operator(>) string<delimiter(")content(blue)delimiter(")> operator(})
ident(ingested_color) operator(=) ident(drink_color)operator(.)ident(clone)operator(.)ident(update)operator(()ident(food_color)operator(\))

ident(substance_color) operator(=) operator({)operator(})
reserved(for) ident(i) reserved(in) operator([) ident(food_color)operator(,) ident(drink_color) operator(])
    ident(i)operator(.)ident(each_key) operator({) operator(|)ident(k)operator(|)
        reserved(if) ident(substance_color)operator(.)ident(has_key?)operator(()ident(k)operator(\))
            ident(puts) string<delimiter(")content(Warning: )inline<delimiter(#{)ident(k)delimiter(})>content( seen twice.  Using the first definition.)delimiter(")>
            reserved(next)
        reserved(end)
        ident(substance_color)operator([)ident(k)operator(]) operator(=) integer(1)
    operator(})
reserved(end)


comment(# @@PLEAC@@_5.11)
ident(common) operator(=) ident(hash1)operator(.)ident(keys) operator(&) ident(hash2)operator(.)ident(keys)

ident(this_not_that) operator(=) ident(hash1)operator(.)ident(keys) operator(-) ident(hash2)operator(.)ident(keys)


comment(# @@PLEAC@@_5.12)
comment(# no problem here, Ruby handles any kind of object for key-ing)
comment(# (it takes Object#hash, which defaults to Object#id\))


comment(# @@PLEAC@@_5.13)
comment(# AFAIK, not possible in Ruby)


comment(# @@PLEAC@@_5.14)
comment(# Be careful, the following is possible only because Fixnum objects are)
comment(# special (documentation says: there is effectively only one Fixnum object)
comment(# instance for any given integer value\).)
ident(count) operator(=) constant(Hash)operator(.)ident(new)operator(()integer(0)operator(\))
ident(array)operator(.)ident(each) operator({) operator(|)ident(e)operator(|)
    ident(count)operator([)ident(e)operator(]) operator(+=) integer(1)
operator(})


comment(# @@PLEAC@@_5.15)
ident(father) operator(=) operator({)
    string<delimiter(")content(Cain)delimiter(")>      operator(,) string<delimiter(")content(Adam)delimiter(")>operator(,)
    string<delimiter(")content(Abel)delimiter(")>      operator(,) string<delimiter(")content(Adam)delimiter(")>operator(,)
    string<delimiter(")content(Seth)delimiter(")>      operator(,) string<delimiter(")content(Adam)delimiter(")>operator(,)
    string<delimiter(")content(Enoch)delimiter(")>     operator(,) string<delimiter(")content(Cain)delimiter(")>operator(,)
    string<delimiter(")content(Irad)delimiter(")>      operator(,) string<delimiter(")content(Enoch)delimiter(")>operator(,)
    string<delimiter(")content(Mehujael)delimiter(")>  operator(,) string<delimiter(")content(Irad)delimiter(")>operator(,)
    string<delimiter(")content(Methusael)delimiter(")> operator(,) string<delimiter(")content(Mehujael)delimiter(")>operator(,)
    string<delimiter(")content(Lamech)delimiter(")>    operator(,) string<delimiter(")content(Methusael)delimiter(")>operator(,)
    string<delimiter(")content(Jabal)delimiter(")>     operator(,) string<delimiter(")content(Lamech)delimiter(")>operator(,)
    string<delimiter(")content(Jubal)delimiter(")>     operator(,) string<delimiter(")content(Lamech)delimiter(")>operator(,)
    string<delimiter(")content(Tubalcain)delimiter(")> operator(,) string<delimiter(")content(Lamech)delimiter(")>operator(,)
    string<delimiter(")content(Enos)delimiter(")>      operator(,) string<delimiter(")content(Seth)delimiter(")>operator(,)
operator(})

reserved(while) ident(gets)
    ident(chomp)
    reserved(begin)
        ident(print) global_variable($_)operator(,) string<delimiter(")content( )delimiter(")>
    reserved(end) reserved(while) global_variable($_) operator(=) ident(father)operator([)global_variable($_)operator(])
    ident(puts)
reserved(end)

ident(children) operator(=) operator({)operator(})
ident(father)operator(.)ident(each) operator({) operator(|)ident(k)operator(,)ident(v)operator(|)
    operator(()ident(children)operator([)ident(v)operator(]) operator(||=) operator([)operator(])operator(\)) operator(<<) ident(k)
operator(})
reserved(while) ident(gets)
    ident(chomp)
    ident(puts) string<delimiter(")inline<delimiter(#{)global_variable($_)delimiter(})>content( begat )inline<delimiter(#{)operator(()ident(children)operator([)global_variable($_)operator(]) operator(||) operator([)string<delimiter(')content(Nobody)delimiter(')>operator(])operator(\))operator(.)ident(join)operator(()string<delimiter(')content(, )delimiter(')>operator(\))delimiter(})>content(.)char(\\n)delimiter(")>
reserved(end)

ident(includes) operator(=) operator({)operator(})
ident(files)operator(.)ident(each) operator({) operator(|)ident(f)operator(|)
    reserved(begin)
        reserved(for) ident(l) reserved(in) constant(IO)operator(.)ident(readlines)operator(()ident(f)operator(\))
            reserved(next) reserved(unless) ident(l) operator(=)operator(~) regexp<delimiter(/)content(^)char(\\s)content(*#)char(\\s)content(*include)char(\\s)content(*<([^>]+\)>)delimiter(/)>
            operator(()ident(includes)operator([)global_variable($1)operator(]) operator(||=) operator([)operator(])operator(\)) operator(<<) ident(f)
        reserved(end)
    reserved(rescue) constant(SystemCallError)
        global_variable($stderr)operator(.)ident(puts) string<delimiter(")escape(#)global_variable($!)content( (skipping\))delimiter(")>
    reserved(end)
operator(})

ident(include_free) operator(=) ident(includes)operator(.)ident(values)operator(.)ident(flatten)operator(.)ident(uniq) operator(-) ident(includes)operator(.)ident(keys)


comment(# @@PLEAC@@_5.16)
comment(# dutree - print sorted intented rendition of du output)
comment(#% dutree)
comment(#% dutree /usr)
comment(#% dutree -a)
comment(#% dutree -a /bin)

comment(# The DuNode class collects all information about a directory,)
comment(# and provides some convenience methods)
reserved(class) class(DuNode)

    ident(attr_reader) symbol(:name)
    ident(attr_accessor) symbol(:size)
    ident(attr_accessor) symbol(:kids)

    reserved(def) method(initialize)operator(()ident(name)operator(\))
        instance_variable(@name) operator(=) ident(name)
        instance_variable(@kids) operator(=) operator([)operator(])
        instance_variable(@size) operator(=) integer(0)
    reserved(end)

    comment(# support for sorting nodes with side)
    reserved(def) method(size_compare)operator(()ident(node2)operator(\))
        instance_variable(@size) operator(<=>) ident(node2)operator(.)ident(size)
    reserved(end)

    reserved(def) method(basename)
        instance_variable(@name)operator(.)ident(sub)operator(()regexp<delimiter(/)content(.*)char(\\/)delimiter(/)>operator(,) string<delimiter(")delimiter(")>operator(\))
    reserved(end)

    comment(#returns substring before last "/", nil if not there)
    reserved(def) method(parent)
        ident(p) operator(=) instance_variable(@name)operator(.)ident(sub)operator(()regexp<delimiter(/)char(\\/)content([^)char(\\/)content(]+$)delimiter(/)>operator(,)string<delimiter(")delimiter(")>operator(\))
        reserved(if) ident(p) operator(==) instance_variable(@name)
            pre_constant(nil)
        reserved(else)
            ident(p)
        reserved(end)
    reserved(end)

reserved(end)

comment(# The DuTree does the acdtual work of)
comment(# getting the input, parsing it, builging up a tree)
comment(# and format it for output)
reserved(class) class(Dutree)

    ident(attr_reader) symbol(:topdir)

    reserved(def) method(initialize)
        instance_variable(@nodes) operator(=) constant(Hash)operator(.)ident(new)
        instance_variable(@dirsizes) operator(=) constant(Hash)operator(.)ident(new)operator(()integer(0)operator(\))
        instance_variable(@kids) operator(=) constant(Hash)operator(.)ident(new)operator(()operator([)operator(])operator(\))
    reserved(end)

    comment(# get a node by name, create it if it does not exist yet)
    reserved(def) method(get_create_node)operator(()ident(name)operator(\))
        reserved(if) instance_variable(@nodes)operator(.)ident(has_key?)operator(()ident(name)operator(\))
            instance_variable(@nodes)operator([)ident(name)operator(])
        reserved(else)
            ident(node) operator(=) constant(DuNode)operator(.)ident(new)operator(()ident(name)operator(\))
            instance_variable(@nodes)operator([)ident(name)operator(]) operator(=) ident(node)
            ident(node)
        reserved(end)
    reserved(end)

    comment(# run du, read in input, save sizes and kids)
    comment(# stores last directory read in instance variable topdir)
    reserved(def) method(input)operator(()ident(arguments)operator(\))
        ident(name) operator(=) string<delimiter(")delimiter(")>
        ident(cmd) operator(=) string<delimiter(")content(du )delimiter(")> operator(+) ident(arguments)operator(.)ident(join)operator(()string<delimiter(")content( )delimiter(")>operator(\))
        constant(IO)operator(.)ident(popen)operator(()ident(cmd)operator(\)) operator({) operator(|)ident(pipe)operator(|)
            ident(pipe)operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
                ident(size)operator(,) ident(name) operator(=) ident(line)operator(.)ident(chomp)operator(.)ident(split)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(,) integer(2)operator(\))
                ident(node) operator(=) ident(get_create_node)operator(()ident(name)operator(\))
                ident(node)operator(.)ident(size) operator(=) ident(size)operator(.)ident(to_i)
                instance_variable(@nodes)operator([)ident(name)operator(]) operator(=) ident(node)
                ident(parent) operator(=) ident(node)operator(.)ident(parent)
                reserved(if) ident(parent)
                    ident(get_create_node)operator(()ident(parent)operator(\))operator(.)ident(kids)operator(.)ident(push)operator(()ident(node)operator(\))
                reserved(end)
            operator(})
        operator(})
        instance_variable(@topdir) operator(=) instance_variable(@nodes)operator([)ident(name)operator(])
    reserved(end)

    comment(# figure out how much is taken in each directory)
    comment(# that isn't stored in the subdirectories. Add a new)
    comment(# fake kid called "." containing that much.)
    reserved(def) method(get_dots)operator(()ident(node)operator(\))
        ident(cursize) operator(=) ident(node)operator(.)ident(size)
        reserved(for) ident(kid) reserved(in) ident(node)operator(.)ident(kids)
            ident(cursize) operator(-=)  ident(kid)operator(.)ident(size)
            ident(get_dots)operator(()ident(kid)operator(\))
        reserved(end)
        reserved(if) ident(node)operator(.)ident(size) operator(!=) ident(cursize)
            ident(newnode) operator(=) ident(get_create_node)operator(()ident(node)operator(.)ident(name) operator(+) string<delimiter(")content(/.)delimiter(")>operator(\))
            ident(newnode)operator(.)ident(size) operator(=) ident(cursize)
            ident(node)operator(.)ident(kids)operator(.)ident(push)operator(()ident(newnode)operator(\))
        reserved(end)
    reserved(end)

    comment(# recursively output everything)
    comment(# passing padding and number width as well)
    comment(# on recursive calls)
    reserved(def) method(output)operator(()ident(node)operator(,) ident(prefix)operator(=)string<delimiter(")delimiter(")>operator(,) ident(width)operator(=)integer(0)operator(\))
        ident(line) operator(=) ident(sprintf)operator(()string<delimiter(")content(%)inline<delimiter(#{)ident(width)delimiter(})>content(d %s)delimiter(")>operator(,) ident(node)operator(.)ident(size)operator(,) ident(node)operator(.)ident(basename)operator(\))
        ident(puts)operator(()ident(prefix) operator(+) ident(line)operator(\))
        ident(prefix) operator(+=) ident(line)operator(.)ident(sub)operator(()regexp<delimiter(/)char(\\d)content( )delimiter(/)>operator(,) string<delimiter(")content(| )delimiter(")>operator(\))
        ident(prefix)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content([^|])delimiter(/)>operator(,) string<delimiter(")content( )delimiter(")>operator(\))
        reserved(if) ident(node)operator(.)ident(kids)operator(.)ident(length) operator(>) integer(0)     comment(# not a bachelor node)
            ident(kids) operator(=) ident(node)operator(.)ident(kids)
            ident(kids)operator(.)ident(sort!) operator({) operator(|)ident(a)operator(,)ident(b)operator(|)
                ident(b)operator(.)ident(size_compare)operator(()ident(a)operator(\))
            operator(})
            ident(width) operator(=) ident(kids)operator([)integer(0)operator(])operator(.)ident(size)operator(.)ident(to_s)operator(.)ident(length)
            reserved(for) ident(kid) reserved(in) ident(kids)
                ident(output)operator(()ident(kid)operator(,) ident(prefix)operator(,) ident(width)operator(\))
            reserved(end)
        reserved(end)
    reserved(end)

reserved(end)

ident(tree) operator(=) constant(Dutree)operator(.)ident(new)
ident(tree)operator(.)ident(input)operator(()pre_constant(ARGV)operator(\))
ident(tree)operator(.)ident(get_dots)operator(()ident(tree)operator(.)ident(topdir)operator(\))
ident(tree)operator(.)ident(output)operator(()ident(tree)operator(.)ident(topdir)operator(\))


comment(# @@PLEAC@@_6.0)
comment(# The verbose version are match, sub, gsub, sub! and gsub!;)
comment(# pattern needs to be a Regexp object; it yields a MatchData)
comment(# object.)
ident(pattern)operator(.)ident(match)operator(()ident(string)operator(\))
ident(string)operator(.)ident(sub)operator(()ident(pattern)operator(,) ident(replacement)operator(\))
ident(string)operator(.)ident(gsub)operator(()ident(pattern)operator(,) ident(replacement)operator(\))
comment(# As usual in Ruby, sub! does the same as sub but also modifies)
comment(# the object, the same for gsub!/gsub.)

comment(# Sugared syntax yields the position of the match (or nil if no)
comment(# match\). Note that the object at the right of the operator needs)
comment(# not to be a Regexp object (it can be a String\). The "dont)
comment(# match" operator yields true or false.)
ident(meadow) operator(=)operator(~) regexp<delimiter(/)content(sheep)delimiter(/)>   comment(# position of the match, nil if no match)
ident(meadow) operator(!)operator(~) regexp<delimiter(/)content(sheep)delimiter(/)>   comment(# true if doesn't match, false if it does)
comment(# There is no sugared version for the substitution)

ident(meadow) operator(=)operator(~) regexp<delimiter(/)char(\\b)content(ovines?)char(\\b)delimiter(/)modifier(i)> reserved(and) ident(print) string<delimiter(")content(Here be sheep!)delimiter(")>

ident(string) operator(=) string<delimiter(")content(good food)delimiter(")>
ident(string)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(o*)delimiter(/)>operator(,) string<delimiter(')content(e)delimiter(')>operator(\))

comment(# % echo ababacaca | ruby -ne 'puts $& if /(a|ba|b\)+(a|ac\)+/')
comment(# ababa)

comment(# The "global" (or "multiple"\) match is handled by String#scan)
ident(scan) operator(()regexp<delimiter(/)content(()char(\\d)content(+\))delimiter(/)>operator(\)) operator({)
    ident(puts) string<delimiter(")content(Found number )inline<delimiter(#{)global_variable($1)delimiter(})>delimiter(")>
operator(})

comment(# String#scan yields an Array if not used with a block)
ident(numbers) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\d)content(+)delimiter(/)>operator(\))

ident(digits) operator(=) string<delimiter(")content(123456789)delimiter(")>
ident(nonlap) operator(=) ident(digits)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\d)char(\\d)char(\\d)content(\))delimiter(/)>operator(\))
ident(yeslap) operator(=) ident(digits)operator(.)ident(scan)operator(()regexp<delimiter(/)content((?=()char(\\d)char(\\d)char(\\d)content(\)\))delimiter(/)>operator(\))
ident(puts) string<delimiter(")content(Non-overlapping:  )inline<delimiter(#{)ident(nonlap)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>delimiter(")>
ident(puts) string<delimiter(")content(Overlapping:      )inline<delimiter(#{)ident(yeslap)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>delimiter(")>operator(;)
comment(# Non-overlapping:  123 456 789)
comment(# Overlapping:      123 234 345 456 567 678 789)

ident(string) operator(=) string<delimiter(")content(And little lambs eat ivy)delimiter(")>
ident(string) operator(=)operator(~) regexp<delimiter(/)content(l[^s]*s)delimiter(/)>
ident(puts) string<delimiter(")content(()escape(#)global_variable($`)content(\) ()escape(#)global_variable($&)content(\) ()escape(#)global_variable($')content(\))delimiter(")>
comment(# (And \) (little lambs\) ( eat ivy\))


comment(# @@PLEAC@@_6.1)
comment(# Ruby doesn't have the same problem:)
ident(dst) operator(=) ident(src)operator(.)ident(sub)operator(()string<delimiter(')content(this)delimiter(')>operator(,) string<delimiter(')content(that)delimiter(')>operator(\))

ident(progname) operator(=) global_variable($0)operator(.)ident(sub)operator(()string<delimiter(')content(^.*/)delimiter(')>operator(,) string<delimiter(')delimiter(')>operator(\))

ident(bindirs) operator(=) string<delimiter(%w()content(/usr/bin /bin /usr/local/bin)delimiter(\))>
ident(libdirs) operator(=) ident(bindirs)operator(.)ident(map) operator({) operator(|)ident(l)operator(|) ident(l)operator(.)ident(sub)operator(()string<delimiter(')content(bin)delimiter(')>operator(,) string<delimiter(')content(lib)delimiter(')>operator(\)) operator(})


comment(# @@PLEAC@@_6.3)
regexp<delimiter(/)char(\\S)content(+)delimiter(/)>               comment(# as many non-whitespace bytes as possible)
regexp<delimiter(/)content([A-Za-z'-]+)delimiter(/)>       comment(# as many letters, apostrophes, and hyphens)

regexp<delimiter(/)char(\\b)content(([A-Za-z]+\))char(\\b)delimiter(/)>   comment(# usually best)
regexp<delimiter(/)char(\\s)content(([A-Za-z]+\))char(\\s)delimiter(/)>   comment(# fails at ends or w/ punctuation)


comment(# @@PLEAC@@_6.4)
ident(require) string<delimiter(')content(socket)delimiter(')>
ident(str) operator(=) string<delimiter(')content(www.ruby-lang.org and www.rubygarden.org)delimiter(')>
ident(re) operator(=) regexp<delimiter(/)content(
      (               # capture the hostname in $1
        (?:           # these parens for grouping only
          (?! [-_] \)  # lookahead for neither underscore nor dash
          [)char(\\w)content(-] +     # hostname component
          )char(\\.)content(          # and the domain dot
        \) +           # now repeat that whole thing a bunch of times
        [A-Za-z]      # next must be a letter
        [)char(\\w)content(-] +       # now trailing domain part
      \)               # end of $1 capture
     )delimiter(/)modifier(x)>               comment(# /x for nice formatting)

ident(str)operator(.)ident(gsub!) ident(re) reserved(do)       comment(# pass a block to execute replacement)
    ident(host) operator(=) constant(TCPsocket)operator(.)ident(gethostbyname)operator(()global_variable($1)operator(\))
    string<delimiter(")inline<delimiter(#{)global_variable($1)delimiter(})>content( [)inline<delimiter(#{)ident(host)operator([)integer(3)operator(])delimiter(})>content(])delimiter(")>
reserved(end)

ident(puts) ident(str)
comment(#-----------------------------)
comment(# to match whitespace or #-characters in an extended re you need to escape)
comment(# them.)

ident(foo) operator(=) integer(42)
ident(str) operator(=) string<delimiter(')content(blah #foo# blah)delimiter(')>
ident(str)operator(.)ident(gsub!) regexp<delimiter(%r/)content(       # replace
              )char(\\#)content(    #   a pound sign
              ()char(\\w)content(+\) #   the variable name
              )char(\\#)content(    #   another pound sign
          )delimiter(/)modifier(x)> reserved(do)
              ident(eval) global_variable($1)           comment(# with the value of a local variable)
          reserved(end)
ident(puts) ident(str)  comment(# => blah 42 blah)


comment(# @@PLEAC@@_6.5)
comment(# The 'g' modifier doesn't exist in Ruby, a regexp can't be used)
comment(# directly in a while loop; instead, use String#scan { |match| .. })
ident(fish) operator(=) string<delimiter(')content(One fish two fish red fish blue fish)delimiter(')>
constant(WANT) operator(=) integer(3)
ident(count) operator(=) integer(0)
ident(fish)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\w)content(+\))char(\\s)content(+fish)char(\\b)delimiter(/)modifier(i)>operator(\)) operator({)
    reserved(if) operator(()ident(count) operator(+=) integer(1)operator(\)) operator(==) constant(WANT)
        ident(puts) string<delimiter(")content(The third fish is a )inline<delimiter(#{)global_variable($1)delimiter(})>content( one.)delimiter(")>
    reserved(end)
operator(})

reserved(if) ident(fish) operator(=)operator(~) regexp<delimiter(/)content((?:)char(\\w)content(+)char(\\s)content(+fish)char(\\s)content(+\){2}()char(\\w)content(+\))char(\\s)content(+fish)delimiter(/)modifier(i)>
    ident(puts) string<delimiter(")content(The third fish is a )inline<delimiter(#{)global_variable($1)delimiter(})>content( one.)delimiter(")>
reserved(end)

ident(pond) operator(=) string<delimiter(')content(One fish two fish red fish blue fish)delimiter(')>
comment(# String#scan without a block gives an array of matches, each match)
comment(# being an array of all the specified groups)
ident(colors) operator(=) ident(pond)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\w)content(+\))char(\\s)content(+fish)char(\\b)delimiter(/)modifier(i)>operator(\))operator(.)ident(flatten)  comment(# get all matches)
ident(color)  operator(=) ident(colors)operator([)integer(2)operator(])                          comment(# then the one we want)
comment(# or without a temporary array)
ident(color) operator(=) ident(pond)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\w)content(+\))char(\\s)content(+fish)char(\\b)delimiter(/)modifier(i)>operator(\))operator(.)ident(flatten)operator([)integer(2)operator(])  comment(# just grab element 3)
ident(puts) string<delimiter(")content(The third fish in the pond is )inline<delimiter(#{)ident(color)delimiter(})>content(.)delimiter(")>

ident(count) operator(=) integer(0)
ident(fishes) operator(=) string<delimiter(')content(One fish two fish red fish blue fish)delimiter(')>
ident(evens) operator(=) ident(fishes)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\w)content(+\))char(\\s)content(+fish)char(\\b)delimiter(/)modifier(i)>operator(\))operator(.)ident(select) operator({) operator(()ident(count)operator(+=)integer(1)operator(\)) operator(%) integer(2) operator(==) integer(0) operator(})
ident(print) string<delimiter(")content(Even numbered fish are )inline<delimiter(#{)ident(evens)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>content(.)delimiter(")>

ident(count) operator(=) integer(0)
ident(fishes)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(
   )char(\\b)content(               # makes next )char(\\w)content( more efficient
   ( )char(\\w)content(+ \)          # this is what we)char(\\')content(ll be changing
   (
     )char(\\s)content(+ fish )char(\\b)content(
   \)
            )delimiter(/)modifier(x)>operator(\)) operator({)
    reserved(if) operator(()ident(count) operator(+=) integer(1)operator(\)) operator(==) integer(4)
        string<delimiter(')content(sushi)delimiter(')> operator(+) global_variable($2)
    reserved(else)
        global_variable($1) operator(+) global_variable($2)
    reserved(end)
operator(})

ident(pond) operator(=) string<delimiter(')content(One fish two fish red fish blue fish swim here.)delimiter(')>
ident(puts) string<delimiter(")content(Last fish is )inline<delimiter(#{)ident(pond)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\b)content(()char(\\w)content(+\))char(\\s)content(+fish)char(\\b)delimiter(/)modifier(i)>operator(\))operator(.)ident(flatten)operator([)operator(-)integer(1)operator(])delimiter(})>delimiter(")>

regexp<delimiter(/)content(
    A               # find some pattern A
    (?!             # mustn)char(\\')content(t be able to find
        .*          # something
        A           # and A
    \)
    $               # through the end of the string
)delimiter(/)modifier(x)>

comment(# The "s" perl modifier is "m" in Ruby (not very nice since there is)
comment(# also an "m" in perl..\))
ident(pond) operator(=) string<delimiter(")content(One fish two fish red fish blue fish swim here.)delimiter(")>
reserved(if) operator(()ident(pond) operator(=)operator(~) regexp<delimiter(/)content(
                    )char(\\b)content(  (  )char(\\w)content(+\) )char(\\s)content(+ fish )char(\\b)content(
                (?! .* )char(\\b)content( fish )char(\\b)content( \)
            )delimiter(/)modifier(mix)>operator(\))
    ident(puts) string<delimiter(")content(Last fish is )inline<delimiter(#{)global_variable($1)delimiter(})>content(.)delimiter(")>
reserved(else)
    ident(puts) string<delimiter(")content(Failed!)delimiter(")>
reserved(end)


comment(# @@PLEAC@@_6.6)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# killtags - very bad html killer)
global_variable($/) operator(=) pre_constant(nil)operator(;)                              comment(# each read is whole file)
reserved(while) ident(file) operator(=) ident(gets)operator(()operator(\)) reserved(do)
    ident(file)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(<.*?>)delimiter(/)modifier(m)>operator(,)string<delimiter(')delimiter(')>operator(\))operator(;)           comment(# strip tags (terribly\))
    ident(puts) ident(file)                          comment(# print file to STDOUT)
reserved(end)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(#headerfy - change certain chapter headers to html)
global_variable($/) operator(=) string<delimiter(')delimiter(')>
reserved(while) ident(file) operator(=) ident(gets)operator(()operator(\)) reserved(do)
    ident(pattern) operator(=) regexp<delimiter(/)content(
                  )char(\\A)content(                   # start of record
                  (                    # capture in $1
                      Chapter          # text string
                      )char(\\s)content(+              # mandatory whitespace
                      )char(\\d)content(+              # decimal number
                      )char(\\s)content(*              # optional whitespace
                      :                # a real colon
                      . *              # anything not a newline till end of line
                  \)
               )delimiter(/)modifier(x)>
    ident(puts) ident(file)operator(.)ident(gsub)operator(()ident(pattern)operator(,)string<delimiter(')content(<H1>)content(\\1)content(</H1>)delimiter(')>operator(\))
reserved(end)
comment(#-----------------------------)
comment(#% ruby -00pe "gsub!(/\\A(Chapter\\s+\\d+\\s*:.*\)/,'<H1>\\1</H1>'\)" datafile)

comment(#!/usr/bin/ruby -w)
comment(#-----------------------------)
reserved(for) ident(file) reserved(in) pre_constant(ARGV)
    ident(file) operator(=) constant(File)operator(.)ident(open)operator(()pre_constant(ARGV)operator(.)ident(shift)operator(\))
    reserved(while) ident(file)operator(.)ident(gets)operator(()string<delimiter(')delimiter(')>operator(\)) reserved(do)             comment(# each read is a paragraph)
        ident(print) string<delimiter(")content(chunk )inline<delimiter(#{)global_variable($.)delimiter(})>content( in $ARGV has <<)inline<delimiter(#{)global_variable($1)delimiter(})>content(>>)char(\\n)delimiter(")> reserved(while) regexp<delimiter(/)content(^START(.*?\)^END)delimiter(/)modifier(m)>
    reserved(end)                                comment(# /m activates the multiline mode)
reserved(end)
comment(#-----------------------------)

comment(# @@PLEAC@@_6.7)
comment(#-----------------------------)
global_variable($/) operator(=) pre_constant(nil)operator(;)
ident(file) operator(=) constant(File)operator(.)ident(open)operator(()string<delimiter(")content(datafile)delimiter(")>operator(\))
ident(chunks) operator(=) ident(file)operator(.)ident(gets)operator(.)ident(split)operator(()regexp<delimiter(/)content(pattern)delimiter(/)>operator(\))
comment(#-----------------------------)
comment(# .Ch, .Se and .Ss divide chunks of STDIN)
ident(chunks) operator(=) ident(gets)operator(()pre_constant(nil)operator(\))operator(.)ident(split)operator(()regexp<delimiter(/)content(^)char(\\.)content((Ch|Se|Ss\)$)delimiter(/)>operator(\))
ident(print) string<delimiter(")content(I read )inline<delimiter(#{)ident(chunks)operator(.)ident(size)delimiter(})>content( chunks.)char(\\n)delimiter(")>
comment(#-----------------------------)


comment(# @@PLEAC@@_6.8)
reserved(while) ident(gets)
    reserved(if) operator(~)regexp<delimiter(/)content(BEGIN)delimiter(/)> operator(..) operator(~)regexp<delimiter(/)content(END)delimiter(/)>
        comment(# line falls between BEGIN and END inclusive)
    reserved(end)
reserved(end)

reserved(while) ident(gets)
    reserved(if) operator(()global_variable($.) operator(==) ident(firstnum)operator(\)) operator(..) operator(()global_variable($.) operator(==) ident(lastnum)operator(\))
        comment(# operate between firstnum and lastnum line number)
    reserved(end)
reserved(end)

comment(# in ruby versions prior to 1.8, the above two conditional)
comment(# expressions could be shortened to:)
comment(#     if /BEGIN/ .. /END/)
comment(# and)
comment(#     if firstnum .. lastnum)
comment(# but these now only work this way from the command line)

comment(#-----------------------------)

reserved(while) ident(gets)
    reserved(if) operator(~)regexp<delimiter(/)content(BEGIN)delimiter(/)> operator(...) operator(~)regexp<delimiter(/)content(END)delimiter(/)>
        comment(# line falls between BEGIN and END on different lines)
    reserved(end)
reserved(end)

reserved(while) ident(gets)
    reserved(if) operator(()global_variable($.) operator(==) ident(first)operator(\)) operator(...) operator(()global_variable($.) operator(==) ident(last)operator(\))
        comment(# operate between first and last line number on different lines)
    reserved(end)
reserved(end)

comment(#-----------------------------)
comment(# command-line to print lines 15 through 17 inclusive (see below\))
ident(ruby) operator(-)ident(ne) string<delimiter(')content(print if 15 .. 17)delimiter(')> ident(datafile)

comment(# print out all <XMP> .. </XMP> displays from HTML doc)
reserved(while) ident(gets)
    ident(print) reserved(if) operator(~)regexp<delimiter(%r#)content(<XMP>)delimiter(#)modifier(i)> operator(..) operator(~)regexp<delimiter(%r#)content(</XMP>)delimiter(#)modifier(i)>operator(;)
reserved(end)

comment(# same, but as shell command)
comment(# ruby -ne 'print if %r#<XMP>#i .. %r#</XMP>#i' document.html)
comment(#-----------------------------)
comment(# ruby -ne 'BEGIN { $top=3; $bottom=5 }; \\)
comment(#     print if $top .. $bottom' /etc/passwd                 #  FAILS)
comment(# ruby -ne 'BEGIN { $top=3; $bottom=5 }; \\)
comment(#     print if $. == $top .. $. ==  $bottom' /etc/passwd    # works)
comment(# ruby -ne 'print if 3 .. 5' /etc/passwd                    # also works)
comment(#-----------------------------)
ident(print) reserved(if) operator(~)regexp<delimiter(/)content(begin)delimiter(/)> operator(..) operator(~)regexp<delimiter(/)content(end)delimiter(/)>operator(;)
ident(print) reserved(if) operator(~)regexp<delimiter(/)content(begin)delimiter(/)> operator(...) operator(~)regexp<delimiter(/)content(end)delimiter(/)>operator(;)
comment(#-----------------------------)
reserved(while) ident(gets)
    global_variable($in_header) operator(=) global_variable($.) operator(==) integer(1)  operator(..) operator(~)regexp<delimiter(/)content(^$)delimiter(/)> operator(?) pre_constant(true) operator(:) pre_constant(false)
    global_variable($in_body)   operator(=) operator(~)regexp<delimiter(/)content(^$)delimiter(/)> operator(..) pre_constant(ARGF)operator(.)ident(eof) operator(?) pre_constant(true) operator(:) pre_constant(false)
reserved(end)
comment(#-----------------------------)
ident(seen) operator(=) operator({)operator(})
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    reserved(next) reserved(unless) ident(line) operator(=)operator(~) regexp<delimiter(/)content(^From:?)char(\\s)delimiter(/)modifier(i)> operator(..) ident(line) operator(=)operator(~) regexp<delimiter(/)content(^$)delimiter(/)>operator(;)
    ident(line)operator(.)ident(scan)operator(()regexp<delimiter(%r/)content(([^<>(\),;)char(\\s)content(]+)char(\\@)content([^<>(\),;)char(\\s)content(]+\))delimiter(/)>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(addr)operator(|)
        ident(puts) ident(addr) reserved(unless) ident(seen)operator([)ident(addr)operator(])
        ident(seen)operator([)ident(addr)operator(]) operator(||=) integer(1)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_6.9)
reserved(def) method(glob2pat)operator(()ident(globstr)operator(\))
    ident(patmap) operator(=) operator({)
        string<delimiter(')content(*)delimiter(')> operator(=)operator(>) string<delimiter(')content(.*)delimiter(')>operator(,)
        string<delimiter(')content(?)delimiter(')> operator(=)operator(>) string<delimiter(')content(.)delimiter(')>operator(,)
        string<delimiter(')content([)delimiter(')> operator(=)operator(>) string<delimiter(')content([)delimiter(')>operator(,)
        string<delimiter(')content(])delimiter(')> operator(=)operator(>) string<delimiter(')content(])delimiter(')>operator(,)
    operator(})
    ident(globstr)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content((.\))delimiter(/)>operator(\)) operator({) operator(|)ident(c)operator(|) ident(patmap)operator([)ident(c)operator(]) operator(||) constant(Regexp)operator(::)ident(escape)operator(()ident(c)operator(\)) operator(})
    string<delimiter(')content(^)delimiter(')> operator(+) ident(globstr) operator(+) string<delimiter(')content($)delimiter(')>
reserved(end)


comment(# @@PLEAC@@_6.10)
comment(# avoid interpolating patterns like this if the pattern)
comment(# isn't going to change:)
ident(pattern) operator(=) pre_constant(ARGV)operator(.)ident(shift)
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)inline<delimiter(#{)ident(pattern)delimiter(})>delimiter(/)>
reserved(end)

comment(# the above creates a new regex each iteration. Instead,)
comment(# use the /o modifier so the regex is compiled only once)

ident(pattern) operator(=) pre_constant(ARGV)operator(.)ident(shift)
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)inline<delimiter(#{)ident(pattern)delimiter(})>delimiter(/)modifier(o)>
reserved(end)

comment(#-----------------------------)

comment(#!/usr/bin/ruby)
comment(# popgrep1 - grep for abbreviations of places that say "pop")
comment(# version 1: slow but obvious way)
ident(popstates) operator(=) string<delimiter(%w()content(CO ON MI WI MN)delimiter(\))>
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(popstates)operator(.)ident(each) reserved(do) operator(|)ident(state)operator(|)
        reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)char(\\b)inline<delimiter(#{)ident(state)delimiter(})>char(\\b)delimiter(/)>
            ident(print) ident(line)
            ident(last)
        reserved(end)
    reserved(end)
reserved(end)

comment(#-----------------------------)
comment(#!/usr/bin/ruby)
comment(# popgrep2 - grep for abbreviations of places that say "pop")
comment(# version 2: eval strings; fast but hard to quote)
ident(popstates) operator(=) string<delimiter(%w()content(CO ON MI WI MN)delimiter(\))>
ident(code) operator(=) string<delimiter(")content(ARGF.each do |line|)char(\\n)delimiter(")>
ident(popstates)operator(.)ident(each) reserved(do) operator(|)ident(state)operator(|)
    ident(code) operator(+=) string<delimiter(")char(\\t)content(if line =~ /)char(\\\\)content(b)inline<delimiter(#{)ident(state)delimiter(})>char(\\\\)content(b/; print(line\); next; end)char(\\n)delimiter(")>
reserved(end)
ident(code) operator(+=) string<delimiter(")content(end)char(\\n)delimiter(")>
ident(print) string<delimiter(")content(CODE IS)char(\\n)content(---)char(\\n)inline<delimiter(#{)ident(code)delimiter(})>char(\\n)content(---)char(\\n)delimiter(")> reserved(if) pre_constant(false) comment(# turn on for debugging)
ident(eval) ident(code)

comment(# CODE IS)
comment(# ---)
comment(# ARGF.each do |line|)
comment(#         if line =~ /\\bCO\\b/; print(line\); next; end)
comment(#         if line =~ /\\bON\\b/; print(line\); next; end)
comment(#         if line =~ /\\bMI\\b/; print(line\); next; end)
comment(#         if line =~ /\\bWI\\b/; print(line\); next; end)
comment(#         if line =~ /\\bMN\\b/; print(line\); next; end)
comment(# end)
comment(#)
comment(# ---)

comment(## alternatively, the same idea as above but compiling)
comment(## to a case statement: (not in perlcookbook\))
comment(#!/usr/bin/ruby -w)
comment(# popgrep2.5 - grep for abbreviations of places that say "pop")
comment(# version 2.5: eval strings; fast but hard to quote)
ident(popstates) operator(=) string<delimiter(%w()content(CO ON MI WI MN)delimiter(\))>
ident(code) operator(=) string<delimiter(")content(ARGF.each do |line|)char(\\n)content(    case line)char(\\n)delimiter(")>
ident(popstates)operator(.)ident(each) reserved(do) operator(|)ident(state)operator(|)
    ident(code) operator(+=) string<delimiter(")content(        when /)char(\\\\)content(b)inline<delimiter(#{)ident(state)delimiter(})>char(\\\\)content(b/ : print line)char(\\n)delimiter(")>
reserved(end)
ident(code) operator(+=) string<delimiter(")content(    end)char(\\n)content(end)char(\\n)delimiter(")>
ident(print) string<delimiter(")content(CODE IS)char(\\n)content(---)char(\\n)inline<delimiter(#{)ident(code)delimiter(})>char(\\n)content(---)char(\\n)delimiter(")> reserved(if) pre_constant(false) comment(# turn on for debugging)
ident(eval) ident(code)

comment(# CODE IS)
comment(# ---)
comment(# ARGF.each do |line|)
comment(#     case line)
comment(#         when /\\bCO\\b/ : print line)
comment(#         when /\\bON\\b/ : print line)
comment(#         when /\\bMI\\b/ : print line)
comment(#         when /\\bWI\\b/ : print line)
comment(#         when /\\bMN\\b/ : print line)
comment(#     end)
comment(# end)
comment(#)
comment(# ---)

comment(# Note: (above\) Ruby 1.8+ allows the 'when EXP : EXPR' on one line)
comment(# with the colon separator.)

comment(#-----------------------------)
comment(#!/usr/bin/ruby)
comment(# popgrep3 - grep for abbreviations of places that say "pop")
comment(# version3: build a match_any function)
ident(popstates) operator(=) string<delimiter(%w()content(CO ON MI WI MN)delimiter(\))>
ident(expr) operator(=) ident(popstates)operator(.)ident(map)operator({)operator(|)ident(e)operator(|)string<delimiter(")content(line =~ /)char(\\\\)content(b)inline<delimiter(#{)ident(e)delimiter(})>char(\\\\)content(b/)delimiter(")>operator(})operator(.)ident(join)operator(()string<delimiter(')content(||)delimiter(')>operator(\))
ident(eval) string<delimiter(")content(def match_any(line\); )inline<delimiter(#{)ident(expr)delimiter(})>content(;end)delimiter(")>
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(match_any)operator(()ident(line)operator(\))
reserved(end)
comment(#-----------------------------)

comment(##  building a match_all function is a trivial)
comment(##  substitution of && for ||)
comment(##  here is a generalized example:)
comment(#!/usr/bin/ruby -w)
comment(## grepauth - print lines that mention both foo and bar)
reserved(class) class(MultiMatch)
    reserved(def) method(initialize)operator(()operator(*)ident(patterns)operator(\))
        ident(_any) operator(=) ident(build_match)operator(()string<delimiter(')content(||)delimiter(')>operator(,)ident(patterns)operator(\))
        ident(_all) operator(=) ident(build_match)operator(()string<delimiter(')content(&&)delimiter(')>operator(,)ident(patterns)operator(\))
        ident(eval) string<delimiter(")content(def match_any(line\);)inline<delimiter(#{)ident(_any)delimiter(})>content(;end)char(\\n)delimiter(")>
        ident(eval) string<delimiter(")content(def match_all(line\);)inline<delimiter(#{)ident(_all)delimiter(})>content(;end)char(\\n)delimiter(")>
      reserved(end)
    reserved(def) method(build_match)operator(()ident(sym)operator(,)ident(args)operator(\))
        ident(args)operator(.)ident(map)operator({)operator(|)ident(e)operator(|)string<delimiter(")content(line =~ /)inline<delimiter(#{)ident(e)delimiter(})>content(/)delimiter(")>operator(})operator(.)ident(join)operator(()ident(sym)operator(\))
    reserved(end)
reserved(end)

ident(mm) operator(=) constant(MultiMatch)operator(.)ident(new)operator(()string<delimiter(')content(foo)delimiter(')>operator(,)string<delimiter(')content(bar)delimiter(')>operator(\))
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(mm)operator(.)ident(match_all)operator(()ident(line)operator(\))
reserved(end)
comment(#-----------------------------)

comment(#!/usr/bin/ruby)
comment(# popgrep4 - grep for abbreviations of places that say "pop")
comment(# version4: pretty fast, but simple: compile all re's first:)
ident(popstates) operator(=) string<delimiter(%w()content(CO ON MI WI MN)delimiter(\))>
ident(popstates) operator(=) ident(popstates)operator(.)ident(map)operator({)operator(|)ident(re)operator(|) regexp<delimiter(%r/)char(\\b)inline<delimiter(#{)ident(re)delimiter(})>char(\\b)delimiter(/)>operator(})
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(popstates)operator(.)ident(each) reserved(do) operator(|)ident(state_re)operator(|)
        reserved(if) ident(line) operator(=)operator(~) ident(state_re)
            ident(print) ident(line)
            reserved(break)
        reserved(end)
    reserved(end)
reserved(end)

comment(## speeds trials on the jargon file(412\): 26006 lines, 1.3MB)
comment(## popgrep1   => 7.040s)
comment(## popgrep2   => 0.656s)
comment(## popgrep2.5 => 0.633s)
comment(## popgrep3   => 0.675s)
comment(## popgrep4   => 1.027s)

comment(# unless speed is criticial, the technique in popgrep4 is a)
comment(# reasonable balance between speed and logical simplicity.)


comment(# @@PLEAC@@_6.11)
reserved(begin)
    ident(print) string<delimiter(")content(Pattern? )delimiter(")>
    ident(pat) operator(=) global_variable($stdin)operator(.)ident(gets)operator(.)ident(chomp)
    constant(Regexp)operator(.)ident(new)operator(()ident(pat)operator(\))
reserved(rescue)
    ident(warn) string<delimiter(")content(Invalid Pattern)delimiter(")>
    reserved(retry)
reserved(end)


comment(# @@PLEAC@@_6.13)
comment(# uses the 'amatch' extension found on:)
comment(# http://raa.ruby-lang.org/project/amatch/)
ident(require) string<delimiter(')content(amatch)delimiter(')>
ident(matcher) operator(=) constant(Amatch)operator(.)ident(new)operator(()string<delimiter(')content(balast)delimiter(')>operator(\))
comment(#$relative, $distance = 0, 1)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(/usr/share/dict/words)delimiter(')>operator(\))operator(.)ident(each_line) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(matcher)operator(.)ident(search)operator(()ident(line)operator(\)) operator(<=) integer(1)
reserved(end)
comment(__END__
)comment(#CODE)
ident(ballast)
ident(ballasts)
ident(balustrade)
ident(balustrades)
ident(blast)
ident(blasted)
ident(blaster)
ident(blasters)
ident(blasting)
ident(blasts)


comment(# @@PLEAC@@_6.14)
ident(str)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\G)content(()char(\\d)content(\))delimiter(/)>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(token)operator(|)
    ident(puts) string<delimiter(")content(found )inline<delimiter(#{)ident(token)delimiter(})>delimiter(")>
reserved(end)
comment(#-----------------------------)
ident(n) operator(=) string<delimiter(")content(   49 here)delimiter(")>
ident(n)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\G)content( )delimiter(/)>operator(,)string<delimiter(')content(0)delimiter(')>operator(\))
ident(puts) ident(n)
comment(#-----------------------------)
ident(str) operator(=) string<delimiter(")content(3,4,5,9,120)delimiter(")>
ident(str)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\G)content(,?()char(\\d)content(+\))delimiter(/)>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(num)operator(|)
    ident(puts) string<delimiter(")content(Found number: )inline<delimiter(#{)ident(num)delimiter(})>delimiter(")>
reserved(end)
comment(#-----------------------------)
comment(# Ruby doesn't have the String.pos or a /c re modifier like Perl)
comment(# But it does have StringScanner in the standard library (strscn\))
comment(# which allows similar functionality:)

ident(require) string<delimiter(')content(strscan)delimiter(')>
ident(text) operator(=) string<delimiter(')content(the year 1752 lost 10 days on the 3rd of September)delimiter(')>
ident(sc) operator(=) constant(StringScanner)operator(.)ident(new)operator(()ident(text)operator(\))
reserved(while) ident(sc)operator(.)ident(scan)operator(()regexp<delimiter(/)content(.*?()char(\\d)content(+\))delimiter(/)>operator(\))
    ident(print) string<delimiter(")content(found: )inline<delimiter(#{)ident(sc)operator([)integer(1)operator(])delimiter(})>char(\\n)delimiter(")>
reserved(end)
reserved(if) ident(sc)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\S)content(+)delimiter(/)>operator(\))
    ident(puts) string<delimiter(")content(Found )inline<delimiter(#{)ident(sc)operator([)integer(0)operator(])delimiter(})>content( after last number)delimiter(")>
reserved(end)
comment(#-----------------------------)
comment(# assuming continuing from above:)
ident(puts) string<delimiter(")content(The position in 'text' is: )inline<delimiter(#{)ident(sc)operator(.)ident(pos)delimiter(})>delimiter(")>
ident(sc)operator(.)ident(pos) operator(=) integer(30)
ident(puts) string<delimiter(")content(The position in 'text' is: )inline<delimiter(#{)ident(sc)operator(.)ident(pos)delimiter(})>delimiter(")>


comment(# @@PLEAC@@_6.15)
comment(#-----------------------------)
comment(# greedy pattern)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(<.*>)delimiter(/)modifier(m)>operator(,)string<delimiter(')delimiter(')>operator(\))   comment(# not good)

comment(# non-greedy (minimal\) pattern)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(<.*?>)delimiter(/)modifier(m)>operator(,)string<delimiter(')delimiter(')>operator(\))   comment(# not great)


comment(#-----------------------------)
comment(#<b><i>this</i> and <i>that</i> are important</b> Oh, <b><i>me too!</i></b>)
comment(#-----------------------------)
regexp<delimiter(%r{)content( <b><i>(.*?\)</i></b> )delimiter(})modifier(mx)>
comment(#-----------------------------)
regexp<delimiter(%r/)content(BEGIN((?:(?!BEGIN\).\)*\)END)delimiter(/)>
comment(#-----------------------------)
regexp<delimiter(%r{)content( <b><i>(  (?: (?!</b>|</i>\). \)*  \) </i></b> )delimiter(})modifier(mx)>
comment(#-----------------------------)
regexp<delimiter(%r{)content( <b><i>(  (?: (?!</[ib]>\). \)*  \) </i></b> )delimiter(})modifier(mx)>
comment(#-----------------------------)
regexp<delimiter(%r{)content(
    <b><i>
    [^<]*  # stuff not possibly bad, and not possibly the end.
    (?:
 # at this point, we can have '<' if not part of something bad
     (?!  </?[ib]>  \)   # what we can't have
     <                  # okay, so match the '<'
     [^<]*              # and continue with more safe stuff
    \) *
    </i></b>
 )delimiter(})modifier(mx)>


comment(# @@PLEAC@@_6.16)
comment(#-----------------------------)
global_variable($/) operator(=) string<delimiter(")delimiter(")>
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(para)operator(|)
    ident(para)operator(.)ident(scan) regexp<delimiter(%r/)content(
                  )char(\\b)content(     # start at word boundary
                  ()char(\\S)content(+\)  # find chunk of non-whitespace
                  )char(\\b)content(     # until a word boundary
                  (
                    )char(\\s)content(+  # followed by whitespace
                    )char(\\1)content(   # and that same chunk again
                    )char(\\b)content(   # and a word boundary
                  \) +    # one or more times
                )delimiter(/)modifier(xi)> reserved(do)
        ident(puts) string<delimiter(")content(dup word ')inline<delimiter(#{)global_variable($1)delimiter(})>content(' at paragraph )inline<delimiter(#{)global_variable($.)delimiter(})>delimiter(")>
    reserved(end)
reserved(end)
comment(#-----------------------------)
ident(astr) operator(=) string<delimiter(')content(nobody)delimiter(')>
ident(bstr) operator(=) string<delimiter(')content(bodysnatcher)delimiter(')>
reserved(if) string<delimiter(")inline<delimiter(#{)ident(astr)delimiter(})>content( )inline<delimiter(#{)ident(bstr)delimiter(})>delimiter(")> operator(=)operator(~) regexp<delimiter(/)content(^()char(\\w)content(+\)()char(\\w)content(+\) )char(\\2)content(()char(\\w)content(+\)$)delimiter(/)>
    ident(print) string<delimiter(")inline<delimiter(#{)global_variable($2)delimiter(})>content( overlaps in )inline<delimiter(#{)global_variable($1)delimiter(})>content(-)inline<delimiter(#{)global_variable($2)delimiter(})>content(-)inline<delimiter(#{)global_variable($3)delimiter(})>delimiter(")>
reserved(end)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# prime_pattern -- find prime factors of argument using patterns)
pre_constant(ARGV) operator(<<) integer(180)
ident(cap) operator(=) string<delimiter(')content(o)delimiter(')> operator(*) pre_constant(ARGV)operator(.)ident(shift)
reserved(while) ident(cap) operator(=)operator(~) regexp<delimiter(/)content(^(oo+?\))char(\\1)content(+$)delimiter(/)>
    ident(print) global_variable($1)operator(.)ident(size)operator(,) string<delimiter(")content( )delimiter(")>
    ident(cap)operator(.)ident(gsub!)operator(()regexp<delimiter(/)inline<delimiter(#{)global_variable($1)delimiter(})>delimiter(/)>operator(,)string<delimiter(')content(o)delimiter(')>operator(\))
reserved(end)
ident(puts) ident(cap)operator(.)ident(size)
comment(#-----------------------------)
comment(#diophantine)
comment(# solve for 12x + 15y + 16z = 281, maximizing x)
reserved(if) operator(()string<delimiter(')content(o)delimiter(')> operator(*) integer(281)operator(\))operator(.)ident(match)operator(()regexp<delimiter(/)content(^(o*\))char(\\1)content({11}(o*\))char(\\2)content({14}(o*\))char(\\3)content({15}$)delimiter(/)>operator(\))
    ident(x)operator(,) ident(y)operator(,) ident(z) operator(=) global_variable($1)operator(.)ident(size)operator(,) global_variable($2)operator(.)ident(size)operator(,) global_variable($3)operator(.)ident(size)
    ident(puts) string<delimiter(")content(One solution is: x=)inline<delimiter(#{)ident(x)delimiter(})>content(; y=)inline<delimiter(#{)ident(y)delimiter(})>content(; z=)inline<delimiter(#{)ident(z)delimiter(})>delimiter(")>
reserved(else)
    ident(puts) string<delimiter(")content(No solution.)delimiter(")>
reserved(end)
comment(#    => One solution is: x=17; y=3; z=2)

comment(#-----------------------------)
comment(# using different quantifiers:)
operator(()string<delimiter(')content(o)delimiter(')> operator(*) integer(281)operator(\))operator(.)ident(match)operator(()regexp<delimiter(/)content(^(o+\))char(\\1)content({11}(o+\))char(\\2)content({14}(o+\))char(\\3)content({15}$)delimiter(/)>operator(\))
comment(#    => One solution is: x=17; y=3; z=2)

operator(()string<delimiter(')content(o)delimiter(')> operator(*) integer(281)operator(\))operator(.)ident(match)operator(()regexp<delimiter(/)content(^(o*?\))char(\\1)content({11}(o*\))char(\\2)content({14}(o*\))char(\\3)content({15}$)delimiter(/)>operator(\))
comment(#    => One solution is: x=0; y=7; z=11)

operator(()string<delimiter(')content(o)delimiter(')> operator(*) integer(281)operator(\))operator(.)ident(match)operator(()regexp<delimiter(/)content(^(o+?\))char(\\1)content({11}(o*\))char(\\2)content({14}(o*\))char(\\3)content({15}$)delimiter(/)>operator(\))
comment(#    => One solution is: x=1; y=3; z=14)


comment(# @@PLEAC@@_6.17)
comment(# alpha OR beta)
regexp<delimiter(%r/)content(alpha|beta)delimiter(/)>

comment(# alpha AND beta)
regexp<delimiter(%r/)content((?=.*alpha\)(?=.*beta\))delimiter(/)modifier(m)>

comment(# alpha AND beta,  no overlap)
regexp<delimiter(%r/)content(alpha.*beta|beta.*alpha)delimiter(/)modifier(m)>

comment(# NOT beta)
regexp<delimiter(%r/)content(^(?:(?!beta\).\)*$)delimiter(/)modifier(m)>

comment(# NOT bad BUT good)
regexp<delimiter(%r/)content((?=(?:(?!BAD\).\)*$\)GOOD)delimiter(/)modifier(m)>
comment(#-----------------------------)

reserved(if) operator(!)operator(()ident(string) operator(=)operator(~) regexp<delimiter(/)content(pattern)delimiter(/)>operator(\))   comment(# ugly)
    ident(something)operator(()operator(\))
reserved(end)

reserved(if) ident(string) operator(!)operator(~) regexp<delimiter(/)content(pattern)delimiter(/)>   comment(# preferred)
    ident(something)operator(()operator(\))
reserved(end)


comment(#-----------------------------)
reserved(if) ident(string) operator(=)operator(~) regexp<delimiter(/)content(pat1)delimiter(/)>  operator(&&) ident(string) operator(=)operator(~) regexp<delimiter(/)content(pat2)delimiter(/)>
    ident(something)operator(()operator(\))
reserved(end)
comment(#-----------------------------)
reserved(if) ident(string) operator(=)operator(~) regexp<delimiter(/)content(pat1)delimiter(/)> operator(||) ident(string) operator(=)operator(~) regexp<delimiter(/)content(pat2)delimiter(/)>
    ident(something)operator(()operator(\))
reserved(end)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# minigrep - trivial grep)
ident(pat) operator(=) pre_constant(ARGV)operator(.)ident(shift)
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)inline<delimiter(#{)ident(pat)delimiter(})>delimiter(/)modifier(o)>
reserved(end)
comment(#-----------------------------)
 string<delimiter(")content(labelled)delimiter(")> operator(=)operator(~) regexp<delimiter(/)content(^(?=.*bell\)(?=.*lab\))delimiter(/)modifier(m)>
comment(#-----------------------------)
global_variable($string) operator(=)operator(~) regexp<delimiter(/)content(bell)delimiter(/)> operator(&&) global_variable($string) operator(=)operator(~) regexp<delimiter(/)content(lab)delimiter(/)>
comment(#-----------------------------)
global_variable($murray_hill) operator(=) string<delimiter(")content(blah bell blah )delimiter(")>
reserved(if) global_variable($murray_hill) operator(=)operator(~) regexp<delimiter(%r{)content(
                         ^              # start of string
                        (?=             # zero-width lookahead
                            .*          # any amount of intervening stuff
                            bell        # the desired bell string
                        \)               # rewind, since we were only looking
                        (?=             # and do the same thing
                            .*          # any amount of intervening stuff
                            lab         # and the lab part
                        \)
                     )delimiter(})modifier(mx)>                comment(# /m means . can match newline)

    ident(print) string<delimiter(")content(Looks like Bell Labs might be in Murray Hill!)char(\\n)delimiter(")>operator(;)
reserved(end)
comment(#-----------------------------)
string<delimiter(")content(labelled)delimiter(")> operator(=)operator(~) regexp<delimiter(/)content((?:^.*bell.*lab\)|(?:^.*lab.*bell\))delimiter(/)>
comment(#-----------------------------)
global_variable($brand) operator(=) string<delimiter(")content(labelled)delimiter(")>operator(;)
reserved(if) global_variable($brand) operator(=)operator(~) regexp<delimiter(%r{)content(
                (?:                 # non-capturing grouper
                    ^ .*?           # any amount of stuff at the front
                      bell          # look for a bell
                      .*?           # followed by any amount of anything
                      lab           # look for a lab
                  \)                 # end grouper
            |                       # otherwise, try the other direction
                (?:                 # non-capturing grouper
                    ^ .*?           # any amount of stuff at the front
                      lab           # look for a lab
                      .*?           # followed by any amount of anything
                      bell          # followed by a bell
                  \)                 # end grouper
            )delimiter(})modifier(mx)>                     comment(# /m means . can match newline)
    ident(print) string<delimiter(")content(Our brand has bell and lab separate.)char(\\n)delimiter(")>operator(;)
reserved(end)
comment(#-----------------------------)
global_variable($map) operator(=)operator(~) regexp<delimiter(/)content(^(?:(?!waldo\).\)*$)delimiter(/)modifier(s)>
comment(#-----------------------------)
global_variable($map) operator(=) string<delimiter(")content(the great baldo)delimiter(")>
reserved(if) global_variable($map) operator(=)operator(~) regexp<delimiter(%r{)content(
                ^                   # start of string
                (?:                 # non-capturing grouper
                    (?!             # look ahead negation
                        waldo       # is he ahead of us now?
                    \)               # is so, the negation failed
                    .               # any character (cuzza /s\)
                \) *                 # repeat that grouping 0 or more
                $                   # through the end of the string
             )delimiter(})modifier(mx)>                    comment(# /m means . can match newline)
    ident(print) string<delimiter(")content(There's no waldo here!)char(\\n)delimiter(")>operator(;)
reserved(end)
comment(=begin
 7:15am  up 206 days, 13:30,  4 users,  load average: 1.04, 1.07, 1.04

USER     TTY      FROM              LOGIN@  IDLE   JCPU   PCPU  WHAT

tchrist  tty1                       5:16pm 36days 24:43   0.03s  xinit

tchrist  tty2                       5:19pm  6days  0.43s  0.43s  -tcsh

tchrist  ttyp0    chthon            7:58am  3days 23.44s  0.44s  -tcsh

gnat     ttyS4    coprolith         2:01pm 13:36m  0.30s  0.30s  -tcsh
=end)
comment(#% w | minigrep '^(?!.*ttyp\).*tchrist')
comment(#-----------------------------)
regexp<delimiter(%r{)content(
    ^                       # anchored to the start
    (?!                     # zero-width look-ahead assertion
        .*                  # any amount of anything (faster than .*?\)
        ttyp                # the string you don't want to find
    \)                       # end look-ahead negation; rewind to start
    .*                      # any amount of anything (faster than .*?\)
    tchrist                 # now try to find Tom
)delimiter(})modifier(x)>
comment(#-----------------------------)
comment(#% w | grep tchrist | grep -v ttyp)
comment(#-----------------------------)
comment(#% grep -i 'pattern' files)
comment(#% minigrep '(?i\)pattern' files)
comment(#-----------------------------)


comment(# @@PLEAC@@_6.20)
ident(ans) operator(=) global_variable($stdin)operator(.)ident(gets)operator(.)ident(chomp)
ident(re) operator(=) regexp<delimiter(%r/)content(^)inline<delimiter(#{)constant(Regexp)operator(.)ident(quote)operator(()ident(ans)operator(\))delimiter(})>delimiter(/)>
reserved(case)
    reserved(when) string<delimiter(")content(SEND)delimiter(")>  operator(=)operator(~) ident(re) operator(:) ident(puts) string<delimiter(")content(Action is send)delimiter(")>
    reserved(when) string<delimiter(")content(STOP)delimiter(")>  operator(=)operator(~) ident(re) operator(:) ident(puts) string<delimiter(")content(Action is stop)delimiter(")>
    reserved(when) string<delimiter(")content(ABORT)delimiter(")> operator(=)operator(~) ident(re) operator(:) ident(puts) string<delimiter(")content(Action is abort)delimiter(")>
    reserved(when) string<delimiter(")content(EDIT)delimiter(")>  operator(=)operator(~) ident(re) operator(:) ident(puts) string<delimiter(")content(Action is edit)delimiter(")>
reserved(end)
comment(#-----------------------------)
ident(require) string<delimiter(')content(abbrev)delimiter(')>
ident(table) operator(=) constant(Abbrev)operator(.)ident(abbrev) string<delimiter(%w-)content(send stop abort edit)delimiter(-)>
ident(loop) reserved(do)
    ident(print) string<delimiter(")content(Action: )delimiter(")>
    ident(ans) operator(=) global_variable($stdin)operator(.)ident(gets)operator(.)ident(chomp)
    ident(puts) string<delimiter(")content(Action for )inline<delimiter(#{)ident(ans)delimiter(})>content( is )inline<delimiter(#{)ident(table)operator([)ident(ans)operator(.)ident(downcase)operator(])delimiter(})>delimiter(")>
reserved(end)


comment(#-----------------------------)
comment(# dummy values are defined for 'file', 'PAGER', and)
comment(# the 'invoke_editor' and 'deliver_message' methods)
comment(# do not do anything interesting in this example.)
comment(#!/usr/bin/ruby -w)
ident(require) string<delimiter(')content(abbrev)delimiter(')>

ident(file) operator(=) string<delimiter(')content(pleac_ruby.data)delimiter(')>
constant(PAGER) operator(=) string<delimiter(')content(less)delimiter(')>

reserved(def) method(invoke_editor)
    ident(puts) string<delimiter(")content(invoking editor)delimiter(")>
reserved(end)

reserved(def) method(deliver_message)
    ident(puts) string<delimiter(")content(delivering message)delimiter(")>
reserved(end)

ident(actions) operator(=) operator({)
    string<delimiter(')content(edit)delimiter(')>  operator(=)operator(>) pre_constant(self)operator(.)ident(method)operator(()symbol(:invoke_editor)operator(\))operator(,)
    string<delimiter(')content(send)delimiter(')>  operator(=)operator(>) pre_constant(self)operator(.)ident(method)operator(()symbol(:deliver_message)operator(\))operator(,)
    string<delimiter(')content(list)delimiter(')>  operator(=)operator(>) ident(proc) operator({)ident(system)operator(()constant(PAGER)operator(,) ident(file)operator(\))operator(})operator(,)
    string<delimiter(')content(abort)delimiter(')> operator(=)operator(>) ident(proc) operator({)ident(puts) string<delimiter(")content(See ya!)delimiter(")>operator(;) ident(exit)operator(})operator(,)
    string<delimiter(")delimiter(")>      operator(=)operator(>) ident(proc) operator({)ident(puts) string<delimiter(")content(Unknown Command)delimiter(")>operator(})
operator(})

ident(dtable) operator(=) constant(Abbrev)operator(.)ident(abbrev)operator(()ident(actions)operator(.)ident(keys)operator(\))
ident(loop) reserved(do)
    ident(print) string<delimiter(")content(Action: )delimiter(")>
    ident(ans) operator(=) global_variable($stdin)operator(.)ident(gets)operator(.)ident(chomp)operator(.)ident(delete)operator(()string<delimiter(")content( )char(\\t)delimiter(")>operator(\))
    ident(actions)operator([) ident(dtable)operator([)ident(ans)operator(.)ident(downcase)operator(]) operator(||) string<delimiter(")delimiter(")> operator(])operator(.)ident(call)
reserved(end)


comment(# @@PLEAC@@_6.19)
comment(#-----------------------------)
comment(# basically, the Perl Cookbook categorizes this as an)
comment(# unsolvable problem ...)
comment(#-----------------------------)
integer(1) reserved(while) ident(addr)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\()content([^(\)]*)char(\\\))delimiter(/)>operator(,)string<delimiter(')delimiter(')>operator(\))
comment(#-----------------------------)
constant(Dear) ident(someuser)instance_variable(@host)operator(.)ident(com)operator(,)

constant(Please) ident(confirm) ident(the) ident(mail) ident(address) ident(you) ident(gave) ident(us) constant(Wed) constant(May)  integer(6) integer(09)operator(:)integer(38)operator(:)integer(41)
constant(MDT) integer(1998) ident(by) ident(replying) ident(to) ident(this) ident(message)operator(.)  constant(Include) ident(the) ident(string)
string<delimiter(")content(Rumpelstiltskin)delimiter(")> reserved(in) ident(that) ident(reply)operator(,) ident(but) ident(spelled) reserved(in) ident(reverse)operator(;) ident(that) ident(is)operator(,)
ident(start) ident(with) string<delimiter(")content(Nik...)delimiter(")>operator(.)  constant(Once) ident(this) ident(is) ident(done)operator(,) ident(your) ident(confirmed) ident(address) ident(will)
ident(be) ident(entered) ident(into) ident(our) ident(records)operator(.)


comment(# @@PLEAC@@_6.21)
comment(#-----------------------------)
comment(#% gunzip -c ~/mail/archive.gz | urlify > archive.urlified)
comment(#-----------------------------)
comment(#% urlify ~/mail/*.inbox > ~/allmail.urlified)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# urlify - wrap HTML links around URL-like constructs)

ident(urls) operator(=) string<delimiter(')content((https?|telnet|gopher|file|wais|ftp\))delimiter(')>operator(;)
ident(ltrs) operator(=) string<delimiter(')content(\\w)delimiter(')>operator(;)
ident(gunk) operator(=) string<delimiter(')content(/#~:.?+=&%@!)content(\\-)delimiter(')>operator(;)
ident(punc) operator(=) string<delimiter(')content(.:?)content(\\-)delimiter(')>operator(;)
ident(any)  operator(=) string<delimiter(")inline<delimiter(#{)ident(ltrs)delimiter(})>inline<delimiter(#{)ident(gunk)delimiter(})>inline<delimiter(#{)ident(punc)delimiter(})>delimiter(")>operator(;)

pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(line)operator(.)ident(gsub!) regexp<delimiter(%r/)content(
        )char(\\b)content(                    # start at word boundary
        (                     # begin $1  {
         )inline<delimiter(#{)ident(urls)delimiter(})>content(     :        # need resource and a colon
         [)inline<delimiter(#{)ident(any)delimiter(})>content(] +?          # followed by on or more
                              #  of any valid character, but
                              #  be conservative and take only
                              #  what you need to....
        \)                     # end   $1  }
        (?=                   # look-ahead non-consumptive assertion
         [)inline<delimiter(#{)ident(punc)delimiter(})>content(]*           # either 0 or more punctuation
         [^)inline<delimiter(#{)ident(any)delimiter(})>content(]            #   followed by a non-url char
         |                    # or else
         $                    #   then end of the string
        \)
    )delimiter(/)modifier(iox)> reserved(do)
        string<delimiter(%Q|)content(<A HREF=")inline<delimiter(#{)global_variable($1)delimiter(})>content(">)inline<delimiter(#{)global_variable($1)delimiter(})>content(</A>)delimiter(|)>
    reserved(end)
    ident(print) ident(line)
reserved(end)


comment(# @@PLEAC@@_6.23)
regexp<delimiter(%r/)content(^m*(d?c{0,3}|c[dm]\)(l?x{0,3}|x[lc]\)(v?i{0,3}|i[vx]\)$)delimiter(/)modifier(i)>
comment(#-----------------------------)
ident(str)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(()char(\\S)content(+\)()char(\\s)content(+\)()char(\\S)content(+\))delimiter(/)>operator(,) string<delimiter(')content(\\3)content(\\2)content(\\1)delimiter(')>operator(\))
comment(#-----------------------------)
regexp<delimiter(%r/)content(()char(\\w)content(+\))char(\\s)content(*=)char(\\s)content(*(.*\))char(\\s)content(*$)delimiter(/)>             comment(# keyword is $1, value is $2)
comment(#-----------------------------)
regexp<delimiter(%r/)content(.{80,})delimiter(/)>
comment(#-----------------------------)
regexp<delimiter(%r|)content(()char(\\d)content(+\)/()char(\\d)content(+\)/()char(\\d)content(+\) ()char(\\d)content(+\):()char(\\d)content(+\):()char(\\d)content(+\))delimiter(|)>
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(%r|)content(/usr/bin)delimiter(|)>operator(,)string<delimiter(')content(/usr/local/bin)delimiter(')>operator(\))
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(%([0-9A-Fa-f][0-9A-Fa-f]\))delimiter(/)>operator(\))operator({) global_variable($1)operator(.)ident(hex)operator(.)ident(chr) operator(})
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(%r{)content(
    /)char(\\*)content(                    # Match the opening delimiter
    .*?                    # Match a minimal number of characters
    )char(\\*)content(/                    # Match the closing delimiter
)delimiter(})modifier(xm)>operator(,)string<delimiter(')delimiter(')>operator(\))
comment(#-----------------------------)
ident(str)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(^)char(\\s)content(+)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))
ident(str)operator(.)ident(sub!)operator(()regexp<delimiter(/)char(\\s)content(+$)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))

comment(# but really, in Ruby we'd just do:)
ident(str)operator(.)ident(strip!)
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\\\)content(n)delimiter(/)>operator(,)string<delimiter(")char(\\n)delimiter(")>operator(\))
comment(#-----------------------------)
ident(str)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(^.*::)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))
comment(#-----------------------------)
regexp<delimiter(%r/)content(^([01]?)char(\\d)char(\\d)content(|2[0-4])char(\\d)content(|25[0-5]\))char(\\.)content(([01]?)char(\\d)char(\\d)content(|2[0-4])char(\\d)content(|25[0-5]\))char(\\.)content(
    ([01]?)char(\\d)char(\\d)content(|2[0-4])char(\\d)content(|25[0-5]\))char(\\.)content(([01]?)char(\\d)char(\\d)content(|2[0-4])char(\\d)content(|25[0-5]\)$)delimiter(/)modifier(x)>
comment(#-----------------------------)
ident(str)operator(.)ident(sub!)operator(()regexp<delimiter(%r|)content(^.*/)delimiter(|)>operator(,) string<delimiter(')delimiter(')>operator(\))
comment(#-----------------------------)
ident(cols) operator(=) operator(() operator(()constant(ENV)operator([)string<delimiter(')content(TERMCAP)delimiter(')>operator(]) operator(||) string<delimiter(")content( )delimiter(")>operator(\)) operator(=)operator(~) regexp<delimiter(/)content(:co#()char(\\d)content(+\):)delimiter(/)> operator(\)) operator(?) global_variable($1) operator(:) integer(80)operator(;)
comment(#-----------------------------)
ident(name) operator(=) string<delimiter(")content( )inline<delimiter(#{)global_variable($0)delimiter(})>content( )inline<delimiter(#{)pre_constant(ARGV)delimiter(})>delimiter(")>operator(.)ident(gsub)operator(()regexp<delimiter(%r|)content( /)char(\\S)content(+/)delimiter(|)>operator(,) string<delimiter(')content( )delimiter(')>operator(\))
comment(#-----------------------------)
ident(require) string<delimiter(')content(rbconfig)delimiter(')>
ident(include) constant(Config)
ident(raise) string<delimiter(")content(This isn't Linux)delimiter(")> reserved(unless) constant(CONFIG)operator([)string<delimiter(')content(target_os)delimiter(')>operator(]) operator(=)operator(~) regexp<delimiter(/)content(linux)delimiter(/)modifier(i)>operator(;)
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(%r/)char(\\n)char(\\s)content(+)delimiter(/)>operator(,) string<delimiter(')content( )delimiter(')>operator(\))
comment(#-----------------------------)
ident(nums) operator(=) ident(str)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\d)content(+)char(\\.)content(?)char(\\d)content(*|)char(\\.)char(\\d)content(+\))delimiter(/)>operator(\))
comment(#-----------------------------)
ident(capwords) operator(=) ident(str)operator(.)ident(scan)operator(()regexp<delimiter(%r/)content(()char(\\b)content([^)char(\\W)content(a-z0-9_]+)char(\\b)content(\))delimiter(/)>operator(\))
comment(#-----------------------------)
ident(lowords) operator(=) ident(str)operator(.)ident(scan)operator(()regexp<delimiter(%r/)content(()char(\\b)content([^)char(\\W)content(A-Z0-9_]+)char(\\b)content(\))delimiter(/)>operator(\))
comment(#-----------------------------)
ident(icwords) operator(=) ident(str)operator(.)ident(scan)operator(()regexp<delimiter(%r/)content(()char(\\b)content([^)char(\\W)content(a-z0-9_][^)char(\\W)content(A-Z0-9_]*)char(\\b)content(\))delimiter(/)>operator(\))
comment(#-----------------------------)
ident(links) operator(=) ident(str)operator(.)ident(scan)operator(()regexp<delimiter(%r/)content(<A[^>]+?HREF)char(\\s)content(*=)char(\\s)content(*["']?([^'" >]+?\)[ '"]?>)delimiter(/)modifier(mi)>operator(\))
comment(#-----------------------------)
ident(initial) operator(=) ident(str) operator(=)operator(~) regexp<delimiter(/)content(^)char(\\S)content(+)char(\\s)content(+()char(\\S)content(\))char(\\S)content(*)char(\\s)content(+)char(\\S)delimiter(/)> operator(?) global_variable($1) operator(:) string<delimiter(")delimiter(")>
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(%r/)content("([^"]*\)")delimiter(/)>operator(,) string<delimiter(%q-)content(``)content(\\1)content('')delimiter(-)>operator(\))
comment(#-----------------------------)

global_variable($/) operator(=) string<delimiter(")delimiter(")>
ident(sentences) operator(=) operator([)operator(])
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(para)operator(|)
    ident(para)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(,) string<delimiter(')content( )delimiter(')>operator(\))
    ident(para)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content( {3,})delimiter(/)>operator(,)string<delimiter(')content(  )delimiter(')>operator(\))
    ident(sentences) operator(<<) ident(para)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\S)content(.*?[!?.]\)(?=  |)char(\\Z)content(\))delimiter(/)>operator(\))
reserved(end)

comment(#-----------------------------)
regexp<delimiter(%r/)content(()char(\\d)content({4}\)-()char(\\d)char(\\d)content(\)-()char(\\d)char(\\d)content(\))delimiter(/)>            comment(# YYYY in $1, MM in $2, DD in $3)
comment(#-----------------------------)
regexp<delimiter(%r/)content( ^
      (?:
       1 )char(\\s)content( (?: )char(\\d)char(\\d)char(\\d)content( )char(\\s)content(\)?            # 1, or 1 and area code
       |                               # ... or ...
       )char(\\()char(\\d)char(\\d)char(\\d)char(\\\))content( )char(\\s)content(                   # area code with parens
       |                               # ... or ...
       (?: )char(\\+)char(\\d)char(\\d)content(?)char(\\d)content(? )char(\\s)content(\)?             # optional +country code
       )char(\\d)char(\\d)char(\\d)content( ([)char(\\s)char(\\-)content(]\)                 # and area code
      \)
      )char(\\d)char(\\d)char(\\d)content( ()char(\\s)content(|)char(\\1)content(\)                   # prefix (and area code separator\)
      )char(\\d)char(\\d)char(\\d)char(\\d)content(                         # exchange
        $
 )delimiter(/)modifier(x)>
comment(#-----------------------------)
regexp<delimiter(%r/)char(\\b)content(oh)char(\\s)content(+my)char(\\s)content(+gh?o(d(dess(es\)?|s?\)|odness|sh\))char(\\b)delimiter(/)modifier(i)>
comment(#-----------------------------)
ident(lines) operator(=) operator([)operator(])
ident(lines) operator(<<) global_variable($1) reserved(while) ident(input)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(^([^)char(\\012)char(\\015)content(]*\)()char(\\012)char(\\015)content(?|)char(\\015)char(\\012)content(?\))delimiter(/)>operator(,)string<delimiter(')delimiter(')>operator(\))


comment(# @@PLEAC@@_7.0)
comment(# An IO object being Enumerable, we can use 'each' directly on it)
constant(File)operator(.)ident(open)operator(()string<delimiter(")content(/usr/local/widgets/data)delimiter(")>operator(\))operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
    ident(puts) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)content(blue)delimiter(/)>
operator(})

ident(logfile) operator(=) constant(File)operator(.)ident(new)operator(()string<delimiter(")content(/var/log/rubylog.txt)delimiter(")>operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
ident(mysub)operator(()global_variable($stdin)operator(,) ident(logfile)operator(\))

comment(# The method IO#readline is similar  to IO#gets)
comment(# but throws an exception when it reaches EOF)
ident(f) operator(=) constant(File)operator(.)ident(new)operator(()string<delimiter(")content(bla.txt)delimiter(")>operator(\))
reserved(begin)
    reserved(while) operator(()ident(line) operator(=) ident(f)operator(.)ident(readline)operator(\))
        ident(line)operator(.)ident(chomp)
        global_variable($stdout)operator(.)ident(print) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)content(blue)delimiter(/)>
    reserved(end)
reserved(rescue) constant(EOFError)
    ident(f)operator(.)ident(close)
reserved(end)

reserved(while) global_variable($stdin)operator(.)ident(gets)                        comment(# reads from STDIN)
    reserved(unless) operator(()regexp<delimiter(/)char(\\d)delimiter(/)>operator(\))
        global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(No digit found.)delimiter(")>   comment(# writes to STDERR)
    reserved(end)
    ident(puts) string<delimiter(")content(Read: )inline<delimiter(#{)global_variable($_)delimiter(})>delimiter(")>                   comment(# writes to STDOUT)
reserved(end)

ident(logfile) operator(=) constant(File)operator(.)ident(new)operator(()string<delimiter(")content(/tmp/log)delimiter(")>operator(,) string<delimiter(")content(w)delimiter(")>operator(\))

ident(logfile)operator(.)ident(close)

comment(# $defout (or its synonym '$>'\) is the destination of output)
comment(# for Kernel#print, Kernel#puts, and family functions)
ident(logfile) operator(=) constant(File)operator(.)ident(new)operator(()string<delimiter(")content(log.txt)delimiter(")>operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
ident(old) operator(=) global_variable($defout)
global_variable($defout) operator(=) ident(logfile)                 comment(# switch to logfile for output)
ident(puts) string<delimiter(")content(Countdown initiated ...)delimiter(")>
global_variable($defout) operator(=) ident(old)                     comment(# return to original output)
ident(puts) string<delimiter(")content(You have 30 seconds to reach minimum safety distance.)delimiter(")>


comment(# @@PLEAC@@_7.1)
ident(source) operator(=) constant(File)operator(.)ident(new)operator(()ident(path)operator(,) string<delimiter(")content(r)delimiter(")>operator(\))  comment(# open file "path" for reading only)
ident(sink)   operator(=) constant(File)operator(.)ident(new)operator(()ident(path)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))  comment(# open file "path" for writing only)

ident(source) operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDONLY)operator(\))  comment(# open file "path" for reading only)
ident(sink)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(\))  comment(# open file "path" for writing only)

ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) string<delimiter(")content(r+)delimiter(")>operator(\))  comment(# open "path" for reading and writing)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) ident(flags)operator(\)) comment(# open "path" with the flags "flags" (see examples below for flags\))

comment(# open file "path" read only)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) string<delimiter(")content(r)delimiter(")>operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDONLY)operator(\))

comment(# open file "path" write only, create it if it does not exist)
comment(# truncate it to zero length if it exists)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(TRUNC)operator(|)constant(File)operator(::)constant(CREAT)operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(TRUNC)operator(|)constant(File)operator(::)constant(CREAT)operator(,) integer(0666)operator(\))  comment(# with permission 0666)

comment(# open file "path" write only, fails if file exists)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(EXCL)operator(|)constant(File)operator(::)constant(CREAT)operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(EXCL)operator(|)constant(File)operator(::)constant(CREAT)operator(,) integer(0666)operator(\))

comment(# open file "path" for appending)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) string<delimiter(")content(a)delimiter(")>operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(APPEND)operator(|)constant(File)operator(::)constant(CREAT)operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(APPEND)operator(|)constant(File)operator(::)constant(CREAT)operator(,) integer(0666)operator(\))

comment(# open file "path" for appending only when file exists)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(APPEND)operator(\))

comment(# open file "path" for reading and writing)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) string<delimiter(")content(r+)delimiter(")>operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDWR)operator(\))

comment(# open file for reading and writing, create a new file if it does not exist)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(CREAT)operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(CREAT)operator(,) integer(0600)operator(\))

comment(# open file "path" reading and writing, fails if file exists)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(EXCL)operator(|)constant(File)operator(::)constant(CREAT)operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(EXCL)operator(|)constant(File)operator(::)constant(CREAT)operator(,) integer(0600)operator(\))


comment(# @@PLEAC@@_7.2)
comment(# No problem with Ruby since the filename doesn't contain characters with)
comment(# special meaning; like Perl's sysopen)
constant(File)operator(.)ident(open)operator(()ident(filename)operator(,) string<delimiter(')content(r)delimiter(')>operator(\))


comment(# @@PLEAC@@_7.3)
constant(File)operator(.)ident(expand_path)operator(()string<delimiter(')content(~root/tmp)delimiter(')>operator(\))
comment(#=> "/root/tmp")
constant(File)operator(.)ident(expand_path)operator(()string<delimiter(')content(~rpcuser)delimiter(')>operator(\))
comment(#=> "/var/lib/nfs")

comment(# To expand ~/.. it explicitely needs the environment variable HOME)
constant(File)operator(.)ident(expand_path)operator(()string<delimiter(')content(~/tmp)delimiter(')>operator(\))
comment(#=> "/home/gc/tmp")


comment(# @@PLEAC@@_7.4)
comment(# The exception raised in Ruby reports the filename)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(afile)delimiter(')>operator(\))


comment(# @@PLEAC@@_7.5)
comment(# Standard Ruby distribution provides the following useful extension)
ident(require) string<delimiter(')content(tempfile)delimiter(')>
comment(# With the Tempfile class, the file is automatically deleted on garbage)
comment(# collection, so you won't need to remove it, later on.)
ident(tf) operator(=) constant(Tempfile)operator(.)ident(new)operator(()string<delimiter(')content(tmp)delimiter(')>operator(\))   comment(# a name is required to create the filename)

comment(# If you need to pass the filename to an external program you can use)
comment(# File#path, but don't forget to File#flush in order to flush anything)
comment(# living in some buffer somewhere.)
ident(tf)operator(.)ident(flush)
ident(system)operator(()string<delimiter(")content(/usr/bin/dowhatever )inline<delimiter(#{)ident(tf)operator(.)ident(path)delimiter(})>delimiter(")>operator(\))

ident(fh) operator(=) constant(Tempfile)operator(.)ident(new)operator(()string<delimiter(')content(tmp)delimiter(')>operator(\))
ident(fh)operator(.)ident(sync) operator(=) pre_constant(true)                comment(# autoflushes)
integer(10)operator(.)ident(times) operator({) operator(|)ident(i)operator(|) ident(fh)operator(.)ident(puts) ident(i) operator(})
ident(fh)operator(.)ident(rewind)
ident(puts) string<delimiter(')content(Tmp file has: )delimiter(')>operator(,) ident(fh)operator(.)ident(readlines)


comment(# @@PLEAC@@_7.6)
reserved(while) operator(()pre_constant(DATA)operator(.)ident(gets)operator(\)) reserved(do)
    comment(# process the line)
reserved(end)
comment(__END__
# your data goes here
# __DATA__ doesn't exist in Ruby

)comment(#CODE)
comment(# get info about the script (size, date of last modification\))
ident(kilosize) operator(=) pre_constant(DATA)operator(.)ident(stat)operator(.)ident(size) operator(/) integer(1024)
ident(last_modif) operator(=) pre_constant(DATA)operator(.)ident(stat)operator(.)ident(mtime)
ident(puts) string<delimiter(")content(<P>Script size is )inline<delimiter(#{)ident(kilosize)delimiter(})>delimiter(")>
ident(puts) string<delimiter(")content(<P>Last script update: )inline<delimiter(#{)ident(last_modif)delimiter(})>delimiter(")>
comment(__END__
# DO NOT REMOVE THE PRECEEDING LINE.
# Everything else in this file will be ignored.
)comment(#CODE)


comment(# @@PLEAC@@_7.7)
reserved(while) ident(line) operator(=) ident(gets) reserved(do)
    comment(# do something with line.)
reserved(end)

comment(#  or)
reserved(while) ident(gets) reserved(do)
    comment(# do something with $_)
reserved(end)

comment(# or more rubyish)
global_variable($stdun)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    comment(# do stuff with line)
reserved(end)


comment(# ARGF may makes this more easy)
comment(# this is skipped if ARGV.size==0)
pre_constant(ARGV)operator(.)ident(each) reserved(do) operator(|)ident(filename)operator(|)
    comment(# closing and exception handling are done by the block)
    ident(open)operator(()ident(filename)operator(\)) reserved(do) operator(|)ident(fd)operator(|)
        ident(fd)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
            comment(# do stuff with line)
        reserved(end)
    reserved(end) reserved(rescue) ident(abort)operator(()string<delimiter(")content(can't open %s)delimiter(")> operator(%) ident(filename)operator(\))
reserved(end)

comment(# globbing is done in the Dir module)
pre_constant(ARGV) operator(=) constant(Dir)operator([)string<delimiter(")content(*.[Cch])delimiter(")>operator(]) reserved(if) pre_constant(ARGV)operator(.)ident(empty?)

comment(# note: optparse is the preferred way to handle this)
reserved(if) operator(()pre_constant(ARGV)operator([)integer(0)operator(]) operator(==) string<delimiter(')content(-c)delimiter(')>operator(\))
    ident(chop_first) operator(+=) integer(1)
    pre_constant(ARGV)operator(.)ident(shift)
reserved(end)


comment(# processing numerical options)
reserved(if) pre_constant(ARGV)operator([)integer(0)operator(]) operator(=)operator(~) regexp<delimiter(/)content(^-()char(\\d)content(+\)$)delimiter(/)>
    ident(columns) operator(=) global_variable($1)
    pre_constant(ARGV)operator(.)ident(shift)
reserved(end)

comment(# again, better to use optparse:)
ident(require) string<delimiter(')content(optparse)delimiter(')>
ident(nostdout) operator(=) integer(0)
ident(append) operator(=) integer(0)
ident(unbuffer) operator(=) integer(0)
ident(ignore_ints) operator(=) integer(0)
pre_constant(ARGV)operator(.)ident(options) reserved(do) operator(|)ident(opt)operator(|)
    ident(opt)operator(.)ident(on)operator(()string<delimiter(')content(-n)delimiter(')>operator(\)) operator({) ident(nostdout) operator(+=)integer(1) operator(})
    ident(opt)operator(.)ident(on)operator(()string<delimiter(')content(-a)delimiter(')>operator(\)) operator({) ident(append)   operator(+=)integer(1) operator(})
    ident(opt)operator(.)ident(on)operator(()string<delimiter(')content(-u)delimiter(')>operator(\)) operator({) ident(unbuffer) operator(+=)integer(1) operator(})
    ident(opt)operator(.)ident(on)operator(()string<delimiter(')content(-i)delimiter(')>operator(\)) operator({) ident(ignore_ints) operator(+=)integer(1) operator(})
    ident(opt)operator(.)ident(parse!)
reserved(end) reserved(or) ident(abort)operator(()string<delimiter(")content(usage: )delimiter(")> operator(+) pre_constant(__FILE__) operator(+) string<delimiter(")content( [-ainu] [filenames])delimiter(")>operator(\))

comment(# no need to do undef $/, we have File.read)
ident(str) operator(=) constant(File)operator(.)ident(read)operator(()pre_constant(ARGV)operator([)integer(0)operator(])operator(\))

comment(# again we have File.read)
ident(str) operator(=) constant(File)operator(.)ident(read)operator(()pre_constant(ARGV)operator([)integer(0)operator(])operator(\))

comment(# not sure what this should do:)
comment(# I believe open the file, print filename, lineno and line:)
pre_constant(ARGF)operator(.)ident(each_with_index) reserved(do) operator(|)ident(line)operator(,) ident(idx)operator(|)
    ident(print) pre_constant(ARGF)operator(.)ident(filename)operator(,) string<delimiter(")content(:)delimiter(")>operator(,) ident(idx)operator(,) string<delimiter(")content(;)delimiter(")>operator(,) ident(line)
reserved(end)

comment(# print all the lines in every file passed via command line that contains login)
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(puts) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)content(login)delimiter(/)>
reserved(end)
comment(#)
comment(# even this would fit)
comment(#%ruby -ne "print if /f/" 2.log)
comment(#)

pre_constant(ARGF)operator(.)ident(each) operator({) operator(|)ident(l)operator(|) ident(puts) ident(l)operator(.)ident(downcase!) operator(})

comment(#------------------)
comment(#!/usr/bin/ruby -p)
comment(# just like perl's -p)
global_variable($_)operator(.)ident(downcase!)
comment(#)

comment(# I don't know who should I trust.)
comment(# perl's version splits on \\w+ while python's on \\w.)

ident(chunks) operator(=) integer(0)

constant(File)operator(.)ident(read)operator(()pre_constant(ARGV)operator([)integer(0)operator(])operator(\))operator(.)ident(split)operator(.)ident(each) reserved(do) operator(|)ident(word)operator(|)
    reserved(next) reserved(if) ident(word) operator(=)operator(~) regexp<delimiter(/)content(^#)delimiter(/)>
    reserved(break) reserved(if) operator([)string<delimiter(")content(__DATA__)delimiter(")>operator(,) string<delimiter(")content(__END__)delimiter(")>operator(])operator(.)ident(member?) ident(word)
    ident(chunks) operator(+=) integer(1)
reserved(end)

ident(print) string<delimiter(")content(Found )delimiter(")>operator(,) ident(chunks)operator(,) string<delimiter(")content( chunks)char(\\n)delimiter(")>


comment(# @@PLEAC@@_7.8)
ident(old) operator(=) constant(File)operator(.)ident(open)operator(()ident(old_file)operator(\))
ident(new) operator(=) constant(File)operator(.)ident(open)operator(()ident(new_file)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
reserved(while) ident(old)operator(.)ident(gets) reserved(do)
    comment(# change $_, then...)
    ident(new)operator(.)ident(print) global_variable($_)
reserved(end)
ident(old)operator(.)ident(close)
ident(new)operator(.)ident(close)
constant(File)operator(.)ident(rename)operator(()ident(old_file)operator(,) string<delimiter(")content(old.orig)delimiter(")>operator(\))
constant(File)operator(.)ident(rename)operator(()ident(new_file)operator(,) ident(old_file)operator(\))

reserved(while) ident(old)operator(.)ident(gets) reserved(do)
    reserved(if) global_variable($.) operator(==) integer(20) reserved(then) comment(# we are at the 20th line)
        ident(new)operator(.)ident(puts) string<delimiter(")content(Extra line 1)delimiter(")>
        ident(new)operator(.)ident(puts) string<delimiter(")content(Extra line 2)delimiter(")>
    reserved(end)
    ident(new)operator(.)ident(print) global_variable($_)
reserved(end)

reserved(while) ident(old)operator(.)ident(gets) reserved(do)
    reserved(next) reserved(if) integer(20)operator(..)integer(30) comment(# skip the 20th line to the 30th)
                   comment(# Ruby (and Perl\) permit to write if 20..30)
                   comment(# instead of if (20 <= $.\) and ($. <= 30\))
    ident(new)operator(.)ident(print) global_variable($_)
reserved(end)


comment(# @@PLEAC@@_7.9)
comment(#% ruby -i.orig -pe 'FILTER COMMAND' file1 file2 file3 ...)
comment(#)
comment(#-----------------------------)
comment(##!/usr/bin/ruby -i.orig -p)
comment(# filter commands go here)
comment(#-----------------------------)

comment(#% ruby -pi.orig -e 'gsub!(/DATE/\){Time.now\)')

comment(# effectively becomes:)
pre_constant(ARGV) operator(<<) string<delimiter(')content(I)delimiter(')>
ident(oldfile) operator(=) string<delimiter(")delimiter(")>
reserved(while) ident(gets)
    reserved(if) pre_constant(ARGF)operator(.)ident(filename) operator(!=) ident(oldfile)
        ident(newfile) operator(=) pre_constant(ARGF)operator(.)ident(filename)
        constant(File)operator(.)ident(rename)operator(()ident(newfile)operator(,) ident(newfile) operator(+) string<delimiter(")content(.orig)delimiter(")>operator(\))
        global_variable($stdout) operator(=) constant(File)operator(.)ident(open)operator(()ident(newfile)operator(,)string<delimiter(')content(w)delimiter(')>operator(\))
        ident(oldfile) operator(=) ident(newfile)
    reserved(end)
    ident(gsub!)operator(()regexp<delimiter(/)content(DATE)delimiter(/)>operator(\))operator({)constant(Time)operator(.)ident(now)operator(})
    ident(print)
reserved(end)
global_variable($stdout) operator(=) constant(STDOUT)
comment(#-----------------------------)
comment(#% ruby -i.old -pe 'gsub!(%r{\\bhisvar\\b}, 'hervar'\)' *.[Cchy])

comment(#-----------------------------)
comment(# set up to iterate over the *.c files in the current directory,)
comment(# editing in place and saving the old file with a .orig extension)
global_variable($-i) operator(=) string<delimiter(')content(.orig)delimiter(')>                       comment(# set up -i mode)
pre_constant(ARGV)operator(.)ident(replace)operator(()constant(Dir)operator([)string<delimiter(')content(*.[Cchy])delimiter(')>operator(])operator(\))
reserved(while) ident(gets)
    reserved(if) global_variable($.) operator(==) integer(1)
        ident(print) string<delimiter(")content(This line should appear at the top of each file)char(\\n)delimiter(")>
    reserved(end)
    ident(gsub!)operator(()regexp<delimiter(/)char(\\b)content((p\)earl)char(\\b)delimiter(/)modifier(i)>operator(,) string<delimiter(')content(\\1)content(erl)delimiter(')>operator(\))    comment(# Correct typos, preserving case)
    ident(print)
    pre_constant(ARGF)operator(.)ident(close) reserved(if) pre_constant(ARGF)operator(.)ident(eof)
reserved(end)


comment(# @@PLEAC@@_7.10)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(itest)delimiter(')>operator(,) string<delimiter(')content(r+)delimiter(')>operator(\)) reserved(do) operator(|)ident(f)operator(|)   comment(# open file for update)
    ident(lines) operator(=) ident(f)operator(.)ident(readlines)           comment(# read into array of lines)
    ident(lines)operator(.)ident(each) reserved(do) operator(|)ident(it)operator(|)            comment(# modify lines)
        ident(it)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(foo)delimiter(/)>operator(,) string<delimiter(')content(QQQ)delimiter(')>operator(\))
    reserved(end)
    ident(f)operator(.)ident(pos) operator(=) integer(0)                     comment(# back to start)
    ident(f)operator(.)ident(print) ident(lines)                 comment(# write out modified lines)
    ident(f)operator(.)ident(truncate)operator(()ident(f)operator(.)ident(pos)operator(\))             comment(# truncate to new length)
reserved(end)                               comment(# file is automatically closed)
comment(#-----------------------------)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(itest)delimiter(')>operator(,) string<delimiter(')content(r+)delimiter(')>operator(\)) reserved(do) operator(|)ident(f)operator(|)
    ident(out) operator(=) string<delimiter(")delimiter(")>
    ident(f)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
        ident(out) operator(<<) ident(line)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(DATE)delimiter(/)>operator(\)) operator({)constant(Time)operator(.)ident(now)operator(})
    reserved(end)
    ident(f)operator(.)ident(pos) operator(=) integer(0)
    ident(f)operator(.)ident(print) ident(out)
    ident(f)operator(.)ident(truncate)operator(()ident(f)operator(.)ident(pos)operator(\))
reserved(end)

comment(# @@PLEAC@@_7.11)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(infile)delimiter(')>operator(,) string<delimiter(')content(r+)delimiter(')>operator(\)) reserved(do) operator(|)ident(f)operator(|)
    ident(f)operator(.)ident(flock) constant(File)operator(::)constant(LOCK_EX)
    comment(# update file)
reserved(end)
comment(#-----------------------------)
constant(File)operator(::)constant(LOCK_SH)     comment(# shared lock (for reading\))
constant(File)operator(::)constant(LOCK_EX)     comment(# exclusive lock (for writing\))
constant(File)operator(::)constant(LOCK_NB)     comment(# non-blocking request)
constant(File)operator(::)constant(LOCK_UN)     comment(# free lock)
comment(#-----------------------------)
reserved(unless) ident(f)operator(.)ident(flock) constant(File)operator(::)constant(LOCK_EX) operator(|) constant(File)operator(::)constant(LOCK_NB)
    ident(warn) string<delimiter(")content(can't get immediate lock: blocking ...)delimiter(")>
    ident(f)operator(.)ident(flock) constant(File)operator(::)constant(LOCK_EX)
reserved(end)
comment(#-----------------------------)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(numfile)delimiter(')>operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(CREAT)operator(\)) reserved(do) operator(|)ident(f)operator(|)
    ident(f)operator(.)ident(flock)operator(()constant(File)operator(::)constant(LOCK_EX)operator(\))
    ident(num) operator(=) ident(f)operator(.)ident(gets)operator(.)ident(to_i) operator(||) integer(0)
    ident(f)operator(.)ident(pos) operator(=) integer(0)
    ident(f)operator(.)ident(truncate) integer(0)
    ident(f)operator(.)ident(puts) ident(num) operator(+) integer(1)ident(q)
reserved(end)


comment(# @@PLEAC@@_7.12)
ident(output_handle)operator(.)ident(sync) operator(=) pre_constant(true)
comment(# Please note that like in Perl, $stderr is already unbuffered)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# seeme - demo stdio output buffering)
global_variable($stdout)operator(.)ident(sync) operator(=) pre_constant(ARGV)operator(.)ident(size) operator(>) integer(0)
ident(print) string<delimiter(")content(Now you don't see it...)delimiter(")>
ident(sleep) integer(2)
ident(puts) string<delimiter(")content(now you do)delimiter(")>
comment(#-----------------------------)
global_variable($stderr)operator(.)ident(sync) operator(=) pre_constant(true)
ident(afile)operator(.)ident(sync) operator(=) pre_constant(false)
comment(#-----------------------------)
comment(# assume 'remote_con' is an interactive socket handle,)
comment(# but 'disk_file' is a handle to a regular file.)
ident(remote_con)operator(.)ident(sync) operator(=) pre_constant(true)       comment(# unbuffer for clarity)
ident(disk_file)operator(.)ident(sync) operator(=) pre_constant(false)       comment(# buffered for speed)
comment(#-----------------------------)
ident(require) string<delimiter(')content(socket)delimiter(')>
ident(sock) operator(=) constant(TCPSocket)operator(.)ident(new)operator(()string<delimiter(')content(www.ruby-lang.org)delimiter(')>operator(,) integer(80)operator(\))
ident(sock)operator(.)ident(sync) operator(=) pre_constant(true)
ident(sock)operator(.)ident(puts) string<delimiter(")content(GET /en/ HTTP/1.0 )char(\\n)char(\\n)delimiter(")>
ident(resp) operator(=) ident(sock)operator(.)ident(read)
ident(print) string<delimiter(")content(DOC IS: )inline<delimiter(#{)ident(resp)delimiter(})>char(\\n)delimiter(")>


comment(# @@PLEAC@@_7.13)
comment(#-----------------------------)
comment(# assumes fh1, fh2, fh2 are oen IO objects)
ident(nfound) operator(=) ident(select)operator(()operator([)global_variable($stdin)operator(,) ident(fh1)operator(,) ident(fh2)operator(,) ident(fh3)operator(])operator(,) pre_constant(nil)operator(,) pre_constant(nil)operator(,) integer(0)operator(\))
ident(nfound)operator([)integer(0)operator(])operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
    reserved(case) ident(file)
        reserved(when) ident(fh1)
            comment(# do something with fh1)
        reserved(when) ident(fh2)
            comment(# do something with fh2)
        reserved(when) ident(fh3)
            comment(# do something with fh3)
    reserved(end)
reserved(end)
comment(#-----------------------------)
ident(input_files) operator(=) operator([)operator(])
comment(# repeat next line for all in-files to poll)
ident(input_files) operator(<<) ident(fh1)
reserved(if) ident(nfound) operator(=) ident(select)operator(()ident(input_files)operator(,) pre_constant(nil)operator(,) pre_constant(nil)operator(,) integer(0)operator(\))
    comment(# input ready on files in nfound[0])
reserved(end)


comment(# @@PLEAC@@_8.0)
comment(#-----------------------------)
comment(# datafile is a file or IO object)
ident(datafile)operator(.)ident(readlines)operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
    ident(line)operator(.)ident(chomp!)
    ident(size) operator(=) ident(line)operator(.)ident(length)
    ident(puts) ident(size)
operator(})
comment(#-----------------------------)
ident(datafile)operator(.)ident(readlines)operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
    ident(puts) ident(line)operator(.)ident(chomp!)operator(.)ident(length)
operator(})
comment(#-----------------------------)
ident(lines) operator(=) ident(datafile)operator(.)ident(readlines)
comment(#-----------------------------)
ident(whole_file) operator(=) ident(file)operator(.)ident(read)
comment(#-----------------------------)
comment(# ruby -040 -e 'word = gets; puts "First word is #{word}"')
comment(#-----------------------------)
comment(# ruby -ne 'BEGIN { $/="%%\\n" }; $_.chomp; puts $_ if( $_=~/Unix/i\)' fortune.dat)
comment(#-----------------------------)
ident(handle)operator(.)ident(print) string<delimiter(")content(one)delimiter(")>operator(,) string<delimiter(")content(two)delimiter(")>operator(,) string<delimiter(")content(three)delimiter(")> comment(# "onetwothree")
ident(puts) string<delimiter(")content(Baa baa black sheep.)delimiter(")>        comment(# sent to $stdout)
comment(#-----------------------------)
ident(buffer) operator(=) ident(handle)operator(.)ident(read)operator(()integer(4096)operator(\))
ident(rv)     operator(=) ident(buffer)operator(.)ident(length)
comment(#-----------------------------)
ident(handle)operator(.)ident(truncate)operator(()ident(length)operator(\))
ident(open)operator(()string<delimiter(")content(/tmp)inline<delimiter(#{)global_variable($$)delimiter(})>content(.pid)delimiter(")>operator(,) string<delimiter(')content(w)delimiter(')>operator(\)) operator({) operator(|)ident(handle)operator(|) ident(handle)operator(.)ident(truncate)operator(()ident(length)operator(\)) operator(})
comment(#-----------------------------)
ident(pos) operator(=) ident(datafile)operator(.)ident(pos)  comment(# tell is an alias of pos)
ident(puts) string<delimiter(")content(I'm )inline<delimiter(#{)ident(pos)delimiter(})>content( bytes from the start of datafile)delimiter(")>
comment(#-----------------------------)
ident(logfile)operator(.)ident(seek)operator(()integer(0)operator(,) constant(IO)operator(::)constant(SEEK_END)operator(\))
ident(datafile)operator(.)ident(seek)operator(()ident(pos)operator(\))  comment(#  IO::SEEK_SET is the default)
ident(out)operator(.)ident(seek)operator(()operator(-)integer(20)operator(,) constant(IO)operator(::)constant(SEEK_CUR)operator(\))
comment(#-----------------------------)
ident(written) operator(=) ident(datafile)operator(.)ident(syswrite)operator(()ident(mystring)operator(\))
ident(raise) constant(RunTimeError) reserved(unless) ident(written) operator(==) ident(mystring)operator(.)ident(length)
ident(block) operator(=) ident(infile)operator(.)ident(sysread)operator(()integer(256)operator(\))   comment(# no equivalent to perl offset parameter in sysread)
ident(puts) string<delimiter(")content(only read )inline<delimiter(#{)ident(block)operator(.)ident(length)delimiter(})>content( bytes)delimiter(")> reserved(if) integer(256) operator(!=) ident(block)operator(.)ident(length)
comment(#-----------------------------)
ident(pos) operator(=) ident(handle)operator(.)ident(sysseek)operator(()integer(0)operator(,) constant(IO)operator(::)constant(SEEK_CUR)operator(\))  comment(# don't change position)


comment(# @@PLEAC@@_8.1)
reserved(while) operator(()ident(line) operator(=) ident(fh)operator(.)ident(gets)operator(\))
    ident(line)operator(.)ident(chomp!)
    ident(nextline) operator(=) pre_constant(nil)
    ident(line)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\\\)content($)delimiter(/)>operator(\)) operator({) operator(|)ident(match)operator(|) ident(nextline) operator(=) ident(fh)operator(.)ident(gets)operator(;) string<delimiter(')delimiter(')> operator(})
    reserved(if) operator(()ident(nextline) operator(!=) pre_constant(nil)operator(\))
        ident(line) operator(+=) ident(nextline)
        reserved(redo)
    reserved(end)
    comment(# process full record in line here)
reserved(end)
comment(#-----------------------------)
comment(# DISTFILES = $(DIST_COMMON\) $(SOURCES\) $(HEADERS\) \\)
comment(#         $(TEXINFOS\) $(INFOS\) $(MANS\) $(DATA\))
comment(# DEP_DISTFILES = $(DIST_COMMON\) $(SOURCES\) $(HEADERS\) \\)
comment(#         $(TEXINFOS\) $(INFO_DEPS\) $(MANS\) $(DATA\) \\)
comment(#         $(EXTRA_DIST\))
comment(#-----------------------------)
ident(line)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\\\)char(\\s)content(*$)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\)) operator({)
    comment(# as before)
operator(})


comment(# @@PLEAC@@_8.2)
comment(#-----------------------------)
ident(count) operator(=) shell<delimiter(`)content(wc -l < )inline<delimiter(#{)ident(filename)delimiter(})>delimiter(`)>
ident(fail) string<delimiter(")content(wc failed: )inline<delimiter(#{)global_variable($?)delimiter(})>delimiter(")> reserved(if) global_variable($?) operator(!=) integer(0)
ident(count)operator(.)ident(chomp!)
comment(#-----------------------------)
ident(count) operator(=) integer(0)
constant(File)operator(.)ident(open)operator(()ident(file)operator(,) string<delimiter(')content(r)delimiter(')>operator(\)) operator({) operator(|)ident(fh)operator(|)
    ident(count) operator(+=) integer(1) reserved(while) ident(fh)operator(.)ident(gets)
operator(})
comment(# count now holds the number of lines read)
comment(#-----------------------------)
ident(count) operator(=) integer(0)
reserved(while) operator(()ident(chunk) operator(=) ident(file)operator(.)ident(sysread)operator(()integer(2)operator(**)integer(16)operator(\))operator(\))
    ident(count) operator(+=) ident(chunk)operator(.)ident(count)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))
reserved(end) reserved(rescue) constant(EOFError)
comment(#-----------------------------)
constant(File)operator(.)ident(open)operator(()ident(filename)operator(,)string<delimiter(')content(r)delimiter(')>operator(\)) operator({) operator(|)ident(fh)operator(|)
    ident(count) operator(+=) integer(1) reserved(while) ident(fh)operator(.)ident(gets)
operator(})
comment(# count now holds the number of lines read)
comment(#-----------------------------)
comment(# As ruby doesn't quite have an equivalent to using a for)
comment(# statement as in perl, I threw this in)
ident(count) operator(=) constant(File)operator(.)ident(readlines)operator(()ident(filename)operator(\))operator(.)ident(size)
comment(#-----------------------------)
integer(1) reserved(while) ident(file)operator(.)ident(gets)
ident(count) operator(=) global_variable($.)
comment(#-----------------------------)
global_variable($/) operator(=) string<delimiter(')delimiter(')>
ident(open)operator(()ident(filename)operator(,) string<delimiter(')content(r)delimiter(')>operator(\)) operator({) operator(|)ident(fh)operator(|)
    integer(1) reserved(while) ident(fh)operator(.)ident(gets)
    ident(para_count) operator(=) global_variable($.)
operator(}) reserved(rescue) ident(fail)operator(()string<delimiter(")content(can't open )inline<delimiter(#{)ident(filename)delimiter(})>content(: $!)delimiter(")>operator(\))
comment(#-----------------------------)


comment(# ^^PLEAC^^_8.3)
comment(#-----------------------------)
reserved(while) operator(()ident(gets)operator(\))
    ident(split)operator(.)ident(each) operator({) operator(|)ident(chunk)operator(|)
        comment(# do something with chunk)
    operator(})
reserved(end)
comment(#-----------------------------)
reserved(while) operator(()ident(gets)operator(\))
    ident(gsub)operator(()regexp<delimiter(/)content(()char(\\w)content([)char(\\w)content('-]*\))delimiter(/)>operator(\)) operator({) operator(|)ident(word)operator(|)
        comment(# do something with word)
    operator(})
reserved(end)
comment(#-----------------------------)
comment(# Make a word frequency count)
comment(# normally hashes can be created using {} or just Hash.new)
comment(# but we want the default value of an entry to be 0 instead)
comment(# of nil. (nil can't be incremented\))
ident(seen) operator(=) constant(Hash)operator(.)ident(new)operator(()integer(0)operator(\))
reserved(while) operator(()ident(gets)operator(\))
    ident(gsub)operator(()regexp<delimiter(/)content(()char(\\w)content([)char(\\w)content('-]*\))delimiter(/)>operator(\)) operator({) operator(|)ident(word)operator(|)
        ident(seen)operator([)ident(word)operator(.)ident(downcase)operator(]) operator(+=) integer(1)
    operator(})
reserved(end)
comment(# output hash in a descending numeric sort of its values)
ident(seen)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(b)operator([)integer(1)operator(]) operator(<=>) ident(a)operator([)integer(1)operator(]) operator(})operator(.)ident(each) reserved(do) operator(|)ident(k)operator(,)ident(v)operator(|)
    ident(printf)operator(()string<delimiter(")content(%5d %s)char(\\n)delimiter(")>operator(,) ident(v)operator(,) ident(k) operator(\))
reserved(end)

comment(#-----------------------------)
comment(# Line frequency count)
ident(seen) operator(=) constant(Hash)operator(.)ident(new)operator(()integer(0)operator(\))
reserved(while) operator(()ident(gets)operator(\))
    ident(seen)operator([)global_variable($_)operator(.)ident(downcase)operator(]) operator(+=) integer(1)
reserved(end)
ident(seen)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(b)operator([)integer(1)operator(]) operator(<=>) ident(a)operator([)integer(1)operator(]) operator(})operator(.)ident(each) reserved(do) operator(|)ident(k)operator(,)ident(v)operator(|)
    ident(printf)operator(()string<delimiter(")content(%5d %s)char(\\n)delimiter(")>operator(,) ident(v)operator(,) ident(k) operator(\))
reserved(end)
comment(#-----------------------------)


comment(# @@PLEAC@@_8.4)
comment(#-----------------------------)
comment(# instead of file handle FILE, we can just)
comment(# use a string containing the filename)
constant(File)operator(.)ident(readlines)operator(()ident(file)operator(\))operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
    comment(# do something with line)
operator(})
comment(#-----------------------------)
constant(File)operator(.)ident(readlines)operator(()ident(file)operator(\))operator(.)ident(reverse_each) operator({) operator(|)ident(line)operator(|)
    comment(# do something with line)
operator(})
comment(#-----------------------------)
comment(# the variable lines might have been created)
comment(# this way)
comment(# lines = File.readlines(file\))
comment(#)
comment(# normally one would use the reverse_each, but)
comment(# if you insist on using a numerical index to)
comment(# iterate over the lines array...)
operator(()ident(lines)operator(.)ident(size) operator(-) integer(1)operator(\))operator(.)ident(downto)operator(()integer(0)operator(\)) operator({) operator(|)ident(i)operator(|)
    ident(line) operator(=) ident(lines)operator([)ident(i)operator(])
operator(})
comment(#-----------------------------)
comment(# the second readlines argument is a the)
comment(# record separator $/, just like perl, a blank)
comment(# separator splits the records into paragraphs)
constant(File)operator(.)ident(readlines)operator(()ident(file)operator(,) string<delimiter(')delimiter(')>operator(\))operator(.)ident(each) operator({) operator(|)ident(paragraph)operator(|)
    comment(# do something with paragraph)
    ident(puts) string<delimiter(")content(->Paragraph )inline<delimiter(#{)ident(paragraph)delimiter(})>delimiter(")>
operator(})
comment(#-----------------------------)


comment(# @@PLEAC@@_8.6)

global_variable($/) operator(=) string<delimiter(")content(%)char(\\n)delimiter(")>operator(;)
ident(srand)operator(;)

constant(File)operator(.)ident(open)operator(()string<delimiter(')content(/usr/share/fortune/humorists)delimiter(')>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(adage) operator(=) ident(line) reserved(if) ident(rand)operator(()global_variable($.)operator(\)) operator(<) integer(1)
reserved(end)

ident(puts) ident(adage)operator(;)


comment(# @@PLEAC@@_8.10)
reserved(begin)
    ident(fh) operator(=) constant(File)operator(.)ident(open)operator(()ident(file)operator(,) string<delimiter(")content(r+)delimiter(")>operator(\))
    ident(addr) operator(=) ident(fh)operator(.)ident(tell) reserved(unless) ident(fh)operator(.)ident(eof) reserved(while) ident(fh)operator(.)ident(gets)
    ident(fh)operator(.)ident(truncate)operator(()ident(addr)operator(\))
reserved(rescue) constant(SystemCallError)
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")escape(#)global_variable($!)delimiter(")>
reserved(end)


comment(# @@PLEAC@@_9.0)
ident(entry) operator(=) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(/usr/bin/vi)delimiter(")>operator(\))
ident(entry) operator(=) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(/usr/bin)delimiter(")>operator(\))
ident(entry) operator(=) constant(File)operator(.)ident(stat)operator(()constant(INFILE)operator(\))

ident(entry) operator(=) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(/usr/bin/vi)delimiter(")>operator(\))
ident(ctime) operator(=) ident(entry)operator(.)ident(ctime)
ident(size)  operator(=) ident(entry)operator(.)ident(size)

ident(f) operator(=) constant(File)operator(.)ident(open)operator(()ident(filename)operator(,) string<delimiter(")content(r)delimiter(")>operator(\))

comment(## There is no -T equivalent in Ruby, but we can still test emptiness)
reserved(if) ident(test)operator(()integer(?s)operator(,) ident(filename)operator(\))
  ident(puts) string<delimiter(")inline<delimiter(#{)ident(filename)delimiter(})>content( doesn't have text in it.)delimiter(")>
  ident(exit)
reserved(end)

constant(Dir)operator(.)ident(new)operator(()string<delimiter(")content(/usr/bin)delimiter(")>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(filename)operator(|)
  ident(puts) string<delimiter(")content(Inside /usr/bin is something called )inline<delimiter(#{)ident(filename)delimiter(})>delimiter(")>
reserved(end)


comment(# @@PLEAC@@_9.1)
ident(file) operator(=) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(filename)delimiter(")>operator(\))
ident(readtime)operator(,) ident(writetime) operator(=) ident(file)operator(.)ident(atime)operator(,) ident(file)operator(.)ident(mtime)
ident(file)operator(.)ident(utime)operator(()ident(readtime)operator(,) ident(writetime)operator(\))

constant(SECONDS_PER_DAY) operator(=) integer(60) operator(*) integer(60) operator(*) integer(24)
ident(file) operator(=) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(filename)delimiter(")>operator(\))
ident(atime)operator(,) ident(mtime) operator(=) ident(file)operator(.)ident(atime)operator(,) ident(file)operator(.)ident(mtime)

ident(atime) operator(-=) integer(7) operator(*) constant(SECONDS_PER_DAY)
ident(mtime) operator(-=) integer(7) operator(*) constant(SECONDS_PER_DAY)

constant(File)operator(.)ident(utime)operator(()ident(atime)operator(,) ident(mtime)operator(,) ident(file)operator(\))
ident(mtime) operator(=) constant(File)operator(.)ident(stat)operator(()ident(file)operator(\))operator(.)ident(mtime)
constant(File)operator(.)ident(utime)operator(()constant(Time)operator(.)ident(new)operator(,) ident(mtime)operator(,) ident(file)operator(\))
constant(File)operator(.)ident(utime)operator(()constant(Time)operator(.)ident(new)operator(,) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(testfile)delimiter(")>operator(\))operator(.)ident(mtime)operator(,) ident(file)operator(\))

comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(## uvi - vi a file without changing it's access times)

reserved(if) pre_constant(ARGV)operator(.)ident(length) operator(!=) integer(1)
  ident(puts) string<delimiter(")content(usage: uvi filename)delimiter(")>
  ident(exit)
reserved(end)
ident(file) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
ident(atime)operator(,) ident(mtime) operator(=) constant(File)operator(.)ident(stat)operator(()ident(file)operator(\))operator(.)ident(atime)operator(,) constant(File)operator(.)ident(stat)operator(()ident(file)operator(\))operator(.)ident(mtime)
ident(system)operator(()constant(ENV)operator([)string<delimiter(")content(EDITOR)delimiter(")>operator(]) operator(||) string<delimiter(")content(vi)delimiter(")>operator(,) ident(file)operator(\))
constant(File)operator(.)ident(utime)operator(()ident(atime)operator(,) ident(mtime)operator(,) ident(file)operator(\))
comment(#-----------------------------)


comment(# @@PLEAC@@_9.2)
constant(File)operator(.)ident(unlink)operator(()constant(FILENAME)operator(\))

ident(err_flg) operator(=) pre_constant(false)
ident(filenames)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
  reserved(begin)
    constant(File)operator(.)ident(unlink)operator(()ident(file)operator(\))
  reserved(rescue)
    ident(err_flg) operator(=) global_variable($!)
  reserved(end)
reserved(end)
ident(err_flg) reserved(and) ident(raise) string<delimiter(")content(Couldn't unlink all of )inline<delimiter(#{)ident(filenames)operator(.)ident(join)operator(()string<delimiter(")content( )delimiter(")>operator(\))delimiter(})>content(: )inline<delimiter(#{)ident(err_flg)delimiter(})>delimiter(")>

constant(File)operator(.)ident(unlink)operator(()ident(file)operator(\))

ident(count) operator(=) ident(filenames)operator(.)ident(length)
ident(filenames)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
  reserved(begin)
    constant(File)operator(.)ident(unlink)operator(()ident(file)operator(\))
  reserved(rescue)
    ident(count) operator(-=) integer(1)
  reserved(end)
reserved(end)
reserved(if) ident(count) operator(!=) ident(filenames)operator(.)ident(length)
  constant(STDERR)operator(.)ident(puts) string<delimiter(")content(could only delete )inline<delimiter(#{)ident(count)delimiter(})>content( of )inline<delimiter(#{)ident(filenames)operator(.)ident(length)delimiter(})>content( files)delimiter(")>
reserved(end)


comment(# @@PLEAC@@_9.3)
ident(require) string<delimiter(")content(ftools)delimiter(")>
constant(File)operator(.)ident(copy)operator(()ident(oldfile)operator(,) ident(newfile)operator(\))

ident(infile)  operator(=) constant(File)operator(.)ident(open)operator(()ident(oldfile)operator(,) string<delimiter(")content(r)delimiter(")>operator(\))
ident(outfile) operator(=) constant(File)operator(.)ident(open)operator(()ident(newfile)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))

ident(blksize) operator(=) ident(infile)operator(.)ident(stat)operator(.)ident(blksize)
comment(# This doesn't handle partial writes or ^Z)
comment(# like the Perl version does.)
reserved(while) operator(()ident(line) operator(=) ident(infile)operator(.)ident(read)operator(()ident(blksize)operator(\))operator(\))
  ident(outfile)operator(.)ident(write)operator(()ident(line)operator(\))
reserved(end)

ident(infile)operator(.)ident(close)
ident(outfile)operator(.)ident(close)

ident(system)operator(()string<delimiter(")content(cp )inline<delimiter(#{)ident(oldfile)delimiter(})>content( )inline<delimiter(#{)ident(newfile)delimiter(})>delimiter(")>operator(\))    comment(# unix)
ident(system)operator(()string<delimiter(")content(copy )inline<delimiter(#{)ident(oldfile)delimiter(})>content( )inline<delimiter(#{)ident(newfile)delimiter(})>delimiter(")>operator(\))  comment(# dos, vms)

ident(require) string<delimiter(")content(ftools)delimiter(")>
constant(File)operator(.)ident(copy)operator(()string<delimiter(")content(datafile.dat)delimiter(")>operator(,) string<delimiter(")content(datafile.bak)delimiter(")>operator(\))
constant(File)operator(.)ident(move)operator(()string<delimiter(")content(datafile.new)delimiter(")>operator(,) string<delimiter(")content(datafile.dat)delimiter(")>operator(\))


comment(# @@PLEAC@@_9.4)
global_variable($seen) operator(=) operator({)operator(}) comment(# must use global var to be seen inside of method below)

reserved(def) method(do_my_thing)operator(()ident(filename)operator(\))
    ident(dev)operator(,) ident(ino) operator(=) constant(File)operator(.)ident(stat)operator(()ident(filename)operator(\))operator(.)ident(dev)operator(,) constant(File)operator(.)ident(stat)operator(()ident(filename)operator(\))operator(.)ident(ino)
    reserved(unless) global_variable($seen)operator([)operator([)ident(dev)operator(,) ident(ino)operator(])operator(])
        comment(# do something with $filename because we haven't)
        comment(# seen it before)
    reserved(end)
    global_variable($seen)operator([)operator([)ident(dev)operator(,) ident(ino)operator(])operator(]) operator(=) global_variable($seen)operator([)operator([)ident(dev)operator(,) ident(ino)operator(])operator(])operator(.)ident(to_i) operator(+) integer(1)
reserved(end)

ident(files)operator(.)ident(each) reserved(do) operator(|)ident(filename)operator(|)
    ident(dev)operator(,) ident(ino) operator(=) constant(File)operator(.)ident(stat)operator(()ident(filename)operator(\))operator(.)ident(dev)operator(,) constant(File)operator(.)ident(stat)operator(()ident(filename)operator(\))operator(.)ident(ino)
    reserved(if) operator(!)global_variable($seen)operator(.)ident(has_key?)operator(()operator([)ident(dev)operator(,) ident(ino)operator(])operator(\))
        global_variable($seen)operator([)operator([)ident(dev)operator(,) ident(ino)operator(])operator(]) operator(=) operator([)operator(])
    reserved(end)
    global_variable($seen)operator([)operator([)ident(dev)operator(,) ident(ino)operator(])operator(])operator(.)ident(push)operator(()ident(filename)operator(\))
reserved(end)

global_variable($seen)operator(.)ident(keys)operator(.)ident(sort)operator(.)ident(each) reserved(do) operator(|)ident(devino)operator(|)
    ident(ino)operator(,) ident(dev) operator(=) ident(devino)
    reserved(if) global_variable($seen)operator([)ident(devino)operator(])operator(.)ident(length) operator(>) integer(1)
        comment(# $seen[devino] is a list of filenames for the same file)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_9.5)
constant(Dir)operator(.)ident(open)operator(()ident(dirname)operator(\)) reserved(do) operator(|)ident(dir)operator(|)
    ident(dir)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
        comment(# do something with dirname/file)
        ident(puts) ident(file)
    reserved(end)
reserved(end)
comment(# Dir.close is automatic)

comment(# No -T equivalent in Ruby)

ident(dir)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
    reserved(next) reserved(if) ident(file) operator(=)operator(~) regexp<delimiter(/)content(^)char(\\.)char(\\.)content(?$)delimiter(/)>
    comment(# ...)
reserved(end)

reserved(def) method(plainfiles)operator(()ident(dir)operator(\))
    ident(dh) operator(=) constant(Dir)operator(.)ident(open)operator(()ident(dir)operator(\))
    ident(dh)operator(.)ident(entries)operator(.)ident(grep)operator(()regexp<delimiter(/)content(^[^.])delimiter(/)>operator(\))operator(.)
        ident(map)      operator({)operator(|)ident(file)operator(|) string<delimiter(")inline<delimiter(#{)ident(dir)delimiter(})>content(/)inline<delimiter(#{)ident(file)delimiter(})>delimiter(")>operator(})operator(.)
        ident(find_all) operator({)operator(|)ident(file)operator(|) ident(test)operator(()integer(?f)operator(,) ident(file)operator(\))operator(})operator(.)
        ident(sort)
reserved(end)


comment(# @@PLEAC@@_9.6)
ident(list) operator(=) constant(Dir)operator(.)ident(glob)operator(()string<delimiter(")content(*.c)delimiter(")>operator(\))

ident(dir) operator(=) constant(Dir)operator(.)ident(open)operator(()ident(path)operator(\))
ident(files) operator(=) ident(dir)operator(.)ident(entries)operator(.)ident(grep)operator(()regexp<delimiter(/)char(\\.)content(c$)delimiter(/)>operator(\))
ident(dir)operator(.)ident(close)

ident(files) operator(=) constant(Dir)operator(.)ident(glob)operator(()string<delimiter(")content(*.c)delimiter(")>operator(\))
ident(files) operator(=) constant(Dir)operator(.)ident(open)operator(()ident(path)operator(\))operator(.)ident(entries)operator(.)ident(grep)operator(()regexp<delimiter(/)char(\\.)content([ch]$)delimiter(/)modifier(i)>operator(\))

ident(dir) operator(=) constant(Dir)operator(.)ident(new)operator(()ident(path)operator(\))
ident(files) operator(=) ident(dir)operator(.)ident(entries)operator(.)ident(grep)operator(()regexp<delimiter(/)char(\\.)content([ch]$)delimiter(/)modifier(i)>operator(\))

reserved(begin)
  ident(d) operator(=) constant(Dir)operator(.)ident(open)operator(()ident(dir)operator(\))
reserved(rescue) constant(Errno)operator(::)constant(ENOENT)
  ident(raise) string<delimiter(")content(Couldn't open )inline<delimiter(#{)ident(dir)delimiter(})>content( for reading: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(end)

ident(files) operator(=) operator([)operator(])
ident(d)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
  ident(puts) ident(file)
  reserved(next) reserved(unless) ident(file) operator(=)operator(~) regexp<delimiter(/)char(\\.)content([ch]$)delimiter(/)modifier(i)>

  ident(filename) operator(=) string<delimiter(")inline<delimiter(#{)ident(dir)delimiter(})>content(/)inline<delimiter(#{)ident(file)delimiter(})>delimiter(")>
  comment(# There is no -T equivalent in Ruby, but we can still test emptiness)
  ident(files)operator(.)ident(push)operator(()ident(filename)operator(\)) reserved(if) ident(test)operator(()integer(?s)operator(,) ident(filename)operator(\))
reserved(end)

ident(dirs)operator(.)ident(entries)operator(.)ident(grep)operator(()regexp<delimiter(/)content(^)char(\\d)content(+$)delimiter(/)>operator(\))operator(.)
             ident(map)    operator({) operator(|)ident(file)operator(|) operator([)ident(file)operator(,) string<delimiter(")inline<delimiter(#{)ident(path)delimiter(})>content(/)inline<delimiter(#{)ident(file)delimiter(})>delimiter(")>operator(])operator(}) operator(.)
             ident(select) operator({) operator(|)ident(file)operator(|) ident(test)operator(()integer(?d)operator(,) ident(file)operator([)integer(1)operator(])operator(\)) operator(})operator(.)
             ident(sort)   operator({) operator(|)ident(a)operator(,)ident(b)operator(|)  ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})operator(.)
             ident(map)    operator({) operator(|)ident(file)operator(|) ident(file)operator([)integer(1)operator(]) operator(})


comment(# @@PLEAC@@_9.7)
ident(require) string<delimiter(')content(find)delimiter(')>
constant(Find)operator(.)ident(find)operator(()ident(dirlist)operator(\)) reserved(do) operator(|)ident(file)operator(|)
  comment(# do whatever)
reserved(end)

ident(require) string<delimiter(')content(find)delimiter(')>
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) string<delimiter(%w{)content(.)delimiter(})> operator(:) pre_constant(ARGV)
constant(Find)operator(.)ident(find)operator(()operator(*)ident(argv)operator(\)) reserved(do) operator(|)ident(file)operator(|)
  ident(print) ident(file)operator(,) operator(()ident(test)operator(()integer(?d)operator(,) ident(file)operator(\)) operator(?) string<delimiter(")content(/)char(\\n)delimiter(")> operator(:) string<delimiter(")char(\\n)delimiter(")>operator(\))
reserved(end)

ident(require) string<delimiter(')content(find)delimiter(')>
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) string<delimiter(%w{)content(.)delimiter(})> operator(:) pre_constant(ARGV)
ident(sum) operator(=) integer(0)
constant(Find)operator(.)ident(find)operator(()operator(*)ident(argv)operator(\)) reserved(do) operator(|)ident(file)operator(|)
  ident(size) operator(=) ident(test)operator(()integer(?s)operator(,) ident(file)operator(\)) operator(||) integer(0)
  ident(sum) operator(+=) ident(size)
reserved(end)
ident(puts) string<delimiter(")inline<delimiter(#{)ident(argv)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>content( contains )inline<delimiter(#{)ident(sum)delimiter(})>content( bytes)delimiter(")>

ident(require) string<delimiter(')content(find)delimiter(')>
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) string<delimiter(%w{)content(.)delimiter(})> operator(:) pre_constant(ARGV)
ident(saved_size)operator(,) ident(saved_name) operator(=) operator(-)integer(1)operator(,) string<delimiter(")delimiter(")>
constant(Find)operator(.)ident(find)operator(()operator(*)ident(argv)operator(\)) reserved(do) operator(|)ident(file)operator(|)
  ident(size) operator(=) ident(test)operator(()integer(?s)operator(,) ident(file)operator(\)) operator(||) integer(0)
  reserved(next) reserved(unless) ident(test)operator(()integer(?f)operator(,) ident(file)operator(\)) operator(&&) ident(size) operator(>) ident(saved_size)
  ident(saved_size) operator(=) ident(size)
  ident(saved_name) operator(=) ident(file)
reserved(end)
ident(puts) string<delimiter(")content(Biggest file )inline<delimiter(#{)ident(saved_name)delimiter(})>content( in )inline<delimiter(#{)ident(argv)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>content( is )inline<delimiter(#{)ident(saved_size)delimiter(})>delimiter(")>

ident(require) string<delimiter(')content(find)delimiter(')>
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) string<delimiter(%w{)content(.)delimiter(})> operator(:) pre_constant(ARGV)
ident(age)operator(,) ident(name) operator(=) pre_constant(nil)
constant(Find)operator(.)ident(find)operator(()operator(*)ident(argv)operator(\)) reserved(do) operator(|)ident(file)operator(|)
  ident(mtime) operator(=) constant(File)operator(.)ident(stat)operator(()ident(file)operator(\))operator(.)ident(mtime)
  reserved(next) reserved(if) ident(age) operator(&&) ident(age) operator(>) ident(mtime)
  ident(age) operator(=) ident(mtime)
  ident(name) operator(=) ident(file)
reserved(end)
ident(puts) string<delimiter(")inline<delimiter(#{)ident(name)delimiter(})>content( )inline<delimiter(#{)ident(age)delimiter(})>delimiter(")>

comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# fdirs - find all directories)
ident(require) string<delimiter(')content(find)delimiter(')>
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) string<delimiter(%w{)content(.)delimiter(})> operator(:) pre_constant(ARGV)
constant(File)operator(.)ident(find)operator(()operator(*)ident(argv)operator(\)) operator({) operator(|)ident(file)operator(|) ident(puts) ident(file) reserved(if) ident(test)operator(()integer(?d)operator(,) ident(file)operator(\)) operator(})
comment(#-----------------------------)


comment(# @@PLEAC@@_9.8)
ident(require) string<delimiter(')content(fileutils)delimiter(')>

ident(puts) string<delimiter(")content(Usage )inline<delimiter(#{)global_variable($0)delimiter(})>content( dir ...)delimiter(")> reserved(if) pre_constant(ARGV)operator(.)ident(empty?)
pre_constant(ARGV)operator(.)ident(each) reserved(do) operator(|)ident(dir)operator(|)
  constant(FileUtils)operator(.)ident(rmtree)operator(()ident(dir)operator(\))
reserved(end)


comment(# @@PLEAC@@_9.9)
ident(require) string<delimiter(')content(ftools)delimiter(')>
ident(names)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
  ident(newname) operator(=) ident(file)
  reserved(begin)
    constant(File)operator(.)ident(move)operator(()ident(file)operator(,) ident(newname)operator(\))
  reserved(rescue) constant(Errno)operator(::)constant(EPERM)
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(Couldn't rename )inline<delimiter(#{)ident(file)delimiter(})>content( to )inline<delimiter(#{)ident(newname)delimiter(})>content(: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
  reserved(end)
reserved(end)

ident(require) string<delimiter(')content(ftools)delimiter(')>
ident(op) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) operator(()ident(raise) string<delimiter(")content(Usage: rename expr [files])char(\\n)delimiter(")>operator(\)) operator(:) pre_constant(ARGV)operator(.)ident(shift)
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) global_variable($stdin)operator(.)ident(readlines)operator(.)ident(map) operator({) operator(|)ident(f)operator(|) ident(f)operator(.)ident(chomp) operator(}) operator(:) pre_constant(ARGV)
ident(argv)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
  ident(was) operator(=) ident(file)
  ident(file) operator(=) ident(eval)operator(()string<delimiter(")content(file.)inline<delimiter(#{)ident(op)delimiter(})>delimiter(")>operator(\))
  constant(File)operator(.)ident(move)operator(()ident(was)operator(,) ident(file)operator(\)) reserved(unless) ident(was) operator(==) ident(file)
reserved(end)


comment(# @@PLEAC@@_9.10)
ident(base) operator(=) constant(File)operator(.)ident(basename)operator(()ident(path)operator(\))
ident(dir)  operator(=) constant(File)operator(.)ident(dirname)operator(()ident(path)operator(\))
comment(# ruby has no fileparse equivalent)
ident(dir)operator(,) ident(base) operator(=) constant(File)operator(.)ident(split)operator(()ident(path)operator(\))
ident(ext) operator(=) ident(base)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\.)content(.*$)delimiter(/)>operator(\))operator(.)ident(to_s)

ident(path) operator(=) string<delimiter(')content(/usr/lib/libc.a)delimiter(')>
ident(file) operator(=) constant(File)operator(.)ident(basename)operator(()ident(path)operator(\))
ident(dir)  operator(=) constant(File)operator(.)ident(dirname)operator(()ident(path)operator(\))

ident(puts) string<delimiter(")content(dir is )inline<delimiter(#{)ident(dir)delimiter(})>content(, file is )inline<delimiter(#{)ident(file)delimiter(})>delimiter(")>
comment(# dir is /usr/lib, file is libc.a)

ident(path) operator(=) string<delimiter(')content(/usr/lib/libc.a)delimiter(')>
ident(dir)operator(,) ident(filename) operator(=) constant(File)operator(.)ident(split)operator(()ident(path)operator(\))
ident(name)operator(,) ident(ext) operator(=) ident(filename)operator(.)ident(split)operator(()regexp<delimiter(/)content((?=)char(\\.)content(\))delimiter(/)>operator(\))
ident(puts) string<delimiter(")content(dir is )inline<delimiter(#{)ident(dir)delimiter(})>content(, name is )inline<delimiter(#{)ident(name)delimiter(})>content(, ext is )inline<delimiter(#{)ident(ext)delimiter(})>delimiter(")>
comment(#   NOTE: The Ruby code prints)
comment(#   dir is /usr/lib, name is libc, extension is .a)
comment(#     while the Perl code prints a '/' after the directory name)
comment(#   dir is /usr/lib/, name is libc, extension is .a)

comment(# No fileparse_set_fstype(\) equivalent in ruby)

reserved(def) method(extension)operator(()ident(path)operator(\))
    ident(ext) operator(=) ident(path)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\.)content(.*$)delimiter(/)>operator(\))operator(.)ident(to_s)
    ident(ext)operator(.)ident(sub)operator(()regexp<delimiter(/)content(^)char(\\.)delimiter(/)>operator(,) string<delimiter(")delimiter(")>operator(\))
reserved(end)


comment(# @@PLEAC@@_9.11)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# symirror - build spectral forest of symlinks)

ident(require) string<delimiter(')content(find)delimiter(')>
ident(require) string<delimiter(')content(fileutils)delimiter(')>

ident(raise) string<delimiter(")content(usage: )inline<delimiter(#{)global_variable($0)delimiter(})>content( realdir mirrordir)delimiter(")> reserved(unless) pre_constant(ARGV)operator(.)ident(size) operator(==) integer(2)

ident(srcdir)operator(,)ident(dstdir) operator(=) pre_constant(ARGV)
ident(srcmode) operator(=) constant(File)operator(::)ident(stat)operator(()ident(srcdir)operator(\))operator(.)ident(mode)
constant(Dir)operator(.)ident(mkdir)operator(()ident(dstdir)operator(,) ident(srcmode) operator(&) integer(07777)operator(\)) reserved(unless) ident(test)operator(()integer(?d)operator(,) ident(dstdir)operator(\))

comment(# fix relative paths)
constant(Dir)operator(.)ident(chdir)operator(()ident(srcdir)operator(\)) operator({)ident(srcdir) operator(=) constant(Dir)operator(.)ident(pwd)operator(})
constant(Dir)operator(.)ident(chdir)operator(()ident(dstdir)operator(\)) operator({)ident(dstdir) operator(=) constant(Dir)operator(.)ident(pwd)operator(})

constant(Find)operator(.)ident(find)operator(()ident(srcdir)operator(\)) reserved(do) operator(|)ident(srcfile)operator(|)
    reserved(if) ident(test)operator(()integer(?d)operator(,) ident(srcfile)operator(\))
        ident(dest) operator(=) ident(srcfile)operator(.)ident(sub)operator(()regexp<delimiter(/)content(^)inline<delimiter(#{)ident(srcdir)delimiter(})>delimiter(/)>operator(,) ident(dstdir)operator(\))
        ident(dmode) operator(=) constant(File)operator(::)ident(stat)operator(()ident(srcfile)operator(\))operator(.)ident(mode) operator(&) integer(07777)
        constant(Dir)operator(.)ident(mkdir)operator(()ident(dest)operator(,) ident(dmode)operator(\)) reserved(unless) ident(test)operator(()integer(?d)operator(,) ident(dest)operator(\))
        ident(a) operator(=) constant(Dir)operator([)string<delimiter(")inline<delimiter(#{)ident(srcfile)delimiter(})>content(/*)delimiter(")>operator(])operator(.)ident(reject)operator({)operator(|)ident(f)operator(|) ident(test)operator(()integer(?d)operator(,) ident(f)operator(\))operator(})
        constant(FileUtils)operator(.)ident(ln_s)operator(()ident(a)operator(,) ident(dest)operator(\))
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_9.12)
comment(# we use the Getopt/Declare library here for convenience:)
comment(#   http://raa.ruby-lang.org/project/getoptdeclare/)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# lst - list sorted directory contents (depth first\))

ident(require) string<delimiter(')content(find)delimiter(')>
ident(require) string<delimiter(')content(etc)delimiter(')>
ident(require) string<delimiter(")content(Getopt/Declare)delimiter(")>

comment(# Note: in the option-spec below there must by at least one hard)
comment(# tab in between each -option and its description. For example)
comment(#    -i <tab> read from stdin)

ident(opts) operator(=) constant(Getopt)operator(::)constant(Declare)operator(.)ident(new)operator(()string<delimiter(<<'EOPARAM')>operator(\))string<content(
    ============
    Input Format:
        -i	read from stdin
    ============
    Output Format:
        -l	long listing
        -r	reverse listing
    ============
    Sort on: (one of\)
        -m	mtime (modify time - default\)
                {$sort_criteria = :mtime}
        -u	atime (access time\)
                {$sort_criteria = :atime}
        -c	ctime (inode change time\)
                {$sort_criteria = :ctime}
        -s	size
                {$sort_criteria = :size}
        [mutex: -m -u -c -s]
)delimiter(
EOPARAM)>

global_variable($sort_criteria) operator(||=) symbol(:mtime)
ident(files) operator(=) operator({)operator(})
constant(DIRS) operator(=) ident(opts)operator([)string<delimiter(')content(-i)delimiter(')>operator(]) operator(?) global_variable($stdin)operator(.)ident(readlines)operator(.)ident(map)operator({)operator(|)ident(f)operator(|)ident(f)operator(.)ident(chomp!)operator(}) operator(:) pre_constant(ARGV)
constant(DIRS)operator(.)ident(each) reserved(do) operator(|)ident(dir)operator(|)
    constant(Find)operator(.)ident(find)operator(()ident(dir)operator(\)) reserved(do) operator(|)ident(ent)operator(|)
        ident(files)operator([)ident(ent)operator(]) operator(=) constant(File)operator(::)ident(stat)operator(()ident(ent)operator(\))
    reserved(end)
reserved(end)
ident(entries) operator(=) ident(files)operator(.)ident(keys)operator(.)ident(sort_by)operator({)operator(|)ident(f)operator(|) ident(files)operator([)ident(f)operator(])operator(.)ident(send)operator(()global_variable($sort_criteria)operator(\))operator(})
ident(entries) operator(=) ident(entries)operator(.)ident(reverse) reserved(unless) ident(opts)operator([)string<delimiter(')content(-r)delimiter(')>operator(])

ident(entries)operator(.)ident(each) reserved(do) operator(|)ident(ent)operator(|)
    reserved(unless) ident(opts)operator([)string<delimiter(')content(-l)delimiter(')>operator(])
        ident(puts) ident(ent)
        reserved(next)
    reserved(end)
    ident(stats) operator(=) ident(files)operator([)ident(ent)operator(])
    ident(ftime) operator(=) ident(stats)operator(.)ident(send)operator(()global_variable($sort_criteria) operator(==) symbol(:size) operator(?) symbol(:mtime) operator(:) global_variable($sort_criteria)operator(\))
    ident(printf) string<delimiter(")content(%6d %04o %6d %8s %8s %8d %s %s)char(\\n)delimiter(")>operator(,)
        ident(stats)operator(.)ident(ino)operator(,)
        ident(stats)operator(.)ident(mode) operator(&) integer(07777)operator(,)
        ident(stats)operator(.)ident(nlink)operator(,)
        constant(ETC)operator(::)constant(PASSWD)operator([)ident(stats)operator(.)ident(uid)operator(])operator(.)ident(name)operator(,)
        constant(ETC)operator(::)constant(GROUP)operator([)ident(stats)operator(.)ident(gid)operator(])operator(.)ident(name)operator(,)
        ident(stats)operator(.)ident(size)operator(,)
        ident(ftime)operator(.)ident(strftime)operator(()string<delimiter(")content(%a %b %d %H:%M:%S %Y)delimiter(")>operator(\))operator(,)
        ident(ent)
reserved(end)


comment(# @@PLEAC@@_10.0)
reserved(def) method(hello)
    global_variable($greeted) operator(+=) integer(1)      comment(# in Ruby, a variable beginning with $ is global (can be any type of course\))
    ident(puts) string<delimiter(")content(hi there!)delimiter(")>
reserved(end)

comment(# We need to initialize $greeted before it can be used, because "+=" is waiting a Numeric object)
global_variable($greeted) operator(=) integer(0)
ident(hello)                  comment(# note that appending (\) is optional to function calls with no parameters)


comment(# @@PLEAC@@_10.1)
comment(# In Ruby, parameters are named anyway)
reserved(def) method(hypotenuse)operator(()ident(side1)operator(,) ident(side2)operator(\))
    constant(Math)operator(.)ident(sqrt)operator(()ident(side1)operator(**)integer(2) operator(+) ident(side2)operator(**)integer(2)operator(\))    comment(# the sqrt function comes from the Math module)
reserved(end)
ident(diag) operator(=) ident(hypotenuse)operator(()integer(3)operator(,) integer(4)operator(\))

ident(puts) ident(hypotenuse)operator(()integer(3)operator(,) integer(4)operator(\))

ident(a) operator(=) operator([)integer(3)operator(,) integer(4)operator(])
ident(print) ident(hypotenuse)operator(()operator(*)ident(a)operator(\))                  comment(# the star operator will magically convert an Array into a "tuple")

ident(both) operator(=) ident(men) operator(+) ident(women)

comment(# In Ruby, all objects are references, so the same problem arises; we then return a new object)
ident(nums) operator(=) operator([)float(1.4)operator(,) float(3.5)operator(,) float(6.7)operator(])
reserved(def) method(int_all)operator(()ident(n)operator(\))
    ident(n)operator(.)ident(collect) operator({) operator(|)ident(v)operator(|) ident(v)operator(.)ident(to_i) operator(})
reserved(end)
ident(ints) operator(=) ident(int_all)operator(()ident(nums)operator(\))

ident(nums) operator(=) operator([)float(1.4)operator(,) float(3.5)operator(,) float(6.7)operator(])
reserved(def) method(trunc_em)operator(()ident(n)operator(\))
    ident(n)operator(.)ident(collect!) operator({) operator(|)ident(v)operator(|) ident(v)operator(.)ident(to_i) operator(})         comment(# the bang-version of collect modifies the object)
reserved(end)
ident(trunc_em)operator(()ident(nums)operator(\))

comment(# Ruby has two chomp version:)
comment(# ``chomp'' chomps the record separator and returns what's expected)
comment(# ``chomp!'' does the same but also modifies the parameter object)


comment(# @@PLEAC@@_10.2)
reserved(def) method(somefunc)
    ident(variable) operator(=) ident(something)  comment(# variable is local by default)
reserved(end)

ident(name)operator(,) ident(age) operator(=) pre_constant(ARGV)
ident(start)     operator(=) ident(fetch_time)

ident(a)operator(,) ident(b) operator(=) ident(pair)               comment(# will succeed if pair is an Array object (like ARGV is\))
ident(c) operator(=) ident(fetch_time)

comment(# In ruby, run_check can't access a, b, or c until they are)
comment(# explicitely defined global (using leading $\), even if they are)
comment(# both defined in the same scope)

reserved(def) method(check_x)operator(()ident(x)operator(\))
    ident(y) operator(=) string<delimiter(")content(whatever)delimiter(")>
    ident(run_check)
    reserved(if) global_variable($condition)
        ident(puts) string<delimiter(")content(got $x)delimiter(")>
    reserved(end)
reserved(end)

comment(# The following will keep a reference to the array, though the)
comment(# results will be slightly different from perl: the last element)
comment(# of $global_array will be itself an array)
reserved(def) method(save_array)operator(()ident(ary)operator(\))
    global_variable($global_array) operator(<<) ident(ary)
reserved(end)

comment(# The following gives the same results as in Perl for $global_array,)
comment(# though it doesn't illustrate anymore the way to keep a reference)
comment(# to an object: $global_array is extended with the elements of ary)
reserved(def) method(save_array)operator(()ident(ary)operator(\))
    global_variable($global_array) operator(+=) ident(ary)
reserved(end)


comment(# @@PLEAC@@_10.3)
comment(# In Ruby, AFAIK a method cannot access "local variables" defined)
comment(# upper scope; mostly because everything is an object, so you'll)
comment(# do the same by defining an attribute or a static attribute)

comment(# In Ruby the BEGIN also exists:)
reserved(BEGIN) operator({) ident(puts) string<delimiter(")content(hello from BEGIN)delimiter(")> operator(})
ident(puts) string<delimiter(")content(hello from main)delimiter(")>
reserved(BEGIN) operator({) ident(puts) string<delimiter(")content(hello from 2nd BEGIN)delimiter(")> operator(})
comment(# gives:)
comment(#   hello from BEGIN)
comment(#   hello from 2nd BEGIN)
comment(#   hello from main)

comment(# In Ruby, it can be written as a static method and a static)
comment(# variable)
reserved(class) class(Counter)
    class_variable(@@counter) operator(=) integer(0)
    reserved(def) constant(Counter)operator(.)ident(next_counter)operator(;) class_variable(@@counter) operator(+=) integer(1)operator(;) reserved(end)
reserved(end)

comment(# There is no need of BEGIN since the variable will get)
comment(# initialized when parsing)
reserved(class) class(Counter)
    class_variable(@@counter) operator(=) integer(42)
    reserved(def) constant(Counter)operator(.)ident(next_counter)operator(;) class_variable(@@counter) operator(+=) integer(1)operator(;) reserved(end)
    reserved(def) constant(Counter)operator(.)ident(prev_counter)operator(;) class_variable(@@counter) operator(-=) integer(1)operator(;) reserved(end)
reserved(end)


comment(# @@PLEAC@@_10.4)
comment(# You can either get the whole trace as an array of strings, each)
comment(# string telling which file, line and method is calling:)
ident(caller)

comment(# ...or only the last caller)
ident(caller)operator([)integer(0)operator(])

comment(# We need to extract just the method name of the backtrace:)
reserved(def) method(whoami)operator(;)  ident(caller)operator(()operator(\))operator([)integer(0)operator(]) operator(=)operator(~) regexp<delimiter(/)content(in `([^']+\)')delimiter(/)> operator(?) global_variable($1) operator(:) string<delimiter(')content((anonymous\))delimiter(')>operator(;) reserved(end)
reserved(def) method(whowasi)operator(;) ident(caller)operator(()operator(\))operator([)integer(1)operator(]) operator(=)operator(~) regexp<delimiter(/)content(in `([^']+\)')delimiter(/)> operator(?) global_variable($1) operator(:) string<delimiter(')content((anonymous\))delimiter(')>operator(;) reserved(end)


comment(# @@PLEAC@@_10.5)
comment(# In Ruby, every value is a reference on an object, thus there is)
comment(# no such problem)
ident(array_diff)operator(()ident(array1)operator(,) ident(array2)operator(\))

reserved(def) method(add_vecpair)operator(()ident(a1)operator(,) ident(a2)operator(\))
    ident(results) operator(=) operator([)operator(])
    ident(a1)operator(.)ident(each_index) operator({) operator(|)ident(i)operator(|) ident(results) operator(<<) operator(()ident(a1)operator([)ident(i)operator(]) operator(+) ident(a2)operator([)ident(i)operator(])operator(\)) operator(})
    ident(results)
reserved(end)
ident(a) operator(=) operator([)integer(1)operator(,) integer(2)operator(])
ident(b) operator(=) operator([)integer(5)operator(,) integer(8)operator(])
ident(c) operator(=) ident(add_vecpair)operator(()ident(a)operator(,) ident(b)operator(\))
ident(p) ident(c)

comment(# Add this to the beginning of the function to check if we were)
comment(# given two arrays)
ident(a1)operator(.)ident(type) operator(==) constant(Array) operator(&&) ident(a2)operator(.)ident(type) operator(==) constant(Array) reserved(or)
    ident(raise) string<delimiter(")content(usage: add_vecpair array1 array2 (was used with: )inline<delimiter(#{)ident(a1)operator(.)ident(type)delimiter(})>content( )inline<delimiter(#{)ident(a2)operator(.)ident(type)delimiter(})>content(\))delimiter(")>


comment(# @@PLEAC@@_10.6)
comment(# There is no return context in Ruby)


comment(# @@PLEAC@@_10.7)
comment(# Like in Perl, we need to fake with a hash, but it's dirty :-()
reserved(def) method(thefunc)operator(()ident(param_args)operator(\))
    ident(args) operator(=) operator({) string<delimiter(')content(INCREMENT)delimiter(')> operator(=)operator(>) string<delimiter(')content(10s)delimiter(')>operator(,) string<delimiter(')content(FINISH)delimiter(')> operator(=)operator(>) string<delimiter(')content(0)delimiter(')>operator(,) string<delimiter(')content(START)delimiter(')> operator(=)operator(>) integer(0) operator(})
    ident(args)operator(.)ident(update)operator(()ident(param_args)operator(\))
    reserved(if) operator(()ident(args)operator([)string<delimiter(')content(INCREMENT)delimiter(')>operator(])  operator(=)operator(~) regexp<delimiter(/)content(m$)delimiter(/)> operator(\))
        comment(# .....)
    reserved(end)
reserved(end)

ident(thefunc)operator(()operator({) string<delimiter(')content(INCREMENT)delimiter(')> operator(=)operator(>) string<delimiter(')content(20s)delimiter(')>operator(,) string<delimiter(')content(START)delimiter(')> operator(=)operator(>) string<delimiter(')content(+5m)delimiter(')>operator(,) string<delimiter(')content(FINISH)delimiter(')> operator(=)operator(>) string<delimiter(')content(+30m)delimiter(')> operator(})operator(\))
ident(thefunc)operator(()operator({)operator(})operator(\))


comment(# @@PLEAC@@_10.8)
comment(# there is no "undef" direct equivalent but there is the slice equiv:)
ident(a)operator(,) ident(c) operator(=) ident(func)operator(.)ident(indexes)operator(()integer(0)operator(,) integer(2)operator(\))


comment(# @@PLEAC@@_10.9)
comment(# Ruby has no such limitation:)
reserved(def) method(somefunc)
    ident(ary) operator(=) operator([)operator(])
    ident(hash) operator(=) operator({)operator(})
    comment(# ...)
    reserved(return) ident(ary)operator(,) ident(hash)
reserved(end)
ident(arr)operator(,) ident(dict) operator(=) ident(somefunc)

ident(array_of_hashes) operator(=) ident(fn)
ident(h1)operator(,) ident(h2)operator(,) ident(h3)      operator(=) ident(fn)


comment(# @@PLEAC@@_10.10)
reserved(return)
comment(# or (equivalent\))
reserved(return) pre_constant(nil)


comment(# @@PLEAC@@_10.11)
comment(# You can't prototype in Ruby regarding types :-()
comment(# Though, you can force the number of arguments:)
reserved(def) method(func_with_no_arg)operator(;) reserved(end)
reserved(def) method(func_with_no_arg)operator(()operator(\))operator(;) reserved(end)
reserved(def) method(func_with_one_arg)operator(()ident(a1)operator(\))operator(;) reserved(end)
reserved(def) method(func_with_two_args)operator(()ident(a1)operator(,) ident(a2)operator(\))operator(;) reserved(end)
reserved(def) method(func_with_any_number_of_args)operator(()operator(*)ident(args)operator(\))operator(;) reserved(end)


comment(# @@PLEAC@@_10.12)
ident(raise) string<delimiter(")content(some message)delimiter(")>        comment(# raise exception)

reserved(begin)
    ident(val) operator(=) ident(func)
reserved(rescue) constant(Exception) operator(=)operator(>) ident(msg)
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(func raised an exception: )inline<delimiter(#{)ident(msg)delimiter(})>delimiter(")>
reserved(end)

comment(# In Ruby the rescue statement uses an exception class, every)
comment(# exception which is not matched is still continuing)
reserved(begin)
    ident(val) operator(=) ident(func)
reserved(rescue) constant(FullMoonError)
    operator(...)
reserved(end)


comment(# @@PLEAC@@_10.13)
comment(# Saving Global Values)
comment(# Of course we can just save the value and restore it later:)
reserved(def) method(print_age)
    ident(puts) string<delimiter(")content(Age is )inline<delimiter(#{)global_variable($age)delimiter(})>delimiter(")>
reserved(end)

global_variable($age) operator(=) integer(18)         comment(# global variable)
ident(print_age)operator(()operator(\))
reserved(if) ident(condition)
    ident(safeage) operator(=) global_variable($age)
    global_variable($age) operator(=) integer(23)
    ident(print_age)operator(()operator(\))
    global_variable($age) operator(=) ident(safeage)
reserved(end)

comment(# We can also use a method that saves the global variable and)
comment(# restores it automatically when the block is left:)

reserved(def) method(local)operator(()ident(var)operator(\))
    ident(eval)operator(()string<delimiter(")content(save = )inline<delimiter(#{)ident(var)operator(.)ident(id2name)delimiter(})>delimiter(")>operator(\))
    reserved(begin)
        ident(result) operator(=) reserved(yield)
    reserved(ensure)
        comment(# we want to call this even if we got an exception)
        ident(eval)operator(()string<delimiter(")inline<delimiter(#{)ident(var)operator(.)ident(id2name)delimiter(})>content( = save)delimiter(")>operator(\))
    reserved(end)
    ident(result)
reserved(end)

ident(condition) operator(=) pre_constant(true)
global_variable($age) operator(=) integer(18)
ident(print_age)operator(()operator(\))
reserved(if) ident(condition)
    ident(local)operator(()symbol(:$age)operator(\)) operator({)
        global_variable($age) operator(=) integer(23)
        ident(print_age)operator(()operator(\))
    operator(})
reserved(end)
ident(print_age)operator(()operator(\))

comment(# There is no need to use local(\) for filehandles or directory)
comment(# handles in ruby because filehandles are normal objects.)


comment(# @@PLEAC@@_10.14)
comment(# In Ruby you may redefine a method [but not overload it :-(])
comment(# just by defining again with the same name.)
reserved(def) method(foo)operator(;) ident(puts) string<delimiter(')content(foo)delimiter(')>operator(;) reserved(end)
reserved(def) method(foo)operator(;) ident(puts) string<delimiter(')content(bar)delimiter(')>operator(;) reserved(end)
ident(foo)
comment(#=> bar)

comment(# You can also take a reference to an existing method before)
comment(# redefining a new one, using the `alias' keyword)
reserved(def) method(foo)operator(;) ident(puts) string<delimiter(')content(foo)delimiter(')>operator(;) reserved(end)
reserved(alias) ident(foo_orig) ident(foo)
reserved(def) method(foo)operator(;) ident(puts) string<delimiter(')content(bar)delimiter(')>operator(;) reserved(end)
ident(foo_orig)
ident(foo)
comment(#=> foo)
comment(#=> bar)

comment(# AFAIK, there is no direct way to create a new method whose name)
comment(# comes from a variable, so use "eval")
ident(colors) operator(=) string<delimiter(%w()content(red blue green yellow orange purple violet)delimiter(\))>
ident(colors)operator(.)ident(each) operator({) operator(|)ident(c)operator(|)
    ident(eval) string<delimiter(<<-EOS)>string<content(
    def )inline<delimiter(#{)ident(c)delimiter(})>content((*a\)
        "<FONT COLOR=')inline<delimiter(#{)ident(c)delimiter(})>content('>" + a.to_s + "</FONT>"
    end)delimiter(
    EOS)>
operator(})


comment(# @@PLEAC@@_10.15)
reserved(def) method(method_missing)operator(()ident(name)operator(,) operator(*)ident(args)operator(\))
    string<delimiter(")content(<FONT COLOR=')inline<delimiter(#{)ident(name)delimiter(})>content('>)delimiter(")> operator(+) ident(args)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\)) operator(+) string<delimiter(")content(</FONT>)delimiter(")>
reserved(end)
ident(puts) ident(chartreuse)operator(()string<delimiter(")content(stuff)delimiter(")>operator(\))


comment(# @@PLEAC@@_10.16)
reserved(def) method(outer)operator(()ident(arg)operator(\))
    ident(x) operator(=) ident(arg) operator(+) integer(35)
    ident(inner) operator(=) ident(proc) operator({) ident(x) operator(*) integer(19) operator(})
    ident(x) operator(+) ident(inner)operator(.)ident(call)operator(()operator(\))
reserved(end)


comment(# @@PLEAC@@_10.17)
comment(#!/usr/bin/ruby -w)
comment(# mailsort - sort mbox by different criteria)
ident(require) string<delimiter(')content(English)delimiter(')>
ident(require) string<delimiter(')content(Date)delimiter(')>

comment(# Objects of class Mail represent a single mail.)
reserved(class) class(Mail)
    ident(attr_accessor) symbol(:no)
    ident(attr_accessor) symbol(:subject)
    ident(attr_accessor) symbol(:fulltext)
    ident(attr_accessor) symbol(:date)

    reserved(def) method(initialize)
        instance_variable(@fulltext) operator(=) string<delimiter(")delimiter(")>
        instance_variable(@subject) operator(=) string<delimiter(")delimiter(")>
    reserved(end)

    reserved(def) method(append)operator(()ident(para)operator(\))
        instance_variable(@fulltext) operator(<<) ident(para)
    reserved(end)

    comment(# this is called if you call puts(mail\))
    reserved(def) method(to_s)
        instance_variable(@fulltext)
    reserved(end)
reserved(end)

comment(# represents a list of mails.)
reserved(class) class(Mailbox) operator(<) constant(Array)

    constant(Subjectpattern) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(Subject:)content(\\s)content(*(?:Re:)content(\\s)content(*\)*(.*\))content(\\n)delimiter(')>operator(\))
    constant(Datepattern) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(Date:)content(\\s)content(*(.*\))content(\\n)delimiter(')>operator(\))

    comment(# reads mails from open file and stores them)
    reserved(def) method(read)operator(()ident(file)operator(\))
        global_variable($INPUT_RECORD_SEPARATOR) operator(=) string<delimiter(')delimiter(')>  comment(# paragraph reads)
        ident(msgno) operator(=) operator(-)integer(1)
        ident(file)operator(.)ident(each) operator({) operator(|)ident(para)operator(|)
            reserved(if) ident(para) operator(=)operator(~) regexp<delimiter(/)content(^From)delimiter(/)>
                ident(mail) operator(=) constant(Mail)operator(.)ident(new)
                ident(mail)operator(.)ident(no) operator(=) operator(()ident(msgno) operator(+=) integer(1)operator(\))
                ident(md) operator(=) constant(Subjectpattern)operator(.)ident(match)operator(()ident(para)operator(\))
                reserved(if) ident(md)
                    ident(mail)operator(.)ident(subject) operator(=) ident(md)operator([)integer(1)operator(])
                reserved(end)
                ident(md) operator(=) constant(Datepattern)operator(.)ident(match)operator(()ident(para)operator(\))
                reserved(if) ident(md)
                    ident(mail)operator(.)ident(date) operator(=) constant(DateTime)operator(.)ident(parse)operator(()ident(md)operator([)integer(1)operator(])operator(\))
                reserved(else)
                    ident(mail)operator(.)ident(date) operator(=) constant(DateTime)operator(.)ident(now)
                reserved(end)
                pre_constant(self)operator(.)ident(push)operator(()ident(mail)operator(\))
            reserved(end)
            ident(mail)operator(.)ident(append)operator(()ident(para)operator(\)) reserved(if) ident(mail)
        operator(})
    reserved(end)

    reserved(def) method(sort_by_subject_and_no)
        pre_constant(self)operator(.)ident(sort_by) operator({) operator(|)ident(m)operator(|)
            operator([)ident(m)operator(.)ident(subject)operator(,) ident(m)operator(.)ident(no)operator(])
        operator(})
    reserved(end)

    comment(# sorts by a list of attributs of mail, given as symbols)
    reserved(def) method(sort_by_attributs)operator(()operator(*)ident(attrs)operator(\))
        comment(# you can sort an Enumerable by an array of)
        comment(# values, they would be compared)
        comment(# from ary[0] to ary[n]t, say:)
        comment(# ['b',1] > ['a',10] > ['a',9])
        pre_constant(self)operator(.)ident(sort_by) operator({) operator(|)ident(elem)operator(|)
            ident(attrs)operator(.)ident(map) operator({) operator(|)ident(attr)operator(|)
                ident(elem)operator(.)ident(send)operator(()ident(attr)operator(\))
            operator(})
        operator(})
    reserved(end)

reserved(end)

ident(mailbox) operator(=) constant(Mailbox)operator(.)ident(new)
ident(mailbox)operator(.)ident(read)operator(()pre_constant(ARGF)operator(\))

comment(# print only subjects sorted by subject and number)
reserved(for) ident(m) reserved(in) ident(mailbox)operator(.)ident(sort_by_subject_and_no)
    ident(puts)operator(()ident(m)operator(.)ident(subject)operator(\))
reserved(end)

comment(# print complete mails sorted by date, then subject, then number)
reserved(for) ident(m) reserved(in) ident(mailbox)operator(.)ident(sort_by_attributs)operator(()symbol(:date)operator(,) symbol(:subject)operator(\))
    ident(puts)operator(()ident(m)operator(\))
reserved(end)


comment(# @@PLEAC@@_11.7)
reserved(def) method(mkcounter)operator(()ident(count)operator(\))
    ident(start)  operator(=) ident(count)
    ident(bundle) operator(=) operator({)
        string<delimiter(")content(NEXT)delimiter(")>   operator(=)operator(>) ident(proc) operator({) ident(count) operator(+=) integer(1) operator(})operator(,)
        string<delimiter(")content(PREV)delimiter(")>   operator(=)operator(>) ident(proc) operator({) ident(count) operator(-=) integer(1) operator(})operator(,)
        string<delimiter(")content(RESET)delimiter(")>  operator(=)operator(>) ident(proc) operator({) ident(count) operator(=) ident(start) operator(})
    operator(})
    ident(bundle)operator([)string<delimiter(")content(LAST)delimiter(")>operator(]) operator(=) ident(bundle)operator([)string<delimiter(")content(PREV)delimiter(")>operator(])
    reserved(return) ident(bundle)
reserved(end)

ident(c1) operator(=) ident(mkcounter)operator(()integer(20)operator(\))
ident(c2) operator(=) ident(mkcounter)operator(()integer(77)operator(\))

ident(puts) string<delimiter(")content(next c1: )inline<delimiter(#{)ident(c1)operator([)string<delimiter(")content(NEXT)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")>  comment(# 21)
ident(puts) string<delimiter(")content(next c2: )inline<delimiter(#{)ident(c2)operator([)string<delimiter(")content(NEXT)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")>  comment(# 78)
ident(puts) string<delimiter(")content(next c1: )inline<delimiter(#{)ident(c1)operator([)string<delimiter(")content(NEXT)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")>  comment(# 22)
ident(puts) string<delimiter(")content(last c1: )inline<delimiter(#{)ident(c1)operator([)string<delimiter(")content(PREV)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")>  comment(# 21)
ident(puts) string<delimiter(")content(last c1: )inline<delimiter(#{)ident(c1)operator([)string<delimiter(")content(LAST)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")>  comment(# 20)
ident(puts) string<delimiter(")content(old  c2: )inline<delimiter(#{)ident(c2)operator([)string<delimiter(")content(RESET)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")> comment(# 77)


comment(# @@PLEAC@@_11.15)
reserved(class) class(Binary_tree)
    reserved(def) method(initialize)operator(()ident(val)operator(\))
        instance_variable(@value) operator(=) ident(val)
        instance_variable(@left) operator(=) pre_constant(nil)
        instance_variable(@right) operator(=) pre_constant(nil)
    reserved(end)

    comment(# insert given value into proper point of)
    comment(# provided tree.  If no tree provided,)
    comment(# use implicit pass by reference aspect of @_)
    comment(# to fill one in for our caller.)
    reserved(def) method(insert)operator(()ident(val)operator(\))
        reserved(if) ident(val) operator(<) instance_variable(@value) reserved(then)
            reserved(if) instance_variable(@left) reserved(then)
                instance_variable(@left)operator(.)ident(insert)operator(()ident(val)operator(\))
            reserved(else)
                instance_variable(@left) operator(=) constant(Binary_tree)operator(.)ident(new)operator(()ident(val)operator(\))
            reserved(end)
        reserved(elsif) ident(val) operator(>) instance_variable(@value) reserved(then)
            reserved(if) instance_variable(@right) reserved(then)
                instance_variable(@right)operator(.)ident(insert)operator(()ident(val)operator(\))
            reserved(else)
                instance_variable(@right) operator(=) constant(Binary_tree)operator(.)ident(new)operator(()ident(val)operator(\))
            reserved(end)
        reserved(else)
            ident(puts) string<delimiter(")content(double)delimiter(")>
            comment(# do nothing, no double values)
        reserved(end)
    reserved(end)

    comment(# recurse on left child,)
    comment(# then show current value,)
    comment(# then recurse on right child.)
    reserved(def) method(in_order)
        instance_variable(@left)operator(.)ident(in_order) reserved(if) instance_variable(@left)
        ident(print) instance_variable(@value)operator(,) string<delimiter(")content( )delimiter(")>
        instance_variable(@right)operator(.)ident(in_order) reserved(if) instance_variable(@right)
    reserved(end)

    comment(# show current value,)
    comment(# then recurse on left child,)
    comment(# then recurse on right child.)
    reserved(def) method(pre_order)
        ident(print) instance_variable(@value)operator(,) string<delimiter(")content( )delimiter(")>
        instance_variable(@left)operator(.)ident(pre_order) reserved(if) instance_variable(@left)
        instance_variable(@right)operator(.)ident(pre_order) reserved(if) instance_variable(@right)
    reserved(end)

    comment(# recurse on left child,)
    comment(# then recurse on right child,)
    comment(# then show current value.)
    reserved(def) method(post_order)
        instance_variable(@left)operator(.)ident(post_order) reserved(if) instance_variable(@left)
        instance_variable(@right)operator(.)ident(post_order) reserved(if) instance_variable(@right)
        ident(print) instance_variable(@value)operator(,) string<delimiter(")content( )delimiter(")>
    reserved(end)

    comment(# find out whether provided value is in the tree.)
    comment(# if so, return the node at which the value was found.)
    comment(# cut down search time by only looking in the correct)
    comment(# branch, based on current value.)
    reserved(def) method(search)operator(()ident(val)operator(\))
        reserved(if) ident(val) operator(==) instance_variable(@value) reserved(then)
            reserved(return) pre_constant(self)
        reserved(elsif) ident(val) operator(<) instance_variable(@value) reserved(then)
            reserved(return) instance_variable(@left)operator(.)ident(search)operator(()ident(val)operator(\)) reserved(if) instance_variable(@left)
            reserved(return) pre_constant(nil)
        reserved(else)
            reserved(return) instance_variable(@right)operator(.)ident(search)operator(()ident(val)operator(\)) reserved(if) instance_variable(@right)
            reserved(return) pre_constant(nil)
        reserved(end)
    reserved(end)
reserved(end)

comment(# first generate 20 random inserts)
ident(test) operator(=) constant(Binary_tree)operator(.)ident(new)operator(()integer(0)operator(\))
reserved(for) ident(a) reserved(in) integer(0)operator(..)integer(20)
    ident(test)operator(.)ident(insert)operator(()ident(rand)operator(()integer(1000)operator(\))operator(\))
reserved(end)

comment(# now dump out the tree all three ways)
ident(print) string<delimiter(")content(Pre order:  )delimiter(")>operator(;)  ident(test)operator(.)ident(pre_order)operator(;)  ident(puts) string<delimiter(")delimiter(")>
ident(print) string<delimiter(")content(In order:  )delimiter(")>operator(;)  ident(test)operator(.)ident(in_order)operator(;)  ident(puts) string<delimiter(")delimiter(")>
ident(print) string<delimiter(")content(Post order:  )delimiter(")>operator(;)  ident(test)operator(.)ident(post_order)operator(;)  ident(puts) string<delimiter(")delimiter(")>

ident(print) string<delimiter(")content(search?)delimiter(")>
reserved(while) ident(gets)
    ident(print) ident(test)operator(.)ident(search)operator(()global_variable($_)operator(.)ident(to_i)operator(\))
    ident(print) string<delimiter(")char(\\n)content(search?)delimiter(")>
reserved(end)


comment(# @@PLEAC@@_12.0)
comment(# class and module names need to have the first letter capitalized)
reserved(module) class(Alpha)
    constant(NAME) operator(=) string<delimiter(')content(first)delimiter(')>
reserved(end)
reserved(module) class(Omega)
    constant(NAME) operator(=) string<delimiter(')content(last)delimiter(')>
reserved(end)
ident(puts) string<delimiter(")content(Alpha is )inline<delimiter(#{)constant(Alpha)operator(::)constant(NAME)delimiter(})>content(, Omega is )inline<delimiter(#{)constant(Omega)operator(::)constant(NAME)delimiter(})>delimiter(")>

comment(# ruby doesn't differentiate beteen compile-time and run-time)
ident(require) string<delimiter(')content(getoptlong.rb)delimiter(')>
ident(require) string<delimiter(')content(getoptlong)delimiter(')>     comment(# assumes the .rb)
ident(require) string<delimiter(')content(cards/poker.rb)delimiter(')>
ident(require) string<delimiter(')content(cards/poker)delimiter(')>    comment(# assumes the .rb)
ident(load)    string<delimiter(')content(cards/poker)delimiter(')>    comment(# require only loads the file once)

reserved(module) class(Cards)
    reserved(module) class(Poker)
        instance_variable(@card_deck) operator(=) constant(Array)operator(.)ident(new) comment(# or @card_deck = [])
        reserved(def) method(shuffle)
        reserved(end)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_12.1)
comment(# a module exports all of its functions)
reserved(module) class(Your_Module)
    reserved(def) pre_constant(self)operator(.)ident(function)
        comment(# this would be called as Your_Module.function)
    reserved(end)

    reserved(def) constant(Your_Module)operator(.)ident(another)
        comment(# this is the same as above, but more specific)
    reserved(end)
reserved(end)

comment(# @@PLEAC@@_12.2)
reserved(begin)
    ident(require) string<delimiter(')content(nonexistent)delimiter(')>
reserved(rescue) constant(LoadError)
    ident(puts) string<delimiter(")content(Couldn't load )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>  comment(# $! contains the last error string)
reserved(end)

comment(# @@PLEAC@@_12.4)
comment(# module variables are private unless access functions are defined)
reserved(module) class(Alpha)
    instance_variable(@aa) operator(=) integer(10)
    instance_variable(@bb) operator(=) integer(11)

    reserved(def) pre_constant(self)operator(.)ident(put_aa)
        ident(puts) instance_variable(@aa)
    reserved(end)

    reserved(def) pre_constant(self)operator(.)ident(bb)operator(=)operator(()ident(val)operator(\))
        instance_variable(@bb) operator(=) ident(val)
    reserved(end)
reserved(end)

constant(Alpha)operator(.)ident(bb) operator(=) integer(12)
comment(# Alpha.aa = 10 # error, no aa=method)


comment(# @@PLEAC@@_12.5)
comment(# caller provides a backtrace of the call stack)
reserved(module) class(MyModule)
    reserved(def) method(find_caller)
        ident(caller)
    reserved(end)

    reserved(def) method(find_caller2)operator(()ident(i)operator(\))
        ident(caller)operator(()ident(i)operator(\)) comment(# an argument limits the size of the stack returned)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_12.6)
reserved(BEGIN) operator({)
    global_variable($logfile) operator(=) string<delimiter(')content(/tmp/mylog)delimiter(')> reserved(unless) reserved(defined?) global_variable($logfile)
    global_variable($LF) operator(=) constant(File)operator(.)ident(open)operator(()global_variable($logfile)operator(,) string<delimiter(')content(a)delimiter(')>operator(\))
operator(})

reserved(module) class(Logger)
    reserved(def) pre_constant(self)operator(.)ident(logmsg)operator(()ident(msg)operator(\))
        global_variable($LF)operator(.)ident(puts) ident(msg)
    reserved(end)

    ident(logmsg)operator(()string<delimiter(')content(startup)delimiter(')>operator(\))
reserved(end)

reserved(END) operator({)
    constant(Logger)operator(::)ident(logmsg)operator(()string<delimiter(')content(shutdown)delimiter(')>operator(\))
    global_variable($LF)operator(.)ident(close)
operator(})


comment(# @@PLEAC@@_12.7)
comment(#-----------------------------)
comment(# results may be different on your system)
comment(# % ruby -e "$LOAD_PATH.each_index { |i| printf("%d %s\\n", i, $LOAD_PATH[i] })
comment(#0 /usr/local/lib/site_ruby/1.6)
comment(#1 /usr/local/lib/site_ruby/1.6/i386-linux)
comment(#2 /usr/local/lib/site_ruby/)
comment(#3 /usr/lib/ruby/1.6)
comment(#4 /usr/lib/ruby/1.6/i136-linux)
comment(#5 .)
comment(#-----------------------------)
comment(# syntax for sh, bash, ksh, or zsh)
comment(#$ export RUBYLIB=$HOME/rubylib)

comment(# syntax for csh or tcsh)
comment(# % setenv RUBYLIB ~/rubylib)
comment(#-----------------------------)
global_variable($LOAD_PATH)operator(.)ident(unshift) string<delimiter(")content(/projects/spectre/lib)delimiter(")>operator(;)


comment(# @@PLEAC@@_12.8)
comment(# equivalents in ruby are mkmf, SWIG, or Ruby/DL depending on usage)


comment(# @@PLEAC@@_12.9)
comment(# no equivalent in ruby)


comment(# @@PLEAC@@_12.10)
comment(# no equivalent in ruby)


comment(# @@PLEAC@@_12.11)
reserved(module) class(FineTime)
    reserved(def) pre_constant(self)operator(.)ident(time)
        comment(# to be defined later)
    reserved(end)
reserved(end)


reserved(module) class(FineTime)
    reserved(def) pre_constant(self)operator(.)ident(time)
        string<delimiter(")content(its a fine time)delimiter(")>
    reserved(end)
reserved(end)

ident(puts) constant(FineTime)operator(.)ident(time) comment(#=> "its a fine time")


comment(# @@PLEAC@@_12.12)
reserved(def) method(even_only)operator(()ident(n)operator(\))
    ident(raise) string<delimiter(")inline<delimiter(#{)ident(n)delimiter(})>content( is not even)delimiter(")> reserved(if) operator(()ident(n) operator(&) integer(1)operator(\)) operator(!=) integer(0)  comment(# one way to test)
    comment(# ...)
reserved(end)
reserved(def) method(even_only)operator(()ident(n)operator(\))
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")inline<delimiter(#{)ident(n)delimiter(})>content( is not even)delimiter(")> reserved(if) operator(()ident(n) operator(&) integer(1)operator(\)) operator(!=) integer(0)
    comment(# ...)
reserved(end)


comment(# @@PLEAC@@_12.17)
comment(# The library archive for ruby is called Ruby Application archive,)
comment(# or shorter RAA, and can be found at http://raa.ruby-lang.org.)
comment(# A typical library is installed like this:)
comment(# % gunzip some-module-4.54.tar.gz)
comment(# % tar xf some-module-4.54.tar)
comment(# % cd some-module-4.54.tar)
comment(# % ruby install.rb config)
comment(# % ruby install.rb setup)
comment(# get superuser previleges here if needed for next step)
comment(# % ruby install.rb install)

comment(# Some modules use a different process,)
comment(# you should find details in the documentation)
comment(# Here is an example of such a different process)
comment(# % ruby extconf.rb)
comment(# % make)
comment(# % make install)

comment(# If you want the module installed in your own directory:)
comment(# For ruby version specific libraries)
comment(# % ruby install.rb config --site-ruby=~/lib)
comment(# For version independent libraries)
comment(# % ruby install.rb config --site-ruby-common=~/lib)

comment(# Information about possible options for config)
comment(# % ruby install.rb --help)

comment(# If you have your own complete distribution)
comment(# % ruby install.rb --prefix=path=~/ruby-private)


comment(# @@PLEAC@@_13.0)
comment(# Classes and objects in Ruby are rather straigthforward)
reserved(class) class(Person)
    comment(# Class variables (also called static attributes\) are prefixed by @@)
    class_variable(@@person_counter)operator(=)integer(0)

    comment(# object constructor)
    reserved(def) method(initialize)operator(()ident(age)operator(,) ident(name)operator(,) ident(alive) operator(=) pre_constant(true)operator(\))     comment(# Default arg like in C++)
        instance_variable(@age)operator(,) instance_variable(@name)operator(,) instance_variable(@alive) operator(=) ident(age)operator(,) ident(name)operator(,) ident(alive)  comment(# Object attributes are prefixed by '@')
        class_variable(@@person_counter) operator(+=) integer(1)
          comment(# There is no '++' operator in Ruby. The '++'/'--'  operators are in fact)
          comment(# hidden assignments which affect variables, not objects. You cannot accomplish)
          comment(# assignment via method. Since everything in Ruby is object, '++' and '--')
          comment(# contradict Ruby OO ideology. Instead '-=' and '+=' are used.)
    reserved(end)

    ident(attr_accessor) symbol(:name)operator(,) symbol(:age)   comment(# This creates setter and getter methods for @name)
                                comment(# and @age. See 13.3 for detailes.)

    comment(# methods modifying the receiver object usually have the '!' suffix)
    reserved(def) method(die!)
        instance_variable(@alive) operator(=) pre_constant(false)
        ident(puts) string<delimiter(")inline<delimiter(#{)instance_variable(@name)delimiter(})>content( has died at the age of )inline<delimiter(#{)instance_variable(@age)delimiter(})>content(.)delimiter(")>
        instance_variable(@alive)
    reserved(end)

    reserved(def) method(kill)operator(()ident(anotherPerson)operator(\))
        ident(print) instance_variable(@name)operator(,) string<delimiter(')content( is killing )delimiter(')>operator(,) ident(anotherPerson)operator(.)ident(name)operator(,) string<delimiter(")content(.)char(\\n)delimiter(")>
        ident(anotherPerson)operator(.)ident(die!)
    reserved(end)

    comment(# methods used as queries)
    comment(# usually have the '?' suffix)
    reserved(def) method(alive?)
        instance_variable(@alive) operator(&&) pre_constant(true)
    reserved(end)

    reserved(def) method(year_of_birth)
        constant(Time)operator(.)ident(now)operator(.)ident(year) operator(-) instance_variable(@age)
    reserved(end)

    comment(# Class method (also called static method\))
    reserved(def) constant(Person)operator(.)ident(number_of_people)
        class_variable(@@person_counter)
    reserved(end)
reserved(end)

comment(# Using the class:)
comment(# Create objects of class Person)
ident(lecter) operator(=) constant(Person)operator(.)ident(new)operator(()integer(47)operator(,) string<delimiter(')content(Hannibal)delimiter(')>operator(\))
ident(starling) operator(=) constant(Person)operator(.)ident(new)operator(()integer(29)operator(,) string<delimiter(')content(Clarice)delimiter(')>operator(,) pre_constant(true)operator(\))
ident(pazzi) operator(=) constant(Person)operator(.)ident(new)operator(()integer(40)operator(,) string<delimiter(')content(Rinaldo)delimiter(')>operator(,) pre_constant(true)operator(\))

comment(# Calling a class method)
ident(print) string<delimiter(")content(There are )delimiter(")>operator(,) constant(Person)operator(.)ident(number_of_people)operator(,) string<delimiter(")content( Person objects)char(\\n)delimiter(")>

ident(print) ident(pazzi)operator(.)ident(name)operator(,) string<delimiter(')content( is )delimiter(')>operator(,) operator(()ident(pazzi)operator(.)ident(alive?)operator(\)) operator(?) string<delimiter(')content(alive)delimiter(')> operator(:) string<delimiter(')content(dead)delimiter(')>operator(,) string<delimiter(")content(.)char(\\n)delimiter(")>
ident(lecter)operator(.)ident(kill)operator(()ident(pazzi)operator(\))
ident(print) ident(pazzi)operator(.)ident(name)operator(,) string<delimiter(')content( is )delimiter(')>operator(,) operator(()ident(pazzi)operator(.)ident(alive?)operator(\)) operator(?) string<delimiter(')content(alive)delimiter(')> operator(:) string<delimiter(')content(dead)delimiter(')>operator(,) string<delimiter(")content(.)char(\\n)delimiter(")>

ident(print) ident(starling)operator(.)ident(name) operator(,) string<delimiter(')content( was born in )delimiter(')>operator(,) ident(starling)operator(.)ident(year_of_birth)operator(,) string<delimiter(")char(\\n)delimiter(")>


comment(# @@PLEAC@@_13.1)
comment(# If you don't need any initialisation in the constructor,)
comment(# you don't need to write a constructor.)
reserved(class) class(MyClass)
reserved(end)

reserved(class) class(MyClass)
    reserved(def) method(initialize)
        instance_variable(@start) operator(=) constant(Time)operator(.)ident(new)
        instance_variable(@age) operator(=) integer(0)
    reserved(end)
reserved(end)

reserved(class) class(MyClass)
    reserved(def) method(initialize)operator(()ident(inithash)operator(\))
        instance_variable(@start) operator(=) constant(Time)operator(.)ident(new)
        instance_variable(@age) operator(=) integer(0)
        reserved(for) ident(key)operator(,) ident(value) reserved(in) ident(inithash)
            ident(instance_variable_set)operator(()string<delimiter(")content(@)inline<delimiter(#{)ident(key)delimiter(})>delimiter(")>operator(,) ident(value)operator(\))
        reserved(end)
    reserved(end)
reserved(end)

comment(# @@PLEAC@@_13.2)
comment(# Objects are destroyed by the garbage collector.)
comment(# The time of destroying is not predictable.)
comment(# The ruby garbage collector can handle circular references,)
comment(# so there is no need to write destructor for that.)

comment(# There is no direct support for destructor.)
comment(# You can call a custom function, or more specific a proc object, when the)
comment(# garbage collector is about to destruct the object, but it is unpredictable)
comment(# when this occurs.)
comment(# Also if such a finalizer object has a reference to the orignal object,)
comment(# this may prevent the original object to get garbage collected.)
comment(# Because of this problem the finalize method below is)
comment(# a class method and not a instance method.)
comment(# So if you need to free resources for an object, like)
comment(# closing a socket or kill a spawned subprocess,)
comment(# you should do it explicitly.)

reserved(class) class(MyClass)
    reserved(def) method(initialize)
        constant(ObjectSpace)operator(.)ident(define_finalizer)operator(()pre_constant(self)operator(,)
                                     pre_constant(self)operator(.)ident(class)operator(.)ident(method)operator(()symbol(:finalize)operator(\))operator(.)ident(to_proc)operator(\))
    reserved(end)
    reserved(def) constant(MyClass)operator(.)ident(finalize)operator(()ident(id)operator(\))
        ident(puts) string<delimiter(")content(Object )inline<delimiter(#{)ident(id)delimiter(})>content( dying at )inline<delimiter(#{)constant(Time)operator(.)ident(new)delimiter(})>delimiter(")>
    reserved(end)
reserved(end)

comment(# test code)
integer(3)operator(.)ident(times) operator({)
    constant(MyClass)operator(.)ident(new)
operator(})
constant(ObjectSpace)operator(.)ident(garbage_collect)


comment(# @@PLEAC@@_13.3)
comment(# You can write getter and setter methods in a natural way:)
reserved(class) class(Person)
    reserved(def) method(name)
        instance_variable(@name)
    reserved(end)
    reserved(def) method(name=)operator(()ident(name)operator(\))
        instance_variable(@name) operator(=) ident(name)
    reserved(end)
reserved(end)

comment(# But there is a better and shorter way)
reserved(class) class(Person)
    ident(attr_reader) symbol(:age)
    ident(attr_writer) symbol(:name)
    comment(# attr_reader and attr_writer are actually methods in class Class)
    comment(# which set getter and setter methods for you.)
reserved(end)

comment(# There is also attr_accessor to create both setters and getters)
reserved(class) class(Person)
    ident(attr_accessor) symbol(:age)operator(,) symbol(:name)
reserved(end)


comment(# @@PLEAC@@_13.4)
reserved(class) class(Person)
    comment(# Class variables (also called static attributes\) are prefixed by @@)
    class_variable(@@person_counter) operator(=) integer(0)

    reserved(def) constant(Person)operator(.)ident(population)
        class_variable(@@person_counter)
    reserved(end)
    reserved(def) method(initialize)
        class_variable(@@person_counter) operator(+=) integer(1)
        constant(ObjectSpace)operator(.)ident(define_finalizer)operator(()pre_constant(self)operator(,)
                                     pre_constant(self)operator(.)ident(class)operator(.)ident(method)operator(()symbol(:finalize)operator(\))operator(.)ident(to_proc)operator(\))
    reserved(end)
    reserved(def) constant(Person)operator(.)ident(finalize)operator(()ident(id)operator(\))
        class_variable(@@person_counter) operator(-=) integer(1)
    reserved(end)
reserved(end)
ident(people) operator(=) operator([)operator(])
integer(10)operator(.)ident(times) operator({)
    ident(people)operator(.)ident(push)operator(()constant(Person)operator(.)ident(new)operator(\))
operator(})
ident(printf)operator(()string<delimiter(")content(There are %d people alive)delimiter(")>operator(,) constant(Person)operator(.)ident(population)operator(\))


constant(FixedArray)operator(.)ident(class_max_bounds) operator(=) integer(100)
ident(alpha) operator(=) constant(FixedArray)operator(.)ident(new)
ident(puts) string<delimiter(")content(Bound on alpha is )inline<delimiter(#{)ident(alpha)operator(.)ident(max_bounds)delimiter(})>delimiter(")>

ident(beta) operator(=) constant(FixedArray)operator(.)ident(new)
ident(beta)operator(.)ident(max_bounds) operator(=) integer(50)                    comment(# calls the instance method)
ident(beta)operator(.)ident(class)operator(.)ident(class_max_bounds) operator(=) integer(50)        comment(# alternative, calls the class method)
ident(puts) string<delimiter(")content(Bound on alpha is )inline<delimiter(#{)ident(alpha)operator(.)ident(max_bounds)delimiter(})>delimiter(")>

reserved(class) class(FixedArray)
    class_variable(@@bounds) operator(=) integer(7)

    reserved(def) method(max_bounds)
        class_variable(@@max_bounds)
    reserved(end)
    comment(# instance method, which sets the class variable)
    reserved(def) method(max_bounds=)operator(()ident(value)operator(\))
        class_variable(@@max_bounds) operator(=) ident(value)
    reserved(end)
    comment(# class method. This can only be called on a class,)
    comment(# but not on the instances)
    reserved(def) constant(FixedArray)operator(.)ident(class_max_bounds)operator(=)operator(()ident(value)operator(\))
        class_variable(@@max_bounds) operator(=) ident(value)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_13.5)
constant(PersonStruct) operator(=) constant(Struct)operator(.)ident(new)operator(()string<delimiter(")content(Person)delimiter(")>operator(,) symbol(:name)operator(,) symbol(:age)operator(,) symbol(:peers)operator(\))
comment(# creates a class "Person::Struct", which is accessiable with the)
comment(# constant "PersonStruct")
ident(p) operator(=) constant(PersonStruct)operator(.)ident(new)
ident(p) operator(=) constant(Struct)operator(::)constant(Person)operator(.)ident(new)                      comment(# alternative using the classname)
ident(p)operator(.)ident(name) operator(=) string<delimiter(")content(Jason Smythe)delimiter(")>
ident(p)operator(.)ident(age) operator(=) integer(13)
ident(p)operator(.)ident(peers) operator(=) operator([)string<delimiter(")content(Wilbur)delimiter(")>operator(,) string<delimiter(")content(Ralph)delimiter(")>operator(,) string<delimiter(")content(Fred)delimiter(")>operator(])
ident(p)operator([)symbol(:peers)operator(]) operator(=) operator([)string<delimiter(")content(Wilbur)delimiter(")>operator(,) string<delimiter(")content(Ralph)delimiter(")>operator(,) string<delimiter(")content(Fred)delimiter(")>operator(])     comment(# alternative access using symbol)
ident(p)operator([)string<delimiter(")content(peers)delimiter(")>operator(]) operator(=) operator([)string<delimiter(")content(Wilbur)delimiter(")>operator(,) string<delimiter(")content(Ralph)delimiter(")>operator(,) string<delimiter(")content(Fred)delimiter(")>operator(])    comment(# alternative access using name of field)
ident(p)operator([)integer(2)operator(]) operator(=) operator([)string<delimiter(")content(Wilbur)delimiter(")>operator(,) string<delimiter(")content(Ralph)delimiter(")>operator(,) string<delimiter(")content(Fred)delimiter(")>operator(])          comment(# alternative access using index of field)
ident(puts) string<delimiter(")content(At age )inline<delimiter(#{)ident(p)operator(.)ident(age)delimiter(})>content(, )inline<delimiter(#{)ident(p)operator(.)ident(name)delimiter(})>content('s first friend is )inline<delimiter(#{)ident(p)operator(.)ident(peers)operator([)integer(0)operator(])delimiter(})>delimiter(")>

comment(# The fields of a struct have no special type, like other ruby variables)
comment(# you can put any objects in. Therefore the discussions how to specify)
comment(# the types of the fields do not apply to ruby.)

constant(FamilyStruct) operator(=) constant(Struct)operator(.)ident(new)operator(()string<delimiter(")content(Family)delimiter(")>operator(,) symbol(:head)operator(,) symbol(:address)operator(,) symbol(:members)operator(\))
ident(folks) operator(=) constant(FamilyStruct)operator(.)ident(new)
ident(folks)operator(.)ident(head) operator(=) constant(PersonStruct)operator(.)ident(new)
ident(dad) operator(=) ident(folks)operator(.)ident(head)
ident(dad)operator(.)ident(name) operator(=) string<delimiter(")content(John)delimiter(")>
ident(dad)operator(.)ident(age) operator(=) integer(34)

comment(# supply of own accessor method for the struct for error checking)
reserved(class) class(PersonStruct)
    reserved(def) method(age=)operator(()ident(value)operator(\))
        reserved(if) operator(!)ident(value)operator(.)ident(kind_of?)operator(()constant(Integer)operator(\))
            ident(raise)operator(()constant(ArgumentError)operator(,) string<delimiter(")content(Age )inline<delimiter(#{)ident(value)delimiter(})>content( isn't an Integer)delimiter(")>operator(\))
        reserved(elsif) ident(value) operator(>) integer(150)
            ident(raise)operator(()constant(ArgumentError)operator(,) string<delimiter(")content(Age )inline<delimiter(#{)ident(value)delimiter(})>content( is unreasonable)delimiter(")>operator(\))
        reserved(end)
        instance_variable(@age) operator(=) ident(value)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_13.6)
comment(# The ruby Object class defines a dup and a clone method.)
comment(# The dup method is recommended for prototype object creation.)
comment(# The default implementation makes a shallow copy,)
comment(# but each class can override it, for example to make a deep copy.)

comment(# If you want to call 'new' directly on the instances,)
comment(# you can create a instance method "new", which returns a new duplicate.)
comment(# This method is distinct from the class method new.)
comment(#)
reserved(class) class(A)
    reserved(def) method(new)
        ident(dup)
    reserved(end)
reserved(end)

ident(ob1) operator(=) constant(A)operator(.)ident(new)
comment(# later on)
ident(ob2) operator(=) ident(ob1)operator(.)ident(new)


comment(# @@PLEAC@@_13.7)
ident(methname) operator(=) string<delimiter(')content(flicker)delimiter(')>
ident(obj)operator(.)ident(send)operator(()ident(methname)operator(,) integer(10)operator(\))      comment(# calls obj.flicker(10\))

comment(# call three methods on the object, by name)
operator([)string<delimiter(')content(start)delimiter(')>operator(,) string<delimiter(')content(run)delimiter(')>operator(,) string<delimiter(')content(stop)delimiter(')>operator(])operator(.)ident(each) reserved(do) operator(|)ident(method_string)operator(|)
    ident(obj)operator(.)ident(send)operator(()ident(method_string)operator(\))
reserved(end)

comment(# Another way is to create a Method object)
ident(method_obj) operator(=) ident(obj)operator(.)ident(method)operator(()string<delimiter(')content(flicker)delimiter(')>operator(\))
comment(# And then call it)
ident(method_obj)operator(.)ident(call)operator(()integer(10)operator(\))


comment(# @@PLEAC@@_13.8)
comment(# All classes in Ruby inherit from class Object)
comment(# and thus all objects share methods defined in this class)

comment(# the class of the object)
ident(puts) ident(any_object)operator(.)ident(type)

comment(# Ruby classes are actually objects of class Class and they)
comment(# respond to methods defined in Object class as well)

comment(# the superclass of this class)
ident(puts) ident(any_object)operator(.)ident(class)operator(.)ident(superclass)

comment(# ask an object whether it is an instance of particular class)
ident(n) operator(=) float(4.7)
ident(puts) ident(n)operator(.)ident(instance_of?)operator(()constant(Float)operator(\))    comment(# true)
ident(puts) ident(n)operator(.)ident(instance_of?)operator(()constant(Numeric)operator(\))  comment(# false)

comment(# ask an object whether it is an instance of class, one of the)
comment(# superclasses of the object, or modules included in it)
ident(puts) ident(n)operator(.)ident(kind_of?)operator(()constant(Float)operator(\))       comment(# true (the class\))
ident(puts) ident(n)operator(.)ident(kind_of?)operator(()constant(Numeric)operator(\))     comment(# true (an ancestor class\))
ident(puts) ident(n)operator(.)ident(kind_of?)operator(()constant(Comparable)operator(\))  comment(# true (a mixin module\))
ident(puts) ident(n)operator(.)ident(kind_of?)operator(()constant(String)operator(\))      comment(# false)

comment(# ask an object whether it can respond to a particular method)
ident(puts) ident(n)operator(.)ident(respond_to?)operator(()string<delimiter(')content(+)delimiter(')>operator(\))      comment(# true)
ident(puts) ident(n)operator(.)ident(respond_to?)operator(()string<delimiter(')content(length)delimiter(')>operator(\)) comment(# false)

comment(# all methods an object can respond to)
string<delimiter(')content(just a string)delimiter(')>operator(.)ident(methods)operator(.)ident(each) operator({) operator(|)ident(m)operator(|) ident(puts) ident(m) operator(})


comment(# @@PLEAC@@_13.9)
comment(# Actually any class in Ruby is inheritable)
reserved(class) class(Person)
    ident(attr_accessor) symbol(:age)operator(,) symbol(:name)
    reserved(def) method(initialize)
        instance_variable(@name)
        instance_variable(@age)
    reserved(end)
reserved(end)
comment(#-----------------------------)
ident(dude) operator(=) constant(Person)operator(.)ident(new)
ident(dude)operator(.)ident(name) operator(=) string<delimiter(')content(Jason)delimiter(')>
ident(dude)operator(.)ident(age) operator(=) integer(23)
ident(printf) string<delimiter(")content(%s is age %d.)char(\\n)delimiter(")>operator(,) ident(dude)operator(.)ident(name)operator(,) ident(dude)operator(.)ident(age)
comment(#-----------------------------)
comment(# Inheriting from Person)
reserved(class) class(Employee) operator(<) constant(Person)
    ident(attr_accessor) symbol(:salary)
reserved(end)
comment(#-----------------------------)
ident(empl) operator(=) constant(Employee)operator(.)ident(new)
ident(empl)operator(.)ident(name) operator(=) string<delimiter(')content(Jason)delimiter(')>
ident(empl)operator(.)ident(age) operator(=) integer(23)
ident(empl)operator(.)ident(salary) operator(=) integer(200)
ident(printf) string<delimiter(")content(%s is age %d, the salary is %d.)char(\\n)delimiter(")>operator(,) ident(empl)operator(.)ident(name)operator(,) ident(empl)operator(.)ident(age)operator(,) ident(empl)operator(.)ident(salary)
comment(#-----------------------------)
comment(# Any built-in class can be inherited the same way)
reserved(class) class(WeirdString) operator(<) constant(String)
    reserved(def) method(initialize)operator(()ident(obj)operator(\))
        reserved(super) ident(obj)
    reserved(end)
    reserved(def) method(+)operator(()ident(anotherObj)operator(\))   comment(# + method in this class is overridden)
        comment(# to return the sum of string lengths)
        pre_constant(self)operator(.)ident(length) operator(+) ident(anotherObj)operator(.)ident(length)  comment(# 'self' can be omitted)
    reserved(end)
reserved(end)
comment(#-----------------------------)
ident(a) operator(=) constant(WeirdString)operator(.)ident(new)operator(()string<delimiter(')content(hello)delimiter(')>operator(\))
ident(b) operator(=) constant(WeirdString)operator(.)ident(new)operator(()string<delimiter(')content(bye)delimiter(')>operator(\))

ident(puts) ident(a) operator(+) ident(b)    comment(# the overridden +)
comment(#=> 8)
ident(puts) ident(a)operator(.)ident(length) comment(# method from the superclass, String)
comment(#=> 5)


comment(# @@PLEAC@@_13.11)
comment(# In ruby you can override the method_missing method)
comment(# to have a solution similar to perls AUTOLOAD.)
reserved(class) class(Person)

    reserved(def) method(initialize)
        instance_variable(@ok_fields) operator(=) string<delimiter(%w()content(name age peers parent)delimiter(\))>
    reserved(end)

    reserved(def) method(valid_attribute?)operator(()ident(name)operator(\))
        instance_variable(@ok_fields)operator(.)ident(include?)operator(()ident(name)operator(\))
    reserved(end)

    reserved(def) method(method_missing)operator(()ident(namesymbol)operator(,) operator(*)ident(params)operator(\))
        ident(name) operator(=) ident(namesymbol)operator(.)ident(to_s)
        reserved(return) reserved(if) ident(name) operator(=)operator(~) regexp<delimiter(/)content(^A-Z)delimiter(/)>
        reserved(if) ident(name)operator(.)ident(to_s)operator([)operator(-)integer(1)operator(]) operator(==) operator(()string<delimiter(')content(=)delimiter(')>operator([)integer(0)operator(])operator(\))       comment(# we have a setter)
            ident(isSetter) operator(=) pre_constant(true)
            ident(name)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(=$)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))
        reserved(end)
        reserved(if) ident(valid_attribute?)operator(()ident(name)operator(\))
            reserved(if) ident(isSetter)
                ident(instance_variable_set)operator(()string<delimiter(")content(@)inline<delimiter(#{)ident(name)delimiter(})>delimiter(")>operator(,) operator(*)ident(params)operator(\))
            reserved(else)
                ident(instance_variable_get)operator(()string<delimiter(")content(@)inline<delimiter(#{)ident(name)delimiter(})>delimiter(")>operator(,) operator(*)ident(params)operator(\))
            reserved(end)
        reserved(else)
            comment(# if no annestor is responsible,)
            comment(# the Object class will throw a NoMethodError exception)
            reserved(super)operator(()ident(namesymbol)operator(,) operator(*)ident(params)operator(\))
        reserved(end)
    reserved(end)

    reserved(def) method(new)
        ident(kid) operator(=) constant(Person)operator(.)ident(new)
        ident(kid)operator(.)ident(parent) operator(=) pre_constant(self)
        ident(kid)
    reserved(end)

reserved(end)

ident(dad) operator(=) constant(Person)operator(.)ident(new)
ident(dad)operator(.)ident(name) operator(=) string<delimiter(")content(Jason)delimiter(")>
ident(dad)operator(.)ident(age) operator(=) integer(23)
ident(kid) operator(=) ident(dad)operator(.)ident(new)
ident(kid)operator(.)ident(name) operator(=) string<delimiter(")content(Rachel)delimiter(")>
ident(kid)operator(.)ident(age) operator(=) integer(2)
ident(puts) string<delimiter(")content(Kid's parent is )inline<delimiter(#{)ident(kid)operator(.)ident(parent)operator(.)ident(name)delimiter(})>delimiter(")>
ident(puts) ident(dad)
ident(puts) ident(kid)

reserved(class) class(Employee) operator(<) constant(Person)
    reserved(def) method(initialize)
        reserved(super)
        instance_variable(@ok_fields)operator(.)ident(push)operator(()string<delimiter(")content(salary)delimiter(")>operator(,) string<delimiter(")content(boss)delimiter(")>operator(\))
    reserved(end)
    reserved(def) method(ok_fields)
        instance_variable(@ok_fields)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_13.13)
comment(# The ruby garbage collector pretends to cope with circular structures.)
comment(# You can test it with this code:)
reserved(class) class(RingNode)
    ident(attr_accessor) symbol(:next)
    ident(attr_accessor) symbol(:prev)
    ident(attr_reader) symbol(:name)

    reserved(def) method(initialize)operator(()ident(aName)operator(\))
        instance_variable(@name) operator(=) ident(aName)
        constant(ObjectSpace)operator(.)ident(define_finalizer)operator(()pre_constant(self)operator(,)
                                     pre_constant(self)operator(.)ident(class)operator(.)ident(method)operator(()symbol(:finalize)operator(\))operator(.)ident(to_proc)operator(\))
    reserved(end)

    reserved(def) constant(RingNode)operator(.)ident(finalize)operator(()ident(id)operator(\))
        ident(puts) string<delimiter(")content(Node )inline<delimiter(#{)ident(id)delimiter(})>content( dying)delimiter(")>
    reserved(end)

    reserved(def) constant(RingNode)operator(.)ident(show_all_objects)
        constant(ObjectSpace)operator(.)ident(each_object) operator({)operator(|)ident(id)operator(|)
            ident(puts) ident(id)operator(.)ident(name) reserved(if) ident(id)operator(.)ident(class) operator(==) constant(RingNode)
        operator(})
    reserved(end)
reserved(end)

reserved(def) method(create_test)
    ident(a) operator(=) constant(RingNode)operator(.)ident(new)operator(()string<delimiter(")content(Node A)delimiter(")>operator(\))
    ident(b) operator(=) constant(RingNode)operator(.)ident(new)operator(()string<delimiter(")content(Node B)delimiter(")>operator(\))
    ident(c) operator(=) constant(RingNode)operator(.)ident(new)operator(()string<delimiter(")content(Node C)delimiter(")>operator(\))
    ident(a)operator(.)ident(next) operator(=) ident(b)
    ident(b)operator(.)ident(next) operator(=) ident(c)
    ident(c)operator(.)ident(next) operator(=) ident(a)
    ident(a)operator(.)ident(prev) operator(=) ident(c)
    ident(c)operator(.)ident(prev) operator(=) ident(b)
    ident(b)operator(.)ident(prev) operator(=) ident(a)

    ident(a) operator(=) pre_constant(nil)
    ident(b) operator(=) pre_constant(nil)
    ident(c) operator(=) pre_constant(nil)
reserved(end)

ident(create_test)
constant(RingNode)operator(.)ident(show_all_objects)
constant(ObjectSpace)operator(.)ident(garbage_collect)
ident(puts) string<delimiter(")content(After garbage collection)delimiter(")>
constant(RingNode)operator(.)ident(show_all_objects)


comment(# @@PLEAC@@_13.14)
reserved(class) class(String)
    reserved(def) method(<=>)operator(()ident(other)operator(\))
        pre_constant(self)operator(.)ident(casecmp) ident(other)
    reserved(end)
reserved(end)

comment(# There is no way to directly overload the '""' (stringify\))
comment(# operator in Ruby.  However, by convention, classes which)
comment(# can reasonably be converted to a String will define a)
comment(# 'to_s' method as in the TimeNumber class defined below.)
comment(# The 'puts' method will automatcally call an object's)
comment(# 'to_s' method as is demonstrated below.)
comment(# Furthermore, if a class defines a to_str method, an object of that)
comment(# class can be used most any place where the interpreter is looking)
comment(# for a String value.)

comment(#---------------------------------------)
comment(# NOTE: Ruby has a builtin Time class which would usually be used)
comment(# to manipulate time objects, the following is supplied for)
comment(# educational purposes to demonstrate operator overloading.)
comment(#)
reserved(class) class(TimeNumber)
    ident(attr_accessor)  symbol(:hours)operator(,)symbol(:minutes)operator(,)symbol(:seconds)
    reserved(def) method(initialize)operator(() ident(hours)operator(,) ident(minutes)operator(,) ident(seconds)operator(\))
        instance_variable(@hours) operator(=) ident(hours)
        instance_variable(@minutes) operator(=) ident(minutes)
        instance_variable(@seconds) operator(=) ident(seconds)
    reserved(end)

    reserved(def) method(to_s)
        reserved(return) ident(sprintf)operator(() string<delimiter(")content(%d:%02d:%02d)delimiter(")>operator(,) instance_variable(@hours)operator(,) instance_variable(@minutes)operator(,) instance_variable(@seconds)operator(\))
    reserved(end)

    reserved(def) method(to_str)
        ident(to_s)
    reserved(end)

    reserved(def) method(+)operator(() ident(other)operator(\))
        ident(seconds) operator(=) instance_variable(@seconds) operator(+) ident(other)operator(.)ident(seconds)
        ident(minutes) operator(=) instance_variable(@minutes) operator(+) ident(other)operator(.)ident(minutes)
        ident(hours) operator(=) instance_variable(@hours) operator(+) ident(other)operator(.)ident(hours)
        reserved(if) ident(seconds) operator(>)operator(=) integer(60)
            ident(seconds) operator(%=) integer(60)
            ident(minutes) operator(+=) integer(1)
        reserved(end)
        reserved(if) ident(minutes) operator(>)operator(=) integer(60)
            ident(minutes) operator(%=) integer(60)
            ident(hours) operator(+=) integer(1)
        reserved(end)
        reserved(return) constant(TimeNumber)operator(.)ident(new)operator(()ident(hours)operator(,) ident(minutes)operator(,) ident(seconds)operator(\))
    reserved(end)

    reserved(def) method(-)operator(()ident(other)operator(\))
        ident(raise) constant(NotImplementedError)
    reserved(end)

    reserved(def) method(*)operator(()ident(other)operator(\))
        ident(raise) constant(NotImplementedError)
    reserved(end)

    reserved(def) method(/)operator(() ident(other)operator(\))
        ident(raise) constant(NotImplementedError)
    reserved(end)
reserved(end)

ident(t1) operator(=) constant(TimeNumber)operator(.)ident(new)operator(()integer(0)operator(,) integer(58)operator(,) integer(59)operator(\))
ident(sec) operator(=) constant(TimeNumber)operator(.)ident(new)operator(()integer(0)operator(,) integer(0)operator(,) integer(1)operator(\))
ident(min) operator(=) constant(TimeNumber)operator(.)ident(new)operator(()integer(0)operator(,) integer(1)operator(,) integer(0)operator(\))
ident(puts) ident(t1) operator(+) ident(sec) operator(+) ident(min) operator(+) ident(min)

comment(#-----------------------------)
comment(# StrNum class example: Ruby's builtin String class already has the)
comment(# capabilities outlined in StrNum Perl example, however the '*' operator)
comment(# on Ruby's String class acts differently: It creates a string which)
comment(# is the original string repeated N times.)
comment(#)
comment(# Using Ruby's String class as is in this example:)
ident(x) operator(=) string<delimiter(")content(Red)delimiter(")>operator(;) ident(y) operator(=) string<delimiter(")content(Black)delimiter(")>
ident(z) operator(=) ident(x)operator(+)ident(y)
ident(r) operator(=) ident(z)operator(*)integer(3) comment(# r is "RedBlackRedBlackRedBlack")
ident(puts) string<delimiter(")content(values are )inline<delimiter(#{)ident(x)delimiter(})>content(, )inline<delimiter(#{)ident(y)delimiter(})>content(, )inline<delimiter(#{)ident(z)delimiter(})>content(, and )inline<delimiter(#{)ident(r)delimiter(})>delimiter(")>
ident(print) string<delimiter(")inline<delimiter(#{)ident(x)delimiter(})>content( is )delimiter(")>operator(,) ident(x) operator(<) ident(y) operator(?) string<delimiter(")content(LT)delimiter(")> operator(:) string<delimiter(")content(GE)delimiter(")>operator(,) string<delimiter(")content( )inline<delimiter(#{)ident(y)delimiter(})>char(\\n)delimiter(")>
comment(# prints:)
comment(# values are Red, Black, RedBlack, and RedBlackRedBlackRedBlack)
comment(# Red is GE Black)

comment(#-----------------------------)
reserved(class) class(FixNum)
    constant(REGEX) operator(=) regexp<delimiter(/)content(()char(\\.)char(\\d)content(*\))delimiter(/)>
    constant(DEFAULT_PLACES) operator(=) integer(0)
    ident(attr_accessor) symbol(:value)operator(,) symbol(:places)
    reserved(def) method(initialize)operator(()ident(value)operator(,) ident(places) operator(=) pre_constant(nil)operator(\))
        instance_variable(@value) operator(=) ident(value)
        reserved(if) ident(places)
            instance_variable(@places) operator(=) ident(places)
        reserved(else)
            ident(m) operator(=) constant(REGEX)operator(.)ident(match)operator(()ident(value)operator(.)ident(to_s)operator(\))
            reserved(if) ident(m)
                instance_variable(@places) operator(=) ident(m)operator([)integer(0)operator(])operator(.)ident(length) operator(-) integer(1)
            reserved(else)
                instance_variable(@places) operator(=) constant(DEFAULT_PLACES)
            reserved(end)
        reserved(end)
    reserved(end)

    reserved(def) method(+)operator(()ident(other)operator(\))
        constant(FixNum)operator(.)ident(new)operator(()instance_variable(@value) operator(+) ident(other)operator(.)ident(value)operator(,) ident(max)operator(()instance_variable(@places)operator(,) ident(other)operator(.)ident(places)operator(\))operator(\))
    reserved(end)

    reserved(def) method(*)operator(()ident(other)operator(\))
        constant(FixNum)operator(.)ident(new)operator(()instance_variable(@value) operator(*) ident(other)operator(.)ident(value)operator(,) ident(max)operator(()instance_variable(@places)operator(,) ident(other)operator(.)ident(places)operator(\))operator(\))
    reserved(end)

    reserved(def) method(/)operator(()ident(other)operator(\))
        ident(puts) string<delimiter(")content(Divide: )inline<delimiter(#{)instance_variable(@value)operator(.)ident(to_f)operator(/)ident(other)operator(.)ident(value)operator(.)ident(to_f)delimiter(})>delimiter(")>
        ident(result) operator(=) constant(FixNum)operator(.)ident(new)operator(()instance_variable(@value)operator(.)ident(to_f)operator(/)ident(other)operator(.)ident(value)operator(.)ident(to_f)operator(\))
        ident(result)operator(.)ident(places) operator(=) ident(max)operator(()ident(result)operator(.)ident(places)operator(,)ident(other)operator(.)ident(places)operator(\))
        ident(result)
    reserved(end)

    reserved(def) method(to_s)
        ident(sprintf)operator(()string<delimiter(")content(STR%s: %.*f)delimiter(")>operator(,) pre_constant(self)operator(.)ident(class)operator(.)ident(to_s) operator(,) instance_variable(@places)operator(,) instance_variable(@value)operator(\))   comment(#.)
    reserved(end)

    reserved(def) method(to_str)
        ident(to_s)
    reserved(end)

    reserved(def) method(to_i) comment(#convert to int)
        instance_variable(@value)operator(.)ident(to_i)
    reserved(end)

    reserved(def) method(to_f) comment(#convert to float`)
        instance_variable(@value)operator(.)ident(to_f)
    reserved(end)

    ident(private)
    reserved(def) method(max)operator(()ident(a)operator(,)ident(b)operator(\))
        ident(a) operator(>) ident(b) operator(?) ident(a) operator(:) ident(b)
    reserved(end)
reserved(end)

reserved(def) method(demo)operator(()operator(\))
    ident(x) operator(=) constant(FixNum)operator(.)ident(new)operator(()integer(40)operator(\))
    ident(y) operator(=) constant(FixNum)operator(.)ident(new)operator(()integer(12)operator(,) integer(0)operator(\))

    ident(puts) string<delimiter(")content(sum of )inline<delimiter(#{)ident(x)delimiter(})>content( and )inline<delimiter(#{)ident(y)delimiter(})>content( is  )inline<delimiter(#{)ident(x)operator(+)ident(y)delimiter(})>delimiter(")>
    ident(puts) string<delimiter(")content(product of )inline<delimiter(#{)ident(x)delimiter(})>content( and )inline<delimiter(#{)ident(y)delimiter(})>content( is )inline<delimiter(#{)ident(x)operator(*)ident(y)delimiter(})>delimiter(")>

    ident(z) operator(=) ident(x)operator(/)ident(y)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(z)delimiter(})>content( has )inline<delimiter(#{)ident(z)operator(.)ident(places)delimiter(})>content( places)delimiter(")>
    reserved(unless) ident(z)operator(.)ident(places)
        ident(z)operator(.)ident(places) operator(=) integer(2)
    reserved(end)

    ident(puts) string<delimiter(")content(div of )inline<delimiter(#{)ident(x)delimiter(})>content( by )inline<delimiter(#{)ident(y)delimiter(})>content( is )inline<delimiter(#{)ident(z)delimiter(})>delimiter(")>
    ident(puts) string<delimiter(")content(square of that is  )inline<delimiter(#{)ident(z)operator(*)ident(z)delimiter(})>delimiter(")>
reserved(end)

reserved(if) pre_constant(__FILE__) operator(==) global_variable($0)
    ident(demo)operator(()operator(\))
reserved(end)


comment(# @@PLEAC@@_14.1)
comment(# There are dbm, sdbm, gdbm modules)
comment(# and the bdb module for accessing the berkeley db)
comment(# sdbm seem to be available on the most systems,)
comment(# so we use it here)
comment(#)
ident(require) string<delimiter(")content(sdbm)delimiter(")>
constant(SDBM)operator(.)ident(open)operator(()string<delimiter(")content(filename)delimiter(")>operator(,) integer(0666)operator(\)) operator({) operator(|)ident(dbobj)operator(|)
    comment(# raises exception if open error)

    comment(# the returned sdbm-dbobj has most of the methods of a hash)
    ident(v) operator(=) ident(dbobj)operator([)string<delimiter(")content(key)delimiter(")>operator(])
    ident(dbobj)operator([)string<delimiter(")content(key)delimiter(")>operator(]) operator(=) string<delimiter(")content(newvalue)delimiter(")>
    reserved(if) ident(dbobj)operator(.)ident(has_key?)operator(()string<delimiter(")content(key)delimiter(")>operator(\))
        comment(# ...)
    reserved(end)
    ident(dbobj)operator(.)ident(delete)operator(()string<delimiter(")content(key2)delimiter(")>operator(\))
operator(})
comment(# database is open only inside the block.)

comment(# It is also possible to use a open .. close pair:)
ident(dbobj) operator(=) constant(SDBM)operator(.)ident(open)operator(()string<delimiter(")content(filename)delimiter(")>operator(,) integer(0666)operator(\))
comment(#.. do something with dbobj)
ident(dbobj)operator(.)ident(close)

comment(#!/usr/bin/ruby -w)
comment(# userstats - generate statistics on who is logged in)
comment(# call with usernames as argument to display the totals)
comment(# for the given usernames, call with "ALL" to display all users)

ident(require) string<delimiter(")content(sdbm)delimiter(")>
ident(filename) operator(=) string<delimiter(')content(/tmp/userstats.db)delimiter(')>
constant(SDBM)operator(.)ident(open)operator(()ident(filename)operator(,) integer(0666)operator(\)) operator({) operator(|)ident(dbobj)operator(|)
    reserved(if) pre_constant(ARGV)operator(.)ident(length) operator(>) integer(0)
        reserved(if) pre_constant(ARGV)operator([)integer(0)operator(]) operator(==) string<delimiter(")content(ALL)delimiter(")>
            comment(# ARGV is constant, so we need the variable userlist)
            ident(userlist) operator(=) ident(dbobj)operator(.)ident(keys)operator(()operator(\))operator(.)ident(sort)operator(()operator(\))
        reserved(else)
            ident(userlist) operator(=) pre_constant(ARGV)
        reserved(end)
        ident(userlist)operator(.)ident(each) operator({) operator(|)ident(user)operator(|)
            ident(print) string<delimiter(")inline<delimiter(#{)ident(user)delimiter(})>char(\\t)inline<delimiter(#{)ident(dbobj)operator([)ident(user)operator(])delimiter(})>char(\\n)delimiter(")>
        operator(})
    reserved(else)
        ident(who) operator(=) shell<delimiter(`)content(who)delimiter(`)>
        ident(who)operator(.)ident(split)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
            ident(md) operator(=) regexp<delimiter(/)content(^()char(\\S)content(+\))delimiter(/)>operator(.)ident(match)operator(()ident(line)operator(\))
            ident(raise) string<delimiter(")content(Bad line from who: )inline<delimiter(#{)ident(line)delimiter(})>delimiter(")> reserved(unless) ident(md)
            comment(# sdbm stores only strings, so "+=" doesn't work,)
            comment(# we need to convert them expicitly back to integer.)
            reserved(if) ident(dbobj)operator(.)ident(has_key?)operator(()ident(md)operator([)integer(0)operator(])operator(\))
                ident(dbobj)operator([)ident(md)operator([)integer(0)operator(])operator(]) operator(=) ident(dbobj)operator([)ident(md)operator([)integer(0)operator(])operator(])operator(.)ident(to_i) operator(+) integer(1)
            reserved(else)
                ident(dbobj)operator([)ident(md)operator([)integer(0)operator(])operator(]) operator(=) string<delimiter(")content(1)delimiter(")>
            reserved(end)
        operator(})
    reserved(end)
operator(})


comment(# @@PLEAC@@_14.2)
comment(# using open and clear)
ident(dbobj) operator(=) constant(SDBM)operator(.)ident(open)operator(()string<delimiter(")content(filename)delimiter(")>operator(,) integer(0666)operator(\))
ident(dbobj)operator(.)ident(clear)operator(()operator(\))
ident(dbobj)operator(.)ident(close)operator(()operator(\))
comment(# deleting file and recreating it)
comment(# the filenames depend on the flavor of dbm you use,)
comment(# for example sdbm has two files named filename.pag and filename.dir,)
comment(# so you need to delete both files)
reserved(begin)
    constant(File)operator(.)ident(delete)operator(()string<delimiter(")content(filename)delimiter(")>operator(\))
    comment(# raises Exception if not exist)
    ident(dbobj) operator(=) constant(SDBM)operator(.)ident(open)operator(()string<delimiter(")content(filename)delimiter(")>operator(,) integer(0666)operator(\))
reserved(rescue)
    comment(# add error handling here)
reserved(end)


comment(# @@PLEAC@@_14.3)
comment(# sdbm2gdbm: converts sdbm database to a gdbm database)
ident(require) string<delimiter(")content(sdbm)delimiter(")>
ident(require) string<delimiter(")content(gdbm)delimiter(")>

reserved(unless) pre_constant(ARGV)operator(.)ident(length) operator(==) integer(2)
    ident(fail) string<delimiter(")content(usage: sdbm2gdbm infile outfile)delimiter(")>
reserved(end)
ident(infile) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
ident(outfile) operator(=) pre_constant(ARGV)operator([)integer(1)operator(])

ident(sdb) operator(=) constant(SDBM)operator(.)ident(open)operator(()ident(infile)operator(\))
ident(gdb) operator(=) constant(GDBM)operator(.)ident(open)operator(()ident(outfile)operator(,) integer(0666)operator(\))
ident(sdb)operator(.)ident(each) operator({) operator(|)ident(key)operator(,) ident(val)operator(|)
    ident(gdb)operator([)ident(key)operator(]) operator(=) ident(val)
operator(})
ident(gdb)operator(.)ident(close)
ident(sdb)operator(.)ident(close)


comment(# @@PLEAC@@_14.4)
comment(#!/usr/bin/ruby -w)
comment(# dbmmerge: merges two dbm databases)
ident(require) string<delimiter(")content(sdbm)delimiter(")>

reserved(unless) pre_constant(ARGV)operator(.)ident(length) operator(==) integer(3)
    ident(fail) string<delimiter(")content(usage: dbmmerge indb1 indb2 outdb)delimiter(")>
reserved(end)
ident(infile1) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
ident(infile2) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
ident(outfile) operator(=) pre_constant(ARGV)operator([)integer(2)operator(])

ident(in1) operator(=) constant(SDBM)operator(.)ident(open)operator(()ident(infile1)operator(,) pre_constant(nil)operator(\))
ident(in2) operator(=) constant(SDBM)operator(.)ident(open)operator(()ident(infile2)operator(,) pre_constant(nil)operator(\))
ident(outdb) operator(=) constant(SDBM)operator(.)ident(open)operator(()ident(outfile)operator(,) integer(0666)operator(\))

operator([)ident(in1)operator(,) ident(in2)operator(])operator(.)ident(each) operator({) operator(|)ident(indb)operator(|)
    ident(indb)operator(.)ident(each) operator({) operator(|)ident(key)operator(,) ident(val)operator(|)
        reserved(if) ident(outdb)operator(.)ident(has_key?)operator(()ident(key)operator(\))
            comment(# decide which value to set.)
            comment(# set outdb[key] if necessary)
        reserved(else)
            ident(outdb)operator([)ident(key)operator(]) operator(=) ident(val)
        reserved(end)
    operator(})
operator(})
ident(in1)operator(.)ident(close)
ident(in2)operator(.)ident(close)
ident(outdb)operator(.)ident(close)


comment(# @@PLEAC@@_14.7)
comment(# we write a tie method that extends the Array class.)
comment(# It reads the file into the memory, executes the code block)
comment(# in which you can manipulate the array as needed, and writes)
comment(# the array back to the file after the end of the block execution)
reserved(class) class(Array)
    reserved(def) method(tie)operator(()ident(filename)operator(,) ident(flags)operator(\))
        constant(File)operator(.)ident(open)operator(()ident(filename)operator(,) ident(flags)operator(\)) operator({) operator(|)ident(f)operator(|)
            ident(f)operator(.)ident(each_line) operator({) operator(|)ident(line)operator(|)
                pre_constant(self)operator(.)ident(push)operator(()ident(line)operator(.)ident(chomp)operator(\))
            operator(})
            reserved(yield)
            ident(f)operator(.)ident(rewind)
            ident(each) operator({) operator(|)ident(line)operator(|)
                reserved(if) ident(line)
                    ident(f)operator(.)ident(puts)operator(()ident(line)operator(\))
                reserved(else)
                    ident(f)operator(.)ident(puts) string<delimiter(")delimiter(")>
                reserved(end)
            operator(})
        operator(})
    reserved(end)
reserved(end)

ident(array) operator(=) constant(Array)operator(.)ident(new)
ident(array)operator(.)ident(tie)operator(()string<delimiter(")content(/tmp/textfile.txt)delimiter(")>operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(CREAT)operator(\)) operator({)
    ident(array)operator([)integer(4)operator(]) operator(=) string<delimiter(")content(a new line 4)delimiter(")>
operator(})

comment(# The tied array can be manipulated like a normal array,)
comment(# so there is no need for a special API, and the recno_demo program)
comment(# to demonstrate is API is useless)


comment(# tied array demo: show how to use array with a tied file)
ident(filename) operator(=) string<delimiter(")content(db_file.txt)delimiter(")>
ident(lines) operator(=) constant(Array)operator(.)ident(new)
constant(File)operator(.)ident(unlink)operator(()ident(filename)operator(\)) reserved(if) constant(File)operator(.)ident(exists?)operator(()ident(filename)operator(\))
ident(lines)operator(.)ident(tie)operator(()ident(filename)operator(,) constant(File)operator(::)constant(RDWR) operator(|) constant(File)operator(::)constant(CREAT)operator(\)) operator({)
    comment(# first create a textfile to play with)
    ident(lines)operator([)integer(0)operator(]) operator(=) string<delimiter(")content(zero)delimiter(")>
    ident(lines)operator([)integer(1)operator(]) operator(=) string<delimiter(")content(one)delimiter(")>
    ident(lines)operator([)integer(2)operator(]) operator(=) string<delimiter(")content(two)delimiter(")>
    ident(lines)operator([)integer(3)operator(]) operator(=) string<delimiter(")content(three)delimiter(")>
    ident(lines)operator([)integer(4)operator(]) operator(=) string<delimiter(")content(four)delimiter(")>

    comment(# print the records in order.)
    comment(# Opposed to perl, the tied array behaves exactly as a normal array)
    ident(puts) string<delimiter(")char(\\n)content(Original)delimiter(")>
    reserved(for) ident(i) reserved(in) integer(0)operator(..)operator(()ident(lines)operator(.)ident(length)operator(-)integer(1)operator(\))
        ident(puts) string<delimiter(")inline<delimiter(#{)ident(i)delimiter(})>content(: )inline<delimiter(#{)ident(lines)operator([)ident(i)operator(])delimiter(})>delimiter(")>
    reserved(end)

    comment(#use push and pop)
    ident(a) operator(=) ident(lines)operator(.)ident(pop)
    ident(lines)operator(.)ident(push)operator(()string<delimiter(")content(last)delimiter(")>operator(\))
    ident(puts)operator(()string<delimiter(")content(The last line was [)inline<delimiter(#{)ident(a)delimiter(})>content(])delimiter(")>operator(\))

    comment(#use shift and unshift)
    ident(a) operator(=) ident(lines)operator(.)ident(shift)
    ident(lines)operator(.)ident(unshift)operator(()string<delimiter(")content(first)delimiter(")>operator(\))
    ident(puts)operator(()string<delimiter(")content(The first line was [)inline<delimiter(#{)ident(a)delimiter(})>content(])delimiter(")>operator(\))

    comment(# add record after record 2)
    ident(i) operator(=) integer(2)
    ident(lines)operator(.)ident(insert)operator(()ident(i) operator(+) integer(1)operator(,) string<delimiter(")content(Newbie)delimiter(")>operator(\))

    comment(# add record before record one)
    ident(i) operator(=) integer(1)
    ident(lines)operator(.)ident(insert)operator(()ident(i)operator(,) string<delimiter(")content(New One)delimiter(")>operator(\))

    comment(# delete record 3)
    ident(lines)operator(.)ident(delete_at)operator(()integer(3)operator(\))

    comment(#now print the records in reverse order)
    ident(puts) string<delimiter(")char(\\n)content(Reverse)delimiter(")>
    operator(()ident(lines)operator(.)ident(length) operator(-) integer(1)operator(\))operator(.)ident(downto)operator(()integer(0)operator(\))operator({) operator(|)ident(i)operator(|)
        ident(puts) string<delimiter(")inline<delimiter(#{)ident(i)delimiter(})>content(: )inline<delimiter(#{)ident(lines)operator([)ident(i)operator(])delimiter(})>delimiter(")>
    operator(})

operator(})


comment(# @@PLEAC@@_14.8)
comment(# example to store complex data in a database)
comment(# uses marshall from the standard library)
ident(require) string<delimiter(")content(sdbm)delimiter(")>
ident(db) operator(=) constant(SDBM)operator(.)ident(open)operator(()string<delimiter(")content(pleac14-8-database)delimiter(")>operator(,) integer(0666)operator(\))

comment(# convert the Objects into strings and back by using the Marshal module.)
comment(# Most normal objects can be converted out of the box,)
comment(# but not special things like procedure objects,)
comment(# IO instance variables, singleton objects)

ident(db)operator([)string<delimiter(")content(Tom Christiansen)delimiter(")>operator(]) operator(=) constant(Marshal)operator(.)ident(dump)operator(()operator([)string<delimiter(")content(book author)delimiter(")>operator(,)  string<delimiter(")content(tchrist@perl.com)delimiter(")>operator(])operator(\))
ident(db)operator([)string<delimiter(")content(Tom Boutell)delimiter(")>operator(]) operator(=) constant(Marshal)operator(.)ident(dump)operator(()operator([)string<delimiter(")content(shareware author)delimiter(")>operator(,)
string<delimiter(")content(boutell@boutell.com)delimiter(")>operator(])operator(\))

ident(name1) operator(=) string<delimiter(")content(Tom Christiansen)delimiter(")>
ident(name2) operator(=) string<delimiter(")content(Tom Boutell)delimiter(")>

ident(tom1) operator(=) constant(Marshal)operator(.)ident(load)operator(()ident(db)operator([)ident(name1)operator(])operator(\))
ident(tom2) operator(=) constant(Marshal)operator(.)ident(load)operator(()ident(db)operator([)ident(name2)operator(])operator(\))

ident(puts) string<delimiter(")content(Two Toming: )inline<delimiter(#{)ident(tom1)delimiter(})>content( )inline<delimiter(#{)ident(tom2)delimiter(})>delimiter(")>

reserved(if) ident(tom1)operator([)integer(0)operator(]) operator(==) ident(tom2)operator([)integer(0)operator(]) operator(&&) ident(tom1)operator([)integer(1)operator(]) operator(==) ident(tom2)operator([)integer(1)operator(])
   ident(puts) string<delimiter(")content(You're having runtime fun with one Tom made two.)delimiter(")>
reserved(else)
   ident(puts) string<delimiter(")content(No two Toms are ever alike)delimiter(")>
reserved(end)

comment(# To change parts of an entry, get the whole entry, change the parts,)
comment(# and save the whole entry back)
ident(entry) operator(=) constant(Marshal)operator(.)ident(load)operator(()ident(db)operator([)string<delimiter(")content(Tom Boutell)delimiter(")>operator(])operator(\))
ident(entry)operator([)integer(0)operator(]) operator(=) string<delimiter(")content(Poet Programmer)delimiter(")>
ident(db)operator([)string<delimiter(")content(Tom Boutell)delimiter(")>operator(]) operator(=) constant(Marshal)operator(.)ident(dump)operator(()ident(entry)operator(\))
ident(db)operator(.)ident(close)


comment(# @@PLEAC@@_14.9)
comment(# example to make data persistent)
comment(# uses Marshal from the standard lib)
comment(# Stores the data in a simple file,)
comment(# see 14.8 on how to store it in a dbm file)

comment(# The BEGIN block is executed before the rest of the script)
comment(# we use global variables here because local variables)
comment(# will go out of scope and are not accessible from the main script)

reserved(BEGIN) operator({)
   global_variable($persistent_store) operator(=) string<delimiter(")content(persitence.dat)delimiter(")>
   reserved(begin)
     constant(File)operator(.)ident(open)operator(()global_variable($persistent_store)operator(\)) reserved(do) operator(|)ident(f)operator(|)
       global_variable($stringvariable1) operator(=) constant(Marshal)operator(.)ident(load)operator(()ident(f)operator(\))
       global_variable($arrayvariable2) operator(=) constant(Marshal)operator(.)ident(load)operator(()ident(f)operator(\))
     reserved(end)
   reserved(rescue)
     ident(puts) string<delimiter(")content(Can not open )inline<delimiter(#{)global_variable($persistent_store)delimiter(})>delimiter(")>
     comment(# Initialisation if this script runs the first time)
     global_variable($stringvariable1) operator(=) string<delimiter(")delimiter(")>
     global_variable($arrayvariable2) operator(=) operator([)operator(])
   reserved(end)
operator(})

reserved(END) operator({)
   constant(File)operator(.)ident(open)operator(()global_variable($persistent_store)operator(,) string<delimiter(")content(w+)delimiter(")>operator(\)) reserved(do) operator(|)ident(f)operator(|)
     constant(Marshal)operator(.)ident(dump)operator(()global_variable($stringvariable1)operator(,) ident(f)operator(\))
     constant(Marshal)operator(.)ident(dump)operator(()global_variable($arrayvariable2)operator(,) ident(f)operator(\))
   reserved(end)
operator(})

comment(# simple test program)
ident(puts) global_variable($stringvariable1)
ident(puts) global_variable($arrayvariable2)
global_variable($stringvariable1) operator(=) string<delimiter(")content(Hello World)delimiter(")>
global_variable($arrayvariable2)operator(.)ident(push)operator(()integer(5)operator(\))
ident(puts) global_variable($stringvariable1)
ident(puts) global_variable($arrayvariable2)


comment(# @@PLEAC@@_14.10)
comment(#!/usr/bin/ruby -w)
comment(# Ruby has a dbi module with an architecture similar)
comment(# to the Perl dbi module: the dbi module provides an unified)
comment(# interface and uses specialized drivers for each dbms vendor)
comment(#)
reserved(begin)
    constant(DBI)operator(.)ident(connect)operator(()string<delimiter(")content(DBI:driver:driverspecific)delimiter(")>operator(,) string<delimiter(")content(username)delimiter(")>operator(,) string<delimiter(")content(auth)delimiter(")>operator(\)) operator({)
        operator(|)ident(dbh)operator(|)

        ident(dbh)operator(.)ident(do)operator(()constant(SQL1)operator(\))

        ident(dbh)operator(.)ident(prepare)operator(()constant(SQL2)operator(\))operator({) operator(|)ident(sth)operator(|)
            ident(sth)operator(.)ident(execute)
            ident(sth)operator(.)ident(fetch) operator({)operator(|)ident(row)operator(|)
                comment(# ...)
            operator(})
        operator(}) comment(# end of block finishes the statement handle)
    operator(}) comment(# end of block closes the database connection)
reserved(rescue) constant(DBI)operator(::)constant(DatabaseError) operator(=)operator(>) ident(e)
    ident(puts) string<delimiter(")content(dbi error occurred)delimiter(")>
    ident(puts) string<delimiter(")content(Error code: )inline<delimiter(#{)ident(e)operator(.)ident(err)delimiter(})>delimiter(")>
    ident(puts) string<delimiter(")content(Error message: )inline<delimiter(#{)ident(e)operator(.)ident(errstr)delimiter(})>delimiter(")>
reserved(end)

comment(#!/usr/bin/ruby -w)
comment(# dbusers - example for mysql which creates a table,)
comment(# fills it with values, retrieves the values back,)
comment(# and finally destroys the table.)

ident(require) string<delimiter(")content(dbi)delimiter(")>

comment(# replacement for the User::pwnt module)
reserved(def) method(getpwent)
    ident(result) operator(=) operator([)operator(])
    constant(File)operator(.)ident(open)operator(()string<delimiter(")content(/etc/passwd)delimiter(")>operator(\)) operator({)operator(|)ident(file)operator(|)
        ident(file)operator(.)ident(each_line) operator({)operator(|)ident(line)operator(|)
            reserved(next) reserved(if) ident(line)operator(.)ident(match)operator(()regexp<delimiter(/)content(^#)delimiter(/)>operator(\))
            ident(cols) operator(=) ident(line)operator(.)ident(split)operator(()string<delimiter(")content(:)delimiter(")>operator(\))
            ident(result)operator(.)ident(push)operator(()operator([)ident(cols)operator([)integer(2)operator(])operator(,) ident(cols)operator([)integer(0)operator(])operator(])operator(\))
        operator(})
    operator(})
    ident(result)
reserved(end)

reserved(begin)
    constant(DBI)operator(.)ident(connect)operator(()string<delimiter(")content(DBI:Mysql:pleacdatabase)delimiter(")>operator(,) string<delimiter(")content(pleac)delimiter(")>operator(,) string<delimiter(")content(pleacpassword)delimiter(")>operator(\)) operator({)
        operator(|)ident(conn)operator(|)

        ident(conn)operator(.)ident(do)operator(()string<delimiter(")content(CREATE TABLE users (uid INT, login CHAR(8\)\))delimiter(")>operator(\))

        ident(users) operator(=) ident(getpwent)

        ident(conn)operator(.)ident(prepare)operator(()string<delimiter(")content(INSERT INTO users VALUES (?,?\))delimiter(")>operator(\)) operator({)operator(|)ident(sth)operator(|)
            ident(users)operator(.)ident(each) operator({)operator(|)ident(entry)operator(|)
                ident(sth)operator(.)ident(execute)operator(()ident(entry)operator([)integer(0)operator(])operator(,) ident(entry)operator([)integer(1)operator(])operator(\))
            operator(})
        operator(})

        ident(conn)operator(.)ident(execute)operator(()string<delimiter(")content(SELECT uid, login FROM users WHERE uid < 50)delimiter(")>operator(\)) operator({)operator(|)ident(sth)operator(|)
            ident(sth)operator(.)ident(fetch) operator({)operator(|)ident(row)operator(|)
                ident(puts) ident(row)operator(.)ident(collect) operator({)operator(|)ident(col)operator(|)
                    reserved(if) ident(col)operator(.)ident(nil?)
                        string<delimiter(")content((null\))delimiter(")>
                    reserved(else)
                        ident(col)
                    reserved(end)
                operator(})operator(.)ident(join)operator(()string<delimiter(")content(, )delimiter(")>operator(\))
            operator(})
        operator(})

        ident(conn)operator(.)ident(do)operator(()string<delimiter(")content(DROP TABLE users)delimiter(")>operator(\))
    operator(})
reserved(rescue) constant(DBI)operator(::)constant(DatabaseError) operator(=)operator(>) ident(e)
    ident(puts) string<delimiter(")content(dbi error occurred)delimiter(")>
    ident(puts) string<delimiter(")content(Error code: )inline<delimiter(#{)ident(e)operator(.)ident(err)delimiter(})>delimiter(")>
    ident(puts) string<delimiter(")content(Error message: )inline<delimiter(#{)ident(e)operator(.)ident(errstr)delimiter(})>delimiter(")>
reserved(end)


comment(# @@PLEAC@@_15.1)
comment(# This test program demonstrates parsing program arguments.)
comment(# It uses the optparse library, which is included with ruby 1.8)
comment(# It handles classic unix style and gnu style options)
ident(require) string<delimiter(')content(optparse)delimiter(')>

instance_variable(@debugmode) operator(=) pre_constant(false)
instance_variable(@verbose) operator(=) pre_constant(false)

pre_constant(ARGV)operator(.)ident(options) reserved(do) operator(|)ident(opts)operator(|)
    ident(opts)operator(.)ident(banner) operator(=) string<delimiter(")content(Usage: ruby )inline<delimiter(#{)global_variable($0)delimiter(})>content( [OPTIONS] INPUTFILES)delimiter(")>

    ident(opts)operator(.)ident(on)operator(()string<delimiter(")content(-h)delimiter(")>operator(,) string<delimiter(")content(--help)delimiter(")>operator(,) string<delimiter(")content(show this message)delimiter(")>operator(\)) operator({)
        ident(puts) ident(opts)
        ident(exit)
    operator(})
    comment(# The OptionParser#on method is called with a specification of short)
    comment(# options, of long options, a data type spezification and user help)
    comment(# messages for this option.)
    comment(# The method analyses the given parameter and decides what it is,)
    comment(# so you can leave out the long option if you don't need it)
    ident(opts)operator(.)ident(on)operator(()string<delimiter(")content(-v)delimiter(")>operator(,) string<delimiter(")content(--[no-]verbose=[FLAG])delimiter(")>operator(,) constant(TrueClass)operator(,) string<delimiter(")content(run verbosly)delimiter(")>operator(\)) operator({)
        operator(|)instance_variable(@verbose)operator(|)   comment(# sets @verbose to true or false)
    operator(})
    ident(opts)operator(.)ident(on)operator(()string<delimiter(")content(-D)delimiter(")>operator(,) string<delimiter(")content(--DEBUG)delimiter(")>operator(,) constant(TrueClass)operator(,) string<delimiter(")content(turns on debug mode)delimiter(")> operator(\))operator({)
        operator(|)instance_variable(@debugmode)operator(|)   comment(# sets @debugmode to true)
    operator(})
    ident(opts)operator(.)ident(on)operator(()string<delimiter(")content(-c)delimiter(")>operator(,) string<delimiter(")content(--count=NUMBER)delimiter(")>operator(,) constant(Integer)operator(,) string<delimiter(")content(how many times we do it)delimiter(")> operator(\))operator({)
        operator(|)instance_variable(@count)operator(|)      comment(# sets @count to given integer)
    operator(})
    ident(opts)operator(.)ident(on)operator(()string<delimiter(")content(-o)delimiter(")>operator(,) string<delimiter(")content(--output=FILE)delimiter(")>operator(,) constant(String)operator(,) string<delimiter(")content(file to write output to)delimiter(")>operator(\))operator({)
        operator(|)instance_variable(@outputfile)operator(|)   comment(# sets @outputfile to given string)
    operator(})
    ident(opts)operator(.)ident(parse!)
reserved(end)

comment(# example to use the options in the main program)
ident(puts) string<delimiter(")content(Verbose is on)delimiter(")> reserved(if) instance_variable(@verbose)
ident(puts) string<delimiter(")content(Debugmode is on)delimiter(")> reserved(if) instance_variable(@debugmode)
ident(puts) string<delimiter(")content(Outfile is )inline<delimiter(#{)instance_variable(@outputfile)delimiter(})>delimiter(")> reserved(if) reserved(defined?) instance_variable(@outputfile)
ident(puts) string<delimiter(")content(Count is )inline<delimiter(#{)instance_variable(@count)delimiter(})>delimiter(")> reserved(if) reserved(defined?) instance_variable(@count)
pre_constant(ARGV)operator(.)ident(each) operator({) operator(|)ident(param)operator(|)
    ident(puts) string<delimiter(")content(Got parameter )inline<delimiter(#{)ident(param)delimiter(})>delimiter(")>
operator(})


comment(# @@PLEAC@@_15.4)
ident(buf) operator(=) string<delimiter(")char(\\0)delimiter(")> operator(*) integer(8)
global_variable($stdout)operator(.)ident(ioctl)operator(()integer(0x5413)operator(,) ident(buf)operator(\))
ident(ws_row)operator(,) ident(ws_col)operator(,) ident(ws_xpixel)operator(,) ident(ws_ypixel) operator(=) ident(buf)operator(.)ident(unpack)operator(()string<delimiter(")content(S4)delimiter(")>operator(\))

ident(raise) string<delimiter(")content(You must have at least 20 characters)delimiter(")> reserved(unless) ident(ws_col) operator(>)operator(=) integer(20)
ident(max) operator(=) integer(0)
ident(values) operator(=) operator(()integer(1)operator(..)integer(5)operator(\))operator(.)ident(collect) operator({) ident(rand)operator(()integer(20)operator(\)) operator(})  comment(# generate an array[5] of rand values)
reserved(for) ident(i) reserved(in) ident(values)
    ident(max) operator(=) ident(i) reserved(if) ident(max) operator(<) ident(i)
reserved(end)
ident(ratio) operator(=) constant(Float)operator(()ident(ws_col)operator(-)integer(12)operator(\))operator(/)ident(max)          comment(# chars per unit)
reserved(for) ident(i) reserved(in) ident(values)
    ident(printf) string<delimiter(")content(%8.1f %s)char(\\n)delimiter(")>operator(,) ident(i)operator(,) string<delimiter(")content(*)delimiter(")> operator(*) operator(()ident(ratio)operator(*)ident(i)operator(\))
reserved(end)

comment(# gives, for example:)
comment(#   15.0 *******************************)
comment(#   10.0 *********************)
comment(#    5.0 **********)
comment(#   14.0 *****************************)
comment(#   18.0 **************************************)


comment(# @@PLEAC@@_16.1)
ident(output) operator(=) shell<delimiter(`)content(program args)delimiter(`)>       comment(# collect output into one multiline string)
ident(output) operator(=) shell<delimiter(`)content(program args)delimiter(`)>operator(.)ident(split) comment(# collect output into array, one line per)
ident(element)

ident(readme) operator(=) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(ls)delimiter(")>operator(\))
ident(output) operator(=) string<delimiter(")delimiter(")>
reserved(while) ident(readme)operator(.)ident(gets) reserved(do)
    ident(output) operator(+=) global_variable($_)
reserved(end)
ident(readme)operator(.)ident(close)

shell<delimiter(`)content(fsck -y /dev/rsd1a)delimiter(`)>  comment(# BAD AND SCARY in Perl because it's managed by the shell)
                      comment(# I donna in Ruby ...)

comment(# so the "clean and secure" version)
ident(readme)operator(,) ident(writeme) operator(=) constant(IO)operator(.)ident(pipe)
ident(pid) operator(=) ident(fork) operator({)
    comment(# child)
    global_variable($stdout) operator(=) ident(writeme)
    ident(readme)operator(.)ident(close)
    ident(exec)operator(()string<delimiter(')content(find)delimiter(')>operator(,) string<delimiter(')content(..)delimiter(')>operator(\))
operator(})
comment(# parent)
constant(Process)operator(.)ident(waitpid)operator(()ident(pid)operator(,) integer(0)operator(\))
ident(writeme)operator(.)ident(close)
reserved(while) ident(readme)operator(.)ident(gets) reserved(do)
    comment(# do something with $_)
reserved(end)


comment(# @@PLEAC@@_16.2)
ident(status) operator(=) ident(system)operator(()string<delimiter(")content(xemacs )inline<delimiter(#{)ident(myfile)delimiter(})>delimiter(")>operator(\))

ident(status) operator(=) ident(system)operator(()string<delimiter(")content(xemacs)delimiter(")>operator(,) ident(myfile)operator(\))

ident(system)operator(()string<delimiter(")content(cmd1 args | cmd2 | cmd3 >outfile)delimiter(")>operator(\))
ident(system)operator(()string<delimiter(")content(cmd args <infile >outfile 2>errfile)delimiter(")>operator(\))

comment(# stop if the command fails)
ident(raise) string<delimiter(")content($program exited funny: )inline<delimiter(#{)global_variable($?)delimiter(})>delimiter(")> reserved(unless) ident(system)operator(()string<delimiter(")content(cmd)delimiter(")>operator(,) string<delimiter(")content(args1)delimiter(")>operator(,) string<delimiter(")content(args2)delimiter(")>operator(\))

comment(# get the value of the signal sent to the child)
comment(# even if it is a SIGINT or SIGQUIT)
ident(system)operator(()ident(arglist)operator(\))
ident(raise) string<delimiter(")content(program killed by signal )inline<delimiter(#{)global_variable($?)delimiter(})>delimiter(")> reserved(if) operator(()global_variable($?) operator(&) integer(127)operator(\)) operator(!=) integer(0)

ident(pid) operator(=) ident(fork) operator({)
    ident(trap)operator(()string<delimiter(")content(SIGINT)delimiter(")>operator(,) string<delimiter(")content(IGNORE)delimiter(")>operator(\))
    ident(exec)operator(()string<delimiter(")content(sleep)delimiter(")>operator(,) string<delimiter(")content(10)delimiter(")>operator(\))
operator(})
ident(trap) operator(()string<delimiter(")content(SIGINT)delimiter(")>operator(\)) operator({)
    ident(puts) string<delimiter(")content(Tsk tsk, no process interruptus)delimiter(")>
operator(})
constant(Process)operator(.)ident(waitpid)operator(()ident(pid)operator(,) integer(0)operator(\))

comment(# Ruby doesn't permit to lie to the program called by a 'system'.)
comment(# (ie specify what return argv[0] in C, $0 in Perl/Ruby ...\))
comment(# A (dirty\) way is to create a link (under Unix\), run this link and)
comment(# erase it. Somebody has a best idea ?)


comment(# @@PLEAC@@_16.3)
ident(exec)operator(()string<delimiter(")content(archive *.data)delimiter(")>operator(\))

ident(exec)operator(()string<delimiter(")content(archive)delimiter(")>operator(,) string<delimiter(")content(accounting.data)delimiter(")>operator(\))

ident(exec)operator(()string<delimiter(")content(archive accounting.data)delimiter(")>operator(\))


comment(# @@PLEAC@@_16.4)
comment(# read the output of a program)
constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(ls)delimiter(")>operator(\)) operator({)operator(|)ident(readme)operator(|)
    reserved(while) ident(readme)operator(.)ident(gets) reserved(do)
        comment(# ...)
    reserved(end)
operator(})
comment(# or)
ident(readme) operator(=) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(ls)delimiter(")>operator(\))
reserved(while) ident(readme)operator(.)ident(gets) reserved(do)
    comment(# ...)
reserved(end)
ident(readme)operator(.)ident(close)

comment(# "write" in a program)
constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(cmd args)delimiter(")>operator(,)string<delimiter(")content(w)delimiter(")>operator(\)) operator({)operator(|)ident(pipe)operator(|)
    ident(pipe)operator(.)ident(puts)operator(()string<delimiter(")content(data)delimiter(")>operator(\))
    ident(pipe)operator(.)ident(puts)operator(()string<delimiter(")content(foo)delimiter(")>operator(\))
operator(})

comment(# close wait for the end of the process)
ident(read) operator(=) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(sleep 10000)delimiter(")>operator(\)) comment(# child goes to sleep)
ident(read)operator(.)ident(close)                     comment(# and the parent goes to lala land)

ident(writeme) operator(=) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(cmd args)delimiter(")>operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
ident(writeme)operator(.)ident(puts) string<delimiter(")content(hello)delimiter(")> comment(# program will get hello\\n on STDIN)
ident(writeme)operator(.)ident(close)        comment(# program will get EOF on STDIN)

comment(# send in a pager (eg less\) all output)
global_variable($stdout) operator(=) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(/usr/bin/less)delimiter(")>operator(,)string<delimiter(")content(w)delimiter(")>operator(\))
ident(print) string<delimiter(")content(huge string)char(\\n)delimiter(")> operator(*) integer(10000)


comment(# @@PLEAC@@_16.5)
comment(#-----------------------------)
reserved(def) method(head)operator(()ident(lines) operator(=) integer(20)operator(\))
    ident(pid) operator(=) ident(open)operator(()string<delimiter(")content(|-)delimiter(")>operator(,)string<delimiter(")content(w)delimiter(")>operator(\))
    reserved(if) ident(pid) operator(==) pre_constant(nil)
        reserved(return)
    reserved(else)
        reserved(while) ident(gets)operator(()operator(\)) reserved(do)
            ident(pid)operator(.)ident(print)
            ident(lines) operator(-=) integer(1)
            reserved(break) reserved(if) ident(lines) operator(==) integer(0)
        reserved(end)
    reserved(end)
    ident(exit)
reserved(end)

ident(head)operator(()integer(100)operator(\))
reserved(while) ident(gets)operator(()operator(\)) reserved(do)
    ident(print)
reserved(end)
comment(#-----------------------------)
integer(1)operator(:) operator(>) constant(Welcome) ident(to) constant(Linux)operator(,) ident(version) float(2.0)operator(.)integer(33) ident(on) ident(a) ident(i686)

integer(2)operator(:) operator(>)

integer(3)operator(:) operator(>)     string<delimiter(")content(The software required `Windows 95 or better',

4: >      so I installed Linux.)delimiter(")>
comment(#-----------------------------)
operator(>) integer(1)operator(:) constant(Welcome) ident(to) constant(Linux)operator(,) constant(Kernel) ident(version) float(2.0)operator(.)integer(33) ident(on) ident(a) ident(i686)

operator(>) integer(2)operator(:)

operator(>) integer(3)operator(:)     string<delimiter(")content(The software required `Windows 95 or better',

> 4:      so I installed Linux.)delimiter(")>
comment(#-----------------------------)
comment(#!/usr/bin/ruby)
comment(# qnumcat - demo additive output filters)

reserved(def) method(number)operator(()operator(\))
    ident(pid) operator(=) ident(open)operator(()string<delimiter(")content(|-)delimiter(")>operator(,)string<delimiter(")content(w)delimiter(")>operator(\))
    reserved(if) ident(pid) operator(==) pre_constant(nil)
        reserved(return)
    reserved(else)
        reserved(while) ident(gets)operator(()operator(\)) reserved(do) ident(pid)operator(.)ident(printf)operator(()string<delimiter(")content(%d: %s)delimiter(")>operator(,) global_variable($.)operator(,) global_variable($_)operator(\))operator(;) reserved(end)
    reserved(end)
    ident(exit)
reserved(end)

reserved(def) method(quote)operator(()operator(\))
    ident(pid) operator(=) ident(open)operator(()string<delimiter(")content(|-)delimiter(")>operator(,)string<delimiter(")content(w)delimiter(")>operator(\))
    reserved(if) ident(pid) operator(==) pre_constant(nil)
        reserved(return)
    reserved(else)
        reserved(while) ident(gets)operator(()operator(\)) reserved(do) ident(pid)operator(.)ident(print) string<delimiter(")content(> )inline<delimiter(#{)global_variable($_)delimiter(})>delimiter(")> reserved(end)
    reserved(end)
    ident(exit)
reserved(end)

ident(number)operator(()operator(\))
ident(quote)operator(()operator(\))

reserved(while) ident(gets)operator(()operator(\)) reserved(do)
    ident(print)
reserved(end)
global_variable($stdout)operator(.)ident(close)
ident(exit)


comment(# @@PLEAC@@_16.6)
pre_constant(ARGV)operator(.)ident(map!) operator({) operator(|)ident(arg)operator(|)
    ident(arg) operator(=)operator(~) regexp<delimiter(/)char(\\.)content((gz|Z\)$)delimiter(/)> operator(?) string<delimiter(")content(|gzip -dc )inline<delimiter(#{)ident(arg)delimiter(})>delimiter(")> operator(:) ident(arg)
operator(})
reserved(for) ident(file) reserved(in) pre_constant(ARGV)
    ident(fh) operator(=) ident(open)operator(()ident(file)operator(\))
    reserved(while) ident(fh)operator(.)ident(gets)operator(()operator(\)) reserved(do)
        comment(# .......)
    reserved(end)
reserved(end)
comment(#-----------------------------)
pre_constant(ARGV)operator(.)ident(map!) operator({) operator(|)ident(arg)operator(|)
    ident(arg) operator(=)operator(~) regexp<delimiter(%r#)content(^)char(\\w)content(+://)delimiter(#)> operator(?) string<delimiter(")content(|GET )inline<delimiter(#{)ident(arg)delimiter(})>delimiter(")> operator(:) ident(arg)   comment(#)
operator(})
reserved(for) ident(file) reserved(in) pre_constant(ARGV)
    ident(fh) operator(=) ident(open)operator(()ident(file)operator(\))
    reserved(while) ident(fh)operator(.)ident(gets)operator(()operator(\)) reserved(do)
        comment(# .......)
    reserved(end)
reserved(end)
comment(#-----------------------------)
ident(pwdinfo) operator(=) operator(()shell<delimiter(`)content(domainname)delimiter(`)> operator(=)operator(~) regexp<delimiter(/)content(^()char(\\()content(none)char(\\\))content(\)?$)delimiter(/)>operator(\)) operator(?) string<delimiter(')content(/etc/passwd)delimiter(')> operator(:) string<delimiter(')content(|ypcat  passwd)delimiter(')>operator(;)
ident(pwd) operator(=) ident(open)operator(()ident(pwdinfo)operator(\))operator(;)
comment(#-----------------------------)
ident(puts) string<delimiter(")content(File, please? )delimiter(")>operator(;)
ident(file) operator(=) ident(gets)operator(()operator(\))operator(.)ident(chomp)operator(()operator(\))operator(;)
ident(fh) operator(=) ident(open)operator(()ident(file)operator(\))operator(;)


comment(# @@PLEAC@@_16.7)
ident(output) operator(=) shell<delimiter(`)content(cmd 2>&1)delimiter(`)>                            comment(# with backticks)
comment(# or)
ident(ph) operator(=) ident(open)operator(()string<delimiter(")content(|cmd 2>&1)delimiter(")>operator(\))                         comment(# with an open pipe)
reserved(while) ident(ph)operator(.)ident(gets)operator(()operator(\)) operator({) operator(})                            comment(# plus a read)
comment(#-----------------------------)
ident(output) operator(=) shell<delimiter(`)content(cmd 2>/dev/null)delimiter(`)>                     comment(# with backticks)
comment(# or)
ident(ph) operator(=) ident(open)operator(()string<delimiter(")content(|cmd 2>/dev/null)delimiter(")>operator(\))                  comment(# with an open pipe)
reserved(while) ident(ph)operator(.)ident(gets)operator(()operator(\)) operator({) operator(})                            comment(# plus a read)
comment(#-----------------------------)
ident(output) operator(=) shell<delimiter(`)content(cmd 2>&1 1>/dev/null)delimiter(`)>                comment(# with backticks)
comment(# or)
ident(ph) operator(=) ident(open)operator(()string<delimiter(")content(|cmd 2>&1 1>/dev/null)delimiter(")>operator(\))             comment(# with an open pipe)
reserved(while) ident(ph)operator(.)ident(gets)operator(()operator(\)) operator({) operator(})                            comment(# plus a read)
comment(#-----------------------------)
ident(output) operator(=) shell<delimiter(`)content(cmd 3>&1 1>&2 2>&3 3>&-)delimiter(`)>             comment(# with backticks)
comment(# or)
ident(ph) operator(=) ident(open)operator(()string<delimiter(")content(|cmd 3>&1 1>&2 2>&3 3>&-)delimiter(")>operator(\))          comment(# with an open pipe)
reserved(while) ident(ph)operator(.)ident(gets)operator(()operator(\)) operator({) operator(})                            comment(# plus a read)
comment(#-----------------------------)
ident(system)operator(()string<delimiter(")content(program args 1>/tmp/program.stdout 2>/tmp/program.stderr)delimiter(")>operator(\))
comment(#-----------------------------)
ident(output) operator(=) shell<delimiter(`)content(cmd 3>&1 1>&2 2>&3 3>&-)delimiter(`)>
comment(#-----------------------------)
ident(fd3) operator(=) ident(fd1)
ident(fd1) operator(=) ident(fd2)
ident(fd2) operator(=) ident(fd3)
ident(fd3) operator(=) reserved(undef)
comment(#-----------------------------)
method(system)operator(()string<delimiter(")content(prog args 1>tmpfile 2>&1)delimiter(")>operator(\))
ident(system)operator(()string<delimiter(")content(prog args 2>&1 1>tmpfile)delimiter(")>operator(\))
comment(#-----------------------------)
comment(# system ("prog args 1>tmpfile 2>&1"\))
ident(fd1) operator(=) string<delimiter(")content(tmpfile)delimiter(")>          comment(# change stdout destination first)
ident(fd2) operator(=) ident(fd1)                comment(# now point stderr there, too)
comment(#-----------------------------)
comment(# system("prog args 2>&1 1>tmpfile"\))
ident(fd2) operator(=) ident(fd1)                comment(# stderr same destination as stdout)
ident(fd1) operator(=) string<delimiter(")content(tmpfile)delimiter(")>          comment(# but change stdout destination)
comment(#-----------------------------)
comment(# It is often better not to rely on the shell,)
comment(# because of portability, possible security problems)
comment(# and bigger resource usage. So, it is often better to use the open3 library.)
comment(# See below for an example.)
comment(# opening stdin, stdout, stderr)
ident(require) string<delimiter(")content(open3)delimiter(")>
ident(stdin)operator(,) ident(stdout)operator(,) ident(stderr) operator(=) constant(Open3)operator(.)ident(popen)operator(()string<delimiter(')content(cmd)delimiter(')>operator(\))


comment(# @@PLEAC@@_16.8)
comment(#-----------------------------)
comment(# Contrary to perl, we don't need to use a module in Ruby)
ident(fh) operator(=) constant(Kernel)operator(.)ident(open)operator(()string<delimiter(")content(|)delimiter(")> operator(+) ident(program)operator(,) string<delimiter(")content(w+)delimiter(")>operator(\))
ident(fh)operator(.)ident(puts) string<delimiter(")content(here's your input)char(\\n)delimiter(")>
ident(output) operator(=) ident(fh)operator(.)ident(gets)operator(()operator(\))
ident(fh)operator(.)ident(close)operator(()operator(\))
comment(#-----------------------------)
constant(Kernel)operator(.)ident(open)operator(()string<delimiter(")content(|program)delimiter(")>operator(\))operator(,)string<delimiter(")content(w+)delimiter(")>operator(\))    comment(# RIGHT !)
comment(#-----------------------------)
comment(# Ruby has already object methods for I/O handles)
comment(#-----------------------------)
reserved(begin)
    ident(fh) operator(=) constant(Kernel)operator(.)ident(open)operator(()string<delimiter(")content(|)delimiter(")> operator(+) ident(program_and_options)operator(,) string<delimiter(")content(w+)delimiter(")>operator(\))
reserved(rescue)
    reserved(if) operator(()global_variable($@) operator(~=) regexp<delimiter(/)content(^open)delimiter(/)>operator(\))
        global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(open failed : )inline<delimiter(#{)global_variable($!)delimiter(})>content( )char(\\n)content( )inline<delimiter(#{)global_variable($@)delimiter(})>content( )char(\\n)delimiter(")>
        reserved(break)
    reserved(end)
    ident(raise)      comment(# reraise unforseen exception)
reserved(end)


comment(# @@PLEAC@@_16.13)
comment(#% kill -l)
comment(#HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE)
comment(#ALRM TERM CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM)
comment(#PROF WINCH POLL PWR)
comment(#-----------------------------)
comment(#% ruby -e 'puts Signal.list.keys.join(" "\)')
comment(#PWR USR1 BUS USR2 TERM SEGV KILL POLL STOP SYS TRAP IOT HUP INT                                                                          #)
comment(#WINCH XCPU TTIN CLD TSTP FPE IO TTOU PROF CHLD CONT PIPE ABRT)
comment(#VTALRM QUIT ILL XFSZ URG ALRM)
comment(#-----------------------------)
comment(# After that, the perl script create an hash equivalent to Signal.list,)
comment(# and an array. The array can be obtained by :)
ident(signame) operator(=) operator([)operator(])
constant(Signal)operator(.)ident(list)operator(.)ident(each) operator({) operator(|)ident(name)operator(,) ident(i)operator(|) ident(signame)operator([)ident(i)operator(]) operator(=) ident(name) operator(})


comment(# @@PLEAC@@_16.14)
constant(Process)operator(.)ident(kill)operator(()integer(9)operator(,) ident(pid)operator(\))                    comment(# send $pid a signal 9)
constant(Process)operator(.)ident(kill)operator(()operator(-)integer(1)operator(,) constant(Process)operator(.)ident(getpgrp)operator(()operator(\))operator(\))     comment(# send whole job a signal 1)
constant(Process)operator(.)ident(kill)operator(()string<delimiter(")content(USR1)delimiter(")>operator(,) global_variable($$)operator(\))                comment(# send myself a SIGUSR1)
constant(Process)operator(.)ident(kill)operator(()string<delimiter(")content(HUP)delimiter(")>operator(,) ident(pid1)operator(,) ident(pid2)operator(,) ident(pid3)operator(\))   comment(# send a SIGHUP to processes in @pids)
comment(#-----------------------------)
reserved(begin)
    constant(Process)operator(.)ident(kill)operator(()integer(0)operator(,) ident(minion)operator(\))
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(minion)delimiter(})>content( is alive!)delimiter(")>
reserved(rescue) constant(Errno)operator(::)constant(EPERM)                     comment(# changed uid)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(minion)delimiter(})>content( has escaped my control!)delimiter(")>operator(;)
reserved(rescue) constant(Errno)operator(::)constant(ESRCH)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(minion)delimiter(})>content( is deceased.)delimiter(")>operator(;)      comment(# or zombied)
reserved(rescue)
    ident(puts) string<delimiter(")content(Odd; I couldn't check the status of )inline<delimiter(#{)ident(minion)delimiter(})>content( : )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(end)


comment(# @@PLEAC@@_16.15)
constant(Kernel)operator(.)ident(trap)operator(()string<delimiter(")content(QUIT)delimiter(")>operator(,) ident(got_sig_quit)operator(\))       comment(# got_sig_quit = Proc.new { puts "Quit\\n" })
ident(trap)operator(()string<delimiter(")content(PIPE)delimiter(")>operator(,) string<delimiter(")content(got_sig_quit)delimiter(")>operator(\))            comment(# def got_sig_pipe ...)
ident(trap)operator(()string<delimiter(")content(INT)delimiter(")>operator(\)) operator({) ident(ouch)operator(+)operator(+) operator(})                  comment(# increment ouch for every SIGINT)
comment(#-----------------------------)
ident(trap)operator(()string<delimiter(")content(INT)delimiter(")>operator(,) string<delimiter(")content(IGNORE)delimiter(")>operator(\))                   comment(# ignore the signal INT)
comment(#-----------------------------)
ident(trap)operator(()string<delimiter(")content(STOP)delimiter(")>operator(,) string<delimiter(")content(DEFAULT)delimiter(")>operator(\))                 comment(# restore default STOP signal handling)


comment(# @@PLEAC@@_16.16)
comment(# the signal handler)
reserved(def) method(ding)
    ident(trap)operator(()string<delimiter(")content(INT)delimiter(")>operator(,) string<delimiter(")content(ding)delimiter(")>operator(\))
    ident(puts) string<delimiter(")char(\\a)content(Enter your name!)delimiter(")>
reserved(end)

comment(# prompt for name, overriding SIGINT)
reserved(def) method(get_name)
    ident(save) operator(=) ident(trap)operator(()string<delimiter(")content(INT)delimiter(")>operator(,) string<delimiter(")content(ding)delimiter(")>operator(\))

    ident(puts) string<delimiter(")content(Kindly Stranger, please enter your name: )delimiter(")>
    ident(name) operator(=) ident(gets)operator(()operator(\))operator(.)ident(chomp)operator(()operator(\))
    ident(trap)operator(()string<delimiter(")content(INT)delimiter(")>operator(,) ident(save)operator(\))
    ident(name)
reserved(end)


comment(# @@PLEAC@@_16.21)
comment(# implemented thanks to http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/1760)
ident(require) string<delimiter(')content(timeout)delimiter(')>

comment(# we'll do something vastly more useful than cookbook to demonstrate timeouts)
reserved(begin)
    ident(timeout)operator(()integer(5)operator(\)) operator({)
        ident(waitsec) operator(=) ident(rand)operator(()integer(10)operator(\))
        ident(puts) string<delimiter(")content(Let's see if a sleep of )inline<delimiter(#{)ident(waitsec)delimiter(})>content( seconds is longer than 5 seconds...)delimiter(")>
        ident(system)operator(()string<delimiter(")content(sleep )inline<delimiter(#{)ident(waitsec)delimiter(})>delimiter(")>operator(\))
    operator(})
    ident(puts) string<delimiter(")content(Timeout didn't occur)delimiter(")>
reserved(rescue) constant(Timeout)operator(::)constant(Error)
    ident(puts) string<delimiter(")content(Timed out!)delimiter(")>
reserved(end)


comment(# @@PLEAC@@_17.1)
comment(# A basic TCP client connection)
ident(require) string<delimiter(')content(socket)delimiter(')>
reserved(begin)
    ident(t) operator(=) constant(TCPSocket)operator(.)ident(new)operator(()string<delimiter(')content(www.ruby-lang.org)delimiter(')>operator(,) string<delimiter(')content(www)delimiter(')>operator(\))
reserved(rescue)
    ident(puts) string<delimiter(")content(error: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(else)
    comment(# ... do something with the socket)
    ident(t)operator(.)ident(print) string<delimiter(")content(GET / HTTP/1.0)char(\\n)char(\\n)delimiter(")>
    ident(answer) operator(=) ident(t)operator(.)ident(gets)operator(()pre_constant(nil)operator(\))
    comment(# and terminate the connection when we're done)
    ident(t)operator(.)ident(close)
reserved(end)

comment(# Using the evil low level socket API)
ident(require) string<delimiter(')content(socket)delimiter(')>
comment(# create a socket)
ident(s) operator(=) constant(Socket)operator(.)ident(new)operator(()constant(Socket)operator(::)constant(AF_INET)operator(,) constant(Socket)operator(::)constant(SOCK_STREAM)operator(,) integer(0)operator(\))
comment(# build the address of the remote machine)
ident(sockaddr_server) operator(=) operator([)constant(Socket)operator(::)constant(AF_INET)operator(,) integer(80)operator(,)
    constant(Socket)operator(.)ident(gethostbyname)operator(()string<delimiter(')content(www.ruby-lang.org)delimiter(')>operator(\))operator([)integer(3)operator(])operator(,)
    integer(0)operator(,) integer(0)operator(])operator(.)ident(pack)operator(()string<delimiter(")content(snA4NN)delimiter(")>operator(\))
comment(# connect)
reserved(begin)
    ident(s)operator(.)ident(connect)operator(()ident(sockaddr_server)operator(\))
reserved(rescue)
    ident(puts) string<delimiter(")content(error: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(else)
    comment(# ... do something with the socket)
    ident(s)operator(.)ident(print) string<delimiter(")content(GET / HTTP/1.0)char(\\n)char(\\n)delimiter(")>
    comment(# and terminate the connection when we're done)
    ident(s)operator(.)ident(close)
reserved(end)

comment(# TCP connection with management of error (DNS\))
ident(require) string<delimiter(')content(socket)delimiter(')>
reserved(begin)
    ident(client) operator(=) constant(TCPSocket)operator(.)ident(new)operator(()string<delimiter(')content(does not exists)delimiter(')>operator(,) string<delimiter(')content(www)delimiter(')>operator(\))
reserved(rescue)
    ident(puts) string<delimiter(")content(error: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(end)

comment(# TCP connection with a time out)
ident(require) string<delimiter(')content(socket)delimiter(')>
ident(require) string<delimiter(')content(timeout)delimiter(')>
reserved(begin)
    ident(timeout)operator(()integer(1)operator(\)) reserved(do) comment(#the server has one second to answer)
        ident(client) operator(=) constant(TCPSocket)operator(.)ident(new)operator(()string<delimiter(')content(www.host.com)delimiter(')>operator(,) string<delimiter(')content(www)delimiter(')>operator(\))
    reserved(end)
reserved(rescue)
    ident(puts) string<delimiter(")content(error: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(end)


comment(# @@PLEAC@@_17.12)
ident(require) string<delimiter(')content(socket)delimiter(')>

reserved(class) class(Preforker)
    ident(attr_reader) operator(()symbol(:child_count)operator(\))

    reserved(def) method(initialize)operator(()ident(prefork)operator(,) ident(max_clients_per_child)operator(,) ident(port)operator(,) ident(client_handler)operator(\))
        instance_variable(@prefork) operator(=) ident(prefork)
        instance_variable(@max_clients_per_child) operator(=) ident(max_clients_per_child)
        instance_variable(@port) operator(=) ident(port)
        instance_variable(@child_count) operator(=) integer(0)

        instance_variable(@reaper) operator(=) ident(proc) operator({)
            ident(trap)operator(()string<delimiter(')content(CHLD)delimiter(')>operator(,) instance_variable(@reaper)operator(\))
            ident(pid) operator(=) constant(Process)operator(.)ident(wait)
            instance_variable(@child_count) operator(-=) integer(1)
        operator(})

        instance_variable(@huntsman) operator(=) ident(proc) operator({)
            ident(trap)operator(()string<delimiter(')content(CHLD)delimiter(')>operator(,) string<delimiter(')content(IGNORE)delimiter(')>operator(\))
            ident(trap)operator(()string<delimiter(')content(INT)delimiter(')>operator(,) string<delimiter(')content(IGNORE)delimiter(')>operator(\))
            constant(Process)operator(.)ident(kill)operator(()string<delimiter(')content(INT)delimiter(')>operator(,) integer(0)operator(\))
            ident(exit)
        operator(})

        instance_variable(@client_handler)operator(=)ident(client_handler)
    reserved(end)

    reserved(def) method(child_handler)
        ident(trap)operator(()string<delimiter(')content(INT)delimiter(')>operator(,) string<delimiter(')content(EXIT)delimiter(')>operator(\))
        instance_variable(@client_handler)operator(.)ident(setUp)
        comment(# wish: sigprocmask UNblock SIGINT)
        instance_variable(@max_clients_per_child)operator(.)ident(times) operator({)
            ident(client) operator(=) instance_variable(@server)operator(.)ident(accept) reserved(or) reserved(break)
            instance_variable(@client_handler)operator(.)ident(handle_request)operator(()ident(client)operator(\))
            ident(client)operator(.)ident(close)
        operator(})
        instance_variable(@client_handler)operator(.)ident(tearDown)
    reserved(end)

    reserved(def) method(make_new_child)
        comment(# wish: sigprocmask block SIGINT)
        instance_variable(@child_count) operator(+=) integer(1)
        ident(pid) operator(=) ident(fork) reserved(do)
            ident(child_handler)
        reserved(end)
        comment(# wish: sigprocmask UNblock SIGINT)
    reserved(end)

    reserved(def) method(run)
        instance_variable(@server) operator(=) constant(TCPserver)operator(.)ident(open)operator(()instance_variable(@port)operator(\))
        ident(trap)operator(()string<delimiter(')content(CHLD)delimiter(')>operator(,) instance_variable(@reaper)operator(\))
        ident(trap)operator(()string<delimiter(')content(INT)delimiter(')>operator(,) instance_variable(@huntsman)operator(\))
        ident(loop) operator({)
            operator(()instance_variable(@prefork) operator(-) instance_variable(@child_count)operator(\))operator(.)ident(times) operator({) operator(|)ident(i)operator(|)
                ident(make_new_child)
            operator(})
            ident(sleep) operator(.)integer(1)
        operator(})
    reserved(end)
reserved(end)

comment(#-----------------------------)
comment(#!/usr/bin/ruby)

ident(require) string<delimiter(')content(Preforker)delimiter(')>

reserved(class) class(ClientHandler)
    reserved(def) method(setUp)
    reserved(end)

    reserved(def) method(tearDown)
    reserved(end)

    reserved(def) method(handle_request)operator(()ident(client)operator(\))
        comment(# do stuff)
    reserved(end)
reserved(end)

ident(server) operator(=) constant(Preforker)operator(.)ident(new)operator(()integer(1)operator(,) integer(100)operator(,) integer(3102)operator(,) constant(ClientHandler)operator(.)ident(new)operator(\))
ident(server)operator(.)ident(run)


comment(# @@PLEAC@@_18.2)
ident(require) string<delimiter(')content(net/ftp)delimiter(')>

reserved(begin)
    ident(ftp) operator(=) constant(Net)operator(::)constant(FTP)operator(::)ident(new)operator(()string<delimiter(")content(ftp.host.com)delimiter(")>operator(\))
    ident(ftp)operator(.)ident(login)operator(()ident(username)operator(,)ident(password)operator(\))
    ident(ftp)operator(.)ident(chdir)operator(()ident(directory)operator(\))
    ident(ftp)operator(.)ident(get)operator(()ident(filename)operator(\))
    ident(ftp)operator(.)ident(put)operator(()ident(filename)operator(\))
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(print) string<delimiter(")content(FTP failed: )delimiter(")> operator(+) global_variable($!)
reserved(ensure)
    ident(ftp)operator(.)ident(close)operator(()operator(\)) reserved(if) ident(ftp)
reserved(end)

comment(# A better solution for a local use could be :)
constant(Net)operator(::)constant(FTP)operator(::)ident(new)operator(()string<delimiter(")content(ftp.host.com)delimiter(")>operator(\)) reserved(do) operator(|)ident(ftp)operator(|)
    ident(ftp)operator(.)ident(login)operator(()ident(username)operator(,)ident(password)operator(\))
    ident(ftp)operator(.)ident(chdir)operator(()ident(directory)operator(\))
    ident(ftp)operator(.)ident(get)operator(()ident(filename)operator(\))
    ident(ftp)operator(.)ident(put)operator(()ident(filename)operator(\))
reserved(end)

comment(# If you have only one file to get, there is a simple solution :)
ident(require) string<delimiter(')content(open-uri)delimiter(')>
ident(open)operator(()string<delimiter(")content(ftp://www.ruby-lang.org/path/filename)delimiter(")>operator(\)) reserved(do) operator(|)ident(fh)operator(|)
    comment(# read from filehandle fh)
reserved(end)
comment(#--------------------------------------------)
comment(# to wait a defined time for the connection,)
comment(# use the timeout module)
ident(require) string<delimiter(')content(timeout)delimiter(')>
reserved(begin)
    ident(timeout)operator(()integer(30)operator(\))operator({)
        ident(ftp) operator(=) constant(Net)operator(::)constant(FTP)operator(::)ident(new)operator(()string<delimiter(")content(ftp.host.com)delimiter(")>operator(\))
        ident(ftp)operator(.)ident(debug_mode) operator(=) pre_constant(true)
    operator(})
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(Couldn't connect.)delimiter(")>
reserved(rescue) constant(Timeout)operator(::)constant(Error)
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(Timeout while connecting to server.)delimiter(")>
reserved(end)

reserved(begin)
    ident(ftp)operator(.)ident(login)operator(()operator(\))
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(print) string<delimiter(")content(Couldn't authentificate.)char(\\n)delimiter(")>
reserved(end)

reserved(begin)
    ident(ftp)operator(.)ident(login)operator(()ident(username)operator(\))
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(print) string<delimiter(")content(Still couldn't authenticate.)char(\\n)delimiter(")>
reserved(end)

reserved(begin)
    ident(ftp)operator(.)ident(login)operator(()ident(username)operator(,) ident(password)operator(\))
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(print) string<delimiter(")content(Couldn't authenticate, even with explicit
    username and password.)char(\\n)delimiter(")>
reserved(end)

reserved(begin)
    ident(ftp)operator(.)ident(login)operator(()ident(username)operator(,) ident(password)operator(,) ident(account)operator(\))
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(print) string<delimiter(")content(No dice. It hates me.)char(\\n)delimiter(")>
reserved(end)
comment(#-----------------------------)
ident(ftp)operator(.)ident(put)operator(()ident(localfile)operator(,) ident(remotefile)operator(\))
comment(#-----------------------------)
comment(# Sending data from STDIN is not directly supported)
comment(# by the ftp library module. A possible way to do it is to use the)
comment(# storlines method directly to send raw commands to the ftp server.)
comment(#-----------------------------)
ident(ftp)operator(.)ident(get)operator(()ident(remotefile)operator(,) ident(localfile)operator(\))
comment(#-----------------------------)
ident(ftp)operator(.)ident(get)operator(()ident(remotefile)operator(\)) operator({) operator(|)ident(data)operator(|) ident(puts) ident(data) operator(})
comment(#-----------------------------)
ident(ftp)operator(.)ident(chdir)operator(()string<delimiter(")content(/pub/ruby)delimiter(")>operator(\))
ident(print) string<delimiter(")content(I'm in the directory )delimiter(")>operator(,) ident(ftp)operator(.)ident(pwd)operator(()operator(\))operator(,) string<delimiter(")char(\\n)delimiter(")>
comment(#-----------------------------)
ident(ftp)operator(.)ident(mkdir)operator(()string<delimiter(")content(/pub/ruby/new_dir)delimiter(")>operator(\))
comment(#-----------------------------)
ident(lines) operator(=) ident(ftp)operator(.)ident(ls)operator(()string<delimiter(")content(/pub/ruby/)delimiter(")>operator(\))
comment(# => ["drwxr-xr-x 2 matz users 4096 July 17 1998 1.0", ... ])

ident(latest) operator(=) ident(ftp)operator(.)ident(dir)operator(()string<delimiter(")content(/pub/ruby/*.tgz)delimiter(")>operator(\))operator(.)ident(sort)operator(.)ident(last)

ident(ftp)operator(.)ident(nlst)operator(()string<delimiter(")content(/pub/ruby)delimiter(")>operator(\))
comment(# => ["/pub/ruby/1.0", ... ])
comment(#-----------------------------)
ident(ftp)operator(.)ident(quit)operator(()operator(\))


comment(# @@PLEAC@@_18.6)
ident(require) string<delimiter(')content(net/telnet)delimiter(')>
ident(t) operator(=) constant(Net)operator(::)constant(Telnet)operator(::)ident(new)operator(() string<delimiter(")content(Timeout)delimiter(")> operator(=)operator(>) integer(10)operator(,)
                      string<delimiter(")content(Prompt)delimiter(")>  operator(=)operator(>) regexp<delimiter(/)content(%)delimiter(/)>operator(,)
                      string<delimiter(")content(Host)delimiter(")>    operator(=)operator(>) ident(host) operator(\))
ident(t)operator(.)ident(login)operator(()ident(username)operator(,) ident(password)operator(\))
ident(files) operator(=) ident(t)operator(.)ident(cmd)operator(()string<delimiter(")content(ls)delimiter(")>operator(\))
ident(t)operator(.)ident(print)operator(()string<delimiter(")content(top)delimiter(")>operator(\))
ident(process_string) operator(=) ident(t)operator(.)ident(waitfor)operator(()regexp<delimiter(/)char(\\d)content(+ processes)delimiter(/)>operator(\))
ident(t)operator(.)ident(close)
comment(#-----------------------------)
regexp<delimiter(/)content([$%#>] )char(\\z)delimiter(/)modifier(n)>
comment(#-----------------------------)
comment(# In case of an error, the telnet module throws an exception.)
comment(# For control of the behavior in case of an error,)
comment(# you just need to catch the exceptions and do your custom)
comment(# error handling.)
comment(#-----------------------------)
reserved(begin)
    ident(telnet)operator(.)ident(login)operator(()ident(username)operator(,) ident(password)operator(\))
reserved(rescue) constant(TimeoutError)
    ident(fail) string<delimiter(")content(Login failed !)char(\\n)delimiter(")>
reserved(end)
comment(#-----------------------------)
ident(telnet)operator(.)ident(waitfor)operator(()string<delimiter(')content(/--more--/)delimiter(')>operator(\))
comment(#-----------------------------)
ident(telnet)operator(.)ident(waitfor)operator(()constant(String) operator(=)operator(>) string<delimiter(')content(greasy smoke)delimiter(')>operator(,) constant(Timeout) operator(=)operator(>) integer(30)operator(\))


comment(# @@PLEAC@@_18.7)
ident(require) string<delimiter(')content(ping)delimiter(')>

ident(puts) string<delimiter(")inline<delimiter(#{)ident(host)delimiter(})>content( is alive.)char(\\n)delimiter(")> reserved(if) constant(Ping)operator(.)ident(pingecho)operator(()ident(host)operator(\))operator(;)
comment(#-----------------------------)
comment(# the ping module only use TCP ping, not ICMP even if we are root)
reserved(if) constant(Ping)operator(.)ident(pingecho)operator(()string<delimiter(")content(kingkong.com)delimiter(")>operator(\))
    ident(puts) string<delimiter(")content(The giant ape lives!)char(\\n)delimiter(")>operator(;)
reserved(else)
    ident(puts) string<delimiter(")content(All hail mighty Gamera, friend of children!)char(\\n)delimiter(")>operator(;)
reserved(end)


comment(# @@PLEAC@@_19.1)
comment(#!/usr/local/bin/ruby -w)
comment(# hiweb - load CGI class to decode information given by web server)

ident(require) string<delimiter(')content(cgi)delimiter(')>

ident(cgi) operator(=) constant(CGI)operator(.)ident(new)operator(()string<delimiter(')content(html3)delimiter(')>operator(\))

comment(# get a parameter from a form)
ident(value) operator(=) ident(cgi)operator(.)ident(params)operator([)string<delimiter(')content(PARAM_NAME)delimiter(')>operator(])operator([)integer(0)operator(])

comment(# output a document)
ident(cgi)operator(.)ident(out) operator({)
    ident(cgi)operator(.)ident(html) operator({)
        ident(cgi)operator(.)ident(head) operator({) ident(cgi)operator(.)ident(title) operator({) string<delimiter(")content(Howdy there!)delimiter(")> operator(}) operator(}) operator(+)
            ident(cgi)operator(.)ident(body) operator({) ident(cgi)operator(.)ident(p) operator({) string<delimiter(")content(You typed: )delimiter(")> operator(+) ident(cgi)operator(.)ident(tt) operator({)
                    constant(CGI)operator(.)ident(escapeHTML)operator(()ident(value)operator(\)) operator(}) operator(}) operator(})
    operator(})
operator(})

ident(require) string<delimiter(')content(cgi)delimiter(')>
ident(cgi) operator(=) constant(CGI)operator(.)ident(new)
ident(who)   operator(=) ident(cgi)operator(.)ident(param)operator([)string<delimiter(")content(Name)delimiter(")>operator(])operator([)integer(0)operator(])     comment(# first param in list)
ident(phone) operator(=) ident(cgi)operator(.)ident(param)operator([)string<delimiter(")content(Number)delimiter(")>operator(])operator([)integer(0)operator(])
ident(picks) operator(=) ident(cgi)operator(.)ident(param)operator([)string<delimiter(")content(Choices)delimiter(")>operator(])     comment(# complete list)

ident(print) ident(cgi)operator(.)ident(header)operator(() string<delimiter(')content(type)delimiter(')> operator(=)operator(>) string<delimiter(')content(text/plain)delimiter(')>operator(,)
                  string<delimiter(')content(expires)delimiter(')> operator(=)operator(>) constant(Time)operator(.)ident(now) operator(+) operator(()integer(3) operator(*) integer(24) operator(*) integer(60) operator(*) integer(60)operator(\)) operator(\))


comment(# @@PLEAC@@_19.3)
comment(#!/usr/local/bin/ruby -w)
comment(# webwhoami - show web user's id)
ident(require) string<delimiter(')content(etc)delimiter(')>
ident(print) string<delimiter(")content(Content-Type: text/plain)char(\\n)char(\\n)delimiter(")>
ident(print) string<delimiter(")content(Running as )delimiter(")> operator(+) constant(Etc)operator(.)ident(getpwuid)operator(.)ident(name) operator(+) string<delimiter(")char(\\n)delimiter(")>

comment(# % ruby -wc cgi-script     # just check syntax)

comment(# % ruby -w  cgi-script     # params from stdin)
comment(# (offline mode: enter name=value pairs on standard input\))
comment(# name=joe)
comment(# number=10)
comment(# ^D)

comment(# % ruby -w  cgi-script name=joe number=10     # run with mock form input)
comment(# % ruby -d  cgi-script name=joe number=10     # ditto, under the debugger)

comment(# POST method script in csh)
comment(# % (setenv HTTP_METHOD POST; ruby -w cgi-script name=joe number=10\))
comment(# POST method script in sh)
comment(# % HTTP_METHOD=POST perl -w cgi-script name=joe number=10)


comment(# @@PLEAC@@_19.4)
comment(# ruby has several security levels, the level "1" is similar to perls taint mode.)
comment(# It can be switched on by providing the -T command line parameter)
comment(# or by setting $SAFE to 1. Setting $SAFE to 2,3 or 4 restricts possible)
comment(# harmful operations further.)

comment(#!/usr/bin/ruby -T)
global_variable($SAFE) operator(=) integer(1)
constant(File)operator(.)ident(open)operator(()pre_constant(ARGV)operator([)integer(0)operator(])operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
comment(# ruby warns with:)
comment(# taint1.rb:2:in `initialize': Insecure operation - initialize (SecurityError\))

global_variable($SAFE) operator(=) integer(1)
ident(file) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
reserved(unless) regexp<delimiter(/)content(^([)char(\\w)content(.-]+\)$)delimiter(/)>operator(.)ident(match)operator(()ident(file)operator(\))
    ident(raise) string<delimiter(")content(filename )inline<delimiter(#{)ident(file)delimiter(})>content( has invalid characters)delimiter(")>
reserved(end)
ident(file) operator(=) global_variable($1)
comment(# In ruby, even the back reference from a regular expression stays tainted.)
comment(# you need to explicitly untaint the variable:)
ident(file)operator(.)ident(untaint)
constant(File)operator(.)ident(open)operator(()ident(file)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))

comment(# Race condition exists like in perl:)
reserved(unless) constant(File)operator(.)ident(exists)operator(()ident(filename)operator(\))        comment(# Wrong because of race condition)
    constant(File)operator(.)ident(open)operator(()ident(filename)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
reserved(end)



comment(# @@PLEAC@@_19.10)
ident(preference_value) operator(=) ident(cgi)operator(.)ident(cookies)operator([)string<delimiter(")content(preference name)delimiter(")>operator(])operator([)integer(0)operator(])

ident(packed_cookie) operator(=) constant(CGI)operator(::)constant(Cookie)operator(.)ident(new)operator(()string<delimiter(")content(name)delimiter(")> operator(=)operator(>) string<delimiter(")content(preference name)delimiter(")>operator(,)
                                string<delimiter(")content(value)delimiter(")> operator(=)operator(>) string<delimiter(")content(whatever you'd like)delimiter(")>operator(,)
                                string<delimiter(")content(expires)delimiter(")> operator(=)operator(>) constant(Time)operator(.)ident(local)operator(()constant(Time)operator(.)ident(now)operator(.)ident(year) operator(+) integer(2)operator(,)
    constant(Time)operator(.)ident(now)operator(.)ident(mon)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(day)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(hour)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(min)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(sec)operator(\)) operator(\))

ident(cgi)operator(.)ident(header)operator(()string<delimiter(")content(cookie)delimiter(")> operator(=)operator(>) operator([)ident(packed_cookie)operator(])operator(\))

comment(#!/usr/local/bin/ruby -w)
comment(# ic_cookies - sample CGI script that uses a cookie)
ident(require) string<delimiter(')content(cgi)delimiter(')>

ident(cgi) operator(=) constant(CGI)operator(.)ident(new)operator(()string<delimiter(')content(html3)delimiter(')>operator(\))

ident(cookname) operator(=) string<delimiter(")content(favorite ice cream)delimiter(")>
ident(favorite) operator(=) ident(cgi)operator(.)ident(params)operator([)string<delimiter(")content(flavor)delimiter(")>operator(])operator([)integer(0)operator(])
ident(tasty)    operator(=) ident(cgi)operator(.)ident(cookies)operator([)ident(cookname)operator(])operator([)integer(0)operator(]) operator(||) string<delimiter(')content(mint)delimiter(')>

reserved(unless) ident(favorite)
    ident(cgi)operator(.)ident(out) operator({)
        ident(cgi)operator(.)ident(html) operator({)
            ident(cgi)operator(.)ident(head) operator({) ident(cgi)operator(.)ident(title) operator({) string<delimiter(")content(Ice Cookies)delimiter(")> operator(}) operator(}) operator(+)
            ident(cgi)operator(.)ident(body) operator({)
                ident(cgi)operator(.)ident(h1) operator({) string<delimiter(")content(Hello Ice Cream)delimiter(")> operator(}) operator(+)
                ident(cgi)operator(.)ident(hr) operator(+)
                ident(cgi)operator(.)ident(form) operator({)
                    ident(cgi)operator(.)ident(p) operator({) string<delimiter(")content(Please select a flavor: )delimiter(")> operator(+)
                            ident(cgi)operator(.)ident(text_field)operator(()string<delimiter(")content(flavor)delimiter(")>operator(,) ident(tasty) operator(\)) operator(})
                operator(}) operator(+)
                ident(cgi)operator(.)ident(hr)
            operator(})
        operator(})
    operator(})
reserved(else)
    ident(cookie) operator(=) constant(CGI)operator(::)constant(Cookie)operator(.)ident(new)operator(() string<delimiter(")content(name)delimiter(")>    operator(=)operator(>) ident(cookname)operator(,)
                              string<delimiter(")content(value)delimiter(")>   operator(=)operator(>) ident(favorite)operator(,)
                              string<delimiter(")content(expires)delimiter(")> operator(=)operator(>) constant(Time)operator(.)ident(local)operator(()constant(Time)operator(.)ident(now)operator(.)ident(year) operator(+) integer(2)operator(,)
constant(Time)operator(.)ident(now)operator(.)ident(mon)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(day)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(hour)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(min)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(sec)operator(\)) operator(\))
    ident(cgi)operator(.)ident(out)operator(()string<delimiter(")content(cookie)delimiter(")> operator(=)operator(>) operator([)ident(cookie)operator(])operator(\)) operator({)
        ident(cgi)operator(.)ident(html) operator({)
            ident(cgi)operator(.)ident(head) operator({) ident(cgi)operator(.)ident(title) operator({) string<delimiter(")content(Ice Cookies)delimiter(")> operator(}) operator(}) operator(+)
            ident(cgi)operator(.)ident(body) operator({)
                ident(cgi)operator(.)ident(h1) operator({) string<delimiter(")content(Hello Ice Cream)delimiter(")> operator(}) operator(+)
                ident(cgi)operator(.)ident(p) operator({) string<delimiter(")content(You chose as your favorite flavor `)inline<delimiter(#{)ident(favorite)delimiter(})>content('.)delimiter(")> operator(})
            operator(})
        operator(})
    operator(})
reserved(end)


comment(# @@PLEAC@@_20.9)
reserved(def) method(templatefile)operator(()ident(filename)operator(,) ident(fillings)operator(\))
    ident(aFile) operator(=) constant(File)operator(.)ident(new)operator(()ident(filename)operator(,) string<delimiter(")content(r)delimiter(")>operator(\))
    ident(text) operator(=) ident(aFile)operator(.)ident(read)operator(()operator(\))
    ident(aFile)operator(.)ident(close)operator(()operator(\))
    ident(pattern) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(%%(.*?\)%%)delimiter(')>operator(\))
    ident(text)operator(.)ident(gsub!)operator(()ident(pattern)operator(\)) operator({)
        ident(fillings)operator([)global_variable($1)operator(]) operator(||) string<delimiter(")delimiter(")>
    operator(})
    ident(text)
reserved(end)

ident(fields) operator(=) operator({)
    string<delimiter(')content(username)delimiter(')> operator(=)operator(>) ident(whats_his_name)operator(,)
    string<delimiter(')content(count)delimiter(')> operator(=)operator(>) ident(login_count)operator(,)
    string<delimiter(')content(total)delimiter(')> operator(=)operator(>) ident(minutes_used)
operator(})
ident(puts) ident(templatefile)operator(()string<delimiter(')content(simple.template)delimiter(')>operator(,) ident(fields)operator(\))

comment(# @@INCOMPLETE@@)
comment(# An example using databases is missing)

