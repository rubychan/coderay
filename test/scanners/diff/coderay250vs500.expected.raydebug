head[head(Index: )plain(lib/coderay/token_classes.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/token_classes.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/token_classes.rb	(revision 500\))]
change[change(@@)plain( -4,6 +4,7 )change(@@)]
comment(       h[k] = k.to_s)
comment(     end)
comment(     ClassOfKind.update with = {)
insert[insert(+)plain(      :annotation => 'at',)]
comment(       :attribute_name => 'an',)
comment(       :attribute_name_fat => 'af',)
comment(       :attribute_value => 'av',)
change[change(@@)plain( -14,12 +15,15 )change(@@)]
comment(       :class_variable => 'cv',)
comment(       :color => 'cr',)
comment(       :comment => 'c',)
insert[insert(+)plain(      :complex => 'cm',)]
comment(       :constant => 'co',)
comment(       :content => 'k',)
insert[insert(+)plain(      :decorator => 'de',)]
comment(       :definition => 'df',)
comment(       :delimiter => 'dl',)
comment(       :directive => 'di',)
comment(       :doc => 'do',)
insert[insert(+)plain(      :doctype => 'dt',)]
comment(       :doc_string => 'ds',)
comment(       :entity => 'en',)
comment(       :error => 'er',)
change[change(@@)plain( -29,12 +33,16 )change(@@)]
comment(       :function => 'fu',)
comment(       :global_variable => 'gv',)
comment(       :hex => 'hx',)
insert[insert(+)plain(      :imaginary => 'cm',)]
insert[insert(+)plain(      :important => 'im',)]
comment(       :include => 'ic',)
comment(       :inline => 'il',)
comment(       :inline_delimiter => 'idl',)
comment(       :instance_variable => 'iv',)
comment(       :integer => 'i',)
comment(       :interpreted => 'in',)
insert[insert(+)plain(      :keyword => 'kw',)]
insert[insert(+)plain(      :key => 'ke',)]
comment(       :label => 'la',)
comment(       :local_variable => 'lv',)
comment(       :modifier => 'mod',)
change[change(@@)plain( -44,6 +52,7 )change(@@)]
comment(       :pre_type => 'pt',)
comment(       :predefined => 'pd',)
comment(       :preprocessor => 'pp',)
insert[insert(+)plain(      :pseudo_class => 'ps',)]
comment(       :regexp => 'rx',)
comment(       :reserved => 'r',)
comment(       :shell => 'sh',)
change[change(@@)plain( -54,7 +63,13 )change(@@)]
comment(       :tag_special => 'ts',)
comment(       :type => 'ty',)
comment(       :variable => 'v',)
insert[insert(+)plain(      :value => 'vl',)]
comment(       :xml_text => 'xt',)
insert[insert(+)plain(      )]
insert[insert(+)plain(      :insert => 'ins',)]
insert[insert(+)plain(      :delete => 'del',)]
insert[insert(+)plain(      :change => 'chg',)]
insert[insert(+)plain(      :head => 'head',)]
comment( )
comment(       :ident => :NO_HIGHLIGHT, # 'id')
comment(       #:operator => 'op',)
change[change(@@)plain( -62,7 +77,7 )change(@@)]
comment(       :space => :NO_HIGHLIGHT,  # 'sp')
comment(       :plain => :NO_HIGHLIGHT,)
comment(     })
delete[delete(-)plain(    ClassOfKind[:procedure] = ClassOfKind[:method] = ClassOfKind[:function])]
insert[insert(+)plain(    ClassOfKind[:method] = ClassOfKind[:function])]
comment(     ClassOfKind[:open] = ClassOfKind[:close] = ClassOfKind[:delimiter])
comment(     ClassOfKind[:nesting_delimiter] = ClassOfKind[:delimiter])
comment(     ClassOfKind[:escape] = ClassOfKind[:delimiter])
head[head(Index: )plain(lib/coderay/encoder.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoder.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoder.rb	(revision 500\))]
change[change(@@)plain( -1,5 +1,3 )change(@@)]
delete[delete(-)plain(require "stringio")]
delete[delete(-)]
comment( module CodeRay)
comment( )
comment(   # This module holds the Encoder class and its subclasses.)
change[change(@@)plain( -126,36 +124,66 )change(@@)]
comment(         @out = '')
comment(       end)
comment( )
delete[delete(-)plain(      # Called with +text+ and +kind+ of the currently scanned token.)]
insert[insert(+)plain(      # Called with +content+ and +kind+ of the currently scanned token.)]
comment(       # For simple scanners, it's enougth to implement this method.)
comment(       #)
comment(       # By default, it calls text_token or block_token, depending on)
delete[delete(-)plain(      # whether +text+ is a String.)]
delete[delete(-)plain(      def token text, kind)]
delete[delete(-)plain(        out =)]
delete[delete(-)plain(          if text.is_a? ::String  # Ruby 1.9: :open.is_a? String)]
delete[delete(-)plain(            text_token text, kind)]
delete[delete(-)plain(          elsif text.is_a? ::Symbol)]
delete[delete(-)plain(            block_token text, kind)]
insert[insert(+)plain(      # whether +content+ is a String.)]
insert[insert(+)plain(      def token content, kind)]
insert[insert(+)plain(        encoded_token =)]
insert[insert(+)plain(          if content.is_a? ::String)]
insert[insert(+)plain(            text_token content, kind)]
insert[insert(+)plain(          elsif content.is_a? ::Symbol)]
insert[insert(+)plain(            block_token content, kind)]
comment(           else)
delete[delete(-)plain(            raise 'Unknown token text type: %p' % text)]
insert[insert(+)plain(            raise 'Unknown token content type: %p' % [content])]
comment(           end)
delete[delete(-)plain(        @out << out if defined?(@out\) && @out)]
insert[insert(+)plain(        append_encoded_token_to_output encoded_token)]
comment(       end)
delete[delete(-)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      def append_encoded_token_to_output encoded_token)]
insert[insert(+)plain(        @out << encoded_token if encoded_token && defined?(@out\) && @out)]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      # Called for each text token ([text, kind]\), where text is a String.)]
comment(       def text_token text, kind)
comment(       end)
delete[delete(-)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      # Called for each block (non-text\) token ([action, kind]\),)]
insert[insert(+)plain(      # where +action+ is a Symbol.)]
insert[insert(+)plain(      # )]
insert[insert(+)plain(      # Calls open_token, close_token, begin_line, and end_line according to)]
insert[insert(+)plain(      # the value of +action+.)]
comment(       def block_token action, kind)
comment(         case action)
comment(         when :open)
comment(           open_token kind)
comment(         when :close)
comment(           close_token kind)
insert[insert(+)plain(        when :begin_line)]
insert[insert(+)plain(          begin_line kind)]
insert[insert(+)plain(        when :end_line)]
insert[insert(+)plain(          end_line kind)]
comment(         else)
comment(           raise 'unknown block action: %p' % action)
comment(         end)
comment(       end)
insert[insert(+)plain(      )]
insert[insert(+)plain(      # Called for each block token at the start of the block ([:open, kind]\).)]
insert[insert(+)plain(      def open_token kind)]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      # Called for each block token end of the block ([:close, kind]\).)]
insert[insert(+)plain(      def close_token kind)]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      # Called for each line token block at the start of the line ([:begin_line, kind]\).)]
insert[insert(+)plain(      def begin_line kind)]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      # Called for each line token block at the end of the line ([:end_line, kind]\).)]
insert[insert(+)plain(      def end_line kind)]
insert[insert(+)plain(      end)]
comment( )
comment(       # Called with merged options after encoding starts.)
comment(       # The return value is the result of encoding, typically @out.)
change[change(@@)plain( -167,9 +195,16 )change(@@)]
comment(       #)
comment(       # The already created +tokens+ object must be used; it can be a)
comment(       # TokenStream or a Tokens object.)
delete[delete(-)plain(      def compile tokens, options)]
delete[delete(-)plain(        tokens.each { |text, kind| token text, kind }  # FIXME for Ruby 1.9?)]
delete[delete(-)plain(        #tokens.each(&self\))]
insert[insert(+)plain(      if RUBY_VERSION >= '1.9')]
insert[insert(+)plain(        def compile tokens, options)]
insert[insert(+)plain(          for text, kind in tokens)]
insert[insert(+)plain(            token text, kind)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(      else)]
insert[insert(+)plain(        def compile tokens, options)]
insert[insert(+)plain(          tokens.each(&self\))]
insert[insert(+)plain(        end)]
comment(       end)
comment( )
comment(     end)
head[head(Index: )plain(lib/coderay/encoders/tokens.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/tokens.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/tokens.rb	(revision 500\))]
change[change(@@)plain( -1,44 +0,0 )change(@@)]
delete[delete(-)plain(module CodeRay)]
delete[delete(-)plain(module Encoders)]
delete[delete(-)]
delete[delete(-)plain(  # The Tokens encoder converts the tokens to a simple)]
delete[delete(-)plain(  # readable format. It doesn't use colors and is mainly)]
delete[delete(-)plain(  # intended for console output.)]
delete[delete(-)plain(  #)]
delete[delete(-)plain(  # The tokens are converted with Tokens.write_token.)]
delete[delete(-)plain(  #)]
delete[delete(-)plain(  # The format is:)]
delete[delete(-)plain(  #)]
delete[delete(-)plain(  #   <token-kind> \\t <escaped token-text> \\n)]
delete[delete(-)plain(  #)]
delete[delete(-)plain(  # Example:)]
delete[delete(-)plain(  #)]
delete[delete(-)plain(  #   require 'coderay')]
delete[delete(-)plain(  #   puts CodeRay.scan("puts 3 + 4", :ruby\).tokens)]
delete[delete(-)plain(  #)]
delete[delete(-)plain(  # prints:)]
delete[delete(-)plain(  #)]
delete[delete(-)plain(  #   ident   puts)]
delete[delete(-)plain(  #   space)]
delete[delete(-)plain(  #   integer 3)]
delete[delete(-)plain(  #   space)]
delete[delete(-)plain(  #   operator        +)]
delete[delete(-)plain(  #   space)]
delete[delete(-)plain(  #   integer 4)]
delete[delete(-)plain(  #)]
delete[delete(-)plain(  class Tokens < Encoder)]
delete[delete(-)]
delete[delete(-)plain(    include Streamable)]
delete[delete(-)plain(    register_for :tokens)]
delete[delete(-)]
delete[delete(-)plain(    FILE_EXTENSION = 'tok')]
delete[delete(-)]
delete[delete(-)plain(  protected)]
delete[delete(-)plain(    def token text, kind)]
delete[delete(-)plain(      @out << CodeRay::Tokens.write_token(text, kind\))]
delete[delete(-)plain(    end)]
delete[delete(-)]
delete[delete(-)plain(  end)]
delete[delete(-)]
delete[delete(-)plain(end)]
delete[delete(-)plain(end)]
head[head(Index: )plain(lib/coderay/encoders/div.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/div.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/div.rb	(revision 500\))]
change[change(@@)plain( -9,10 +9,9 )change(@@)]
comment( )
comment(     register_for :div)
comment( )
delete[delete(-)plain(    DEFAULT_OPTIONS = HTML::DEFAULT_OPTIONS.merge({)]
insert[insert(+)plain(    DEFAULT_OPTIONS = HTML::DEFAULT_OPTIONS.merge \\)]
comment(       :css => :style,)
delete[delete(-)plain(      :wrap => :div,)]
delete[delete(-)plain(    }\))]
insert[insert(+)plain(      :wrap => :div)]
comment( )
comment(   end)
comment( )
head[head(Index: )plain(lib/coderay/encoders/text.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/text.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/text.rb	(revision 500\))]
change[change(@@)plain( -14,16 +14,16 )change(@@)]
comment( )
comment(   protected)
comment(     def setup options)
delete[delete(-)plain(      @out = '')]
insert[insert(+)plain(      super)]
comment(       @sep = options[:separator])
comment(     end)
comment( )
delete[delete(-)plain(    def token text, kind)]
delete[delete(-)plain(      @out << text + @sep if text.is_a? ::String)]
insert[insert(+)plain(    def text_token text, kind)]
insert[insert(+)plain(      text + @sep)]
comment(     end)
comment( )
comment(     def finish options)
delete[delete(-)plain(      @out.chomp @sep)]
insert[insert(+)plain(      super.chomp @sep)]
comment(     end)
comment( )
comment(   end)
head[head(Index: )plain(lib/coderay/encoders/filter.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/filter.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/encoders/filter.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,75 )change(@@)]
insert[insert(+)plain(($:.unshift '../..'; require 'coderay'\) unless defined? CodeRay)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Encoders)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  class Filter < Encoder)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    register_for :filter)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    def setup options)]
insert[insert(+)plain(      @out = Tokens.new)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def text_token text, kind)]
insert[insert(+)plain(      [text, kind] if include_text_token? text, kind)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def include_text_token? text, kind)]
insert[insert(+)plain(      true)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def block_token action, kind)]
insert[insert(+)plain(      [action, kind] if include_block_token? action, kind)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def include_block_token? action, kind)]
insert[insert(+)plain(      true)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
insert[insert(+)]
insert[insert(+)plain(if $0 == __FILE__)]
insert[insert(+)plain(  $VERBOSE = true)]
insert[insert(+)plain(  $: << File.join(File.dirname(__FILE__\), '..'\))]
insert[insert(+)plain(  eval DATA.read, nil, $0, __LINE__ + 4)]
insert[insert(+)plain(end)]
insert[insert(+)]
insert[insert(+)plain(__END__)]
insert[insert(+)plain(require 'test/unit')]
insert[insert(+)]
insert[insert(+)plain(class FilterTest < Test::Unit::TestCase)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_creation)]
insert[insert(+)plain(    assert CodeRay::Encoders::Filter < CodeRay::Encoders::Encoder)]
insert[insert(+)plain(    filter = nil)]
insert[insert(+)plain(    assert_nothing_raised do)]
insert[insert(+)plain(      filter = CodeRay.encoder :filter)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    assert_kind_of CodeRay::Encoders::Encoder, filter)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_filtering_text_tokens)]
insert[insert(+)plain(    tokens = CodeRay::Tokens.new)]
insert[insert(+)plain(    10.times do |i|)]
insert[insert(+)plain(      tokens << [i.to_s, :index])]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    assert_equal tokens, CodeRay::Encoders::Filter.new.encode_tokens(tokens\))]
insert[insert(+)plain(    assert_equal tokens, tokens.filter)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_filtering_block_tokens)]
insert[insert(+)plain(    tokens = CodeRay::Tokens.new)]
insert[insert(+)plain(    10.times do |i|)]
insert[insert(+)plain(      tokens << [:open, :index])]
insert[insert(+)plain(      tokens << [i.to_s, :content])]
insert[insert(+)plain(      tokens << [:close, :index])]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    assert_equal tokens, CodeRay::Encoders::Filter.new.encode_tokens(tokens\))]
insert[insert(+)plain(    assert_equal tokens, tokens.filter)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/encoders/debug.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/debug.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/debug.rb	(revision 500\))]
change[change(@@)plain( -32,9 +32,17 )change(@@)]
comment(     end)
comment( )
comment(     def close_token kind)
delete[delete(-)plain(      ">")]
insert[insert(+)plain(      '>')]
comment(     end)
comment( )
insert[insert(+)plain(    def begin_line kind)]
insert[insert(+)plain(      "#{kind}[")]
insert[insert(+)plain(    end)]
insert[insert(+)]
insert[insert(+)plain(    def end_line kind)]
insert[insert(+)plain(      ']')]
insert[insert(+)plain(    end)]
insert[insert(+)]
comment(   end)
comment( )
comment( end)
head[head(Index: )plain(lib/coderay/encoders/lines_of_code.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/lines_of_code.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/encoders/lines_of_code.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,90 )change(@@)]
insert[insert(+)plain(($:.unshift '../..'; require 'coderay'\) unless defined? CodeRay)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Encoders)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # Counts the LoC (Lines of Code\). Returns an Integer >= 0.)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Alias: :loc)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Everything that is not comment, markup, doctype/shebang, or an empty line,)]
insert[insert(+)plain(  # is considered to be code.)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # For example,)]
insert[insert(+)plain(  # * HTML files not containing JavaScript have 0 LoC)]
insert[insert(+)plain(  # * in a Java class without comments, LoC is the number of non-empty lines)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # A Scanner class should define the token kinds that are not code in the)]
insert[insert(+)plain(  # KINDS_NOT_LOC constant, which defaults to [:comment, :doctype].)]
insert[insert(+)plain(  class LinesOfCode < Encoder)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    register_for :lines_of_code)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    NON_EMPTY_LINE = /^\\s*\\S.*$/)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def compile tokens, options)]
insert[insert(+)plain(      if scanner = tokens.scanner)]
insert[insert(+)plain(        kinds_not_loc = scanner.class::KINDS_NOT_LOC)]
insert[insert(+)plain(      else)]
insert[insert(+)plain(        warn ArgumentError, 'Tokens have no scanner.' if $DEBUG)]
insert[insert(+)plain(        kinds_not_loc = CodeRay::Scanners::Scanner::KINDS_NOT_LOC)]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      code = tokens.token_class_filter :exclude => kinds_not_loc)]
insert[insert(+)plain(      @loc = code.text.scan(NON_EMPTY_LINE\).size)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def finish options)]
insert[insert(+)plain(      @loc)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
insert[insert(+)]
insert[insert(+)plain(if $0 == __FILE__)]
insert[insert(+)plain(  $VERBOSE = true)]
insert[insert(+)plain(  $: << File.join(File.dirname(__FILE__\), '..'\))]
insert[insert(+)plain(  eval DATA.read, nil, $0, __LINE__ + 4)]
insert[insert(+)plain(end)]
insert[insert(+)]
insert[insert(+)plain(__END__)]
insert[insert(+)plain(require 'test/unit')]
insert[insert(+)]
insert[insert(+)plain(class LinesOfCodeTest < Test::Unit::TestCase)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_creation)]
insert[insert(+)plain(    assert CodeRay::Encoders::LinesOfCode < CodeRay::Encoders::Encoder)]
insert[insert(+)plain(    filter = nil)]
insert[insert(+)plain(    assert_nothing_raised do)]
insert[insert(+)plain(      filter = CodeRay.encoder :loc)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    assert_kind_of CodeRay::Encoders::LinesOfCode, filter)]
insert[insert(+)plain(    assert_nothing_raised do)]
insert[insert(+)plain(      filter = CodeRay.encoder :lines_of_code)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    assert_kind_of CodeRay::Encoders::LinesOfCode, filter)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_lines_of_code)]
insert[insert(+)plain(    tokens = CodeRay.scan <<-RUBY, :ruby)]
insert[insert(+)plain(#!/usr/bin/env ruby)]
insert[insert(+)]
insert[insert(+)plain(# a minimal Ruby program)]
insert[insert(+)plain(puts "Hello world!")]
insert[insert(+)plain(    RUBY)]
insert[insert(+)plain(    assert_equal 1, CodeRay::Encoders::LinesOfCode.new.encode_tokens(tokens\))]
insert[insert(+)plain(    assert_equal 1, tokens.lines_of_code)]
insert[insert(+)plain(    assert_equal 1, tokens.loc)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_filtering_block_tokens)]
insert[insert(+)plain(    tokens = CodeRay::Tokens.new)]
insert[insert(+)plain(    tokens << ["Hello\\n", :world])]
insert[insert(+)plain(    tokens << ["Hello\\n", :space])]
insert[insert(+)plain(    tokens << ["Hello\\n", :comment])]
insert[insert(+)plain(    assert_equal 2, CodeRay::Encoders::LinesOfCode.new.encode_tokens(tokens\))]
insert[insert(+)plain(    assert_equal 2, tokens.lines_of_code)]
insert[insert(+)plain(    assert_equal 2, tokens.loc)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
change[change(\\ )plain(No newline at end of file)]
head[head(Index: )plain(lib/coderay/encoders/xml.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/xml.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/xml.rb	(revision 500\))]
change[change(@@)plain( -29,6 +29,7 )change(@@)]
comment(     end)
comment( )
comment(     def finish options)
insert[insert(+)plain(      @out = '')]
comment(       @doc.write @out, options[:pretty], options[:transitive], true)
comment(       @out)
comment(     end)
head[head(Index: )plain(lib/coderay/encoders/span.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/span.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/span.rb	(revision 500\))]
change[change(@@)plain( -9,10 +9,9 )change(@@)]
comment( )
comment(     register_for :span)
comment( )
delete[delete(-)plain(    DEFAULT_OPTIONS = HTML::DEFAULT_OPTIONS.merge({)]
insert[insert(+)plain(    DEFAULT_OPTIONS = HTML::DEFAULT_OPTIONS.merge \\)]
comment(       :css => :style,)
delete[delete(-)plain(      :wrap => :span,)]
delete[delete(-)plain(    }\))]
insert[insert(+)plain(      :wrap => :span)]
comment( )
comment(   end)
comment( )
head[head(Index: )plain(lib/coderay/encoders/html/output.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/html/output.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/html/output.rb	(revision 500\))]
change[change(@@)plain( -86,6 +86,11 )change(@@)]
comment(         Template.wrap! self, template, 'CONTENT')
comment(         self)
comment(       end)
insert[insert(+)plain(      )]
insert[insert(+)plain(      def apply_title! title)]
insert[insert(+)plain(        self.sub!(/(<title>\)(<\\/title>\)/\) { $1 + title + $2 })]
insert[insert(+)plain(        self)]
insert[insert(+)plain(      end)]
comment( )
comment(       def wrap! element, *args)
comment(         return self if not element or element == wrapped_in)
change[change(@@)plain( -100,6 +105,10 )change(@@)]
comment(           wrap! :div if wrapped_in? nil)
comment(           raise "Can't wrap %p in %p" % [wrapped_in, element] unless wrapped_in? :div)
comment(           wrap_in! Output.page_template_for_css(@css\))
insert[insert(+)plain(          if args.first.is_a?(Hash\) && title = args.first[:title])]
insert[insert(+)plain(            apply_title! title)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          self)]
comment(         when nil)
comment(           return self)
comment(         else)
change[change(@@)plain( -166,7 +175,9 )change(@@)]
comment(       # title="double click to expand")
comment( )
comment(       LIST = <<-`LIST`)
delete[delete(-)plain(<ol class="CodeRay"><%CONTENT%></ol>)]
insert[insert(+)plain(<ol class="CodeRay">)]
insert[insert(+)plain(<%CONTENT%>)]
insert[insert(+)plain(</ol>)]
comment(       LIST)
comment( )
comment(       PAGE = <<-`PAGE`)
change[change(@@)plain( -175,7 +186,7 )change(@@)]
comment( <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="de">)
comment( <head>)
comment(   <meta http-equiv="content-type" content="text/html; charset=utf-8" />)
delete[delete(-)plain(  <title>CodeRay HTML Encoder Example</title>)]
insert[insert(+)plain(  <title></title>)]
comment(   <style type="text/css">)
comment( <%CSS%>)
comment(   </style>)
head[head(Index: )plain(lib/coderay/encoders/html/numerization.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/html/numerization.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/html/numerization.rb	(revision 500\))]
change[change(@@)plain( -32,9 +32,19 )change(@@)]
comment(         #end)
comment( )
comment(         bold_every = options[:bold_every])
insert[insert(+)plain(        highlight_lines = options[:highlight_lines])]
comment(         bolding =)
delete[delete(-)plain(          if bold_every == false)]
insert[insert(+)plain(          if bold_every == false && highlight_lines == nil)]
comment(             proc { |line| line.to_s })
insert[insert(+)plain(          elsif highlight_lines.is_a? Enumerable)]
insert[insert(+)plain(            highlight_lines = highlight_lines.to_set)]
insert[insert(+)plain(            proc do |line|)]
insert[insert(+)plain(              if highlight_lines.include? line)]
insert[insert(+)plain(                "<strong class=\\"highlighted\\">#{line}</strong>"  # highlighted line numbers in bold)]
insert[insert(+)plain(              else)]
insert[insert(+)plain(                line.to_s)]
insert[insert(+)plain(              end)]
insert[insert(+)plain(            end)]
comment(           elsif bold_every.is_a? Integer)
comment(             raise ArgumentError, ":bolding can't be 0." if bold_every == 0)
comment(             proc do |line|)
change[change(@@)plain( -65,12 +75,12 )change(@@)]
comment(           # Because even monospace fonts seem to have different heights when bold,)
comment(           # I make the newline bold, both in the code and the line numbers.)
comment(           # FIXME Still not working perfect for Mr. Internet Exploder)
delete[delete(-)plain(          # FIXME Firefox struggles with very long codes (> 200 lines\))]
comment(           line_numbers = (start ... start + line_count\).to_a.map(&bolding\).join("\\n"\))
comment(           line_numbers << "\\n"  # also for Mr. MS Internet Exploder :-/)
comment(           line_numbers.gsub!(/\\n/\) { "<tt>\\n</tt>" })
comment( )
comment(           line_numbers_table_tpl = TABLE.apply('LINE_NUMBERS', line_numbers\))
insert[insert(+)plain(          gsub!(/<\\/div>\\n/\) { '</div>' })]
comment(           gsub!(/\\n/\) { "<tt>\\n</tt>" })
comment(           wrap_in! line_numbers_table_tpl)
comment(           @wrapped_in = :div)
change[change(@@)plain( -90,8 +100,9 )change(@@)]
comment(             end)
comment(             close = '</span>' * opened_tags.size)
comment( )
delete[delete(-)plain(            "<li>#{open}#{line}#{close}</li>")]
insert[insert(+)plain(            "<li>#{open}#{line}#{close}</li>\\n")]
comment(           end)
insert[insert(+)plain(          chomp!("\\n"\))]
comment(           wrap_in! LIST)
comment(           @wrapped_in = :div)
comment( )
head[head(Index: )plain(lib/coderay/encoders/html/css.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/html/css.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/html/css.rb	(revision 500\))]
change[change(@@)plain( -27,16 +27,19 )change(@@)]
comment(         1.upto(styles.size\) do |offset|)
comment(           break if style = cl[styles[offset .. -1]])
comment(         end)
delete[delete(-)plain(        raise 'Style not found: %p' % [styles] if $DEBUG and style.empty?)]
insert[insert(+)plain(        $stderr.puts 'Style not found: %p' % [styles] if $DEBUG and style.empty?)]
comment(         return style)
comment(       end)
comment( )
comment(     private)
comment( )
comment(       CSS_CLASS_PATTERN = /)
delete[delete(-)plain(        ( (?:                # $1 = classes)]
delete[delete(-)plain(          \\s* \\. [-\\w]+)]
delete[delete(-)plain(        \)+ \))]
insert[insert(+)plain(        (                    # $1 = selectors)]
insert[insert(+)plain(          (?:)]
insert[insert(+)plain(            (?: \\s* \\. [-\\w]+ \)+)]
insert[insert(+)plain(            \\s* ,?)]
insert[insert(+)plain(          \)+)]
insert[insert(+)plain(        \))]
comment(         \\s* \\{ \\s*)
comment(         ( [^\\}]+ \)?          # $2 = style)
comment(         \\s* \\} \\s*)
change[change(@@)plain( -44,12 +47,14 )change(@@)]
comment(         ( . \)                # $3 = error)
comment(       /mx)
comment(       def parse stylesheet)
delete[delete(-)plain(        stylesheet.scan CSS_CLASS_PATTERN do |classes, style, error|)]
insert[insert(+)plain(        stylesheet.scan CSS_CLASS_PATTERN do |selectors, style, error|)]
comment(           raise "CSS parse error: '#{error.inspect}' not recognized" if error)
delete[delete(-)plain(          styles = classes.scan(/[-\\w]+/\))]
delete[delete(-)plain(          cl = styles.pop)]
delete[delete(-)plain(          @classes[cl] ||= Hash.new)]
delete[delete(-)plain(          @classes[cl][styles] = style.to_s.strip)]
insert[insert(+)plain(          for selector in selectors.split(','\))]
insert[insert(+)plain(            classes = selector.scan(/[-\\w]+/\))]
insert[insert(+)plain(            cl = classes.pop)]
insert[insert(+)plain(            @classes[cl] ||= Hash.new)]
insert[insert(+)plain(            @classes[cl][classes] = style.to_s.strip.delete(' '\).chomp(';'\))]
insert[insert(+)plain(          end)]
comment(         end)
comment(       end)
comment( )
head[head(Index: )plain(lib/coderay/encoders/html.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/html.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/html.rb	(revision 500\))]
change[change(@@)plain( -1,4 +1,4 )change(@@)]
delete[delete(-)plain(require "set")]
insert[insert(+)plain(require 'set')]
comment( )
comment( module CodeRay)
comment( module Encoders)
change[change(@@)plain( -41,6 +41,12 )change(@@)]
comment(   #)
comment(   # Default: nil)
comment(   #)
insert[insert(+)plain(  # === :title)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # The title of the HTML page (works only when :wrap is set to :page.\))]
insert[insert(+)plain(  #)]
insert[insert(+)plain(  # Default: 'CodeRay output')]
insert[insert(+)plain(  #)]
comment(   # === :line_numbers)
comment(   # Include line numbers in :table, :inline, :list or nil (no line numbers\))
comment(   #)
change[change(@@)plain( -56,6 +62,16 )change(@@)]
comment(   #)
comment(   # Default: 10)
comment(   #)
insert[insert(+)plain(  # === :highlight_lines)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Highlights certain line numbers.)]
insert[insert(+)plain(  # Can be any Enumerable, typically just an Array or Range, of numbers.)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Bolding is deactivated when :highlight_lines is set. It only makes sense)]
insert[insert(+)plain(  # in combination with :line_numbers.)]
insert[insert(+)plain(  #)]
insert[insert(+)plain(  # Default: nil)]
insert[insert(+)plain(  #)]
comment(   # === :hint)
comment(   # Include some information into the output using the title attribute.)
comment(   # Can be :info (show token type on mouse-over\), :info_long (with full path\))
change[change(@@)plain( -72,16 +88,16 )change(@@)]
comment(     DEFAULT_OPTIONS = {)
comment(       :tab_width => 8,)
comment( )
delete[delete(-)plain(      :level => :xhtml,)]
comment(       :css => :class,)
comment( )
comment(       :style => :cycnus,)
delete[delete(-)]
comment(       :wrap => nil,)
insert[insert(+)plain(      :title => 'CodeRay output',)]
comment( )
comment(       :line_numbers => nil,)
comment(       :line_number_start => 1,)
comment(       :bold_every => 10,)
insert[insert(+)plain(      :highlight_lines => nil,)]
comment( )
comment(       :hint => false,)
comment(     })
change[change(@@)plain( -216,43 +232,70 )change(@@)]
comment(       @out.css = @css)
comment(       @out.numerize! options[:line_numbers], options)
comment(       @out.wrap! options[:wrap])
insert[insert(+)plain(      @out.apply_title! options[:title])]
comment( )
comment(       super)
comment(     end)
comment( )
comment(     def token text, type)
delete[delete(-)plain(      if text.is_a? ::String)]
insert[insert(+)plain(      case text)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      when nil)]
insert[insert(+)plain(        # raise 'Token with nil as text was given: %p' % [[text, type]] )]
insert[insert(+)plain(      )]
insert[insert(+)plain(      when String)]
comment(         if text =~ /#{HTML_ESCAPE_PATTERN}/o)
comment(           text = text.gsub(/#{HTML_ESCAPE_PATTERN}/o\) { |m| @HTML_ESCAPE[m] })
comment(         end)
comment(         @opened[0] = type)
delete[delete(-)plain(        if style = @css_style[@opened])]
insert[insert(+)plain(        if text != "\\n" && style = @css_style[@opened])]
comment(           @out << style << text << '</span>')
comment(         else)
comment(           @out << text)
comment(         end)
delete[delete(-)plain(      else)]
delete[delete(-)plain(        case text)]
delete[delete(-)plain(        when :open)]
delete[delete(-)plain(          @opened[0] = type)]
delete[delete(-)plain(          @out << (@css_style[@opened] || '<span>'\))]
delete[delete(-)plain(          @opened << type)]
delete[delete(-)plain(        when :close)]
delete[delete(-)plain(          if @opened.empty?)]
delete[delete(-)plain(            # nothing to close)]
delete[delete(-)plain(          else)]
delete[delete(-)plain(            if $DEBUG and (@opened.size == 1 or @opened.last != type\))]
delete[delete(-)plain(              raise 'Malformed token stream: Trying to close a token (%p\) \\)]
delete[delete(-)plain(                that is not open. Open are: %p.' % [type, @opened[1..-1]])]
delete[delete(-)plain(            end)]
delete[delete(-)plain(            @out << '</span>')]
delete[delete(-)plain(            @opened.pop)]
insert[insert(+)plain(        )]
insert[insert(+)plain(      )]
insert[insert(+)plain(      # token groups, eg. strings)]
insert[insert(+)plain(      when :open)]
insert[insert(+)plain(        @opened[0] = type)]
insert[insert(+)plain(        @out << (@css_style[@opened] || '<span>'\))]
insert[insert(+)plain(        @opened << type)]
insert[insert(+)plain(      when :close)]
insert[insert(+)plain(        if @opened.empty?)]
insert[insert(+)plain(          # nothing to close)]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          if $DEBUG and (@opened.size == 1 or @opened.last != type\))]
insert[insert(+)plain(            raise 'Malformed token stream: Trying to close a token (%p\) \\)]
insert[insert(+)plain(              that is not open. Open are: %p.' % [type, @opened[1..-1]])]
comment(           end)
delete[delete(-)plain(        when nil)]
delete[delete(-)plain(          raise 'Token with nil as text was given: %p' % [[text, type]])]
insert[insert(+)plain(          @out << '</span>')]
insert[insert(+)plain(          @opened.pop)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      # whole lines to be highlighted, eg. a deleted line in a diff)]
insert[insert(+)plain(      when :begin_line)]
insert[insert(+)plain(        @opened[0] = type)]
insert[insert(+)plain(        if style = @css_style[@opened])]
insert[insert(+)plain(          @out << style.sub('<span', '<div'\))]
comment(         else)
delete[delete(-)plain(          raise 'unknown token kind: %p' % text)]
insert[insert(+)plain(          @out << '<div>')]
comment(         end)
insert[insert(+)plain(        @opened << type)]
insert[insert(+)plain(      when :end_line)]
insert[insert(+)plain(        if @opened.empty?)]
insert[insert(+)plain(          # nothing to close)]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          if $DEBUG and (@opened.size == 1 or @opened.last != type\))]
insert[insert(+)plain(            raise 'Malformed token stream: Trying to close a line (%p\) \\)]
insert[insert(+)plain(              that is not open. Open are: %p.' % [type, @opened[1..-1]])]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          @out << '</div>')]
insert[insert(+)plain(          @opened.pop)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      else)]
insert[insert(+)plain(        raise 'unknown token kind: %p' % [text])]
insert[insert(+)plain(        )]
comment(       end)
comment(     end)
comment( )
head[head(Index: )plain(lib/coderay/encoders/comment_filter.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/comment_filter.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/encoders/comment_filter.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,43 )change(@@)]
insert[insert(+)plain(($:.unshift '../..'; require 'coderay'\) unless defined? CodeRay)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Encoders)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  load :token_class_filter)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  class CommentFilter < TokenClassFilter)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    register_for :comment_filter)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    DEFAULT_OPTIONS = superclass::DEFAULT_OPTIONS.merge \\)]
insert[insert(+)plain(      :exclude => [:comment])]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
insert[insert(+)]
insert[insert(+)plain(if $0 == __FILE__)]
insert[insert(+)plain(  $VERBOSE = true)]
insert[insert(+)plain(  $: << File.join(File.dirname(__FILE__\), '..'\))]
insert[insert(+)plain(  eval DATA.read, nil, $0, __LINE__ + 4)]
insert[insert(+)plain(end)]
insert[insert(+)]
insert[insert(+)plain(__END__)]
insert[insert(+)plain(require 'test/unit')]
insert[insert(+)]
insert[insert(+)plain(class CommentFilterTest < Test::Unit::TestCase)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_filtering_comments)]
insert[insert(+)plain(    tokens = CodeRay.scan <<-RUBY, :ruby)]
insert[insert(+)plain(#!/usr/bin/env ruby)]
insert[insert(+)plain(# a minimal Ruby program)]
insert[insert(+)plain(puts "Hello world!")]
insert[insert(+)plain(    RUBY)]
insert[insert(+)plain(    assert_equal <<-RUBY_FILTERED, tokens.comment_filter.text)]
insert[insert(+)plain(#!/usr/bin/env ruby)]
insert[insert(+)]
insert[insert(+)plain(puts "Hello world!")]
insert[insert(+)plain(    RUBY_FILTERED)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
change[change(\\ )plain(No newline at end of file)]
head[head(Index: )plain(lib/coderay/encoders/json.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/json.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/encoders/json.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,69 )change(@@)]
insert[insert(+)plain(($:.unshift '../..'; require 'coderay'\) unless defined? CodeRay)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Encoders)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # = JSON Encoder)]
insert[insert(+)plain(  class JSON < Encoder)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    register_for :json)]
insert[insert(+)plain(    FILE_EXTENSION = 'json')]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    def setup options)]
insert[insert(+)plain(      begin)]
insert[insert(+)plain(        require 'json')]
insert[insert(+)plain(      rescue LoadError)]
insert[insert(+)plain(        require 'rubygems')]
insert[insert(+)plain(        require 'json')]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      @out = [])]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def text_token text, kind)]
insert[insert(+)plain(      { :type => 'text', :text => text, :kind => kind })]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def block_token action, kind)]
insert[insert(+)plain(      { :type => 'block', :action => action, :kind => kind })]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def finish options)]
insert[insert(+)plain(      @out.to_json)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
insert[insert(+)]
insert[insert(+)plain(if $0 == __FILE__)]
insert[insert(+)plain(  $VERBOSE = true)]
insert[insert(+)plain(  $: << File.join(File.dirname(__FILE__\), '..'\))]
insert[insert(+)plain(  eval DATA.read, nil, $0, __LINE__ + 4)]
insert[insert(+)plain(end)]
insert[insert(+)]
insert[insert(+)plain(__END__)]
insert[insert(+)plain(require 'test/unit')]
insert[insert(+)plain($:.delete '.')]
insert[insert(+)plain(require 'rubygems' if RUBY_VERSION < '1.9')]
insert[insert(+)]
insert[insert(+)plain(class JSONEncoderTest < Test::Unit::TestCase)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_json_output)]
insert[insert(+)plain(    tokens = CodeRay.scan <<-RUBY, :ruby)]
insert[insert(+)plain(puts "Hello world!")]
insert[insert(+)plain(    RUBY)]
insert[insert(+)plain(    require 'json')]
insert[insert(+)plain(    assert_equal [)]
insert[insert(+)plain(      {"type"=>"text", "text"=>"puts", "kind"=>"ident"},)]
insert[insert(+)plain(      {"type"=>"text", "text"=>" ", "kind"=>"space"},)]
insert[insert(+)plain(      {"type"=>"block", "action"=>"open", "kind"=>"string"},)]
insert[insert(+)plain(      {"type"=>"text", "text"=>"\\"", "kind"=>"delimiter"},)]
insert[insert(+)plain(      {"type"=>"text", "text"=>"Hello world!", "kind"=>"content"},)]
insert[insert(+)plain(      {"type"=>"text", "text"=>"\\"", "kind"=>"delimiter"},)]
insert[insert(+)plain(      {"type"=>"block", "action"=>"close", "kind"=>"string"},)]
insert[insert(+)plain(      {"type"=>"text", "text"=>"\\n", "kind"=>"space"})]
insert[insert(+)plain(    ], JSON.load(tokens.json\))]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
change[change(\\ )plain(No newline at end of file)]
head[head(Index: )plain(lib/coderay/encoders/token_class_filter.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/token_class_filter.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/encoders/token_class_filter.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,84 )change(@@)]
insert[insert(+)plain(($:.unshift '../..'; require 'coderay'\) unless defined? CodeRay)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Encoders)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  load :filter)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  class TokenClassFilter < Filter)]
insert[insert(+)]
insert[insert(+)plain(    include Streamable)]
insert[insert(+)plain(    register_for :token_class_filter)]
insert[insert(+)]
insert[insert(+)plain(    DEFAULT_OPTIONS = {)]
insert[insert(+)plain(      :exclude => [],)]
insert[insert(+)plain(      :include => :all)]
insert[insert(+)plain(    })]
insert[insert(+)]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    def setup options)]
insert[insert(+)plain(      super)]
insert[insert(+)plain(      @exclude = options[:exclude])]
insert[insert(+)plain(      @exclude = Array(@exclude\) unless @exclude == :all)]
insert[insert(+)plain(      @include = options[:include])]
insert[insert(+)plain(      @include = Array(@include\) unless @include == :all)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def include_text_token? text, kind)]
insert[insert(+)plain(       (@include == :all || @include.include?(kind\)\) &&)]
insert[insert(+)plain(      !(@exclude == :all || @exclude.include?(kind\)\))]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
insert[insert(+)]
insert[insert(+)plain(if $0 == __FILE__)]
insert[insert(+)plain(  $VERBOSE = true)]
insert[insert(+)plain(  $: << File.join(File.dirname(__FILE__\), '..'\))]
insert[insert(+)plain(  eval DATA.read, nil, $0, __LINE__ + 4)]
insert[insert(+)plain(end)]
insert[insert(+)]
insert[insert(+)plain(__END__)]
insert[insert(+)plain(require 'test/unit')]
insert[insert(+)]
insert[insert(+)plain(class TokenClassFilterTest < Test::Unit::TestCase)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_creation)]
insert[insert(+)plain(    assert CodeRay::Encoders::TokenClassFilter < CodeRay::Encoders::Encoder)]
insert[insert(+)plain(    assert CodeRay::Encoders::TokenClassFilter < CodeRay::Encoders::Filter)]
insert[insert(+)plain(    filter = nil)]
insert[insert(+)plain(    assert_nothing_raised do)]
insert[insert(+)plain(      filter = CodeRay.encoder :token_class_filter)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    assert_instance_of CodeRay::Encoders::TokenClassFilter, filter)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_filtering_text_tokens)]
insert[insert(+)plain(    tokens = CodeRay::Tokens.new)]
insert[insert(+)plain(    for i in 1..10)]
insert[insert(+)plain(      tokens << [i.to_s, :index])]
insert[insert(+)plain(      tokens << [' ', :space] if i < 10)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    assert_equal 10, CodeRay::Encoders::TokenClassFilter.new.encode_tokens(tokens, :exclude => :space\).size)]
insert[insert(+)plain(    assert_equal 10, tokens.token_class_filter(:exclude => :space\).size)]
insert[insert(+)plain(    assert_equal 9, CodeRay::Encoders::TokenClassFilter.new.encode_tokens(tokens, :include => :space\).size)]
insert[insert(+)plain(    assert_equal 9, tokens.token_class_filter(:include => :space\).size)]
insert[insert(+)plain(    assert_equal 0, CodeRay::Encoders::TokenClassFilter.new.encode_tokens(tokens, :exclude => :all\).size)]
insert[insert(+)plain(    assert_equal 0, tokens.token_class_filter(:exclude => :all\).size)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_filtering_block_tokens)]
insert[insert(+)plain(    tokens = CodeRay::Tokens.new)]
insert[insert(+)plain(    10.times do |i|)]
insert[insert(+)plain(      tokens << [:open, :index])]
insert[insert(+)plain(      tokens << [i.to_s, :content])]
insert[insert(+)plain(      tokens << [:close, :index])]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    assert_equal 20, CodeRay::Encoders::TokenClassFilter.new.encode_tokens(tokens, :include => :blubb\).size)]
insert[insert(+)plain(    assert_equal 20, tokens.token_class_filter(:include => :blubb\).size)]
insert[insert(+)plain(    assert_equal 30, CodeRay::Encoders::TokenClassFilter.new.encode_tokens(tokens, :exclude => :index\).size)]
insert[insert(+)plain(    assert_equal 30, tokens.token_class_filter(:exclude => :index\).size)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/encoders/terminal.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/terminal.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/encoders/terminal.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,137 )change(@@)]
insert[insert(+)plain(# By Rob Aldred (http://robaldred.co.uk\))]
insert[insert(+)plain(# Based on idea by Nathan Weizenbaum (http://nex-3.com\))]
insert[insert(+)plain(# MIT License (http://www.opensource.org/licenses/mit-license.php\))]
insert[insert(+)plain(#)]
insert[insert(+)plain(# A CodeRay encoder that outputs code highlighted for a color terminal.)]
insert[insert(+)plain(# Check out http://robaldred.co.uk)]
insert[insert(+)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(  module Encoders)]
insert[insert(+)plain(    class Terminal < Encoder)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      register_for :terminal)]
insert[insert(+)]
insert[insert(+)plain(      TOKEN_COLORS = {)]
insert[insert(+)plain(        :attribute_name => '33',)]
insert[insert(+)plain(        :attribute_name_fat => '33',)]
insert[insert(+)plain(        :attribute_value => '31',)]
insert[insert(+)plain(        :attribute_value_fat => '31',)]
insert[insert(+)plain(        :bin => '1;35',)]
insert[insert(+)plain(        :char => {:self => '36', :delimiter => '34'},)]
insert[insert(+)plain(        :class => '1;35',)]
insert[insert(+)plain(        :class_variable => '36',)]
insert[insert(+)plain(        :color => '32',)]
insert[insert(+)plain(        :comment => '37',)]
insert[insert(+)plain(        :constant => ['34', '4'],)]
insert[insert(+)plain(        :definition => '1;32',)]
insert[insert(+)plain(        :directive => ['32', '4'],)]
insert[insert(+)plain(        :doc => '46',)]
insert[insert(+)plain(        :doc_string => ['31', '4'],)]
insert[insert(+)plain(        :entity => '33',)]
insert[insert(+)plain(        :error => ['1;33', '41'],)]
insert[insert(+)plain(        :exception => '1;31',)]
insert[insert(+)plain(        :float => '1;35',)]
insert[insert(+)plain(        :function => '1;34',)]
insert[insert(+)plain(        :global_variable => '42',)]
insert[insert(+)plain(        :hex => '1;36',)]
insert[insert(+)plain(        :include => '33',)]
insert[insert(+)plain(        :integer => '1;34',)]
insert[insert(+)plain(        :interpreted => '1;35',)]
insert[insert(+)plain(        :label => '1;4',)]
insert[insert(+)plain(        :local_variable => '33',)]
insert[insert(+)plain(        :oct => '1;35',)]
insert[insert(+)plain(        :operator_name => '1;29',)]
insert[insert(+)plain(        :pre_constant => '1;36',)]
insert[insert(+)plain(        :pre_type => '1;30',)]
insert[insert(+)plain(        :predefined => ['4', '1;34'],)]
insert[insert(+)plain(        :preprocessor => '36',)]
insert[insert(+)plain(        :regexp => {)]
insert[insert(+)plain(          :content => '31',)]
insert[insert(+)plain(          :delimiter => '1;29',)]
insert[insert(+)plain(          :modifier => '35',)]
insert[insert(+)plain(          :function => '1;29')]
insert[insert(+)plain(        },)]
insert[insert(+)plain(        :reserved => '1;31',)]
insert[insert(+)plain(        :shell => {:self => '42', :content => '1;29'},)]
insert[insert(+)plain(        :string => '32',)]
insert[insert(+)plain(        :symbol => '1;32',)]
insert[insert(+)plain(        :tag => '34',)]
insert[insert(+)plain(        :tag_fat => '1;34',)]
insert[insert(+)plain(        :tag_special => ['34', '4'],)]
insert[insert(+)plain(        :type => '1;34',)]
insert[insert(+)plain(        :variable => '34')]
insert[insert(+)plain(      })]
insert[insert(+)plain(      TOKEN_COLORS[:method] = TOKEN_COLORS[:function])]
insert[insert(+)plain(      TOKEN_COLORS[:open] = TOKEN_COLORS[:close] = TOKEN_COLORS[:nesting_delimiter] = TOKEN_COLORS[:escape] = TOKEN_COLORS[:delimiter])]
insert[insert(+)]
insert[insert(+)plain(      protected)]
insert[insert(+)]
insert[insert(+)plain(      def setup(options\))]
insert[insert(+)plain(        super)]
insert[insert(+)plain(        @opened = [nil])]
insert[insert(+)plain(        @subcolors = nil)]
insert[insert(+)plain(      end)]
insert[insert(+)]
insert[insert(+)plain(      def finish(options\))]
insert[insert(+)plain(        super)]
insert[insert(+)plain(      end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(      def token text, type)]
insert[insert(+)plain(        case text)]
insert[insert(+)plain(      )]
insert[insert(+)plain(        when nil)]
insert[insert(+)plain(          # raise 'Token with nil as text was given: %p' % [[text, type]])]
insert[insert(+)plain(      )]
insert[insert(+)plain(        when String)]
insert[insert(+)plain(        )]
insert[insert(+)plain(          if color = (@subcolors || TOKEN_COLORS\)[type])]
insert[insert(+)plain(            color = color[:self] || return if Hash === color)]
insert[insert(+)]
insert[insert(+)plain(            @out << col(color\) + text.gsub("\\n", col(0\) + "\\n" + col(color\)\) + col(0\))]
insert[insert(+)plain(            @out << col(@subcolors[:self]\) if @subcolors && @subcolors[:self])]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            @out << text)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(        # token groups, eg. strings)]
insert[insert(+)plain(        when :open)]
insert[insert(+)plain(          @opened[0] = type)]
insert[insert(+)plain(          if color = TOKEN_COLORS[type])]
insert[insert(+)plain(            if Hash === color)]
insert[insert(+)plain(              @subcolors = color)]
insert[insert(+)plain(              @out << col(color[:self]\) if color[:self])]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              @subcolors = {})]
insert[insert(+)plain(              @out << col(color\))]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          @opened << type)]
insert[insert(+)plain(        when :close)]
insert[insert(+)plain(          if @opened.empty?)]
insert[insert(+)plain(            # nothing to close)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            if (@subcolors || {}\)[:self])]
insert[insert(+)plain(              @out << col(0\))]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            @subcolors = nil)]
insert[insert(+)plain(            @opened.pop)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(        # whole lines to be highlighted, eg. a added/modified/deleted lines in a diff)]
insert[insert(+)plain(        when :begin_line)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        when :end_line        )]
insert[insert(+)plain(      )]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          raise 'unknown token kind: %p' % [text])]
insert[insert(+)plain(        end)]
insert[insert(+)plain(      end)]
insert[insert(+)]
insert[insert(+)plain(      private)]
insert[insert(+)]
insert[insert(+)plain(      def col(color\))]
insert[insert(+)plain(        Array(color\).map { |c| "\\e[#{c}m" }.join)]
insert[insert(+)plain(      end)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(end)]
change[change(\\ )plain(No newline at end of file)]
head[head(Index: )plain(lib/coderay/encoders/page.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/page.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/page.rb	(revision 500\))]
change[change(@@)plain( -9,11 +9,10 )change(@@)]
comment( )
comment(     register_for :page)
comment( )
delete[delete(-)plain(    DEFAULT_OPTIONS = HTML::DEFAULT_OPTIONS.merge({)]
insert[insert(+)plain(    DEFAULT_OPTIONS = HTML::DEFAULT_OPTIONS.merge \\)]
comment(       :css => :class,)
comment(       :wrap => :page,)
comment(       :line_numbers => :table)
delete[delete(-)plain(    }\))]
comment( )
comment(   end)
comment( )
head[head(Index: )plain(lib/coderay/encoders/_map.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/encoders/_map.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/encoders/_map.rb	(revision 500\))]
change[change(@@)plain( -1,8 +1,11 )change(@@)]
comment( module CodeRay)
comment( module Encoders)
comment( )
delete[delete(-)plain(  map :stats => :statistic,)]
insert[insert(+)plain(  map \\)]
insert[insert(+)plain(    :loc => :lines_of_code,)]
insert[insert(+)plain(    :term => :terminal,)]
comment(     :plain => :text,)
insert[insert(+)plain(    :stats => :statistic,)]
comment(     :tex => :latex)
comment( )
comment( end)
head[head(Index: )plain(lib/coderay/helpers/plugin.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/helpers/plugin.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/helpers/plugin.rb	(revision 500\))]
change[change(@@)plain( -2,8 +2,6 )change(@@)]
comment(   )
comment( # = PluginHost)
comment( #)
delete[delete(-)plain(# $Id$)]
delete[delete(-)plain(#)]
comment( # A simple subclass plugin system.)
comment( #)
comment( #  Example:)
change[change(@@)plain( -135,9 +133,13 )change(@@)]
comment(   #    map :navy => :dark_blue)
comment(   #    default :gray)
comment(   #  end)
delete[delete(-)plain(  def default id)]
delete[delete(-)plain(    id = validate_id id)]
delete[delete(-)plain(    plugin_hash[nil] = id)]
insert[insert(+)plain(  def default id = nil)]
insert[insert(+)plain(    if id)]
insert[insert(+)plain(      id = validate_id id)]
insert[insert(+)plain(      plugin_hash[nil] = id)]
insert[insert(+)plain(    else)]
insert[insert(+)plain(      plugin_hash[nil])]
insert[insert(+)plain(    end)]
comment(   end)
comment( )
comment(   # Every plugin must register itself for one or more)
change[change(@@)plain( -174,7 +176,7 )change(@@)]
comment(   def inspect)
comment(     map = plugin_hash.dup)
comment(     map.each do |id, plugin|)
delete[delete(-)plain(      map[id] = plugin.to_s[/(?>[\\w_]+\)$/])]
insert[insert(+)plain(      map[id] = plugin.to_s[/(?>\\w+\)$/])]
comment(     end)
comment(     "#{name}[#{host_id}]#{map.inspect}")
comment(   end)
change[change(@@)plain( -241,7 +243,7 )change(@@)]
comment(       id)
comment(     elsif id.is_a? String)
comment(       if id[/\\w+/] == id)
delete[delete(-)plain(        id.to_sym)]
insert[insert(+)plain(        id.downcase.to_sym)]
comment(       else)
comment(         raise ArgumentError, "Invalid id: '#{id}' given.")
comment(       end)
change[change(@@)plain( -278,6 +280,16 )change(@@)]
comment(   def register_for *ids)
comment(     plugin_host.register self, *ids)
comment(   end)
insert[insert(+)plain(  )]
insert[insert(+)plain(  # Returns the title of the plugin, or sets it to the)]
insert[insert(+)plain(  # optional argument +title+.)]
insert[insert(+)plain(  def title title = nil)]
insert[insert(+)plain(    if title)]
insert[insert(+)plain(      @title = title.to_s)]
insert[insert(+)plain(    else)]
insert[insert(+)plain(      @title ||= name[/([^:]+\)$/, 1])]
insert[insert(+)plain(    end)]
insert[insert(+)plain(  end)]
comment( )
comment(   # The host for this Plugin class.)
comment(   def plugin_host host = nil)
change[change(@@)plain( -299,15 +311,23 )change(@@)]
comment(   #)
comment(   # The above example loads the file myplugin/my_helper.rb relative to the)
comment(   # file in which MyPlugin was defined.)
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # You can also load a helper from a different plugin:)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  #  helper 'other_plugin/helper_name')]
comment(   def helper *helpers)
comment(     for helper in helpers)
delete[delete(-)plain(      self::PLUGIN_HOST.require_helper plugin_id, helper.to_s)]
insert[insert(+)plain(      if helper.is_a?(String\) && helper[/\\//])]
insert[insert(+)plain(        self::PLUGIN_HOST.require_helper $`, $')]
insert[insert(+)plain(      else)]
insert[insert(+)plain(        self::PLUGIN_HOST.require_helper plugin_id, helper.to_s)]
insert[insert(+)plain(      end)]
comment(     end)
comment(   end)
comment( )
comment(   # Returns the pulgin id used by the engine.)
comment(   def plugin_id)
delete[delete(-)plain(    name[/[\\w_]+$/].downcase)]
insert[insert(+)plain(    name[/\\w+$/].downcase)]
comment(   end)
comment( )
comment( end)
head[head(Index: )plain(lib/coderay/helpers/file_type.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/helpers/file_type.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/helpers/file_type.rb	(revision 500\))]
change[change(@@)plain( -35,10 +35,12 )change(@@)]
comment(     def [] filename, read_shebang = false)
comment(       name = File.basename filename)
comment(       ext = File.extname(name\).sub(/^\\./, ''\)  # from last dot, delete the leading dot)
delete[delete(-)plain(      ext2 = filename[/\\.(.*\)/, 1]  # from first dot)]
insert[insert(+)plain(      ext2 = filename.to_s[/\\.(.*\)/, 1]  # from first dot)]
comment( )
comment(       type =)
insert[insert(+)plain(        TypeFromExt[ext] ||)]
comment(         TypeFromExt[ext.downcase] ||)
insert[insert(+)plain(        (TypeFromExt[ext2] if ext2\) ||)]
comment(         (TypeFromExt[ext2.downcase] if ext2\) ||)
comment(         TypeFromName[name] ||)
comment(         TypeFromName[name.downcase])
change[change(@@)plain( -81,25 +83,46 )change(@@)]
comment(   end)
comment( )
comment(   TypeFromExt = {)
delete[delete(-)plain(    'rb' => :ruby,)]
delete[delete(-)plain(    'rbw' => :ruby,)]
delete[delete(-)plain(    'rake' => :ruby,)]
delete[delete(-)plain(    'mab' => :ruby,)]
delete[delete(-)plain(    'cpp' => :c,)]
comment(     'c' => :c,)
insert[insert(+)plain(    'css' => :css,)]
insert[insert(+)plain(    'diff' => :diff,)]
insert[insert(+)plain(    'dpr' => :delphi,)]
insert[insert(+)plain(    'groovy' => :groovy,)]
insert[insert(+)plain(    'gvy' => :groovy,)]
comment(     'h' => :c,)
delete[delete(-)plain(    'xml' => :xml,)]
comment(     'htm' => :html,)
comment(     'html' => :html,)
delete[delete(-)plain(    'xhtml' => :xhtml,)]
insert[insert(+)plain(    'html.erb' => :rhtml,)]
insert[insert(+)plain(    'java' => :java,)]
insert[insert(+)plain(    'js' => :java_script,)]
insert[insert(+)plain(    'json' => :json,)]
insert[insert(+)plain(    'mab' => :ruby,)]
insert[insert(+)plain(    'pas' => :delphi,)]
insert[insert(+)plain(    'patch' => :diff,)]
insert[insert(+)plain(    'php' => :php,)]
insert[insert(+)plain(    'php3' => :php,)]
insert[insert(+)plain(    'php4' => :php,)]
insert[insert(+)plain(    'php5' => :php,)]
insert[insert(+)plain(    'py' => :python,)]
insert[insert(+)plain(    'py3' => :python,)]
insert[insert(+)plain(    'pyw' => :python,)]
insert[insert(+)plain(    'rake' => :ruby,)]
comment(     'raydebug' => :debug,)
insert[insert(+)plain(    'rb' => :ruby,)]
insert[insert(+)plain(    'rbw' => :ruby,)]
comment(     'rhtml' => :rhtml,)
delete[delete(-)plain(    'html.erb' => :rhtml,)]
insert[insert(+)plain(    'rxml' => :ruby,)]
insert[insert(+)plain(    'sch' => :scheme,)]
insert[insert(+)plain(    'sql' => :sql,)]
comment(     'ss' => :scheme,)
delete[delete(-)plain(    'sch' => :scheme,)]
insert[insert(+)plain(    'xhtml' => :xhtml,)]
insert[insert(+)plain(    'xml' => :xml,)]
comment(     'yaml' => :yaml,)
comment(     'yml' => :yaml,)
comment(   })
insert[insert(+)plain(  for cpp_alias in %w[cc cpp cp cxx c++ C hh hpp h++ cu])]
insert[insert(+)plain(    TypeFromExt[cpp_alias] = :cpp)]
insert[insert(+)plain(  end)]
comment( )
comment(   TypeFromShebang = /\\b(?:ruby|perl|python|sh\)\\b/)
comment( )
change[change(@@)plain( -114,13 +137,13 )change(@@)]
comment( )
comment( if $0 == __FILE__)
comment(   $VERBOSE = true)
delete[delete(-)plain(  eval DATA.read, nil, $0, __LINE__+4)]
insert[insert(+)plain(  eval DATA.read, nil, $0, __LINE__ + 4)]
comment( end)
comment( )
comment( __END__)
comment( require 'test/unit')
comment( )
delete[delete(-)plain(class TC_FileType < Test::Unit::TestCase)]
insert[insert(+)plain(class FileTypeTests < Test::Unit::TestCase)]
comment(   )
comment(   include CodeRay)
comment(   )
change[change(@@)plain( -150,6 +173,8 )change(@@)]
comment( )
comment(   def test_ruby)
comment(     assert_equal :ruby, FileType['test.rb'])
insert[insert(+)plain(    assert_equal :ruby, FileType['test.java.rb'])]
insert[insert(+)plain(    assert_equal :java, FileType['test.rb.java'])]
comment(     assert_equal :ruby, FileType['C:\\\\Program Files\\\\x\\\\y\\\\c\\\\test.rbw'])
comment(     assert_equal :ruby, FileType['/usr/bin/something/Rakefile'])
comment(     assert_equal :ruby, FileType['~/myapp/gem/Rantfile'])
change[change(@@)plain( -169,6 +194,17 )change(@@)]
comment(     assert_not_equal :c, FileType['~/projects/blabla/c'])
comment(   end)
comment( )
insert[insert(+)plain(  def test_cpp)]
insert[insert(+)plain(    assert_equal :cpp, FileType['test.c++'])]
insert[insert(+)plain(    assert_equal :cpp, FileType['test.cxx'])]
insert[insert(+)plain(    assert_equal :cpp, FileType['test.hh'])]
insert[insert(+)plain(    assert_equal :cpp, FileType['test.hpp'])]
insert[insert(+)plain(    assert_equal :cpp, FileType['test.cu'])]
insert[insert(+)plain(    assert_equal :cpp, FileType['test.C'])]
insert[insert(+)plain(    assert_not_equal :cpp, FileType['test.c'])]
insert[insert(+)plain(    assert_not_equal :cpp, FileType['test.h'])]
insert[insert(+)plain(  end)]
insert[insert(+)]
comment(   def test_html)
comment(     assert_equal :html, FileType['test.htm'])
comment(     assert_equal :xhtml, FileType['test.xhtml'])
change[change(@@)plain( -184,6 +220,15 )change(@@)]
comment(     assert_not_equal :yaml, FileType['YAML'])
comment(   end)
comment( )
insert[insert(+)plain(  def test_pathname)]
insert[insert(+)plain(    require 'pathname')]
insert[insert(+)plain(    pn = Pathname.new 'test.rb')]
insert[insert(+)plain(    assert_equal :ruby, FileType[pn])]
insert[insert(+)plain(    dir = Pathname.new '/etc/var/blubb')]
insert[insert(+)plain(    assert_equal :ruby, FileType[dir + pn])]
insert[insert(+)plain(    assert_equal :cpp, FileType[dir + 'test.cpp'])]
insert[insert(+)plain(  end)]
insert[insert(+)]
comment(   def test_no_shebang)
comment(     dir = './test')
comment(     if File.directory? dir)
head[head(Index: )plain(lib/coderay/helpers/gzip_simple.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/helpers/gzip_simple.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/helpers/gzip_simple.rb	(revision 500\))]
change[change(@@)plain( -2,7 +2,7 )change(@@)]
comment( #)
comment( # A simplified interface to the gzip library +zlib+ (from the Ruby Standard Library.\))
comment( #)
delete[delete(-)plain(# Author: murphy (mail to murphy cYcnus de\))]
insert[insert(+)plain(# Author: murphy (mail to murphy rubychan de\))]
comment( #)
comment( # Version: 0.2 (2005.may.28\))
comment( #)
head[head(Index: )plain(lib/coderay/helpers/word_list.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/helpers/word_list.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/helpers/word_list.rb	(revision 500\))]
change[change(@@)plain( -98,17 +98,24 )change(@@)]
comment(   # Creates a new case-insensitive WordList with +default+ as default value.)
comment(   # )
comment(   # You can activate caching to store the results for every [] request.)
insert[insert(+)plain(  # This speeds up subsequent lookups for the same word, but also)]
insert[insert(+)plain(  # uses memory.)]
comment(   def initialize default = false, caching = false)
comment(     if caching)
comment(       super(default, false\) do |h, k|)
comment(         h[k] = h.fetch k.downcase, default)
comment(       end)
comment(     else)
delete[delete(-)plain(      def self.[] key  # :nodoc:)]
delete[delete(-)plain(        super(key.downcase\))]
delete[delete(-)plain(      end)]
insert[insert(+)plain(      super(default, false\))]
insert[insert(+)plain(      extend Uncached)]
comment(     end)
comment(   end)
insert[insert(+)plain(  )]
insert[insert(+)plain(  module Uncached  # :nodoc:)]
insert[insert(+)plain(    def [] key)]
insert[insert(+)plain(      super(key.downcase\))]
insert[insert(+)plain(    end)]
insert[insert(+)plain(  end)]
comment( )
comment(   # Add +words+ to the list and associate them with +kind+.)
comment(   def add words, kind = true)
change[change(@@)plain( -120,4 +127,12 )change(@@)]
comment( )
comment( end)
comment( )
delete[delete(-)plain(end)]
change[change(\\ )plain(No newline at end of file)]
insert[insert(+)plain(end)]
insert[insert(+)]
insert[insert(+)plain(__END__)]
insert[insert(+)plain(# check memory consumption)]
insert[insert(+)plain(END {)]
insert[insert(+)plain(  ObjectSpace.each_object(CodeRay::CaseIgnoringWordList\) do |wl|)]
insert[insert(+)plain(    p wl.inject(0\) { |memo, key, value| memo + key.size + 24 })]
insert[insert(+)plain(  end)]
insert[insert(+)plain(})]
change[change(\\ )plain(No newline at end of file)]
head[head(Index: )plain(lib/coderay/style.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/style.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/style.rb	(revision 500\))]
change[change(@@)plain( -1,20 +1,23 )change(@@)]
comment( module CodeRay)
comment( )
comment(   # This module holds the Style class and its subclasses.)
delete[delete(-)plain(  #)]
insert[insert(+)plain(  # )]
comment(   # See Plugin.)
comment(   module Styles)
comment(     extend PluginHost)
comment(     plugin_path File.dirname(__FILE__\), 'styles')
delete[delete(-)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    # Base class for styles.)]
insert[insert(+)plain(    # )]
insert[insert(+)plain(    # Styles are used by Encoders::HTML to colorize tokens.)]
comment(     class Style)
comment(       extend Plugin)
comment(       plugin_host Styles)
delete[delete(-)]
delete[delete(-)plain(      DEFAULT_OPTIONS = { })]
delete[delete(-)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      DEFAULT_OPTIONS = { }  # :nodoc:)]
insert[insert(+)plain(      )]
comment(     end)
delete[delete(-)]
insert[insert(+)plain(    )]
comment(   end)
delete[delete(-)]
insert[insert(+)plain(  )]
comment( end)
head[head(Index: )plain(lib/coderay/styles/cycnus.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/styles/cycnus.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/styles/cycnus.rb	(revision 500\))]
change[change(@@)plain( -8,7 +8,7 )change(@@)]
comment(     code_background = '#f8f8f8')
comment(     numbers_background = '#def')
comment(     border_color = 'silver')
delete[delete(-)plain(    normal_color = '#100')]
insert[insert(+)plain(    normal_color = '#000')]
comment( )
comment(     CSS_MAIN_STYLES = <<-MAIN)
comment( .CodeRay {)
change[change(@@)plain( -32,6 +32,7 )change(@@)]
comment(   text-align: right;)
comment( })
comment( .CodeRay .line_numbers tt { font-weight: bold })
insert[insert(+)plain(.CodeRay .line_numbers .highlighted { color: red })]
comment( .CodeRay .no { padding: 0px 4px })
comment( .CodeRay .code { width: 100% })
comment( )
change[change(@@)plain( -46,28 +47,32 )change(@@)]
comment( )
comment( .af { color:#00C })
comment( .an { color:#007 })
insert[insert(+)plain(.at { color:#f08 })]
comment( .av { color:#700 })
comment( .aw { color:#C00 })
comment( .bi { color:#509; font-weight:bold })
delete[delete(-)plain(.c  { color:#666; })]
insert[insert(+)plain(.c  { color:#888; })]
comment( )
comment( .ch { color:#04D })
comment( .ch .k { color:#04D })
comment( .ch .dl { color:#039 })
comment( )
comment( .cl { color:#B06; font-weight:bold })
insert[insert(+)plain(.cm { color:#A08; font-weight:bold })]
comment( .co { color:#036; font-weight:bold })
comment( .cr { color:#0A0 })
comment( .cv { color:#369 })
insert[insert(+)plain(.de { color:#B0B; })]
comment( .df { color:#099; font-weight:bold })
comment( .di { color:#088; font-weight:bold })
comment( .dl { color:black })
comment( .do { color:#970 })
insert[insert(+)plain(.dt { color:#34b })]
comment( .ds { color:#D42; font-weight:bold })
comment( .e  { color:#666; font-weight:bold })
comment( .en { color:#800; font-weight:bold })
comment( .er { color:#F00; background-color:#FAA })
delete[delete(-)plain(.ex { color:#F00; font-weight:bold })]
insert[insert(+)plain(.ex { color:#C00; font-weight:bold })]
comment( .fl { color:#60E; font-weight:bold })
comment( .fu { color:#06B; font-weight:bold })
comment( .gv { color:#d70; font-weight:bold })
change[change(@@)plain( -75,11 +80,13 )change(@@)]
comment( .i  { color:#00D; font-weight:bold })
comment( .ic { color:#B44; font-weight:bold })
comment( )
delete[delete(-)plain(.il { background: #eee })]
delete[delete(-)plain(.il .il { background: #ddd })]
delete[delete(-)plain(.il .il .il { background: #ccc })]
delete[delete(-)plain(.il .idl { font-weight: bold; color: #888 })]
insert[insert(+)plain(.il { background: #ddd; color: black })]
insert[insert(+)plain(.il .il { background: #ccc })]
insert[insert(+)plain(.il .il .il { background: #bbb })]
insert[insert(+)plain(.il .idl { background: #ddd; font-weight: bold; color: #666 })]
insert[insert(+)plain(.idl { background-color: #bbb; font-weight: bold; color: #666; })]
comment( )
insert[insert(+)plain(.im { color:#f00; })]
comment( .in { color:#B2B; font-weight:bold })
comment( .iv { color:#33B })
comment( .la { color:#970; font-weight:bold })
change[change(@@)plain( -89,24 +96,31 )change(@@)]
comment( .op { })
comment( .pc { color:#038; font-weight:bold })
comment( .pd { color:#369; font-weight:bold })
delete[delete(-)plain(.pp { color:#579 })]
delete[delete(-)plain(.pt { color:#339; font-weight:bold })]
delete[delete(-)plain(.r  { color:#080; font-weight:bold })]
insert[insert(+)plain(.pp { color:#579; })]
insert[insert(+)plain(.ps { color:#00C; font-weight:bold })]
insert[insert(+)plain(.pt { color:#074; font-weight:bold })]
insert[insert(+)plain(.r, .kw  { color:#080; font-weight:bold })]
comment( )
insert[insert(+)plain(.ke { color: #808; })]
insert[insert(+)plain(.ke .dl { color: #606; })]
insert[insert(+)plain(.ke .ch { color: #80f; })]
insert[insert(+)plain(.vl { color: #088; })]
insert[insert(+)]
comment( .rx { background-color:#fff0ff })
comment( .rx .k { color:#808 })
comment( .rx .dl { color:#404 })
comment( .rx .mod { color:#C2C })
comment( .rx .fu  { color:#404; font-weight: bold })
comment( )
delete[delete(-)plain(.s  { background-color:#fff0f0 })]
delete[delete(-)plain(.s  .s { background-color:#ffe0e0 })]
delete[delete(-)plain(.s  .s  .s { background-color:#ffd0d0 })]
delete[delete(-)plain(.s  .k { color:#D20 })]
delete[delete(-)plain(.s  .dl { color:#710 })]
insert[insert(+)plain(.s { background-color:#fff0f0; color: #D20; })]
insert[insert(+)plain(.s .s { background-color:#ffe0e0 })]
insert[insert(+)plain(.s .s  .s { background-color:#ffd0d0 })]
insert[insert(+)plain(.s .k { })]
insert[insert(+)plain(.s .ch { color: #b0b; })]
insert[insert(+)plain(.s .dl { color: #710; })]
comment( )
delete[delete(-)plain(.sh { background-color:#f0fff0 })]
delete[delete(-)plain(.sh .k { color:#2B2 })]
insert[insert(+)plain(.sh { background-color:#f0fff0; color:#2B2 })]
insert[insert(+)plain(.sh .k { })]
comment( .sh .dl { color:#161 })
comment( )
comment( .sy { color:#A60 })
change[change(@@)plain( -119,6 +133,16 )change(@@)]
comment( .ty { color:#339; font-weight:bold })
comment( .v  { color:#036 })
comment( .xt { color:#444 })
insert[insert(+)]
insert[insert(+)plain(.ins { background: #afa; })]
insert[insert(+)plain(.del { background: #faa; })]
insert[insert(+)plain(.chg { color: #aaf; background: #007; })]
insert[insert(+)plain(.head { color: #f8f; background: #505 })]
insert[insert(+)]
insert[insert(+)plain(.ins .ins { color: #080; font-weight:bold })]
insert[insert(+)plain(.del .del { color: #800; font-weight:bold })]
insert[insert(+)plain(.chg .chg { color: #66f; })]
insert[insert(+)plain(.head .head { color: #f4f; })]
comment(     TOKENS)
comment( )
comment(   end)
head[head(Index: )plain(lib/coderay/styles/murphy.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/styles/murphy.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/styles/murphy.rb	(revision 500\))]
change[change(@@)plain( -84,7 +84,10 )change(@@)]
comment( .pp { color:#579; })
comment( .pt { color:#66f; font-weight:bold; })
comment( .r  { color:#5de; font-weight:bold; })
insert[insert(+)plain(.r, .kw  { color:#5de; font-weight:bold })]
comment( )
insert[insert(+)plain(.ke { color: #808; })]
insert[insert(+)]
comment( .rx { background-color:#221133; })
comment( .rx .k { color:#f8f; })
comment( .rx .dl { color:#f0f; })
change[change(@@)plain( -111,6 +114,16 )change(@@)]
comment( .ty { color:#339; font-weight:bold; })
comment( .v  { color:#036; })
comment( .xt { color:#444; })
insert[insert(+)]
insert[insert(+)plain(.ins { background: #afa; })]
insert[insert(+)plain(.del { background: #faa; })]
insert[insert(+)plain(.chg { color: #aaf; background: #007; })]
insert[insert(+)plain(.head { color: #f8f; background: #505 })]
insert[insert(+)]
insert[insert(+)plain(.ins .ins { color: #080; font-weight:bold })]
insert[insert(+)plain(.del .del { color: #800; font-weight:bold })]
insert[insert(+)plain(.chg .chg { color: #66f; })]
insert[insert(+)plain(.head .head { color: #f4f; })]
comment(     TOKENS)
comment( )
comment(   end)
head[head(Index: )plain(lib/coderay/styles/alpha.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/styles/alpha.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/styles/alpha.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,145 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Styles)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # A colorful theme using CSS 3 colors (with alpha channel\).)]
insert[insert(+)plain(  class Alpha < Style)]
insert[insert(+)]
insert[insert(+)plain(    register_for :alpha)]
insert[insert(+)]
insert[insert(+)plain(    code_background = '#f8f8f8')]
insert[insert(+)plain(    numbers_background = '#def')]
insert[insert(+)plain(    border_color = 'silver')]
insert[insert(+)plain(    normal_color = '#000')]
insert[insert(+)]
insert[insert(+)plain(    CSS_MAIN_STYLES = <<-MAIN  # :nodoc:)]
insert[insert(+)plain(.CodeRay {)]
insert[insert(+)plain(  background-color: #{code_background};)]
insert[insert(+)plain(  border: 1px solid #{border_color};)]
insert[insert(+)plain(  font-family: 'Courier New', 'Terminal', monospace;)]
insert[insert(+)plain(  color: #{normal_color};)]
insert[insert(+)plain(})]
insert[insert(+)plain(.CodeRay pre { margin: 0px })]
insert[insert(+)]
insert[insert(+)plain(div.CodeRay { })]
insert[insert(+)]
insert[insert(+)plain(span.CodeRay { white-space: pre; border: 0px; padding: 2px })]
insert[insert(+)]
insert[insert(+)plain(table.CodeRay { border-collapse: collapse; width: 100%; padding: 2px })]
insert[insert(+)plain(table.CodeRay td { padding: 2px 4px; vertical-align: top })]
insert[insert(+)]
insert[insert(+)plain(.CodeRay .line_numbers, .CodeRay .no {)]
insert[insert(+)plain(  background-color: #{numbers_background};)]
insert[insert(+)plain(  color: gray;)]
insert[insert(+)plain(  text-align: right;)]
insert[insert(+)plain(})]
insert[insert(+)plain(.CodeRay .line_numbers tt { font-weight: bold })]
insert[insert(+)plain(.CodeRay .line_numbers .highlighted { color: red })]
insert[insert(+)plain(.CodeRay .no { padding: 0px 4px })]
insert[insert(+)plain(.CodeRay .code { width: 100% })]
insert[insert(+)]
insert[insert(+)plain(ol.CodeRay { font-size: 10pt })]
insert[insert(+)plain(ol.CodeRay li { white-space: pre })]
insert[insert(+)]
insert[insert(+)plain(.CodeRay .code pre { overflow: auto })]
insert[insert(+)plain(    MAIN)]
insert[insert(+)]
insert[insert(+)plain(    TOKEN_COLORS = <<-'TOKENS')]
insert[insert(+)plain(.debug { color:white ! important; background:blue ! important; })]
insert[insert(+)]
insert[insert(+)plain(.an { color:#007 })]
insert[insert(+)plain(.at { color:#f08 })]
insert[insert(+)plain(.av { color:#700 })]
insert[insert(+)plain(.bi { color:#509; font-weight:bold })]
insert[insert(+)plain(.c  { color:#888; })]
insert[insert(+)]
insert[insert(+)plain(.ch { color:#04D })]
insert[insert(+)plain(.ch .k { color:#04D })]
insert[insert(+)plain(.ch .dl { color:#039 })]
insert[insert(+)]
insert[insert(+)plain(.cl { color:#B06; font-weight:bold })]
insert[insert(+)plain(.cm { color:#A08; font-weight:bold })]
insert[insert(+)plain(.co { color:#036; font-weight:bold })]
insert[insert(+)plain(.cr { color:#0A0 })]
insert[insert(+)plain(.cv { color:#369 })]
insert[insert(+)plain(.de { color:#B0B; })]
insert[insert(+)plain(.df { color:#099; font-weight:bold })]
insert[insert(+)plain(.di { color:#088; font-weight:bold })]
insert[insert(+)plain(.dl { color:black })]
insert[insert(+)plain(.do { color:#970 })]
insert[insert(+)plain(.dt { color:#34b })]
insert[insert(+)plain(.ds { color:#D42; font-weight:bold })]
insert[insert(+)plain(.e  { color:#666; font-weight:bold })]
insert[insert(+)plain(.en { color:#800; font-weight:bold })]
insert[insert(+)plain(.er { color:#F00; background-color:#FAA })]
insert[insert(+)plain(.ex { color:#C00; font-weight:bold })]
insert[insert(+)plain(.fl { color:#60E; font-weight:bold })]
insert[insert(+)plain(.fu { color:#06B; font-weight:bold })]
insert[insert(+)plain(.gv { color:#d70; font-weight:bold })]
insert[insert(+)plain(.hx { color:#058; font-weight:bold })]
insert[insert(+)plain(.i  { color:#00D; font-weight:bold })]
insert[insert(+)plain(.ic { color:#B44; font-weight:bold })]
insert[insert(+)]
insert[insert(+)plain(.il { background: hsla(0,0%,0%,0.1\); color: black })]
insert[insert(+)plain(.il .idl { font-weight: bold; color: #666 })]
insert[insert(+)plain(.idl { font-weight: bold; color: #666; })]
insert[insert(+)]
insert[insert(+)plain(.im { color:#f00; })]
insert[insert(+)plain(.in { color:#B2B; font-weight:bold })]
insert[insert(+)plain(.iv { color:#33B })]
insert[insert(+)plain(.la { color:#970; font-weight:bold })]
insert[insert(+)plain(.lv { color:#963 })]
insert[insert(+)plain(.oc { color:#40E; font-weight:bold })]
insert[insert(+)plain(.op { })]
insert[insert(+)plain(.pc { color:#038; font-weight:bold })]
insert[insert(+)plain(.pd { color:#369; font-weight:bold })]
insert[insert(+)plain(.pp { color:#579; })]
insert[insert(+)plain(.ps { color:#00C; font-weight:bold })]
insert[insert(+)plain(.pt { color:#074; font-weight:bold })]
insert[insert(+)plain(.r, .kw  { color:#080; font-weight:bold })]
insert[insert(+)]
insert[insert(+)plain(.ke { color: #808; })]
insert[insert(+)plain(.ke .dl { color: #606; })]
insert[insert(+)plain(.ke .ch { color: #80f; })]
insert[insert(+)plain(.vl { color: #088; })]
insert[insert(+)]
insert[insert(+)plain(.rx { background-color:hsla(300,100%,50%,0.1\); })]
insert[insert(+)plain(.rx .k { color:#808 })]
insert[insert(+)plain(.rx .dl { color:#404 })]
insert[insert(+)plain(.rx .mod { color:#C2C })]
insert[insert(+)plain(.rx .fu  { color:#404; font-weight: bold })]
insert[insert(+)]
insert[insert(+)plain(.s { background-color:hsla(0,100%,50%,0.1\); color: #D20; })]
insert[insert(+)plain(.s .k { })]
insert[insert(+)plain(.s .ch { color: #b0b; })]
insert[insert(+)plain(.s .dl { color: #710; })]
insert[insert(+)]
insert[insert(+)plain(.sh { background-color:hsla(120,100%,50%,0.1\); color:#2B2 })]
insert[insert(+)plain(.sh .k { })]
insert[insert(+)plain(.sh .dl { color:#161 })]
insert[insert(+)]
insert[insert(+)plain(.sy { color:#A60 })]
insert[insert(+)plain(.sy .k { color:#A60 })]
insert[insert(+)plain(.sy .dl { color:#630 })]
insert[insert(+)]
insert[insert(+)plain(.ta { color:#070 })]
insert[insert(+)plain(.ts { color:#D70; font-weight:bold })]
insert[insert(+)plain(.ty { color:#339; font-weight:bold })]
insert[insert(+)plain(.v  { color:#036 })]
insert[insert(+)plain(.xt { color:#444 })]
insert[insert(+)]
insert[insert(+)plain(.ins { background: #afa; })]
insert[insert(+)plain(.del { background: #faa; })]
insert[insert(+)plain(.chg { color: #aaf; background: #007; })]
insert[insert(+)plain(.head { color: #f8f; background: #505 })]
insert[insert(+)plain(.head .filename { color: white; })]
insert[insert(+)]
insert[insert(+)plain(.ins .ins { color: #080; font-weight:bold })]
insert[insert(+)plain(.del .del { color: #800; font-weight:bold })]
insert[insert(+)plain(.chg .chg { color: #66f; })]
insert[insert(+)plain(.head .head { color: #f4f; })]
insert[insert(+)plain(    TOKENS)]
insert[insert(+)]
insert[insert(+)plain(  end)]
insert[insert(+)]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/tokens.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/tokens.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/tokens.rb	(revision 500\))]
change[change(@@)plain( -14,7 +14,7 )change(@@)]
comment(   #)
comment(   #   [:comment, '# It looks like this'])
comment(   #   [:float, '3.1415926'])
delete[delete(-)plain(  #   [:error, ''])]
insert[insert(+)plain(  #   [:error, '$^'])]
comment(   #)
comment(   # Some scanners also yield some kind of sub-tokens, represented by special)
comment(   # token texts, namely :open and :close .)
change[change(@@)plain( -46,47 +46,10 )change(@@)]
comment(   #)
comment(   # Tokens' subclass TokenStream allows streaming to save memory.)
comment(   class Tokens < Array)
delete[delete(-)]
delete[delete(-)plain(    class << self)]
delete[delete(-)]
delete[delete(-)plain(      # Convert the token to a string.)]
delete[delete(-)plain(      #)]
delete[delete(-)plain(      # This format is used by Encoders.Tokens.)]
delete[delete(-)plain(      # It can be reverted using read_token.)]
delete[delete(-)plain(      def write_token text, type)]
delete[delete(-)plain(        if text.is_a? String)]
delete[delete(-)plain(          "#{type}\\t#{escape(text\)}\\n")]
delete[delete(-)plain(        else)]
delete[delete(-)plain(          ":#{text}\\t#{type}\\t\\n")]
delete[delete(-)plain(        end)]
delete[delete(-)plain(      end)]
delete[delete(-)]
delete[delete(-)plain(      # Read a token from the string.)]
delete[delete(-)plain(      #)]
delete[delete(-)plain(      # Inversion of write_token.)]
delete[delete(-)plain(      #)]
delete[delete(-)plain(      # TODO Test this!)]
delete[delete(-)plain(      def read_token token)]
delete[delete(-)plain(        type, text = token.split("\\t", 2\))]
delete[delete(-)plain(        if type[0] == ?:)]
delete[delete(-)plain(          [text.to_sym, type[1..-1].to_sym])]
delete[delete(-)plain(        else)]
delete[delete(-)plain(          [type.to_sym, unescape(text\)])]
delete[delete(-)plain(        end)]
delete[delete(-)plain(      end)]
delete[delete(-)]
delete[delete(-)plain(      # Escapes a string for use in write_token.)]
delete[delete(-)plain(      def escape text)]
delete[delete(-)plain(        text.gsub(/[\\n\\\\]/, '\\\\\\\\\\&'\))]
delete[delete(-)plain(      end)]
delete[delete(-)]
delete[delete(-)plain(      # Unescapes a string created by escape.)]
delete[delete(-)plain(      def unescape text)]
delete[delete(-)plain(        text.gsub(/\\\\[\\n\\\\]/\) { |m| m[1,1] })]
delete[delete(-)plain(      end)]
delete[delete(-)]
delete[delete(-)plain(    end)]
delete[delete(-)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    # The Scanner instance that created the tokens.)]
insert[insert(+)plain(    attr_accessor :scanner)]
insert[insert(+)plain(    )]
comment(     # Whether the object is a TokenStream.)
comment(     #)
comment(     # Returns false.)
change[change(@@)plain( -146,7 +109,6 )change(@@)]
comment(       encode :text, options)
comment(     end)
comment( )
delete[delete(-)]
comment(     # Redirects unknown methods to encoder calls.)
comment(     #)
comment(     # For example, if you call +tokens.html+, the HTML encoder)
change[change(@@)plain( -200,25 +162,29 )change(@@)]
comment(     #)
comment(     # TODO: Test this!)
comment(     def fix)
insert[insert(+)plain(      tokens = self.class.new)]
comment(       # Check token nesting using a stack of kinds.)
comment(       opened = [])
delete[delete(-)plain(      for token, kind in self)]
delete[delete(-)plain(        if token == :open)]
delete[delete(-)plain(          opened.push kind)]
delete[delete(-)plain(        elsif token == :close)]
insert[insert(+)plain(      for type, kind in self)]
insert[insert(+)plain(        case type)]
insert[insert(+)plain(        when :open)]
insert[insert(+)plain(          opened.push [:close, kind])]
insert[insert(+)plain(        when :begin_line)]
insert[insert(+)plain(          opened.push [:end_line, kind])]
insert[insert(+)plain(        when :close, :end_line)]
comment(           expected = opened.pop)
delete[delete(-)plain(          if kind != expected)]
insert[insert(+)plain(          if [type, kind] != expected)]
comment(             # Unexpected :close; decide what to do based on the kind:)
insert[insert(+)plain(            # - token was never opened: delete the :close (just skip it\))]
insert[insert(+)plain(            next unless opened.rindex expected)]
comment(             # - token was opened earlier: also close tokens in between)
delete[delete(-)plain(            # - token was never opened: delete the :close (skip with next\))]
delete[delete(-)plain(            next unless opened.rindex expected)]
delete[delete(-)plain(            tokens << [:close, kind] until (kind = opened.pop\) == expected)]
insert[insert(+)plain(            tokens << token until (token = opened.pop\) == expected)]
comment(           end)
comment(         end)
delete[delete(-)plain(        tokens << [token, kind])]
insert[insert(+)plain(        tokens << [type, kind])]
comment(       end)
comment(       # Close remaining opened tokens)
delete[delete(-)plain(      tokens << [:close, kind] while kind = opened.pop)]
insert[insert(+)plain(      tokens << token while token = opened.pop)]
comment(       tokens)
comment(     end)
comment(     )
change[change(@@)plain( -226,6 +192,8 )change(@@)]
comment(       replace fix)
comment(     end)
comment(     )
insert[insert(+)plain(    # TODO: Scanner#split_into_lines)]
insert[insert(+)plain(    # )]
comment(     # Makes sure that:)
comment(     # - newlines are single tokens)
comment(     #   (which means all other token are single-line\))
change[change(@@)plain( -376,8 +344,48 )change(@@)]
comment( )
comment(   end)
comment( )
delete[delete(-)plain(  )]
delete[delete(-)plain(  # Token name abbreviations)]
delete[delete(-)plain(  require 'coderay/token_classes')]
insert[insert(+)plain(end)]
comment( )
insert[insert(+)plain(if $0 == __FILE__)]
insert[insert(+)plain(  $VERBOSE = true)]
insert[insert(+)plain(  $: << File.join(File.dirname(__FILE__\), '..'\))]
insert[insert(+)plain(  eval DATA.read, nil, $0, __LINE__ + 4)]
comment( end)
insert[insert(+)]
insert[insert(+)plain(__END__)]
insert[insert(+)plain(require 'test/unit')]
insert[insert(+)]
insert[insert(+)plain(class TokensTest < Test::Unit::TestCase)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_creation)]
insert[insert(+)plain(    assert CodeRay::Tokens < Array)]
insert[insert(+)plain(    tokens = nil)]
insert[insert(+)plain(    assert_nothing_raised do)]
insert[insert(+)plain(      tokens = CodeRay::Tokens.new)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    assert_kind_of Array, tokens)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_adding_tokens)]
insert[insert(+)plain(    tokens = CodeRay::Tokens.new)]
insert[insert(+)plain(    assert_nothing_raised do)]
insert[insert(+)plain(      tokens << ['string', :type])]
insert[insert(+)plain(      tokens << ['(\)', :operator])]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    assert_equal tokens.size, 2)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  def test_dump_undump)]
insert[insert(+)plain(    tokens = CodeRay::Tokens.new)]
insert[insert(+)plain(    assert_nothing_raised do)]
insert[insert(+)plain(      tokens << ['string', :type])]
insert[insert(+)plain(      tokens << ['(\)', :operator])]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    tokens2 = nil)]
insert[insert(+)plain(    assert_nothing_raised do)]
insert[insert(+)plain(      tokens2 = tokens.dump.undump)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    assert_equal tokens, tokens2)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
change[change(\\ )plain(No newline at end of file)]
head[head(Index: )plain(lib/coderay/duo.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/duo.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/duo.rb	(revision 500\))]
change[change(@@)plain( -2,8 +2,6 )change(@@)]
comment(   )
comment(   # = Duo)
comment(   #)
delete[delete(-)plain(  # $Id: scanner.rb 123 2006-03-21 14:46:34Z murphy $)]
delete[delete(-)plain(  #)]
comment(   # A Duo is a convenient way to use CodeRay. You just create a Duo,)
comment(   # giving it a lang (language of the input code\) and a format (desired)
comment(   # output format\), and call Duo#highlight with the code.)
head[head(Index: )plain(lib/coderay/scanner.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanner.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanner.rb	(revision 500\))]
change[change(@@)plain( -4,8 +4,6 )change(@@)]
comment( )
comment(   # = Scanners)
comment(   #)
delete[delete(-)plain(  # $Id$)]
delete[delete(-)plain(  #)]
comment(   # This module holds the Scanner class and its subclasses.)
comment(   # For example, the Ruby scanner is named CodeRay::Scanners::Ruby)
comment(   # can be found in coderay/scanners/ruby.)
change[change(@@)plain( -45,6 +43,7 )change(@@)]
comment(     # You can also use +map+, +any?+, +find+ and even +sort_by+,)
comment(     # if you want.)
comment(     class Scanner < StringScanner)
insert[insert(+)plain(      )]
comment(       extend Plugin)
comment(       plugin_host Scanners)
comment( )
change[change(@@)plain( -57,6 +56,8 )change(@@)]
comment(       #)
comment(       # Define @default_options for subclasses.)
comment(       DEFAULT_OPTIONS = { :stream => false })
insert[insert(+)plain(      )]
insert[insert(+)plain(      KINDS_NOT_LOC = [:comment, :doctype])]
comment( )
comment(       class << self)
comment( )
change[change(@@)plain( -67,7 +68,14 )change(@@)]
comment( )
comment(         def normify code)
comment(           code = code.to_s)
delete[delete(-)plain(          code.force_encoding 'binary' if code.respond_to? :force_encoding)]
insert[insert(+)plain(          if code.respond_to? :force_encoding)]
insert[insert(+)plain(            begin)]
insert[insert(+)plain(              code.force_encoding 'utf-8')]
insert[insert(+)plain(              code[/\\z/]  # raises an ArgumentError when code contains a non-UTF-8 char)]
insert[insert(+)plain(            rescue ArgumentError)]
insert[insert(+)plain(              code.force_encoding 'binary')]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          end)]
comment(           code.to_unix)
comment(         end)
comment(         )
change[change(@@)plain( -77,7 +85,7 )change(@@)]
comment(           else)
comment(             @file_extension ||= plugin_id.to_s)
comment(           end)
delete[delete(-)plain(        end        )]
insert[insert(+)plain(        end)]
comment( )
comment(       end)
comment( )
change[change(@@)plain( -106,9 +114,10 )change(@@)]
comment(       #)
comment(       # Else, a Tokens object is used.)
comment(       def initialize code='', options = {}, &block)
delete[delete(-)plain(        @options = self.class::DEFAULT_OPTIONS.merge options)]
comment(         raise "I am only the basic Scanner class. I can't scan "\\)
comment(           "anything. :( Use my subclasses." if self.class == Scanner)
insert[insert(+)plain(        )]
insert[insert(+)plain(        @options = self.class::DEFAULT_OPTIONS.merge options)]
comment( )
comment(         super Scanner.normify(code\))
comment( )
change[change(@@)plain( -123,6 +132,7 )change(@@)]
comment(             "but :stream is #{@options[:stream]}" if block_given?)
comment(           @tokens ||= Tokens.new)
comment(         end)
insert[insert(+)plain(        @tokens.scanner = self)]
comment( )
comment(         setup)
comment(       end)
change[change(@@)plain( -142,6 +152,11 )change(@@)]
comment(       alias code string)
comment(       alias code= string=)
comment( )
insert[insert(+)plain(      # Returns the Plugin ID for this scanner.)]
insert[insert(+)plain(      def lang)]
insert[insert(+)plain(        self.class.plugin_id)]
insert[insert(+)plain(      end)]
insert[insert(+)]
comment(       # Scans the code and returns all tokens in a Tokens object.)
comment(       def tokenize new_string=nil, options = {})
comment(         options = @options.merge(options\))
change[change(@@)plain( -180,6 +195,24 )change(@@)]
comment(       def line)
comment(         string[0..pos].count("\\n"\) + 1)
comment(       end)
insert[insert(+)plain(      )]
insert[insert(+)plain(      def column pos = self.pos)]
insert[insert(+)plain(        return 0 if pos <= 0)]
insert[insert(+)plain(        string = string(\))]
insert[insert(+)plain(        if string.respond_to?(:bytesize\) && (defined?(@bin_string\) || string.bytesize != string.size\))]
insert[insert(+)plain(          @bin_string ||= string.dup.force_encoding(:binary\))]
insert[insert(+)plain(          string = @bin_string)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        pos - (string.rindex(?\\n, pos\) || 0\))]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      def marshal_dump)]
insert[insert(+)plain(        @options)]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      def marshal_load options)]
insert[insert(+)plain(        @options = options)]
insert[insert(+)plain(      end)]
comment( )
comment(     protected)
comment( )
change[change(@@)plain( -204,6 +237,7 )change(@@)]
comment(       def reset_instance)
comment(         @tokens.clear unless @options[:keep_tokens])
comment(         @cached_tokens = nil)
insert[insert(+)plain(        @bin_string = nil if defined? @bin_string)]
comment(       end)
comment( )
comment(       # Scanner error with additional status information)
change[change(@@)plain( -216,7 +250,7 )change(@@)]
comment( tokens:)
comment( %s)
comment( )
delete[delete(-)plain(current line: %d  pos = %d)]
insert[insert(+)plain(current line: %d  column: %d  pos: %d)]
comment( matched: %p  state: %p)
comment( bol? = %p,  eos? = %p)
comment( )
change[change(@@)plain( -231,10 +265,10 )change(@@)]
comment(           msg,)
comment(           tokens.size,)
comment(           tokens.last(10\).map { |t| t.inspect }.join("\\n"\),)
delete[delete(-)plain(          line, pos,)]
insert[insert(+)plain(          line, column, pos,)]
comment(           matched, state, bol?, eos?,)
delete[delete(-)plain(          string[pos-ambit,ambit],)]
delete[delete(-)plain(          string[pos,ambit],)]
insert[insert(+)plain(          string[pos - ambit, ambit],)]
insert[insert(+)plain(          string[pos, ambit],)]
comment(         ])
comment(       end)
comment( )
head[head(Index: )plain(lib/coderay/for_redcloth.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/for_redcloth.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/for_redcloth.rb	(revision 500\))]
change[change(@@)plain( -1,4 +1,4 )change(@@)]
delete[delete(-)plain(module CodeRay  # :nodoc:)]
insert[insert(+)plain(module CodeRay)]
comment(   )
comment(   # A little hack to enable CodeRay highlighting in RedCloth.)
comment(   # )
change[change(@@)plain( -15,10 +15,12 )change(@@)]
comment(     def self.install)
comment(       gem 'RedCloth', '>= 4.0.3' rescue nil)
comment(       require 'redcloth')
delete[delete(-)plain(      raise 'CodeRay.for_redcloth needs RedCloth 4.0.3 or later.' unless RedCloth::VERSION.to_s >= '4.0.3')]
insert[insert(+)plain(      unless RedCloth::VERSION.to_s >= '4.0.3')]
insert[insert(+)plain(        raise 'CodeRay.for_redcloth needs RedCloth version 4.0.3 or later.')]
insert[insert(+)plain(      end)]
comment(       RedCloth::TextileDoc.send :include, ForRedCloth::TextileDoc)
comment(       RedCloth::Formatters::HTML.module_eval do)
delete[delete(-)plain(        def unescape(html\))]
insert[insert(+)plain(        def unescape(html\)  # :nodoc:)]
comment(           replacements = {)
comment(             '&amp;' => '&',)
comment(             '&quot;' => '"',)
change[change(@@)plain( -27,16 +29,26 )change(@@)]
comment(           })
comment(           html.gsub(/&(?:amp|quot|[gl]t\);/\) { |entity| replacements[entity] })
comment(         end)
delete[delete(-)plain(        undef_method :code, :bc_open, :bc_close, :escape_pre)]
insert[insert(+)plain(        undef code, bc_open, bc_close, escape_pre)]
comment(         def code(opts\)  # :nodoc:)
comment(           opts[:block] = true)
insert[insert(+)plain(          if !opts[:lang] && RedCloth::VERSION.to_s >= '4.2.0')]
insert[insert(+)plain(            # simulating pre-4.2 behavior)]
insert[insert(+)plain(            if opts[:text].sub!(/\\A\\[(\\w+\)\\]/, ''\))]
insert[insert(+)plain(              if CodeRay::Scanners[$1].plugin_id == 'plaintext')]
insert[insert(+)plain(                opts[:text] = $& + opts[:text])]
insert[insert(+)plain(              else)]
insert[insert(+)plain(                opts[:lang] = $1)]
insert[insert(+)plain(              end)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          end)]
comment(           if opts[:lang] && !filter_coderay)
comment(             require 'coderay')
comment(             @in_bc ||= nil)
comment(             format = @in_bc ? :div : :span)
insert[insert(+)plain(            opts[:text] = unescape(opts[:text]\) unless @in_bc)]
comment(             highlighted_code = CodeRay.encode opts[:text], opts[:lang], format, :stream => true)
comment(             highlighted_code.sub!(/\\A<(span|div\)/\) { |m| m + pba(@in_bc || opts\) })
delete[delete(-)plain(            highlighted_code = unescape(highlighted_code\) unless @in_bc)]
comment(             highlighted_code)
comment(           else)
comment(             "<code#{pba(opts\)}>#{opts[:text]}</code>")
change[change(@@)plain( -48,10 +60,11 )change(@@)]
comment(           opts[:lang] ? '' : "<pre#{pba(opts\)}>")
comment(         end)
comment(         def bc_close(opts\)  # :nodoc:)
insert[insert(+)plain(          opts = @in_bc)]
comment(           @in_bc = nil)
comment(           opts[:lang] ? '' : "</pre>\\n")
comment(         end)
delete[delete(-)plain(        def escape_pre(text\))]
insert[insert(+)plain(        def escape_pre(text\)  # :nodoc:)]
comment(           if @in_bc ||= nil)
comment(             text)
comment(           else)
head[head(Index: )plain(lib/coderay/scanners/ruby/patterns.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/ruby/patterns.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/ruby/patterns.rb	(revision 500\))]
change[change(@@)plain( -1,3 +1,4 )change(@@)]
insert[insert(+)plain(# encoding: utf-8)]
comment( module CodeRay)
comment( module Scanners)
comment( )
change[change(@@)plain( -31,18 +32,18 )change(@@)]
comment(       add(RESERVED_WORDS, :reserved\).)
comment(       add(PREDEFINED_CONSTANTS, :pre_constant\))
comment( )
delete[delete(-)plain(    IDENT = /[a-z_][\\w_]*/i)]
insert[insert(+)plain(    IDENT = ''[/[[:alpha:]]/] == '' ? /[[:alpha:]_][[:alnum:]_]*/ : /[^\\W\\d]\\w*/)]
comment( )
comment(     METHOD_NAME = / #{IDENT} [?!]? /ox)
comment(     METHOD_NAME_OPERATOR = /)
comment(       \\*\\*?           # multiplication and power)
delete[delete(-)plain(      | [-+~]@?       # plus, minus, tilde with and without @)]
delete[delete(-)plain(      | [\\/%&|^`]     # division, modulo or format strings, &and, |or, ^xor, `system`)]
insert[insert(+)plain(      | [-+~]@?       # plus, minus, tilde with and without at sign)]
insert[insert(+)plain(      | [\\/%&|^`]     # division, modulo or format strings, and, or, xor, system)]
comment(       | \\[\\]=?        # array getter and setter)
comment(       | << | >>       # append or shift left, shift right)
comment(       | <=?>? | >=?   # comparison, rocket operator)
comment(       | ===? | =~     # simple equality, case equality, match)
delete[delete(-)plain(      | ![~=@]?       # negation with and without @, not-equal and not-match)]
insert[insert(+)plain(      | ![~=@]?       # negation with and without at sign, not-equal and not-match)]
comment(     /ox)
comment(     METHOD_NAME_EX = / #{IDENT} (?:[?!]|=(?!>\)\)? | #{METHOD_NAME_OPERATOR} /ox)
comment(     INSTANCE_VARIABLE = / @ #{IDENT} /ox)
change[change(@@)plain( -59,7 +60,7 )change(@@)]
comment(     QUOTE_TO_TYPE.default = :string)
comment( )
comment(     REGEXP_MODIFIERS = /[mixounse]*/)
delete[delete(-)plain(    REGEXP_SYMBOLS = /[|?*+?(\){}\\[\\].^$]/)]
insert[insert(+)plain(    REGEXP_SYMBOLS = /[|?*+(\){}\\[\\].^$]/)]
comment( )
comment(     DECIMAL = /\\d+(?:_\\d+\)*/)
comment(     OCTAL = /0_?[0-7]+(?:_[0-7]+\)*/)
change[change(@@)plain( -81,25 +82,30 )change(@@)]
comment(     /ox)
comment(     METHOD_NAME_OR_SYMBOL = / #{METHOD_NAME_EX} | #{SYMBOL} /ox)
comment( )
delete[delete(-)plain(    # TODO investigste \\M, \\c and \\C escape sequences)]
delete[delete(-)plain(    # (?: M-\\\\C-|C-\\\\M-|M-\\\\c|c\\\\M-|c|C-|M-\)? (?: \\\\ (?: [0-7]{3} | x[0-9A-Fa-f]{2} | . \) \))]
delete[delete(-)plain(    # assert_equal(225, ?\\M-a\))]
delete[delete(-)plain(    # assert_equal(129, ?\\M-\\C-a\))]
delete[delete(-)plain(    ESCAPE = /)]
insert[insert(+)plain(    SIMPLE_ESCAPE = /)]
comment(         [abefnrstv])
delete[delete(-)plain(      | M-\\\\C-|C-\\\\M-|M-\\\\c|c\\\\M-|c|C-|M-)]
comment(       |  [0-7]{1,3})
comment(       | x[0-9A-Fa-f]{1,2})
delete[delete(-)plain(      | .)]
insert[insert(+)plain(      | .?)]
comment(     /mx)
delete[delete(-)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    CONTROL_META_ESCAPE = /)]
insert[insert(+)plain(      (?: M-|C-|c \))]
insert[insert(+)plain(      (?: \\\\ (?: M-|C-|c \) \)*)]
insert[insert(+)plain(      (?: [^\\\\] | \\\\ #{SIMPLE_ESCAPE} \)?)]
insert[insert(+)plain(    /mox)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    ESCAPE = /)]
insert[insert(+)plain(      #{CONTROL_META_ESCAPE} | #{SIMPLE_ESCAPE})]
insert[insert(+)plain(    /mox)]
insert[insert(+)plain(    )]
comment(     CHARACTER = /)
comment(       \\?)
comment(       (?:)
comment(         [^\\s\\\\])
comment(       | \\\\ #{ESCAPE})
comment(       \))
delete[delete(-)plain(    /mx)]
insert[insert(+)plain(    /mox)]
comment( )
comment(     # NOTE: This is not completely correct, but)
comment(     # nobody needs heredoc delimiters ending with \\n.)
change[change(@@)plain( -136,14 +142,19 )change(@@)]
comment(       | #{CHARACTER})
comment(       \))
comment(     /x)
insert[insert(+)plain(    KEYWORDS_EXPECTING_VALUE = WordList.new.add(%w[)]
insert[insert(+)plain(      and end in or unless begin)]
insert[insert(+)plain(      defined? ensure redo super until)]
insert[insert(+)plain(      break do next rescue then)]
insert[insert(+)plain(      when case else for retry)]
insert[insert(+)plain(      while elsif if not return)]
insert[insert(+)plain(      yield)]
insert[insert(+)plain(    ]\))]
comment( )
comment(     RUBYDOC_OR_DATA = / #{RUBYDOC} | #{DATA} /xo)
comment( )
comment(     RDOC_DATA_START = / ^=begin (?!\\S\) | ^__END__$ /x)
comment( )
delete[delete(-)plain(    # FIXME: \\s and = are only a workaround, they are still allowed)]
delete[delete(-)plain(    # as delimiters.)]
delete[delete(-)plain(    FANCY_START_SAVE = / % ( [qQwWxsr] | (?![a-zA-Z0-9\\s=]\) \) ([^a-zA-Z0-9]\) /mx)]
comment(     FANCY_START_CORRECT = / % ( [qQwWxsr] | (?![a-zA-Z0-9]\) \) ([^a-zA-Z0-9]\) /mx)
comment( )
comment(     FancyStringType = {)
change[change(@@)plain( -166,17 +177,18 )change(@@)]
comment(         { })
comment(       ] ])
comment( )
delete[delete(-)plain(      CLOSING_PAREN.values.each { |o| o.freeze }  # debug, if I try to change it with <<)]
insert[insert(+)plain(      CLOSING_PAREN.each { |k,v| k.freeze; v.freeze }  # debug, if I try to change it with <<)]
comment(       OPENING_PAREN = CLOSING_PAREN.invert)
comment( )
delete[delete(-)plain(      STRING_PATTERN = Hash.new { |h, k|)]
insert[insert(+)plain(      STRING_PATTERN = Hash.new do |h, k|)]
comment(         delim, interpreted = *k)
delete[delete(-)plain(        delim_pattern = Regexp.escape(delim.dup\))]
insert[insert(+)plain(        delim_pattern = Regexp.escape(delim.dup\)  # dup: workaround for old Ruby)]
comment(         if closing_paren = CLOSING_PAREN[delim])
insert[insert(+)plain(          delim_pattern = delim_pattern[0..-1] if defined? JRUBY_VERSION  # JRuby fix)]
comment(           delim_pattern << Regexp.escape(closing_paren\))
comment(         end)
delete[delete(-)]
delete[delete(-)]
insert[insert(+)plain(        delim_pattern << '\\\\\\\\' unless delim == '\\\\')]
insert[insert(+)plain(        )]
comment(         special_escapes =)
comment(           case interpreted)
comment(           when :regexp_symbols)
change[change(@@)plain( -184,18 +196,18 )change(@@)]
comment(           when :words)
comment(             '| \\s')
comment(           end)
delete[delete(-)]
insert[insert(+)plain(        )]
comment(         h[k] =)
comment(           if interpreted and not delim == '#')
delete[delete(-)plain(            / (?= [#{delim_pattern}\\\\] | \\# [{$@] #{special_escapes} \) /mx)]
insert[insert(+)plain(            / (?= [#{delim_pattern}] | \\# [{$@] #{special_escapes} \) /mx)]
comment(           else)
delete[delete(-)plain(            / (?= [#{delim_pattern}\\\\] #{special_escapes} \) /mx)]
insert[insert(+)plain(            / (?= [#{delim_pattern}] #{special_escapes} \) /mx)]
comment(           end)
delete[delete(-)plain(      })]
insert[insert(+)plain(      end)]
comment( )
delete[delete(-)plain(      HEREDOC_PATTERN = Hash.new { |h, k|)]
insert[insert(+)plain(      HEREDOC_PATTERN = Hash.new do |h, k|)]
comment(         delim, interpreted, indented = *k)
delete[delete(-)plain(        delim_pattern = Regexp.escape(delim.dup\))]
insert[insert(+)plain(        delim_pattern = Regexp.escape(delim.dup\)  # dup: workaround for old Ruby)]
comment(         delim_pattern = / \\n #{ '(?>[\\ \\t]*\)' if indented } #{ Regexp.new delim_pattern } $ /x)
comment(         h[k] =)
comment(           if interpreted)
change[change(@@)plain( -203,12 +215,12 )change(@@)]
comment(           else)
comment(             / (?= #{delim_pattern}(\) | \\\\ \) /mx)
comment(           end)
delete[delete(-)plain(      })]
insert[insert(+)plain(      end)]
comment( )
comment(       def initialize kind, interpreted, delim, heredoc = false)
comment(         if heredoc)
comment(           pattern = HEREDOC_PATTERN[ [delim, interpreted, heredoc == :indented] ])
delete[delete(-)plain(          delim  = nil)]
insert[insert(+)plain(          delim = nil)]
comment(         else)
comment(           pattern = STRING_PATTERN[ [delim, interpreted] ])
comment(           if paren = CLOSING_PAREN[delim])
head[head(Index: )plain(lib/coderay/scanners/java/builtin_types.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/java/builtin_types.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/java/builtin_types.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,419 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Scanners)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  module Java::BuiltinTypes  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    List = %w[)]
insert[insert(+)plain(      AbstractAction AbstractBorder AbstractButton AbstractCellEditor AbstractCollection)]
insert[insert(+)plain(      AbstractColorChooserPanel AbstractDocument AbstractExecutorService AbstractInterruptibleChannel)]
insert[insert(+)plain(      AbstractLayoutCache AbstractList AbstractListModel AbstractMap AbstractMethodError AbstractPreferences)]
insert[insert(+)plain(      AbstractQueue AbstractQueuedSynchronizer AbstractSelectableChannel AbstractSelectionKey AbstractSelector)]
insert[insert(+)plain(      AbstractSequentialList AbstractSet AbstractSpinnerModel AbstractTableModel AbstractUndoableEdit)]
insert[insert(+)plain(      AbstractWriter AccessControlContext AccessControlException AccessController AccessException Accessible)]
insert[insert(+)plain(      AccessibleAction AccessibleAttributeSequence AccessibleBundle AccessibleComponent AccessibleContext)]
insert[insert(+)plain(      AccessibleEditableText AccessibleExtendedComponent AccessibleExtendedTable AccessibleExtendedText)]
insert[insert(+)plain(      AccessibleHyperlink AccessibleHypertext AccessibleIcon AccessibleKeyBinding AccessibleObject)]
insert[insert(+)plain(      AccessibleRelation AccessibleRelationSet AccessibleResourceBundle AccessibleRole AccessibleSelection)]
insert[insert(+)plain(      AccessibleState AccessibleStateSet AccessibleStreamable AccessibleTable AccessibleTableModelChange)]
insert[insert(+)plain(      AccessibleText AccessibleTextSequence AccessibleValue AccountException AccountExpiredException)]
insert[insert(+)plain(      AccountLockedException AccountNotFoundException Acl AclEntry AclNotFoundException Action ActionEvent)]
insert[insert(+)plain(      ActionListener ActionMap ActionMapUIResource Activatable ActivateFailedException ActivationDesc)]
insert[insert(+)plain(      ActivationException ActivationGroup ActivationGroupDesc ActivationGroupID ActivationGroup_Stub)]
insert[insert(+)plain(      ActivationID ActivationInstantiator ActivationMonitor ActivationSystem Activator ActiveEvent)]
insert[insert(+)plain(      ActivityCompletedException ActivityRequiredException Adjustable AdjustmentEvent AdjustmentListener)]
insert[insert(+)plain(      Adler32 AffineTransform AffineTransformOp AlgorithmParameterGenerator AlgorithmParameterGeneratorSpi)]
insert[insert(+)plain(      AlgorithmParameters AlgorithmParameterSpec AlgorithmParametersSpi AllPermission AlphaComposite)]
insert[insert(+)plain(      AlreadyBoundException AlreadyConnectedException AncestorEvent AncestorListener AnnotatedElement)]
insert[insert(+)plain(      Annotation AnnotationFormatError AnnotationTypeMismatchException AppConfigurationEntry Appendable Applet)]
insert[insert(+)plain(      AppletContext AppletInitializer AppletStub Arc2D Area AreaAveragingScaleFilter ArithmeticException Array)]
insert[insert(+)plain(      ArrayBlockingQueue ArrayIndexOutOfBoundsException ArrayList Arrays ArrayStoreException ArrayType)]
insert[insert(+)plain(      AssertionError AsyncBoxView AsynchronousCloseException AtomicBoolean AtomicInteger AtomicIntegerArray)]
insert[insert(+)plain(      AtomicIntegerFieldUpdater AtomicLong AtomicLongArray AtomicLongFieldUpdater AtomicMarkableReference)]
insert[insert(+)plain(      AtomicReference AtomicReferenceArray AtomicReferenceFieldUpdater AtomicStampedReference Attribute)]
insert[insert(+)plain(      AttributeChangeNotification AttributeChangeNotificationFilter AttributedCharacterIterator)]
insert[insert(+)plain(      AttributedString AttributeException AttributeInUseException AttributeList AttributeModificationException)]
insert[insert(+)plain(      AttributeNotFoundException Attributes AttributeSet AttributeSetUtilities AttributeValueExp AudioClip)]
insert[insert(+)plain(      AudioFileFormat AudioFileReader AudioFileWriter AudioFormat AudioInputStream AudioPermission AudioSystem)]
insert[insert(+)plain(      AuthenticationException AuthenticationNotSupportedException Authenticator AuthorizeCallback)]
insert[insert(+)plain(      AuthPermission AuthProvider Autoscroll AWTError AWTEvent AWTEventListener AWTEventListenerProxy)]
insert[insert(+)plain(      AWTEventMulticaster AWTException AWTKeyStroke AWTPermission BackingStoreException)]
insert[insert(+)plain(      BadAttributeValueExpException BadBinaryOpValueExpException BadLocationException BadPaddingException)]
insert[insert(+)plain(      BadStringOperationException BandCombineOp BandedSampleModel BaseRowSet BasicArrowButton BasicAttribute)]
insert[insert(+)plain(      BasicAttributes BasicBorders BasicButtonListener BasicButtonUI BasicCheckBoxMenuItemUI BasicCheckBoxUI)]
insert[insert(+)plain(      BasicColorChooserUI BasicComboBoxEditor BasicComboBoxRenderer BasicComboBoxUI BasicComboPopup)]
insert[insert(+)plain(      BasicControl BasicDesktopIconUI BasicDesktopPaneUI BasicDirectoryModel BasicEditorPaneUI)]
insert[insert(+)plain(      BasicFileChooserUI BasicFormattedTextFieldUI BasicGraphicsUtils BasicHTML BasicIconFactory)]
insert[insert(+)plain(      BasicInternalFrameTitlePane BasicInternalFrameUI BasicLabelUI BasicListUI BasicLookAndFeel)]
insert[insert(+)plain(      BasicMenuBarUI BasicMenuItemUI BasicMenuUI BasicOptionPaneUI BasicPanelUI BasicPasswordFieldUI)]
insert[insert(+)plain(      BasicPermission BasicPopupMenuSeparatorUI BasicPopupMenuUI BasicProgressBarUI BasicRadioButtonMenuItemUI)]
insert[insert(+)plain(      BasicRadioButtonUI BasicRootPaneUI BasicScrollBarUI BasicScrollPaneUI BasicSeparatorUI BasicSliderUI)]
insert[insert(+)plain(      BasicSpinnerUI BasicSplitPaneDivider BasicSplitPaneUI BasicStroke BasicTabbedPaneUI BasicTableHeaderUI)]
insert[insert(+)plain(      BasicTableUI BasicTextAreaUI BasicTextFieldUI BasicTextPaneUI BasicTextUI BasicToggleButtonUI)]
insert[insert(+)plain(      BasicToolBarSeparatorUI BasicToolBarUI BasicToolTipUI BasicTreeUI BasicViewportUI BatchUpdateException)]
insert[insert(+)plain(      BeanContext BeanContextChild BeanContextChildComponentProxy BeanContextChildSupport)]
insert[insert(+)plain(      BeanContextContainerProxy BeanContextEvent BeanContextMembershipEvent BeanContextMembershipListener)]
insert[insert(+)plain(      BeanContextProxy BeanContextServiceAvailableEvent BeanContextServiceProvider)]
insert[insert(+)plain(      BeanContextServiceProviderBeanInfo BeanContextServiceRevokedEvent BeanContextServiceRevokedListener)]
insert[insert(+)plain(      BeanContextServices BeanContextServicesListener BeanContextServicesSupport BeanContextSupport)]
insert[insert(+)plain(      BeanDescriptor BeanInfo Beans BevelBorder Bidi BigDecimal BigInteger BinaryRefAddr BindException Binding)]
insert[insert(+)plain(      BitSet Blob BlockingQueue BlockView BMPImageWriteParam Book Boolean BooleanControl Border BorderFactory)]
insert[insert(+)plain(      BorderLayout BorderUIResource BoundedRangeModel Box BoxLayout BoxView BreakIterator)]
insert[insert(+)plain(      BrokenBarrierException Buffer BufferCapabilities BufferedImage BufferedImageFilter BufferedImageOp)]
insert[insert(+)plain(      BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter BufferOverflowException)]
insert[insert(+)plain(      BufferStrategy BufferUnderflowException Button ButtonGroup ButtonModel ButtonUI Byte)]
insert[insert(+)plain(      ByteArrayInputStream ByteArrayOutputStream ByteBuffer ByteChannel ByteLookupTable ByteOrder CachedRowSet)]
insert[insert(+)plain(      CacheRequest CacheResponse Calendar Callable CallableStatement Callback CallbackHandler)]
insert[insert(+)plain(      CancelablePrintJob CancellationException CancelledKeyException CannotProceedException)]
insert[insert(+)plain(      CannotRedoException CannotUndoException Canvas CardLayout Caret CaretEvent CaretListener CellEditor)]
insert[insert(+)plain(      CellEditorListener CellRendererPane Certificate CertificateEncodingException CertificateException)]
insert[insert(+)plain(      CertificateExpiredException CertificateFactory CertificateFactorySpi CertificateNotYetValidException)]
insert[insert(+)plain(      CertificateParsingException CertPath CertPathBuilder CertPathBuilderException CertPathBuilderResult)]
insert[insert(+)plain(      CertPathBuilderSpi CertPathParameters CertPathTrustManagerParameters CertPathValidator)]
insert[insert(+)plain(      CertPathValidatorException CertPathValidatorResult CertPathValidatorSpi CertSelector CertStore)]
insert[insert(+)plain(      CertStoreException CertStoreParameters CertStoreSpi ChangedCharSetException ChangeEvent ChangeListener)]
insert[insert(+)plain(      Channel Channels Character CharacterCodingException CharacterIterator CharArrayReader CharArrayWriter)]
insert[insert(+)plain(      CharBuffer CharConversionException CharSequence Charset CharsetDecoder CharsetEncoder CharsetProvider)]
insert[insert(+)plain(      Checkbox CheckboxGroup CheckboxMenuItem CheckedInputStream CheckedOutputStream Checksum Choice)]
insert[insert(+)plain(      ChoiceCallback ChoiceFormat Chromaticity Cipher CipherInputStream CipherOutputStream CipherSpi Class)]
insert[insert(+)plain(      ClassCastException ClassCircularityError ClassDefinition ClassDesc ClassFileTransformer ClassFormatError)]
insert[insert(+)plain(      ClassLoader ClassLoaderRepository ClassLoadingMXBean ClassNotFoundException Clip Clipboard)]
insert[insert(+)plain(      ClipboardOwner Clob Cloneable CloneNotSupportedException Closeable ClosedByInterruptException)]
insert[insert(+)plain(      ClosedChannelException ClosedSelectorException CMMException CoderMalfunctionError CoderResult CodeSigner)]
insert[insert(+)plain(      CodeSource CodingErrorAction CollationElementIterator CollationKey Collator Collection)]
insert[insert(+)plain(      CollectionCertStoreParameters Collections Color ColorChooserComponentFactory ColorChooserUI)]
insert[insert(+)plain(      ColorConvertOp ColorModel ColorSelectionModel ColorSpace ColorSupported ColorType ColorUIResource)]
insert[insert(+)plain(      ComboBoxEditor ComboBoxModel ComboBoxUI ComboPopup CommunicationException Comparable Comparator)]
insert[insert(+)plain(      CompilationMXBean Compiler CompletionService Component ComponentAdapter ComponentColorModel)]
insert[insert(+)plain(      ComponentEvent ComponentInputMap ComponentInputMapUIResource ComponentListener ComponentOrientation)]
insert[insert(+)plain(      ComponentSampleModel ComponentUI ComponentView Composite CompositeContext CompositeData)]
insert[insert(+)plain(      CompositeDataSupport CompositeName CompositeType CompositeView CompoundBorder CompoundControl)]
insert[insert(+)plain(      CompoundEdit CompoundName Compression ConcurrentHashMap ConcurrentLinkedQueue ConcurrentMap)]
insert[insert(+)plain(      ConcurrentModificationException Condition Configuration ConfigurationException ConfirmationCallback)]
insert[insert(+)plain(      ConnectException ConnectIOException Connection ConnectionEvent ConnectionEventListener)]
insert[insert(+)plain(      ConnectionPendingException ConnectionPoolDataSource ConsoleHandler Constructor Container)]
insert[insert(+)plain(      ContainerAdapter ContainerEvent ContainerListener ContainerOrderFocusTraversalPolicy ContentHandler)]
insert[insert(+)plain(      ContentHandlerFactory ContentModel Context ContextNotEmptyException ContextualRenderedImageFactory)]
insert[insert(+)plain(      Control ControlFactory ControllerEventListener ConvolveOp CookieHandler Copies CopiesSupported)]
insert[insert(+)plain(      CopyOnWriteArrayList CopyOnWriteArraySet CountDownLatch CounterMonitor CounterMonitorMBean CRC32)]
insert[insert(+)plain(      CredentialException CredentialExpiredException CredentialNotFoundException CRL CRLException CRLSelector)]
insert[insert(+)plain(      CropImageFilter CSS CubicCurve2D Currency Cursor Customizer CyclicBarrier DatabaseMetaData DataBuffer)]
insert[insert(+)plain(      DataBufferByte DataBufferDouble DataBufferFloat DataBufferInt DataBufferShort DataBufferUShort)]
insert[insert(+)plain(      DataFlavor DataFormatException DatagramChannel DatagramPacket DatagramSocket DatagramSocketImpl)]
insert[insert(+)plain(      DatagramSocketImplFactory DataInput DataInputStream DataLine DataOutput DataOutputStream DataSource)]
insert[insert(+)plain(      DataTruncation DatatypeConfigurationException DatatypeConstants DatatypeFactory Date DateFormat)]
insert[insert(+)plain(      DateFormatSymbols DateFormatter DateTimeAtCompleted DateTimeAtCreation DateTimeAtProcessing)]
insert[insert(+)plain(      DateTimeSyntax DebugGraphics DecimalFormat DecimalFormatSymbols DefaultBoundedRangeModel)]
insert[insert(+)plain(      DefaultButtonModel DefaultCaret DefaultCellEditor DefaultColorSelectionModel DefaultComboBoxModel)]
insert[insert(+)plain(      DefaultDesktopManager DefaultEditorKit DefaultFocusManager DefaultFocusTraversalPolicy DefaultFormatter)]
insert[insert(+)plain(      DefaultFormatterFactory DefaultHighlighter DefaultKeyboardFocusManager DefaultListCellRenderer)]
insert[insert(+)plain(      DefaultListModel DefaultListSelectionModel DefaultLoaderRepository DefaultMenuLayout DefaultMetalTheme)]
insert[insert(+)plain(      DefaultMutableTreeNode DefaultPersistenceDelegate DefaultSingleSelectionModel DefaultStyledDocument)]
insert[insert(+)plain(      DefaultTableCellRenderer DefaultTableColumnModel DefaultTableModel DefaultTextUI DefaultTreeCellEditor)]
insert[insert(+)plain(      DefaultTreeCellRenderer DefaultTreeModel DefaultTreeSelectionModel Deflater DeflaterOutputStream Delayed)]
insert[insert(+)plain(      DelayQueue DelegationPermission Deprecated Descriptor DescriptorAccess DescriptorSupport DESedeKeySpec)]
insert[insert(+)plain(      DesignMode DESKeySpec DesktopIconUI DesktopManager DesktopPaneUI Destination Destroyable)]
insert[insert(+)plain(      DestroyFailedException DGC DHGenParameterSpec DHKey DHParameterSpec DHPrivateKey DHPrivateKeySpec)]
insert[insert(+)plain(      DHPublicKey DHPublicKeySpec Dialog Dictionary DigestException DigestInputStream DigestOutputStream)]
insert[insert(+)plain(      Dimension Dimension2D DimensionUIResource DirContext DirectColorModel DirectoryManager DirObjectFactory)]
insert[insert(+)plain(      DirStateFactory DisplayMode DnDConstants Doc DocAttribute DocAttributeSet DocFlavor DocPrintJob Document)]
insert[insert(+)plain(      DocumentBuilder DocumentBuilderFactory Documented DocumentEvent DocumentFilter DocumentListener)]
insert[insert(+)plain(      DocumentName DocumentParser DomainCombiner DOMLocator DOMResult DOMSource Double DoubleBuffer)]
insert[insert(+)plain(      DragGestureEvent DragGestureListener DragGestureRecognizer DragSource DragSourceAdapter)]
insert[insert(+)plain(      DragSourceContext DragSourceDragEvent DragSourceDropEvent DragSourceEvent DragSourceListener)]
insert[insert(+)plain(      DragSourceMotionListener Driver DriverManager DriverPropertyInfo DropTarget DropTargetAdapter)]
insert[insert(+)plain(      DropTargetContext DropTargetDragEvent DropTargetDropEvent DropTargetEvent DropTargetListener DSAKey)]
insert[insert(+)plain(      DSAKeyPairGenerator DSAParameterSpec DSAParams DSAPrivateKey DSAPrivateKeySpec DSAPublicKey)]
insert[insert(+)plain(      DSAPublicKeySpec DTD DTDConstants DuplicateFormatFlagsException Duration DynamicMBean ECField ECFieldF2m)]
insert[insert(+)plain(      ECFieldFp ECGenParameterSpec ECKey ECParameterSpec ECPoint ECPrivateKey ECPrivateKeySpec ECPublicKey)]
insert[insert(+)plain(      ECPublicKeySpec EditorKit Element ElementIterator ElementType Ellipse2D EllipticCurve EmptyBorder)]
insert[insert(+)plain(      EmptyStackException EncodedKeySpec Encoder EncryptedPrivateKeyInfo Entity Enum)]
insert[insert(+)plain(      EnumConstantNotPresentException EnumControl Enumeration EnumMap EnumSet EnumSyntax EOFException Error)]
insert[insert(+)plain(      ErrorListener ErrorManager EtchedBorder Event EventContext EventDirContext EventHandler EventListener)]
insert[insert(+)plain(      EventListenerList EventListenerProxy EventObject EventQueue EventSetDescriptor Exception)]
insert[insert(+)plain(      ExceptionInInitializerError ExceptionListener Exchanger ExecutionException Executor)]
insert[insert(+)plain(      ExecutorCompletionService Executors ExecutorService ExemptionMechanism ExemptionMechanismException)]
insert[insert(+)plain(      ExemptionMechanismSpi ExpandVetoException ExportException Expression ExtendedRequest ExtendedResponse)]
insert[insert(+)plain(      Externalizable FactoryConfigurationError FailedLoginException FeatureDescriptor Fidelity Field)]
insert[insert(+)plain(      FieldPosition FieldView File FileCacheImageInputStream FileCacheImageOutputStream FileChannel)]
insert[insert(+)plain(      FileChooserUI FileDescriptor FileDialog FileFilter FileHandler FileImageInputStream)]
insert[insert(+)plain(      FileImageOutputStream FileInputStream FileLock FileLockInterruptionException FilenameFilter FileNameMap)]
insert[insert(+)plain(      FileNotFoundException FileOutputStream FilePermission FileReader FileSystemView FileView FileWriter)]
insert[insert(+)plain(      Filter FilteredImageSource FilteredRowSet FilterInputStream FilterOutputStream FilterReader FilterWriter)]
insert[insert(+)plain(      Finishings FixedHeightLayoutCache FlatteningPathIterator FlavorEvent FlavorException FlavorListener)]
insert[insert(+)plain(      FlavorMap FlavorTable Float FloatBuffer FloatControl FlowLayout FlowView Flushable FocusAdapter)]
insert[insert(+)plain(      FocusEvent FocusListener FocusManager FocusTraversalPolicy Font FontFormatException FontMetrics)]
insert[insert(+)plain(      FontRenderContext FontUIResource Format FormatConversionProvider FormatFlagsConversionMismatchException)]
insert[insert(+)plain(      Formattable FormattableFlags Formatter FormatterClosedException FormSubmitEvent FormView Frame Future)]
insert[insert(+)plain(      FutureTask GapContent GarbageCollectorMXBean GatheringByteChannel GaugeMonitor GaugeMonitorMBean)]
insert[insert(+)plain(      GeneralPath GeneralSecurityException GenericArrayType GenericDeclaration GenericSignatureFormatError)]
insert[insert(+)plain(      GlyphJustificationInfo GlyphMetrics GlyphVector GlyphView GradientPaint GraphicAttribute Graphics)]
insert[insert(+)plain(      Graphics2D GraphicsConfigTemplate GraphicsConfiguration GraphicsDevice GraphicsEnvironment GrayFilter)]
insert[insert(+)plain(      GregorianCalendar GridBagConstraints GridBagLayout GridLayout Group Guard GuardedObject GZIPInputStream)]
insert[insert(+)plain(      GZIPOutputStream Handler HandshakeCompletedEvent HandshakeCompletedListener HasControls HashAttributeSet)]
insert[insert(+)plain(      HashDocAttributeSet HashMap HashPrintJobAttributeSet HashPrintRequestAttributeSet)]
insert[insert(+)plain(      HashPrintServiceAttributeSet HashSet Hashtable HeadlessException HierarchyBoundsAdapter)]
insert[insert(+)plain(      HierarchyBoundsListener HierarchyEvent HierarchyListener Highlighter HostnameVerifier HTML HTMLDocument)]
insert[insert(+)plain(      HTMLEditorKit HTMLFrameHyperlinkEvent HTMLWriter HttpRetryException HttpsURLConnection HttpURLConnection)]
insert[insert(+)plain(      HyperlinkEvent HyperlinkListener ICC_ColorSpace ICC_Profile ICC_ProfileGray ICC_ProfileRGB Icon)]
insert[insert(+)plain(      IconUIResource IconView Identity IdentityHashMap IdentityScope IIOByteBuffer IIOException IIOImage)]
insert[insert(+)plain(      IIOInvalidTreeException IIOMetadata IIOMetadataController IIOMetadataFormat IIOMetadataFormatImpl)]
insert[insert(+)plain(      IIOMetadataNode IIOParam IIOParamController IIOReadProgressListener IIOReadUpdateListener)]
insert[insert(+)plain(      IIOReadWarningListener IIORegistry IIOServiceProvider IIOWriteProgressListener IIOWriteWarningListener)]
insert[insert(+)plain(      IllegalAccessError IllegalAccessException IllegalArgumentException IllegalBlockingModeException)]
insert[insert(+)plain(      IllegalBlockSizeException IllegalCharsetNameException IllegalClassFormatException)]
insert[insert(+)plain(      IllegalComponentStateException IllegalFormatCodePointException IllegalFormatConversionException)]
insert[insert(+)plain(      IllegalFormatException IllegalFormatFlagsException IllegalFormatPrecisionException)]
insert[insert(+)plain(      IllegalFormatWidthException IllegalMonitorStateException IllegalPathStateException)]
insert[insert(+)plain(      IllegalSelectorException IllegalStateException IllegalThreadStateException Image ImageCapabilities)]
insert[insert(+)plain(      ImageConsumer ImageFilter ImageGraphicAttribute ImageIcon ImageInputStream ImageInputStreamImpl)]
insert[insert(+)plain(      ImageInputStreamSpi ImageIO ImageObserver ImageOutputStream ImageOutputStreamImpl ImageOutputStreamSpi)]
insert[insert(+)plain(      ImageProducer ImageReader ImageReaderSpi ImageReaderWriterSpi ImageReadParam ImageTranscoder)]
insert[insert(+)plain(      ImageTranscoderSpi ImageTypeSpecifier ImageView ImageWriteParam ImageWriter ImageWriterSpi)]
insert[insert(+)plain(      ImagingOpException IncompatibleClassChangeError IncompleteAnnotationException IndexColorModel)]
insert[insert(+)plain(      IndexedPropertyChangeEvent IndexedPropertyDescriptor IndexOutOfBoundsException Inet4Address Inet6Address)]
insert[insert(+)plain(      InetAddress InetSocketAddress Inflater InflaterInputStream InheritableThreadLocal Inherited)]
insert[insert(+)plain(      InitialContext InitialContextFactory InitialContextFactoryBuilder InitialDirContext InitialLdapContext)]
insert[insert(+)plain(      InlineView InputContext InputEvent InputMap InputMapUIResource InputMethod InputMethodContext)]
insert[insert(+)plain(      InputMethodDescriptor InputMethodEvent InputMethodHighlight InputMethodListener InputMethodRequests)]
insert[insert(+)plain(      InputMismatchException InputStream InputStreamReader InputSubset InputVerifier Insets InsetsUIResource)]
insert[insert(+)plain(      InstanceAlreadyExistsException InstanceNotFoundException InstantiationError InstantiationException)]
insert[insert(+)plain(      Instrument Instrumentation InsufficientResourcesException IntBuffer Integer IntegerSyntax InternalError)]
insert[insert(+)plain(      InternalFrameAdapter InternalFrameEvent InternalFrameFocusTraversalPolicy InternalFrameListener)]
insert[insert(+)plain(      InternalFrameUI InternationalFormatter InterruptedException InterruptedIOException)]
insert[insert(+)plain(      InterruptedNamingException InterruptibleChannel IntrospectionException Introspector)]
insert[insert(+)plain(      InvalidActivityException InvalidAlgorithmParameterException InvalidApplicationException)]
insert[insert(+)plain(      InvalidAttributeIdentifierException InvalidAttributesException InvalidAttributeValueException)]
insert[insert(+)plain(      InvalidClassException InvalidDnDOperationException InvalidKeyException InvalidKeySpecException)]
insert[insert(+)plain(      InvalidMarkException InvalidMidiDataException InvalidNameException InvalidObjectException)]
insert[insert(+)plain(      InvalidOpenTypeException InvalidParameterException InvalidParameterSpecException)]
insert[insert(+)plain(      InvalidPreferencesFormatException InvalidPropertiesFormatException InvalidRelationIdException)]
insert[insert(+)plain(      InvalidRelationServiceException InvalidRelationTypeException InvalidRoleInfoException)]
insert[insert(+)plain(      InvalidRoleValueException InvalidSearchControlsException InvalidSearchFilterException)]
insert[insert(+)plain(      InvalidTargetObjectTypeException InvalidTransactionException InvocationEvent InvocationHandler)]
insert[insert(+)plain(      InvocationTargetException IOException ItemEvent ItemListener ItemSelectable Iterable Iterator)]
insert[insert(+)plain(      IvParameterSpec JApplet JarEntry JarException JarFile JarInputStream JarOutputStream JarURLConnection)]
insert[insert(+)plain(      JButton JCheckBox JCheckBoxMenuItem JColorChooser JComboBox JComponent JdbcRowSet JDesktopPane JDialog)]
insert[insert(+)plain(      JEditorPane JFileChooser JFormattedTextField JFrame JInternalFrame JLabel JLayeredPane JList JMenu)]
insert[insert(+)plain(      JMenuBar JMenuItem JMException JMRuntimeException JMXAuthenticator JMXConnectionNotification)]
insert[insert(+)plain(      JMXConnector JMXConnectorFactory JMXConnectorProvider JMXConnectorServer JMXConnectorServerFactory)]
insert[insert(+)plain(      JMXConnectorServerMBean JMXConnectorServerProvider JMXPrincipal JMXProviderException)]
insert[insert(+)plain(      JMXServerErrorException JMXServiceURL JobAttributes JobHoldUntil JobImpressions JobImpressionsCompleted)]
insert[insert(+)plain(      JobImpressionsSupported JobKOctets JobKOctetsProcessed JobKOctetsSupported JobMediaSheets)]
insert[insert(+)plain(      JobMediaSheetsCompleted JobMediaSheetsSupported JobMessageFromOperator JobName JobOriginatingUserName)]
insert[insert(+)plain(      JobPriority JobPrioritySupported JobSheets JobState JobStateReason JobStateReasons Joinable JoinRowSet)]
insert[insert(+)plain(      JOptionPane JPanel JPasswordField JPEGHuffmanTable JPEGImageReadParam JPEGImageWriteParam JPEGQTable)]
insert[insert(+)plain(      JPopupMenu JProgressBar JRadioButton JRadioButtonMenuItem JRootPane JScrollBar JScrollPane JSeparator)]
insert[insert(+)plain(      JSlider JSpinner JSplitPane JTabbedPane JTable JTableHeader JTextArea JTextComponent JTextField)]
insert[insert(+)plain(      JTextPane JToggleButton JToolBar JToolTip JTree JViewport JWindow KerberosKey KerberosPrincipal)]
insert[insert(+)plain(      KerberosTicket Kernel Key KeyAdapter KeyAgreement KeyAgreementSpi KeyAlreadyExistsException)]
insert[insert(+)plain(      KeyboardFocusManager KeyEvent KeyEventDispatcher KeyEventPostProcessor KeyException KeyFactory)]
insert[insert(+)plain(      KeyFactorySpi KeyGenerator KeyGeneratorSpi KeyListener KeyManagementException KeyManager)]
insert[insert(+)plain(      KeyManagerFactory KeyManagerFactorySpi Keymap KeyPair KeyPairGenerator KeyPairGeneratorSpi KeyRep)]
insert[insert(+)plain(      KeySpec KeyStore KeyStoreBuilderParameters KeyStoreException KeyStoreSpi KeyStroke Label LabelUI)]
insert[insert(+)plain(      LabelView LanguageCallback LastOwnerException LayeredHighlighter LayoutFocusTraversalPolicy)]
insert[insert(+)plain(      LayoutManager LayoutManager2 LayoutQueue LDAPCertStoreParameters LdapContext LdapName)]
insert[insert(+)plain(      LdapReferralException Lease Level LimitExceededException Line Line2D LineBorder LineBreakMeasurer)]
insert[insert(+)plain(      LineEvent LineListener LineMetrics LineNumberInputStream LineNumberReader LineUnavailableException)]
insert[insert(+)plain(      LinkageError LinkedBlockingQueue LinkedHashMap LinkedHashSet LinkedList LinkException LinkLoopException)]
insert[insert(+)plain(      LinkRef List ListCellRenderer ListDataEvent ListDataListener ListenerNotFoundException ListIterator)]
insert[insert(+)plain(      ListModel ListResourceBundle ListSelectionEvent ListSelectionListener ListSelectionModel ListUI ListView)]
insert[insert(+)plain(      LoaderHandler Locale LocateRegistry Lock LockSupport Logger LoggingMXBean LoggingPermission LoginContext)]
insert[insert(+)plain(      LoginException LoginModule LogManager LogRecord LogStream Long LongBuffer LookAndFeel LookupOp)]
insert[insert(+)plain(      LookupTable Mac MacSpi MalformedInputException MalformedLinkException MalformedObjectNameException)]
insert[insert(+)plain(      MalformedParameterizedTypeException MalformedURLException ManagementFactory ManagementPermission)]
insert[insert(+)plain(      ManageReferralControl ManagerFactoryParameters Manifest Map MappedByteBuffer MarshalException)]
insert[insert(+)plain(      MarshalledObject MaskFormatter Matcher MatchResult Math MathContext MatteBorder MBeanAttributeInfo)]
insert[insert(+)plain(      MBeanConstructorInfo MBeanException MBeanFeatureInfo MBeanInfo MBeanNotificationInfo MBeanOperationInfo)]
insert[insert(+)plain(      MBeanParameterInfo MBeanPermission MBeanRegistration MBeanRegistrationException MBeanServer)]
insert[insert(+)plain(      MBeanServerBuilder MBeanServerConnection MBeanServerDelegate MBeanServerDelegateMBean MBeanServerFactory)]
insert[insert(+)plain(      MBeanServerForwarder MBeanServerInvocationHandler MBeanServerNotification MBeanServerNotificationFilter)]
insert[insert(+)plain(      MBeanServerPermission MBeanTrustPermission Media MediaName MediaPrintableArea MediaSize MediaSizeName)]
insert[insert(+)plain(      MediaTracker MediaTray Member MemoryCacheImageInputStream MemoryCacheImageOutputStream MemoryHandler)]
insert[insert(+)plain(      MemoryImageSource MemoryManagerMXBean MemoryMXBean MemoryNotificationInfo MemoryPoolMXBean MemoryType)]
insert[insert(+)plain(      MemoryUsage Menu MenuBar MenuBarUI MenuComponent MenuContainer MenuDragMouseEvent MenuDragMouseListener)]
insert[insert(+)plain(      MenuElement MenuEvent MenuItem MenuItemUI MenuKeyEvent MenuKeyListener MenuListener MenuSelectionManager)]
insert[insert(+)plain(      MenuShortcut MessageDigest MessageDigestSpi MessageFormat MetaEventListener MetalBorders MetalButtonUI)]
insert[insert(+)plain(      MetalCheckBoxIcon MetalCheckBoxUI MetalComboBoxButton MetalComboBoxEditor MetalComboBoxIcon)]
insert[insert(+)plain(      MetalComboBoxUI MetalDesktopIconUI MetalFileChooserUI MetalIconFactory MetalInternalFrameTitlePane)]
insert[insert(+)plain(      MetalInternalFrameUI MetalLabelUI MetalLookAndFeel MetalMenuBarUI MetalPopupMenuSeparatorUI)]
insert[insert(+)plain(      MetalProgressBarUI MetalRadioButtonUI MetalRootPaneUI MetalScrollBarUI MetalScrollButton)]
insert[insert(+)plain(      MetalScrollPaneUI MetalSeparatorUI MetalSliderUI MetalSplitPaneUI MetalTabbedPaneUI MetalTextFieldUI)]
insert[insert(+)plain(      MetalTheme MetalToggleButtonUI MetalToolBarUI MetalToolTipUI MetalTreeUI MetaMessage Method)]
insert[insert(+)plain(      MethodDescriptor MGF1ParameterSpec MidiChannel MidiDevice MidiDeviceProvider MidiEvent MidiFileFormat)]
insert[insert(+)plain(      MidiFileReader MidiFileWriter MidiMessage MidiSystem MidiUnavailableException MimeTypeParseException)]
insert[insert(+)plain(      MinimalHTMLWriter MissingFormatArgumentException MissingFormatWidthException MissingResourceException)]
insert[insert(+)plain(      Mixer MixerProvider MLet MLetMBean ModelMBean ModelMBeanAttributeInfo ModelMBeanConstructorInfo)]
insert[insert(+)plain(      ModelMBeanInfo ModelMBeanInfoSupport ModelMBeanNotificationBroadcaster ModelMBeanNotificationInfo)]
insert[insert(+)plain(      ModelMBeanOperationInfo ModificationItem Modifier Monitor MonitorMBean MonitorNotification)]
insert[insert(+)plain(      MonitorSettingException MouseAdapter MouseDragGestureRecognizer MouseEvent MouseInfo MouseInputAdapter)]
insert[insert(+)plain(      MouseInputListener MouseListener MouseMotionAdapter MouseMotionListener MouseWheelEvent)]
insert[insert(+)plain(      MouseWheelListener MultiButtonUI MulticastSocket MultiColorChooserUI MultiComboBoxUI MultiDesktopIconUI)]
insert[insert(+)plain(      MultiDesktopPaneUI MultiDoc MultiDocPrintJob MultiDocPrintService MultiFileChooserUI)]
insert[insert(+)plain(      MultiInternalFrameUI MultiLabelUI MultiListUI MultiLookAndFeel MultiMenuBarUI MultiMenuItemUI)]
insert[insert(+)plain(      MultiOptionPaneUI MultiPanelUI MultiPixelPackedSampleModel MultipleDocumentHandling MultipleMaster)]
insert[insert(+)plain(      MultiPopupMenuUI MultiProgressBarUI MultiRootPaneUI MultiScrollBarUI MultiScrollPaneUI MultiSeparatorUI)]
insert[insert(+)plain(      MultiSliderUI MultiSpinnerUI MultiSplitPaneUI MultiTabbedPaneUI MultiTableHeaderUI MultiTableUI)]
insert[insert(+)plain(      MultiTextUI MultiToolBarUI MultiToolTipUI MultiTreeUI MultiViewportUI MutableAttributeSet)]
insert[insert(+)plain(      MutableComboBoxModel MutableTreeNode Name NameAlreadyBoundException NameCallback NameClassPair)]
insert[insert(+)plain(      NameNotFoundException NameParser NamespaceChangeListener NamespaceContext Naming NamingEnumeration)]
insert[insert(+)plain(      NamingEvent NamingException NamingExceptionEvent NamingListener NamingManager NamingSecurityException)]
insert[insert(+)plain(      NavigationFilter NegativeArraySizeException NetPermission NetworkInterface NoClassDefFoundError)]
insert[insert(+)plain(      NoConnectionPendingException NodeChangeEvent NodeChangeListener NoInitialContextException)]
insert[insert(+)plain(      NoninvertibleTransformException NonReadableChannelException NonWritableChannelException)]
insert[insert(+)plain(      NoPermissionException NoRouteToHostException NoSuchAlgorithmException NoSuchAttributeException)]
insert[insert(+)plain(      NoSuchElementException NoSuchFieldError NoSuchFieldException NoSuchMethodError NoSuchMethodException)]
insert[insert(+)plain(      NoSuchObjectException NoSuchPaddingException NoSuchProviderException NotActiveException)]
insert[insert(+)plain(      NotBoundException NotCompliantMBeanException NotContextException Notification NotificationBroadcaster)]
insert[insert(+)plain(      NotificationBroadcasterSupport NotificationEmitter NotificationFilter NotificationFilterSupport)]
insert[insert(+)plain(      NotificationListener NotificationResult NotOwnerException NotSerializableException NotYetBoundException)]
insert[insert(+)plain(      NotYetConnectedException NullCipher NullPointerException Number NumberFormat NumberFormatException)]
insert[insert(+)plain(      NumberFormatter NumberOfDocuments NumberOfInterveningJobs NumberUp NumberUpSupported NumericShaper)]
insert[insert(+)plain(      OAEPParameterSpec Object ObjectChangeListener ObjectFactory ObjectFactoryBuilder ObjectInput)]
insert[insert(+)plain(      ObjectInputStream ObjectInputValidation ObjectInstance ObjectName ObjectOutput ObjectOutputStream)]
insert[insert(+)plain(      ObjectStreamClass ObjectStreamConstants ObjectStreamException ObjectStreamField ObjectView ObjID)]
insert[insert(+)plain(      Observable Observer OceanTheme OpenDataException OpenMBeanAttributeInfo OpenMBeanAttributeInfoSupport)]
insert[insert(+)plain(      OpenMBeanConstructorInfo OpenMBeanConstructorInfoSupport OpenMBeanInfo OpenMBeanInfoSupport)]
insert[insert(+)plain(      OpenMBeanOperationInfo OpenMBeanOperationInfoSupport OpenMBeanParameterInfo)]
insert[insert(+)plain(      OpenMBeanParameterInfoSupport OpenType OperatingSystemMXBean Operation OperationNotSupportedException)]
insert[insert(+)plain(      OperationsException Option OptionalDataException OptionPaneUI OrientationRequested OutOfMemoryError)]
insert[insert(+)plain(      OutputDeviceAssigned OutputKeys OutputStream OutputStreamWriter OverlappingFileLockException)]
insert[insert(+)plain(      OverlayLayout Override Owner Pack200 Package PackedColorModel Pageable PageAttributes)]
insert[insert(+)plain(      PagedResultsControl PagedResultsResponseControl PageFormat PageRanges PagesPerMinute PagesPerMinuteColor)]
insert[insert(+)plain(      Paint PaintContext PaintEvent Panel PanelUI Paper ParagraphView ParameterBlock ParameterDescriptor)]
insert[insert(+)plain(      ParameterizedType ParameterMetaData ParseException ParsePosition Parser ParserConfigurationException)]
insert[insert(+)plain(      ParserDelegator PartialResultException PasswordAuthentication PasswordCallback PasswordView Patch)]
insert[insert(+)plain(      PathIterator Pattern PatternSyntaxException PBEKey PBEKeySpec PBEParameterSpec PDLOverrideSupported)]
insert[insert(+)plain(      Permission PermissionCollection Permissions PersistenceDelegate PersistentMBean PhantomReference Pipe)]
insert[insert(+)plain(      PipedInputStream PipedOutputStream PipedReader PipedWriter PixelGrabber PixelInterleavedSampleModel)]
insert[insert(+)plain(      PKCS8EncodedKeySpec PKIXBuilderParameters PKIXCertPathBuilderResult PKIXCertPathChecker)]
insert[insert(+)plain(      PKIXCertPathValidatorResult PKIXParameters PlainDocument PlainView Point Point2D PointerInfo Policy)]
insert[insert(+)plain(      PolicyNode PolicyQualifierInfo Polygon PooledConnection Popup PopupFactory PopupMenu PopupMenuEvent)]
insert[insert(+)plain(      PopupMenuListener PopupMenuUI Port PortableRemoteObject PortableRemoteObjectDelegate)]
insert[insert(+)plain(      PortUnreachableException Position Predicate PreferenceChangeEvent PreferenceChangeListener Preferences)]
insert[insert(+)plain(      PreferencesFactory PreparedStatement PresentationDirection Principal Printable PrinterAbortException)]
insert[insert(+)plain(      PrinterException PrinterGraphics PrinterInfo PrinterIOException PrinterIsAcceptingJobs PrinterJob)]
insert[insert(+)plain(      PrinterLocation PrinterMakeAndModel PrinterMessageFromOperator PrinterMoreInfo)]
insert[insert(+)plain(      PrinterMoreInfoManufacturer PrinterName PrinterResolution PrinterState PrinterStateReason)]
insert[insert(+)plain(      PrinterStateReasons PrinterURI PrintEvent PrintException PrintGraphics PrintJob PrintJobAdapter)]
insert[insert(+)plain(      PrintJobAttribute PrintJobAttributeEvent PrintJobAttributeListener PrintJobAttributeSet PrintJobEvent)]
insert[insert(+)plain(      PrintJobListener PrintQuality PrintRequestAttribute PrintRequestAttributeSet PrintService)]
insert[insert(+)plain(      PrintServiceAttribute PrintServiceAttributeEvent PrintServiceAttributeListener PrintServiceAttributeSet)]
insert[insert(+)plain(      PrintServiceLookup PrintStream PrintWriter PriorityBlockingQueue PriorityQueue PrivateClassLoader)]
insert[insert(+)plain(      PrivateCredentialPermission PrivateKey PrivateMLet PrivilegedAction PrivilegedActionException)]
insert[insert(+)plain(      PrivilegedExceptionAction Process ProcessBuilder ProfileDataException ProgressBarUI ProgressMonitor)]
insert[insert(+)plain(      ProgressMonitorInputStream Properties PropertyChangeEvent PropertyChangeListener)]
insert[insert(+)plain(      PropertyChangeListenerProxy PropertyChangeSupport PropertyDescriptor PropertyEditor)]
insert[insert(+)plain(      PropertyEditorManager PropertyEditorSupport PropertyPermission PropertyResourceBundle)]
insert[insert(+)plain(      PropertyVetoException ProtectionDomain ProtocolException Provider ProviderException Proxy ProxySelector)]
insert[insert(+)plain(      PSource PSSParameterSpec PublicKey PushbackInputStream PushbackReader QName QuadCurve2D Query QueryEval)]
insert[insert(+)plain(      QueryExp Queue QueuedJobCount Random RandomAccess RandomAccessFile Raster RasterFormatException RasterOp)]
insert[insert(+)plain(      RC2ParameterSpec RC5ParameterSpec Rdn Readable ReadableByteChannel Reader ReadOnlyBufferException)]
insert[insert(+)plain(      ReadWriteLock RealmCallback RealmChoiceCallback Receiver Rectangle Rectangle2D RectangularShape)]
insert[insert(+)plain(      ReentrantLock ReentrantReadWriteLock Ref RefAddr Reference Referenceable ReferenceQueue)]
insert[insert(+)plain(      ReferenceUriSchemesSupported ReferralException ReflectionException ReflectPermission Refreshable)]
insert[insert(+)plain(      RefreshFailedException Region RegisterableService Registry RegistryHandler RejectedExecutionException)]
insert[insert(+)plain(      RejectedExecutionHandler Relation RelationException RelationNotFoundException RelationNotification)]
insert[insert(+)plain(      RelationService RelationServiceMBean RelationServiceNotRegisteredException RelationSupport)]
insert[insert(+)plain(      RelationSupportMBean RelationType RelationTypeNotFoundException RelationTypeSupport Remote RemoteCall)]
insert[insert(+)plain(      RemoteException RemoteObject RemoteObjectInvocationHandler RemoteRef RemoteServer RemoteStub)]
insert[insert(+)plain(      RenderableImage RenderableImageOp RenderableImageProducer RenderContext RenderedImage)]
insert[insert(+)plain(      RenderedImageFactory Renderer RenderingHints RepaintManager ReplicateScaleFilter RequestingUserName)]
insert[insert(+)plain(      RequiredModelMBean RescaleOp ResolutionSyntax Resolver ResolveResult ResourceBundle ResponseCache Result)]
insert[insert(+)plain(      ResultSet ResultSetMetaData Retention RetentionPolicy ReverbType RGBImageFilter RMIClassLoader)]
insert[insert(+)plain(      RMIClassLoaderSpi RMIClientSocketFactory RMIConnection RMIConnectionImpl RMIConnectionImpl_Stub)]
insert[insert(+)plain(      RMIConnector RMIConnectorServer RMIFailureHandler RMIIIOPServerImpl RMIJRMPServerImpl)]
insert[insert(+)plain(      RMISecurityException RMISecurityManager RMIServer RMIServerImpl RMIServerImpl_Stub)]
insert[insert(+)plain(      RMIServerSocketFactory RMISocketFactory Robot Role RoleInfo RoleInfoNotFoundException RoleList)]
insert[insert(+)plain(      RoleNotFoundException RoleResult RoleStatus RoleUnresolved RoleUnresolvedList RootPaneContainer)]
insert[insert(+)plain(      RootPaneUI RoundingMode RoundRectangle2D RowMapper RowSet RowSetEvent RowSetInternal RowSetListener)]
insert[insert(+)plain(      RowSetMetaData RowSetMetaDataImpl RowSetReader RowSetWarning RowSetWriter RSAKey RSAKeyGenParameterSpec)]
insert[insert(+)plain(      RSAMultiPrimePrivateCrtKey RSAMultiPrimePrivateCrtKeySpec RSAOtherPrimeInfo RSAPrivateCrtKey)]
insert[insert(+)plain(      RSAPrivateCrtKeySpec RSAPrivateKey RSAPrivateKeySpec RSAPublicKey RSAPublicKeySpec RTFEditorKit)]
insert[insert(+)plain(      RuleBasedCollator Runnable Runtime RuntimeErrorException RuntimeException RuntimeMBeanException)]
insert[insert(+)plain(      RuntimeMXBean RuntimeOperationsException RuntimePermission SampleModel Sasl SaslClient SaslClientFactory)]
insert[insert(+)plain(      SaslException SaslServer SaslServerFactory Savepoint SAXParser SAXParserFactory SAXResult SAXSource)]
insert[insert(+)plain(      SAXTransformerFactory Scanner ScatteringByteChannel ScheduledExecutorService ScheduledFuture)]
insert[insert(+)plain(      ScheduledThreadPoolExecutor Schema SchemaFactory SchemaFactoryLoader SchemaViolationException Scrollable)]
insert[insert(+)plain(      Scrollbar ScrollBarUI ScrollPane ScrollPaneAdjustable ScrollPaneConstants ScrollPaneLayout ScrollPaneUI)]
insert[insert(+)plain(      SealedObject SearchControls SearchResult SecretKey SecretKeyFactory SecretKeyFactorySpi SecretKeySpec)]
insert[insert(+)plain(      SecureCacheResponse SecureClassLoader SecureRandom SecureRandomSpi Security SecurityException)]
insert[insert(+)plain(      SecurityManager SecurityPermission Segment SelectableChannel SelectionKey Selector SelectorProvider)]
insert[insert(+)plain(      Semaphore SeparatorUI Sequence SequenceInputStream Sequencer SerialArray SerialBlob SerialClob)]
insert[insert(+)plain(      SerialDatalink SerialException Serializable SerializablePermission SerialJavaObject SerialRef)]
insert[insert(+)plain(      SerialStruct ServerCloneException ServerError ServerException ServerNotActiveException ServerRef)]
insert[insert(+)plain(      ServerRuntimeException ServerSocket ServerSocketChannel ServerSocketFactory ServiceNotFoundException)]
insert[insert(+)plain(      ServicePermission ServiceRegistry ServiceUI ServiceUIFactory ServiceUnavailableException Set)]
insert[insert(+)plain(      SetOfIntegerSyntax Severity Shape ShapeGraphicAttribute SheetCollate Short ShortBuffer)]
insert[insert(+)plain(      ShortBufferException ShortLookupTable ShortMessage Sides Signature SignatureException SignatureSpi)]
insert[insert(+)plain(      SignedObject Signer SimpleAttributeSet SimpleBeanInfo SimpleDateFormat SimpleDoc SimpleFormatter)]
insert[insert(+)plain(      SimpleTimeZone SimpleType SinglePixelPackedSampleModel SingleSelectionModel Size2DSyntax)]
insert[insert(+)plain(      SizeLimitExceededException SizeRequirements SizeSequence Skeleton SkeletonMismatchException)]
insert[insert(+)plain(      SkeletonNotFoundException SliderUI Socket SocketAddress SocketChannel SocketException SocketFactory)]
insert[insert(+)plain(      SocketHandler SocketImpl SocketImplFactory SocketOptions SocketPermission SocketSecurityException)]
insert[insert(+)plain(      SocketTimeoutException SoftBevelBorder SoftReference SortControl SortedMap SortedSet)]
insert[insert(+)plain(      SortingFocusTraversalPolicy SortKey SortResponseControl Soundbank SoundbankReader SoundbankResource)]
insert[insert(+)plain(      Source SourceDataLine SourceLocator SpinnerDateModel SpinnerListModel SpinnerModel SpinnerNumberModel)]
insert[insert(+)plain(      SpinnerUI SplitPaneUI Spring SpringLayout SQLData SQLException SQLInput SQLInputImpl SQLOutput)]
insert[insert(+)plain(      SQLOutputImpl SQLPermission SQLWarning SSLContext SSLContextSpi SSLEngine SSLEngineResult SSLException)]
insert[insert(+)plain(      SSLHandshakeException SSLKeyException SSLPeerUnverifiedException SSLPermission SSLProtocolException)]
insert[insert(+)plain(      SslRMIClientSocketFactory SslRMIServerSocketFactory SSLServerSocket SSLServerSocketFactory SSLSession)]
insert[insert(+)plain(      SSLSessionBindingEvent SSLSessionBindingListener SSLSessionContext SSLSocket SSLSocketFactory Stack)]
insert[insert(+)plain(      StackOverflowError StackTraceElement StandardMBean StartTlsRequest StartTlsResponse StateEdit)]
insert[insert(+)plain(      StateEditable StateFactory Statement StreamCorruptedException StreamHandler StreamPrintService)]
insert[insert(+)plain(      StreamPrintServiceFactory StreamResult StreamSource StreamTokenizer StrictMath String StringBuffer)]
insert[insert(+)plain(      StringBufferInputStream StringBuilder StringCharacterIterator StringContent)]
insert[insert(+)plain(      StringIndexOutOfBoundsException StringMonitor StringMonitorMBean StringReader StringRefAddr)]
insert[insert(+)plain(      StringSelection StringTokenizer StringValueExp StringWriter Stroke Struct Stub StubDelegate)]
insert[insert(+)plain(      StubNotFoundException Style StyleConstants StyleContext StyledDocument StyledEditorKit StyleSheet)]
insert[insert(+)plain(      Subject SubjectDelegationPermission SubjectDomainCombiner SupportedValuesAttribute SuppressWarnings)]
insert[insert(+)plain(      SwingConstants SwingPropertyChangeSupport SwingUtilities SyncFactory SyncFactoryException)]
insert[insert(+)plain(      SyncFailedException SynchronousQueue SyncProvider SyncProviderException SyncResolver SynthConstants)]
insert[insert(+)plain(      SynthContext Synthesizer SynthGraphicsUtils SynthLookAndFeel SynthPainter SynthStyle SynthStyleFactory)]
insert[insert(+)plain(      SysexMessage System SystemColor SystemFlavorMap TabableView TabbedPaneUI TabExpander TableCellEditor)]
insert[insert(+)plain(      TableCellRenderer TableColumn TableColumnModel TableColumnModelEvent TableColumnModelListener)]
insert[insert(+)plain(      TableHeaderUI TableModel TableModelEvent TableModelListener TableUI TableView TabSet TabStop TabularData)]
insert[insert(+)plain(      TabularDataSupport TabularType TagElement Target TargetDataLine TargetedNotification Templates)]
insert[insert(+)plain(      TemplatesHandler TextAction TextArea TextAttribute TextComponent TextEvent TextField TextHitInfo)]
insert[insert(+)plain(      TextInputCallback TextLayout TextListener TextMeasurer TextOutputCallback TextSyntax TextUI TexturePaint)]
insert[insert(+)plain(      Thread ThreadDeath ThreadFactory ThreadGroup ThreadInfo ThreadLocal ThreadMXBean ThreadPoolExecutor)]
insert[insert(+)plain(      Throwable Tie TileObserver Time TimeLimitExceededException TimeoutException Timer)]
insert[insert(+)plain(      TimerAlarmClockNotification TimerMBean TimerNotification TimerTask Timestamp TimeUnit TimeZone)]
insert[insert(+)plain(      TitledBorder ToolBarUI Toolkit ToolTipManager ToolTipUI TooManyListenersException Track)]
insert[insert(+)plain(      TransactionalWriter TransactionRequiredException TransactionRolledbackException Transferable)]
insert[insert(+)plain(      TransferHandler TransformAttribute Transformer TransformerConfigurationException TransformerException)]
insert[insert(+)plain(      TransformerFactory TransformerFactoryConfigurationError TransformerHandler Transmitter Transparency)]
insert[insert(+)plain(      TreeCellEditor TreeCellRenderer TreeExpansionEvent TreeExpansionListener TreeMap TreeModel)]
insert[insert(+)plain(      TreeModelEvent TreeModelListener TreeNode TreePath TreeSelectionEvent TreeSelectionListener)]
insert[insert(+)plain(      TreeSelectionModel TreeSet TreeUI TreeWillExpandListener TrustAnchor TrustManager TrustManagerFactory)]
insert[insert(+)plain(      TrustManagerFactorySpi Type TypeInfoProvider TypeNotPresentException Types TypeVariable UID UIDefaults)]
insert[insert(+)plain(      UIManager UIResource UndeclaredThrowableException UndoableEdit UndoableEditEvent UndoableEditListener)]
insert[insert(+)plain(      UndoableEditSupport UndoManager UnexpectedException UnicastRemoteObject UnknownError)]
insert[insert(+)plain(      UnknownFormatConversionException UnknownFormatFlagsException UnknownGroupException UnknownHostException)]
insert[insert(+)plain(      UnknownObjectException UnknownServiceException UnmappableCharacterException UnmarshalException)]
insert[insert(+)plain(      UnmodifiableClassException UnmodifiableSetException UnrecoverableEntryException)]
insert[insert(+)plain(      UnrecoverableKeyException Unreferenced UnresolvedAddressException UnresolvedPermission)]
insert[insert(+)plain(      UnsatisfiedLinkError UnsolicitedNotification UnsolicitedNotificationEvent)]
insert[insert(+)plain(      UnsolicitedNotificationListener UnsupportedAddressTypeException UnsupportedAudioFileException)]
insert[insert(+)plain(      UnsupportedCallbackException UnsupportedCharsetException UnsupportedClassVersionError)]
insert[insert(+)plain(      UnsupportedEncodingException UnsupportedFlavorException UnsupportedLookAndFeelException)]
insert[insert(+)plain(      UnsupportedOperationException URI URIException URIResolver URISyntax URISyntaxException URL)]
insert[insert(+)plain(      URLClassLoader URLConnection URLDecoder URLEncoder URLStreamHandler URLStreamHandlerFactory)]
insert[insert(+)plain(      UTFDataFormatException Util UtilDelegate Utilities UUID Validator ValidatorHandler ValueExp ValueHandler)]
insert[insert(+)plain(      ValueHandlerMultiFormat VariableHeightLayoutCache Vector VerifyError VetoableChangeListener)]
insert[insert(+)plain(      VetoableChangeListenerProxy VetoableChangeSupport View ViewFactory ViewportLayout ViewportUI)]
insert[insert(+)plain(      VirtualMachineError Visibility VMID VoiceStatus Void VolatileImage WeakHashMap WeakReference WebRowSet)]
insert[insert(+)plain(      WildcardType Window WindowAdapter WindowConstants WindowEvent WindowFocusListener WindowListener)]
insert[insert(+)plain(      WindowStateListener WrappedPlainView WritableByteChannel WritableRaster WritableRenderedImage)]
insert[insert(+)plain(      WriteAbortedException Writer X500Principal X500PrivateCredential X509Certificate X509CertSelector)]
insert[insert(+)plain(      X509CRL X509CRLEntry X509CRLSelector X509EncodedKeySpec X509ExtendedKeyManager X509Extension)]
insert[insert(+)plain(      X509KeyManager X509TrustManager XAConnection XADataSource XAException XAResource Xid XMLConstants)]
insert[insert(+)plain(      XMLDecoder XMLEncoder XMLFormatter XMLGregorianCalendar XMLParseException XmlReader XmlWriter XPath)]
insert[insert(+)plain(      XPathConstants XPathException XPathExpression XPathExpressionException XPathFactory)]
insert[insert(+)plain(      XPathFactoryConfigurationException XPathFunction XPathFunctionException XPathFunctionResolver)]
insert[insert(+)plain(      XPathVariableResolver ZipEntry ZipException ZipFile ZipInputStream ZipOutputStream ZoneView)]
insert[insert(+)plain(    ])]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/scanners/ruby.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/ruby.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/ruby.rb	(revision 500\))]
change[change(@@)plain( -21,6 +21,10 )change(@@)]
comment(     file_extension 'rb')
comment( )
comment(     helper :patterns)
insert[insert(+)plain(    )]
insert[insert(+)plain(    if not defined? EncodingError)]
insert[insert(+)plain(      EncodingError = Class.new Exception)]
insert[insert(+)plain(    end)]
comment( )
comment(   private)
comment(     def scan_tokens tokens, options)
change[change(@@)plain( -31,9 +35,10 )change(@@)]
comment(       state = :initial)
comment(       depth = nil)
comment(       inline_block_stack = [])
delete[delete(-)]
insert[insert(+)plain(      unicode = string.respond_to?(:encoding\) && string.encoding.name == 'UTF-8')]
insert[insert(+)plain(      )]
comment(       patterns = Patterns  # avoid constant lookup)
delete[delete(-)]
insert[insert(+)plain(      )]
comment(       until eos?)
comment(         match = nil)
comment(         kind = nil)
change[change(@@)plain( -125,14 +130,14 )change(@@)]
comment(           if match = scan(/[ \\t\\f]+/\))
comment(             kind = :space)
comment(             match << scan(/\\s*/\) unless eos? || heredocs)
delete[delete(-)plain(            value_expected = true if match.index(?\\n\) # FIXME not quite true)]
insert[insert(+)plain(            value_expected = true if match.index(?\\n\))]
comment(             tokens << [match, kind])
comment(             next)
comment(             )
comment(           elsif match = scan(/\\\\?\\n/\))
comment(             kind = :space)
comment(             if match == "\\n")
delete[delete(-)plain(              value_expected = true  # FIXME not quite true)]
insert[insert(+)plain(              value_expected = true)]
comment(               state = :initial if state == :undef_comma_expected)
comment(             end)
comment(             if heredocs)
change[change(@@)plain( -147,17 +152,21 )change(@@)]
comment(             tokens << [match, kind])
comment(             next)
comment(           )
insert[insert(+)plain(          elsif bol? && match = scan(/\\#!.*/\))]
insert[insert(+)plain(            tokens << [match, :doctype])]
insert[insert(+)plain(            next)]
insert[insert(+)plain(            )]
comment(           elsif match = scan(/\\#.*/\) or)
comment(             ( bol? and match = scan(/#{patterns::RUBYDOC_OR_DATA}/o\) \))
comment(               kind = :comment)
delete[delete(-)plain(              value_expected = true)]
comment(               tokens << [match, kind])
comment(               next)
comment( )
comment(           elsif state == :initial)
comment( )
comment(             # IDENTS #)
delete[delete(-)plain(            if match = scan(/#{patterns::METHOD_NAME}/o\))]
insert[insert(+)plain(            if match = scan(unicode ? /#{patterns::METHOD_NAME}/uo :)]
insert[insert(+)plain(                                      /#{patterns::METHOD_NAME}/o\))]
comment(               if last_token_dot)
comment(                 kind = if match[/^[A-Z]/] and not match?(/\\(/\) then :constant else :ident end)
comment(               else)
change[change(@@)plain( -166,17 +175,16 )change(@@)]
comment(                   kind = :constant)
comment(                 elsif kind == :reserved)
comment(                   state = patterns::DEF_NEW_STATE[match])
insert[insert(+)plain(                  value_expected = :set if patterns::KEYWORDS_EXPECTING_VALUE[match])]
comment(                 end)
comment(               end)
delete[delete(-)plain(              ## experimental!)]
comment(               value_expected = :set if check(/#{patterns::VALUE_FOLLOWS}/o\))
comment(             )
delete[delete(-)plain(            elsif last_token_dot and match = scan(/#{patterns::METHOD_NAME_OPERATOR}/o\))]
insert[insert(+)plain(            elsif last_token_dot and match = scan(/#{patterns::METHOD_NAME_OPERATOR}|\\(/o\))]
comment(               kind = :ident)
comment(               value_expected = :set if check(/#{patterns::VALUE_FOLLOWS}/o\))
comment( )
comment(             # OPERATORS #)
delete[delete(-)plain(            # TODO: match (\), [], {} as one single operator)]
comment(             elsif not last_token_dot and match = scan(/ \\.\\.\\.? | (?:\\.|::\)(\) | [,\\(\\\)\\[\\]\\{\\}] | ==?=? /x\))
comment(               if match !~ / [.\\\)\\]\\}] /x or match =~ /\\.\\.\\.?/)
comment(                 value_expected = :set)
change[change(@@)plain( -191,6 +199,7 )change(@@)]
comment(                   depth -= 1)
comment(                   if depth == 0  # closing brace of inline block reached)
comment(                     state, depth, heredocs = inline_block_stack.pop)
insert[insert(+)plain(                    heredocs = nil if heredocs && heredocs.empty?)]
comment(                     tokens << [match, :inline_delimiter])
comment(                     kind = :inline)
comment(                     match = :close)
change[change(@@)plain( -276,13 +285,24 )change(@@)]
comment( )
comment(             else)
comment(               kind = :error)
delete[delete(-)plain(              match = getch)]
insert[insert(+)plain(              match = (scan(/./mu\) rescue nil\) || getch)]
insert[insert(+)plain(              if !unicode && match.size > 1)]
insert[insert(+)plain(                # warn 'Switching to unicode mode because of char %p' % [match])]
insert[insert(+)plain(                unicode = true)]
insert[insert(+)plain(                unscan)]
insert[insert(+)plain(                next)]
insert[insert(+)plain(              end)]
comment( )
comment(             end)
comment( )
comment(           elsif state == :def_expected)
comment(             state = :initial)
delete[delete(-)plain(            if match = scan(/(?>#{patterns::METHOD_NAME_EX}\)(?!\\.|::\)/o\))]
insert[insert(+)plain(            if scan(/self\\./\))]
insert[insert(+)plain(              tokens << ['self', :pre_constant])]
insert[insert(+)plain(              tokens << ['.', :operator])]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            if match = scan(unicode ? /(?>#{patterns::METHOD_NAME_EX}\)(?!\\.|::\)/uo :)]
insert[insert(+)plain(                                      /(?>#{patterns::METHOD_NAME_EX}\)(?!\\.|::\)/o\))]
comment(               kind = :method)
comment(             else)
comment(               next)
change[change(@@)plain( -322,7 +342,10 )change(@@)]
comment(             end)
comment( )
comment(           elsif state == :alias_expected)
delete[delete(-)plain(            if match = scan(/(#{patterns::METHOD_NAME_OR_SYMBOL}\)([ \\t]+\)(#{patterns::METHOD_NAME_OR_SYMBOL}\)/o\))]
insert[insert(+)plain(            match = scan(unicode ? /(#{patterns::METHOD_NAME_OR_SYMBOL}\)([ \\t]+\)(#{patterns::METHOD_NAME_OR_SYMBOL}\)/uo :)]
insert[insert(+)plain(                                   /(#{patterns::METHOD_NAME_OR_SYMBOL}\)([ \\t]+\)(#{patterns::METHOD_NAME_OR_SYMBOL}\)/o\))]
insert[insert(+)plain(            )]
insert[insert(+)plain(            if match)]
comment(               tokens << [self[1], (self[1][0] == ?: ? :symbol : :method\)])
comment(               tokens << [self[2], :space])
comment(               tokens << [self[3], (self[3][0] == ?: ? :symbol : :method\)])
change[change(@@)plain( -346,7 +369,7 )change(@@)]
comment(             value_expected = value_expected == :set)
comment(             last_token_dot = last_token_dot == :set)
comment(           end)
delete[delete(-)]
insert[insert(+)plain(          )]
comment(           if $DEBUG and not kind)
comment(             raise_inspect 'Error token %p in line %d' %)
comment(               [[match, kind], line], tokens, state)
head[head(Index: )plain(lib/coderay/scanners/python.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/python.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/python.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,289 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Scanners)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # Scanner for Python. Supports Python 3.)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Based on pygments' PythonLexer, see)]
insert[insert(+)plain(  # http://dev.pocoo.org/projects/pygments/browser/pygments/lexers/agile.py.)]
insert[insert(+)plain(  class Python < Scanner)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    include Streamable)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    register_for :python)]
insert[insert(+)plain(    file_extension 'py')]
insert[insert(+)plain(    )]
insert[insert(+)plain(    KEYWORDS = [)]
insert[insert(+)plain(      'and', 'as', 'assert', 'break', 'class', 'continue', 'def',)]
insert[insert(+)plain(      'del', 'elif', 'else', 'except', 'finally', 'for',)]
insert[insert(+)plain(      'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'not',)]
insert[insert(+)plain(      'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield',)]
insert[insert(+)plain(      'nonlocal',  # new in Python 3)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    OLD_KEYWORDS = [)]
insert[insert(+)plain(      'exec', 'print',  # gone in Python 3)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    PREDEFINED_METHODS_AND_TYPES = %w[)]
insert[insert(+)plain(      __import__ abs all any apply basestring bin bool buffer)]
insert[insert(+)plain(      bytearray bytes callable chr classmethod cmp coerce compile)]
insert[insert(+)plain(      complex delattr dict dir divmod enumerate eval execfile exit)]
insert[insert(+)plain(      file filter float frozenset getattr globals hasattr hash hex id)]
insert[insert(+)plain(      input int intern isinstance issubclass iter len list locals)]
insert[insert(+)plain(      long map max min next object oct open ord pow property range)]
insert[insert(+)plain(      raw_input reduce reload repr reversed round set setattr slice)]
insert[insert(+)plain(      sorted staticmethod str sum super tuple type unichr unicode)]
insert[insert(+)plain(      vars xrange zip)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    PREDEFINED_EXCEPTIONS = %w[)]
insert[insert(+)plain(      ArithmeticError AssertionError AttributeError)]
insert[insert(+)plain(      BaseException DeprecationWarning EOFError EnvironmentError)]
insert[insert(+)plain(      Exception FloatingPointError FutureWarning GeneratorExit IOError)]
insert[insert(+)plain(      ImportError ImportWarning IndentationError IndexError KeyError)]
insert[insert(+)plain(      KeyboardInterrupt LookupError MemoryError NameError)]
insert[insert(+)plain(      NotImplemented NotImplementedError OSError OverflowError)]
insert[insert(+)plain(      OverflowWarning PendingDeprecationWarning ReferenceError)]
insert[insert(+)plain(      RuntimeError RuntimeWarning StandardError StopIteration)]
insert[insert(+)plain(      SyntaxError SyntaxWarning SystemError SystemExit TabError)]
insert[insert(+)plain(      TypeError UnboundLocalError UnicodeDecodeError)]
insert[insert(+)plain(      UnicodeEncodeError UnicodeError UnicodeTranslateError)]
insert[insert(+)plain(      UnicodeWarning UserWarning ValueError Warning ZeroDivisionError)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    PREDEFINED_VARIABLES_AND_CONSTANTS = [)]
insert[insert(+)plain(      'False', 'True', 'None',  # "keywords" since Python 3)]
insert[insert(+)plain(      'self', 'Ellipsis', 'NotImplemented',)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    IDENT_KIND = WordList.new(:ident\).)]
insert[insert(+)plain(      add(KEYWORDS, :keyword\).)]
insert[insert(+)plain(      add(OLD_KEYWORDS, :old_keyword\).)]
insert[insert(+)plain(      add(PREDEFINED_METHODS_AND_TYPES, :predefined\).)]
insert[insert(+)plain(      add(PREDEFINED_VARIABLES_AND_CONSTANTS, :pre_constant\).)]
insert[insert(+)plain(      add(PREDEFINED_EXCEPTIONS, :exception\)  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    NAME = / [^\\W\\d] \\w* /x  # :nodoc:)]
insert[insert(+)plain(    ESCAPE = / [abfnrtv\\n\\\\'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} /x  # :nodoc:)]
insert[insert(+)plain(    UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} | N\\{[-\\w ]+\\} /x  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    OPERATOR = /)]
insert[insert(+)plain(      \\.\\.\\. |          # ellipsis)]
insert[insert(+)plain(      \\.(?!\\d\) |        # dot but not decimal point)]
insert[insert(+)plain(      [,;:(\)\\[\\]{}] |   # simple delimiters)]
insert[insert(+)plain(      \\/\\/=? | \\*\\*=? | # special math)]
insert[insert(+)plain(      [-+*\\/%&|^]=? |   # ordinary math and binary logic)]
insert[insert(+)plain(      [~`] |            # binary complement and inspection)]
insert[insert(+)plain(      <<=? | >>=? | [<>=]=? | !=  # comparison and assignment)]
insert[insert(+)plain(    /x  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    STRING_DELIMITER_REGEXP = Hash.new { |h, delimiter|)]
insert[insert(+)plain(      h[delimiter] = Regexp.union delimiter  # :nodoc:)]
insert[insert(+)plain(    })]
insert[insert(+)plain(    )]
insert[insert(+)plain(    STRING_CONTENT_REGEXP = Hash.new { |h, delimiter|)]
insert[insert(+)plain(      h[delimiter] = / [^\\\\\\n]+? (?= \\\\ | $ | #{Regexp.escape(delimiter\)} \) /x  # :nodoc:)]
insert[insert(+)plain(    })]
insert[insert(+)plain(    )]
insert[insert(+)plain(    DEF_NEW_STATE = WordList.new(:initial\).)]
insert[insert(+)plain(      add(%w(def\), :def_expected\).)]
insert[insert(+)plain(      add(%w(import from\), :include_expected\).)]
insert[insert(+)plain(      add(%w(class\), :class_expected\)  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    DESCRIPTOR = /)]
insert[insert(+)plain(      #{NAME})]
insert[insert(+)plain(      (?: \\. #{NAME} \)*)]
insert[insert(+)plain(      | \\*)]
insert[insert(+)plain(    /x  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def scan_tokens tokens, options)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      state = :initial)]
insert[insert(+)plain(      string_delimiter = nil)]
insert[insert(+)plain(      string_raw = false)]
insert[insert(+)plain(      import_clause = class_name_follows = last_token_dot = false)]
insert[insert(+)plain(      unicode = string.respond_to?(:encoding\) && string.encoding.name == 'UTF-8')]
insert[insert(+)plain(      from_import_state = [])]
insert[insert(+)plain(      )]
insert[insert(+)plain(      until eos?)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        kind = nil)]
insert[insert(+)plain(        match = nil)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        if state == :string)]
insert[insert(+)plain(          if scan(STRING_DELIMITER_REGEXP[string_delimiter]\))]
insert[insert(+)plain(            tokens << [matched, :delimiter])]
insert[insert(+)plain(            tokens << [:close, :string])]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif string_delimiter.size == 3 && scan(/\\n/\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif scan(STRING_CONTENT_REGEXP[string_delimiter]\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif !string_raw && scan(/ \\\\ #{ESCAPE} /ox\))]
insert[insert(+)plain(            kind = :char)]
insert[insert(+)plain(          elsif scan(/ \\\\ #{UNICODE_ESCAPE} /ox\))]
insert[insert(+)plain(            kind = :char)]
insert[insert(+)plain(          elsif scan(/ \\\\ . /x\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif scan(/ \\\\ | $ /x\))]
insert[insert(+)plain(            tokens << [:close, :string])]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            raise_inspect "else case \\" reached; %p not handled." % peek(1\), tokens, state)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        elsif match = scan(/ [ \\t]+ | \\\\\\n /x\))]
insert[insert(+)plain(          tokens << [match, :space])]
insert[insert(+)plain(          next)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        elsif match = scan(/\\n/\))]
insert[insert(+)plain(          tokens << [match, :space])]
insert[insert(+)plain(          state = :initial if state == :include_expected)]
insert[insert(+)plain(          next)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        elsif match = scan(/ \\# [^\\n]* /mx\))]
insert[insert(+)plain(          tokens << [match, :comment])]
insert[insert(+)plain(          next)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        elsif state == :initial)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          if scan(/#{OPERATOR}/o\))]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/(u?r?|b\)?("""|"|'''|'\)/i\))]
insert[insert(+)plain(            tokens << [:open, :string])]
insert[insert(+)plain(            string_delimiter = self[2])]
insert[insert(+)plain(            string_raw = false)]
insert[insert(+)plain(            modifiers = self[1])]
insert[insert(+)plain(            unless modifiers.empty?)]
insert[insert(+)plain(              string_raw = !!modifiers.index(?r\))]
insert[insert(+)plain(              tokens << [modifiers, :modifier])]
insert[insert(+)plain(              match = string_delimiter)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            state = :string)]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          # TODO: backticks)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(unicode ? /#{NAME}/uo : /#{NAME}/o\))]
insert[insert(+)plain(            kind = IDENT_KIND[match])]
insert[insert(+)plain(            # TODO: keyword arguments)]
insert[insert(+)plain(            kind = :ident if last_token_dot)]
insert[insert(+)plain(            if kind == :old_keyword)]
insert[insert(+)plain(              kind = check(/\\(/\) ? :ident : :keyword)]
insert[insert(+)plain(            elsif kind == :predefined && check(/ *=/\))]
insert[insert(+)plain(              kind = :ident)]
insert[insert(+)plain(            elsif kind == :keyword)]
insert[insert(+)plain(              state = DEF_NEW_STATE[match])]
insert[insert(+)plain(              from_import_state << match.to_sym if state == :include_expected)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/@[a-zA-Z0-9_.]+[lL]?/\))]
insert[insert(+)plain(            kind = :decorator)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/0[xX][0-9A-Fa-f]+[lL]?/\))]
insert[insert(+)plain(            kind = :hex)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/0[bB][01]+[lL]?/\))]
insert[insert(+)plain(            kind = :bin)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/(?:\\d*\\.\\d+|\\d+\\.\\d*\)(?:[eE][+-]?\\d+\)?|\\d+[eE][+-]?\\d+/\))]
insert[insert(+)plain(            kind = :float)]
insert[insert(+)plain(            if scan(/[jJ]/\))]
insert[insert(+)plain(              match << matched)]
insert[insert(+)plain(              kind = :imaginary)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/0[oO][0-7]+|0[0-7]+(?![89.eE]\)[lL]?/\))]
insert[insert(+)plain(            kind = :oct)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/\\d+([lL]\)?/\))]
insert[insert(+)plain(            kind = :integer)]
insert[insert(+)plain(            if self[1] == nil && scan(/[jJ]/\))]
insert[insert(+)plain(              match << matched)]
insert[insert(+)plain(              kind = :imaginary)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            getch)]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          end)]
insert[insert(+)plain(            )]
insert[insert(+)plain(        elsif state == :def_expected)]
insert[insert(+)plain(          state = :initial)]
insert[insert(+)plain(          if match = scan(unicode ? /#{NAME}/uo : /#{NAME}/o\))]
insert[insert(+)plain(            kind = :method)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        elsif state == :class_expected)]
insert[insert(+)plain(          state = :initial)]
insert[insert(+)plain(          if match = scan(unicode ? /#{NAME}/uo : /#{NAME}/o\))]
insert[insert(+)plain(            kind = :class)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        elsif state == :include_expected)]
insert[insert(+)plain(          if match = scan(unicode ? /#{DESCRIPTOR}/uo : /#{DESCRIPTOR}/o\))]
insert[insert(+)plain(            kind = :include)]
insert[insert(+)plain(            if match == 'as')]
insert[insert(+)plain(              kind = :keyword)]
insert[insert(+)plain(              from_import_state << :as)]
insert[insert(+)plain(            elsif from_import_state.first == :from && match == 'import')]
insert[insert(+)plain(              kind = :keyword)]
insert[insert(+)plain(              from_import_state << :import)]
insert[insert(+)plain(            elsif from_import_state.last == :as)]
insert[insert(+)plain(              # kind = match[0,1][unicode ? /[[:upper:]]/u : /[[:upper:]]/] ? :class : :method)]
insert[insert(+)plain(              kind = :ident)]
insert[insert(+)plain(              from_import_state.pop)]
insert[insert(+)plain(            elsif IDENT_KIND[match] == :keyword)]
insert[insert(+)plain(              unscan)]
insert[insert(+)plain(              match = nil)]
insert[insert(+)plain(              state = :initial)]
insert[insert(+)plain(              next)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          elsif match = scan(/,/\))]
insert[insert(+)plain(            from_import_state.pop if from_import_state.last == :as)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            from_import_state = [])]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          raise_inspect 'Unknown state', tokens, state)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        match ||= matched)]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
insert[insert(+)plain(          raise_inspect 'Error token %p in line %d' %)]
insert[insert(+)plain(            [[match, kind], line], tokens, state)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        raise_inspect 'Empty token', tokens, state unless match)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        last_token_dot = match == '.')]
insert[insert(+)plain(        )]
insert[insert(+)plain(        tokens << [match, kind])]
insert[insert(+)plain(        )]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      if state == :string)]
insert[insert(+)plain(        tokens << [:close, :string])]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      tokens)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/scanners/java.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/java.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/java.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,179 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Scanners)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # Scanner for Java.)]
insert[insert(+)plain(  class Java < Scanner)]
insert[insert(+)]
insert[insert(+)plain(    include Streamable)]
insert[insert(+)plain(    register_for :java)]
insert[insert(+)plain(    helper :builtin_types)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    # http://java.sun.com/docs/books/tutorial/java/nutsandbolts/_keywords.html)]
insert[insert(+)plain(    KEYWORDS = %w[)]
insert[insert(+)plain(      assert break case catch continue default do else)]
insert[insert(+)plain(      finally for if instanceof import new package)]
insert[insert(+)plain(      return switch throw try typeof while)]
insert[insert(+)plain(      debugger export)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    RESERVED = %w[ const goto ]  # :nodoc:)]
insert[insert(+)plain(    CONSTANTS = %w[ false null true ]  # :nodoc:)]
insert[insert(+)plain(    MAGIC_VARIABLES = %w[ this super ]  # :nodoc:)]
insert[insert(+)plain(    TYPES = %w[)]
insert[insert(+)plain(      boolean byte char class double enum float int interface long)]
insert[insert(+)plain(      short void)]
insert[insert(+)plain(    ] << '[]'  # :nodoc: because int[] should be highlighted as a type)]
insert[insert(+)plain(    DIRECTIVES = %w[)]
insert[insert(+)plain(      abstract extends final implements native private protected public)]
insert[insert(+)plain(      static strictfp synchronized throws transient volatile)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    IDENT_KIND = WordList.new(:ident\).)]
insert[insert(+)plain(      add(KEYWORDS, :keyword\).)]
insert[insert(+)plain(      add(RESERVED, :reserved\).)]
insert[insert(+)plain(      add(CONSTANTS, :pre_constant\).)]
insert[insert(+)plain(      add(MAGIC_VARIABLES, :local_variable\).)]
insert[insert(+)plain(      add(TYPES, :type\).)]
insert[insert(+)plain(      add(BuiltinTypes::List, :pre_type\).)]
insert[insert(+)plain(      add(BuiltinTypes::List.select { |builtin| builtin[/(Error|Exception\)$/] }, :exception\).)]
insert[insert(+)plain(      add(DIRECTIVES, :directive\)  # :nodoc:)]
insert[insert(+)]
insert[insert(+)plain(    ESCAPE = / [bfnrtv\\n\\\\'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} /x  # :nodoc:)]
insert[insert(+)plain(    UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} /x  # :nodoc:)]
insert[insert(+)plain(    STRING_CONTENT_PATTERN = {)]
insert[insert(+)plain(      "'" => /[^\\\\']+/,)]
insert[insert(+)plain(      '"' => /[^\\\\"]+/,)]
insert[insert(+)plain(      '/' => /[^\\\\\\/]+/,)]
insert[insert(+)plain(    }  # :nodoc:)]
insert[insert(+)plain(    IDENT = /[a-zA-Z_][A-Za-z_0-9]*/  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def scan_tokens tokens, options)]
insert[insert(+)]
insert[insert(+)plain(      state = :initial)]
insert[insert(+)plain(      string_delimiter = nil)]
insert[insert(+)plain(      import_clause = class_name_follows = last_token_dot = false)]
insert[insert(+)]
insert[insert(+)plain(      until eos?)]
insert[insert(+)]
insert[insert(+)plain(        kind = nil)]
insert[insert(+)plain(        match = nil)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        case state)]
insert[insert(+)]
insert[insert(+)plain(        when :initial)]
insert[insert(+)]
insert[insert(+)plain(          if match = scan(/ \\s+ | \\\\\\n /x\))]
insert[insert(+)plain(            tokens << [match, :space])]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(%r! // [^\\n\\\\]* (?: \\\\. [^\\n\\\\]* \)* | /\\* (?: .*? \\*/ | .* \) !mx\))]
insert[insert(+)plain(            tokens << [match, :comment])]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif import_clause && scan(/ #{IDENT} (?: \\. #{IDENT} \)* /ox\))]
insert[insert(+)plain(            kind = :include)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/ #{IDENT} | \\[\\] /ox\))]
insert[insert(+)plain(            kind = IDENT_KIND[match])]
insert[insert(+)plain(            if last_token_dot)]
insert[insert(+)plain(              kind = :ident)]
insert[insert(+)plain(            elsif class_name_follows)]
insert[insert(+)plain(              kind = :class)]
insert[insert(+)plain(              class_name_follows = false)]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              import_clause = true if match == 'import')]
insert[insert(+)plain(              class_name_follows = true if match == 'class' || match == 'interface')]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/ \\.(?!\\d\) | [,?:(\)\\[\\]}] | -- | \\+\\+ | && | \\|\\| | \\*\\*=? | [-+*\\/%^~&|<>=!]=? | <<<?=? | >>>?=? /x\))]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/;/\))]
insert[insert(+)plain(            import_clause = false)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/\\{/\))]
insert[insert(+)plain(            class_name_follows = false)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif check(/[\\d.]/\))]
insert[insert(+)plain(            if scan(/0[xX][0-9A-Fa-f]+/\))]
insert[insert(+)plain(              kind = :hex)]
insert[insert(+)plain(            elsif scan(/(?>0[0-7]+\)(?![89.eEfF]\)/\))]
insert[insert(+)plain(              kind = :oct)]
insert[insert(+)plain(            elsif scan(/\\d+[fFdD]|\\d*\\.\\d+(?:[eE][+-]?\\d+\)?[fFdD]?|\\d+[eE][+-]?\\d+[fFdD]?/\))]
insert[insert(+)plain(              kind = :float)]
insert[insert(+)plain(            elsif scan(/\\d+[lL]?/\))]
insert[insert(+)plain(              kind = :integer)]
insert[insert(+)plain(            end)]
insert[insert(+)]
insert[insert(+)plain(          elsif match = scan(/["']/\))]
insert[insert(+)plain(            tokens << [:open, :string])]
insert[insert(+)plain(            state = :string)]
insert[insert(+)plain(            string_delimiter = match)]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/ @ #{IDENT} /ox\))]
insert[insert(+)plain(            kind = :annotation)]
insert[insert(+)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            getch)]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)]
insert[insert(+)plain(          end)]
insert[insert(+)]
insert[insert(+)plain(        when :string)]
insert[insert(+)plain(          if scan(STRING_CONTENT_PATTERN[string_delimiter]\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif match = scan(/["'\\/]/\))]
insert[insert(+)plain(            tokens << [match, :delimiter])]
insert[insert(+)plain(            tokens << [:close, state])]
insert[insert(+)plain(            string_delimiter = nil)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif state == :string && (match = scan(/ \\\\ (?: #{ESCAPE} | #{UNICODE_ESCAPE} \) /mox\)\))]
insert[insert(+)plain(            if string_delimiter == "'" && !(match == "\\\\\\\\" || match == "\\\\'"\))]
insert[insert(+)plain(              kind = :content)]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              kind = :char)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          elsif scan(/\\\\./m\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif scan(/ \\\\ | $ /x\))]
insert[insert(+)plain(            tokens << [:close, :delimiter])]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            raise_inspect "else case \\" reached; %p not handled." % peek(1\), tokens)]
insert[insert(+)plain(          end)]
insert[insert(+)]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          raise_inspect 'Unknown state', tokens)]
insert[insert(+)]
insert[insert(+)plain(        end)]
insert[insert(+)]
insert[insert(+)plain(        match ||= matched)]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
insert[insert(+)plain(          raise_inspect 'Error token %p in line %d' %)]
insert[insert(+)plain(            [[match, kind], line], tokens)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        raise_inspect 'Empty token', tokens unless match)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        last_token_dot = match == '.')]
insert[insert(+)plain(        )]
insert[insert(+)plain(        tokens << [match, kind])]
insert[insert(+)]
insert[insert(+)plain(      end)]
insert[insert(+)]
insert[insert(+)plain(      if state == :string)]
insert[insert(+)plain(        tokens << [:close, state])]
insert[insert(+)plain(      end)]
insert[insert(+)]
insert[insert(+)plain(      tokens)]
insert[insert(+)plain(    end)]
insert[insert(+)]
insert[insert(+)plain(  end)]
insert[insert(+)]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/scanners/c.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/c.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/c.rb	(revision 500\))]
change[change(@@)plain( -1,44 +1,55 )change(@@)]
comment( module CodeRay)
comment( module Scanners)
delete[delete(-)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # Scanner for C.)]
comment(   class C < Scanner)
comment( )
insert[insert(+)plain(    include Streamable)]
insert[insert(+)plain(    )]
comment(     register_for :c)
insert[insert(+)plain(    file_extension 'c')]
comment(     )
delete[delete(-)plain(    include Streamable)]
delete[delete(-)]
comment(     RESERVED_WORDS = [)
delete[delete(-)plain(      'asm', 'break', 'case', 'continue', 'default', 'do', 'else',)]
delete[delete(-)plain(      'for', 'goto', 'if', 'return', 'switch', 'while',)]
delete[delete(-)plain(      'struct', 'union', 'enum', 'typedef',)]
delete[delete(-)plain(      'static', 'register', 'auto', 'extern',)]
delete[delete(-)plain(      'sizeof',)]
delete[delete(-)plain(      'volatile', 'const',  # C89)]
delete[delete(-)plain(      'inline', 'restrict', # C99)]
delete[delete(-)plain(    ])]
insert[insert(+)plain(      'asm', 'break', 'case', 'continue', 'default', 'do',)]
insert[insert(+)plain(      'else', 'enum', 'for', 'goto', 'if', 'return',)]
insert[insert(+)plain(      'sizeof', 'struct', 'switch', 'typedef', 'union', 'while',)]
insert[insert(+)plain(      'restrict',  # added in C99)]
insert[insert(+)plain(    ]  # :nodoc:)]
comment( )
comment(     PREDEFINED_TYPES = [)
delete[delete(-)plain(      'int', 'long', 'short', 'char', 'void',)]
insert[insert(+)plain(      'int', 'long', 'short', 'char',)]
comment(       'signed', 'unsigned', 'float', 'double',)
delete[delete(-)plain(      'bool', 'complex',  # C99)]
delete[delete(-)plain(    ])]
insert[insert(+)plain(      'bool', 'complex',  # added in C99)]
insert[insert(+)plain(    ]  # :nodoc:)]
comment( )
comment(     PREDEFINED_CONSTANTS = [)
comment(       'EOF', 'NULL',)
delete[delete(-)plain(      'true', 'false',  # C99)]
delete[delete(-)plain(    ])]
insert[insert(+)plain(      'true', 'false',  # added in C99)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    DIRECTIVES = [)]
insert[insert(+)plain(      'auto', 'extern', 'register', 'static', 'void',)]
insert[insert(+)plain(      'const', 'volatile',  # added in C89)]
insert[insert(+)plain(      'inline',  # added in C99)]
insert[insert(+)plain(    ]  # :nodoc:)]
comment( )
comment(     IDENT_KIND = WordList.new(:ident\).)
comment(       add(RESERVED_WORDS, :reserved\).)
comment(       add(PREDEFINED_TYPES, :pre_type\).)
delete[delete(-)plain(      add(PREDEFINED_CONSTANTS, :pre_constant\))]
insert[insert(+)plain(      add(DIRECTIVES, :directive\).)]
insert[insert(+)plain(      add(PREDEFINED_CONSTANTS, :pre_constant\)  # :nodoc:)]
comment( )
delete[delete(-)plain(    ESCAPE = / [rbfnrtv\\n\\\\'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} /x)]
delete[delete(-)plain(    UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} /x)]
delete[delete(-)]
insert[insert(+)plain(    ESCAPE = / [rbfntv\\n\\\\'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} /x  # :nodoc:)]
insert[insert(+)plain(    UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} /x  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
comment(     def scan_tokens tokens, options)
comment( )
comment(       state = :initial)
insert[insert(+)plain(      label_expected = true)]
insert[insert(+)plain(      case_expected = false)]
insert[insert(+)plain(      label_expected_before_preproc_line = nil)]
insert[insert(+)plain(      in_preproc_line = false)]
comment( )
comment(       until eos?)
comment( )
change[change(@@)plain( -49,8 +60,13 )change(@@)]
comment( )
comment(         when :initial)
comment( )
delete[delete(-)plain(          if scan(/ \\s+ | \\\\\\n /x\))]
delete[delete(-)plain(            kind = :space)]
insert[insert(+)plain(          if match = scan(/ \\s+ | \\\\\\n /x\))]
insert[insert(+)plain(            if in_preproc_line && match != "\\\\\\n" && match.index(?\\n\))]
insert[insert(+)plain(              in_preproc_line = false)]
insert[insert(+)plain(              label_expected = label_expected_before_preproc_line)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            tokens << [match, :space])]
insert[insert(+)plain(            next)]
comment( )
comment(           elsif scan(%r! // [^\\n\\\\]* (?: \\\\. [^\\n\\\\]* \)* | /\\* (?: .*? \\*/ | .* \) !mx\))
comment(             kind = :comment)
change[change(@@)plain( -59,16 +75,32 )change(@@)]
comment(             match << scan_until(/ ^\\# (?:elif|else|endif\) .*? $ | \\z /xm\) unless eos?)
comment(             kind = :comment)
comment( )
delete[delete(-)plain(          elsif scan(/ [-+*\\/=<>?:;,!&^|(\)\\[\\]{}~%]+ | \\.(?!\\d\) /x\))]
insert[insert(+)plain(          elsif match = scan(/ [-+*=<>?:;,!&^|(\)\\[\\]{}~%]+ | \\/=? | \\.(?!\\d\) /x\))]
insert[insert(+)plain(            label_expected = match =~ /[;\\{\\}]/)]
insert[insert(+)plain(            if case_expected)]
insert[insert(+)plain(              label_expected = true if match == ':')]
insert[insert(+)plain(              case_expected = false)]
insert[insert(+)plain(            end)]
comment(             kind = :operator)
comment( )
comment(           elsif match = scan(/ [A-Za-z_][A-Za-z_0-9]* /x\))
comment(             kind = IDENT_KIND[match])
delete[delete(-)plain(            if kind == :ident and check(/:(?!:\)/\))]
delete[delete(-)plain(              match << scan(/:/\))]
insert[insert(+)plain(            if kind == :ident && label_expected && !in_preproc_line && scan(/:(?!:\)/\))]
comment(               kind = :label)
insert[insert(+)plain(              match << matched)]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              label_expected = false)]
insert[insert(+)plain(              if kind == :reserved)]
insert[insert(+)plain(                case match)]
insert[insert(+)plain(                when 'case', 'default')]
insert[insert(+)plain(                  case_expected = true)]
insert[insert(+)plain(                end)]
insert[insert(+)plain(              end)]
comment(             end)
comment( )
insert[insert(+)plain(          elsif scan(/\\$/\))]
insert[insert(+)plain(            kind = :ident)]
insert[insert(+)plain(          )]
comment(           elsif match = scan(/L?"/\))
comment(             tokens << [:open, :string])
comment(             if match[0] == ?L)
change[change(@@)plain( -78,23 +110,30 )change(@@)]
comment(             state = :string)
comment(             kind = :delimiter)
comment( )
delete[delete(-)plain(          elsif scan(/#\\s*(\\w*\)/\))]
delete[delete(-)plain(            kind = :preprocessor  # FIXME multiline preprocs)]
insert[insert(+)plain(          elsif scan(/#[ \\t]*(\\w*\)/\))]
insert[insert(+)plain(            kind = :preprocessor)]
insert[insert(+)plain(            in_preproc_line = true)]
insert[insert(+)plain(            label_expected_before_preproc_line = label_expected)]
comment(             state = :include_expected if self[1] == 'include')
comment( )
comment(           elsif scan(/ L?' (?: [^\\'\\n\\\\] | \\\\ #{ESCAPE} \)? '? /ox\))
insert[insert(+)plain(            label_expected = false)]
comment(             kind = :char)
comment( )
comment(           elsif scan(/0[xX][0-9A-Fa-f]+/\))
insert[insert(+)plain(            label_expected = false)]
comment(             kind = :hex)
comment( )
comment(           elsif scan(/(?:0[0-7]+\)(?![89.eEfF]\)/\))
insert[insert(+)plain(            label_expected = false)]
comment(             kind = :oct)
comment( )
delete[delete(-)plain(          elsif scan(/(?:\\d+\)(?![.eEfF]\)/\))]
insert[insert(+)plain(          elsif scan(/(?:\\d+\)(?![.eEfF]\)L?L?/\))]
insert[insert(+)plain(            label_expected = false)]
comment(             kind = :integer)
comment( )
comment(           elsif scan(/\\d[fF]?|\\d*\\.\\d+(?:[eE][+-]?\\d+\)?[fF]?|\\d+[eE][+-]?\\d+[fF]?/\))
insert[insert(+)plain(            label_expected = false)]
comment(             kind = :float)
comment( )
comment(           else)
change[change(@@)plain( -110,6 +149,7 )change(@@)]
comment(             tokens << ['"', :delimiter])
comment(             tokens << [:close, :string])
comment(             state = :initial)
insert[insert(+)plain(            label_expected = false)]
comment(             next)
comment(           elsif scan(/ \\\\ (?: #{ESCAPE} | #{UNICODE_ESCAPE} \) /mox\))
comment(             kind = :char)
change[change(@@)plain( -117,6 +157,7 )change(@@)]
comment(             tokens << [:close, :string])
comment(             kind = :error)
comment(             state = :initial)
insert[insert(+)plain(            label_expected = false)]
comment(           else)
comment(             raise_inspect "else case \\" reached; %p not handled." % peek(1\), tokens)
comment(           end)
change[change(@@)plain( -131,8 +172,8 )change(@@)]
comment(             state = :initial if match.index ?\\n)
comment( )
comment(           else)
delete[delete(-)plain(            getch)]
delete[delete(-)plain(            kind = :error)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            next)]
comment( )
comment(           end)
comment( )
change[change(@@)plain( -142,7 +183,7 )change(@@)]
comment(         end)
comment( )
comment(         match ||= matched)
delete[delete(-)plain(        if $DEBUG and not kind)]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
comment(           raise_inspect 'Error token %p in line %d' %)
comment(             [[match, kind], line], tokens)
comment(         end)
head[head(Index: )plain(lib/coderay/scanners/cpp.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/cpp.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/cpp.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,233 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Scanners)]
insert[insert(+)]
insert[insert(+)plain(  # Scanner for C++.)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Aliases: +cplusplus+, c++)]
insert[insert(+)plain(  class CPlusPlus < Scanner)]
insert[insert(+)]
insert[insert(+)plain(    include Streamable)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    register_for :cpp)]
insert[insert(+)plain(    file_extension 'cpp')]
insert[insert(+)plain(    title 'C++')]
insert[insert(+)plain(    )]
insert[insert(+)plain(    #-- http://www.cppreference.com/wiki/keywords/start)]
insert[insert(+)plain(    RESERVED_WORDS = [)]
insert[insert(+)plain(      'and', 'and_eq', 'asm', 'bitand', 'bitor', 'break',)]
insert[insert(+)plain(      'case', 'catch', 'class', 'compl', 'const_cast',)]
insert[insert(+)plain(      'continue', 'default', 'delete', 'do', 'dynamic_cast', 'else',)]
insert[insert(+)plain(      'enum', 'export', 'for', 'goto', 'if', 'namespace', 'new',)]
insert[insert(+)plain(      'not', 'not_eq', 'or', 'or_eq', 'reinterpret_cast', 'return',)]
insert[insert(+)plain(      'sizeof', 'static_cast', 'struct', 'switch', 'template',)]
insert[insert(+)plain(      'throw', 'try', 'typedef', 'typeid', 'typename', 'union',)]
insert[insert(+)plain(      'while', 'xor', 'xor_eq',)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    PREDEFINED_TYPES = [)]
insert[insert(+)plain(      'bool', 'char', 'double', 'float', 'int', 'long',)]
insert[insert(+)plain(      'short', 'signed', 'unsigned', 'wchar_t', 'string',)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    PREDEFINED_CONSTANTS = [)]
insert[insert(+)plain(      'false', 'true',)]
insert[insert(+)plain(      'EOF', 'NULL',)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    PREDEFINED_VARIABLES = [)]
insert[insert(+)plain(      'this',)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    DIRECTIVES = [)]
insert[insert(+)plain(      'auto', 'const', 'explicit', 'extern', 'friend', 'inline', 'mutable', 'operator',)]
insert[insert(+)plain(      'private', 'protected', 'public', 'register', 'static', 'using', 'virtual', 'void',)]
insert[insert(+)plain(      'volatile',)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    IDENT_KIND = WordList.new(:ident\).)]
insert[insert(+)plain(      add(RESERVED_WORDS, :reserved\).)]
insert[insert(+)plain(      add(PREDEFINED_TYPES, :pre_type\).)]
insert[insert(+)plain(      add(PREDEFINED_VARIABLES, :local_variable\).)]
insert[insert(+)plain(      add(DIRECTIVES, :directive\).)]
insert[insert(+)plain(      add(PREDEFINED_CONSTANTS, :pre_constant\)  # :nodoc:)]
insert[insert(+)]
insert[insert(+)plain(    ESCAPE = / [rbfntv\\n\\\\'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} /x  # :nodoc:)]
insert[insert(+)plain(    UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} /x  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def scan_tokens tokens, options)]
insert[insert(+)]
insert[insert(+)plain(      state = :initial)]
insert[insert(+)plain(      label_expected = true)]
insert[insert(+)plain(      case_expected = false)]
insert[insert(+)plain(      label_expected_before_preproc_line = nil)]
insert[insert(+)plain(      in_preproc_line = false)]
insert[insert(+)]
insert[insert(+)plain(      until eos?)]
insert[insert(+)]
insert[insert(+)plain(        kind = nil)]
insert[insert(+)plain(        match = nil)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        case state)]
insert[insert(+)]
insert[insert(+)plain(        when :initial)]
insert[insert(+)]
insert[insert(+)plain(          if match = scan(/ \\s+ | \\\\\\n /x\))]
insert[insert(+)plain(            if in_preproc_line && match != "\\\\\\n" && match.index(?\\n\))]
insert[insert(+)plain(              in_preproc_line = false)]
insert[insert(+)plain(              label_expected = label_expected_before_preproc_line)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            tokens << [match, :space])]
insert[insert(+)plain(            next)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(%r! // [^\\n\\\\]* (?: \\\\. [^\\n\\\\]* \)* | /\\* (?: .*? \\*/ | .* \) !mx\))]
insert[insert(+)plain(            kind = :comment)]
insert[insert(+)]
insert[insert(+)plain(          elsif match = scan(/ \\# \\s* if \\s* 0 /x\))]
insert[insert(+)plain(            match << scan_until(/ ^\\# (?:elif|else|endif\) .*? $ | \\z /xm\) unless eos?)]
insert[insert(+)plain(            kind = :comment)]
insert[insert(+)]
insert[insert(+)plain(          elsif match = scan(/ [-+*=<>?:;,!&^|(\)\\[\\]{}~%]+ | \\/=? | \\.(?!\\d\) /x\))]
insert[insert(+)plain(            label_expected = match =~ /[;\\{\\}]/)]
insert[insert(+)plain(            if case_expected)]
insert[insert(+)plain(              label_expected = true if match == ':')]
insert[insert(+)plain(              case_expected = false)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)]
insert[insert(+)plain(          elsif match = scan(/ [A-Za-z_][A-Za-z_0-9]* /x\))]
insert[insert(+)plain(            kind = IDENT_KIND[match])]
insert[insert(+)plain(            if kind == :ident && label_expected && !in_preproc_line && scan(/:(?!:\)/\))]
insert[insert(+)plain(              kind = :label)]
insert[insert(+)plain(              match << matched)]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              label_expected = false)]
insert[insert(+)plain(              if kind == :reserved)]
insert[insert(+)plain(                case match)]
insert[insert(+)plain(                when 'class')]
insert[insert(+)plain(                  state = :class_name_expected)]
insert[insert(+)plain(                when 'case', 'default')]
insert[insert(+)plain(                  case_expected = true)]
insert[insert(+)plain(                end)]
insert[insert(+)plain(              end)]
insert[insert(+)plain(            end)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/\\$/\))]
insert[insert(+)plain(            kind = :ident)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/L?"/\))]
insert[insert(+)plain(            tokens << [:open, :string])]
insert[insert(+)plain(            if match[0] == ?L)]
insert[insert(+)plain(              tokens << ['L', :modifier])]
insert[insert(+)plain(              match = '"')]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            state = :string)]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/#[ \\t]*(\\w*\)/\))]
insert[insert(+)plain(            kind = :preprocessor)]
insert[insert(+)plain(            in_preproc_line = true)]
insert[insert(+)plain(            label_expected_before_preproc_line = label_expected)]
insert[insert(+)plain(            state = :include_expected if self[1] == 'include')]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/ L?' (?: [^\\'\\n\\\\] | \\\\ #{ESCAPE} \)? '? /ox\))]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            kind = :char)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/0[xX][0-9A-Fa-f]+/\))]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            kind = :hex)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/(?:0[0-7]+\)(?![89.eEfF]\)/\))]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            kind = :oct)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/(?:\\d+\)(?![.eEfF]\)L?L?/\))]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            kind = :integer)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/\\d[fF]?|\\d*\\.\\d+(?:[eE][+-]?\\d+\)?[fF]?|\\d+[eE][+-]?\\d+[fF]?/\))]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            kind = :float)]
insert[insert(+)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            getch)]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)]
insert[insert(+)plain(          end)]
insert[insert(+)]
insert[insert(+)plain(        when :string)]
insert[insert(+)plain(          if scan(/[^\\\\"]+/\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif scan(/"/\))]
insert[insert(+)plain(            tokens << ['"', :delimiter])]
insert[insert(+)plain(            tokens << [:close, :string])]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif scan(/ \\\\ (?: #{ESCAPE} | #{UNICODE_ESCAPE} \) /mox\))]
insert[insert(+)plain(            kind = :char)]
insert[insert(+)plain(          elsif scan(/ \\\\ | $ /x\))]
insert[insert(+)plain(            tokens << [:close, :string])]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            raise_inspect "else case \\" reached; %p not handled." % peek(1\), tokens)]
insert[insert(+)plain(          end)]
insert[insert(+)]
insert[insert(+)plain(        when :include_expected)]
insert[insert(+)plain(          if scan(/<[^>\\n]+>?|"[^"\\n\\\\]*(?:\\\\.[^"\\n\\\\]*\)*"?/\))]
insert[insert(+)plain(            kind = :include)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)]
insert[insert(+)plain(          elsif match = scan(/\\s+/\))]
insert[insert(+)plain(            kind = :space)]
insert[insert(+)plain(            state = :initial if match.index ?\\n)]
insert[insert(+)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            next)]
insert[insert(+)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        when :class_name_expected)]
insert[insert(+)plain(          if scan(/ [A-Za-z_][A-Za-z_0-9]* /x\))]
insert[insert(+)plain(            kind = :class)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)]
insert[insert(+)plain(          elsif match = scan(/\\s+/\))]
insert[insert(+)plain(            kind = :space)]
insert[insert(+)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            getch)]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          raise_inspect 'Unknown state', tokens)]
insert[insert(+)]
insert[insert(+)plain(        end)]
insert[insert(+)]
insert[insert(+)plain(        match ||= matched)]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
insert[insert(+)plain(          raise_inspect 'Error token %p in line %d' %)]
insert[insert(+)plain(            [[match, kind], line], tokens)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        raise_inspect 'Empty token', tokens unless match)]
insert[insert(+)]
insert[insert(+)plain(        tokens << [match, kind])]
insert[insert(+)]
insert[insert(+)plain(      end)]
insert[insert(+)]
insert[insert(+)plain(      if state == :string)]
insert[insert(+)plain(        tokens << [:close, :string])]
insert[insert(+)plain(      end)]
insert[insert(+)]
insert[insert(+)plain(      tokens)]
insert[insert(+)plain(    end)]
insert[insert(+)]
insert[insert(+)plain(  end)]
insert[insert(+)]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/scanners/groovy.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/groovy.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/groovy.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,267 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Scanners)]
insert[insert(+)]
insert[insert(+)plain(  load :java)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # Scanner for Groovy.)]
insert[insert(+)plain(  class Groovy < Java)]
insert[insert(+)]
insert[insert(+)plain(    include Streamable)]
insert[insert(+)plain(    register_for :groovy)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    # TODO: check list of keywords)]
insert[insert(+)plain(    GROOVY_KEYWORDS = %w[)]
insert[insert(+)plain(      as assert def in)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    KEYWORDS_EXPECTING_VALUE = WordList.new.add %w[)]
insert[insert(+)plain(      case instanceof new return throw typeof while as assert in)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    GROOVY_MAGIC_VARIABLES = %w[ it ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    IDENT_KIND = Java::IDENT_KIND.dup.)]
insert[insert(+)plain(      add(GROOVY_KEYWORDS, :keyword\).)]
insert[insert(+)plain(      add(GROOVY_MAGIC_VARIABLES, :local_variable\)  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    ESCAPE = / [bfnrtv$\\n\\\\'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} /x  # :nodoc:)]
insert[insert(+)plain(    UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} /x  # :nodoc: no 4-byte unicode chars? U[a-fA-F0-9]{8})]
insert[insert(+)plain(    REGEXP_ESCAPE =  / [bfnrtv\\n\\\\'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} | \\d | [bBdDsSwW\\/] /x  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    # TODO: interpretation inside ', ", /)]
insert[insert(+)plain(    STRING_CONTENT_PATTERN = {)]
insert[insert(+)plain(      "'" => /(?>\\\\[^\\\\'\\n]+|[^\\\\'\\n]+\)+/,)]
insert[insert(+)plain(      '"' => /[^\\\\$"\\n]+/,)]
insert[insert(+)plain(      "'''" => /(?>[^\\\\']+|'(?!''\)\)+/,)]
insert[insert(+)plain(      '"""' => /(?>[^\\\\$"]+|"(?!""\)\)+/,)]
insert[insert(+)plain(      '/' => /[^\\\\$\\/\\n]+/,)]
insert[insert(+)plain(    }  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def scan_tokens tokens, options)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      state = :initial)]
insert[insert(+)plain(      inline_block_stack = [])]
insert[insert(+)plain(      inline_block_paren_depth = nil)]
insert[insert(+)plain(      string_delimiter = nil)]
insert[insert(+)plain(      import_clause = class_name_follows = last_token = after_def = false)]
insert[insert(+)plain(      value_expected = true)]
insert[insert(+)]
insert[insert(+)plain(      until eos?)]
insert[insert(+)]
insert[insert(+)plain(        kind = nil)]
insert[insert(+)plain(        match = nil)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        case state)]
insert[insert(+)]
insert[insert(+)plain(        when :initial)]
insert[insert(+)]
insert[insert(+)plain(          if match = scan(/ \\s+ | \\\\\\n /x\))]
insert[insert(+)plain(            tokens << [match, :space])]
insert[insert(+)plain(            if match.index ?\\n)]
insert[insert(+)plain(              import_clause = after_def = false)]
insert[insert(+)plain(              value_expected = true unless value_expected)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(%r! // [^\\n\\\\]* (?: \\\\. [^\\n\\\\]* \)* | /\\* (?: .*? \\*/ | .* \) !mx\))]
insert[insert(+)plain(            value_expected = true)]
insert[insert(+)plain(            after_def = false)]
insert[insert(+)plain(            kind = :comment)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif bol? && scan(/ \\#!.* /x\))]
insert[insert(+)plain(            kind = :doctype)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif import_clause && scan(/ (?!as\) #{IDENT} (?: \\. #{IDENT} \)* (?: \\.\\* \)? /ox\))]
insert[insert(+)plain(            after_def = value_expected = false)]
insert[insert(+)plain(            kind = :include)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/ #{IDENT} | \\[\\] /ox\))]
insert[insert(+)plain(            kind = IDENT_KIND[match])]
insert[insert(+)plain(            value_expected = (kind == :keyword\) && KEYWORDS_EXPECTING_VALUE[match])]
insert[insert(+)plain(            if last_token == '.')]
insert[insert(+)plain(              kind = :ident)]
insert[insert(+)plain(            elsif class_name_follows)]
insert[insert(+)plain(              kind = :class)]
insert[insert(+)plain(              class_name_follows = false)]
insert[insert(+)plain(            elsif after_def && check(/\\s*[({]/\))]
insert[insert(+)plain(              kind = :method)]
insert[insert(+)plain(              after_def = false)]
insert[insert(+)plain(            elsif kind == :ident && last_token != '?' && check(/:/\))]
insert[insert(+)plain(              kind = :key)]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              class_name_follows = true if match == 'class' || (import_clause && match == 'as'\))]
insert[insert(+)plain(              import_clause = match == 'import')]
insert[insert(+)plain(              after_def = true if match == 'def')]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/;/\))]
insert[insert(+)plain(            import_clause = after_def = false)]
insert[insert(+)plain(            value_expected = true)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/\\{/\))]
insert[insert(+)plain(            class_name_follows = after_def = false)]
insert[insert(+)plain(            value_expected = true)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(            if !inline_block_stack.empty?)]
insert[insert(+)plain(              inline_block_paren_depth += 1)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          # TODO: ~'...', ~"..." and ~/.../ style regexps)]
insert[insert(+)plain(          elsif match = scan(/ \\.\\.<? | \\*?\\.(?!\\d\)@? | \\.& | \\?:? | [,?:(\\[] | -[->] | \\+\\+ |)]
insert[insert(+)plain(              && | \\|\\| | \\*\\*=? | ==?~ | <=?>? | [-+*%^~&|>=!]=? | <<<?=? | >>>?=? /x\))]
insert[insert(+)plain(            value_expected = true)]
insert[insert(+)plain(            value_expected = :regexp if match == '~')]
insert[insert(+)plain(            after_def = false)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/ [\)\\]}] /x\))]
insert[insert(+)plain(            value_expected = after_def = false)]
insert[insert(+)plain(            if !inline_block_stack.empty? && match == '}')]
insert[insert(+)plain(              inline_block_paren_depth -= 1)]
insert[insert(+)plain(              if inline_block_paren_depth == 0  # closing brace of inline block reached)]
insert[insert(+)plain(                tokens << [match, :inline_delimiter])]
insert[insert(+)plain(                tokens << [:close, :inline])]
insert[insert(+)plain(                state, string_delimiter, inline_block_paren_depth = inline_block_stack.pop)]
insert[insert(+)plain(                next)]
insert[insert(+)plain(              end)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif check(/[\\d.]/\))]
insert[insert(+)plain(            after_def = value_expected = false)]
insert[insert(+)plain(            if scan(/0[xX][0-9A-Fa-f]+/\))]
insert[insert(+)plain(              kind = :hex)]
insert[insert(+)plain(            elsif scan(/(?>0[0-7]+\)(?![89.eEfF]\)/\))]
insert[insert(+)plain(              kind = :oct)]
insert[insert(+)plain(            elsif scan(/\\d+[fFdD]|\\d*\\.\\d+(?:[eE][+-]?\\d+\)?[fFdD]?|\\d+[eE][+-]?\\d+[fFdD]?/\))]
insert[insert(+)plain(              kind = :float)]
insert[insert(+)plain(            elsif scan(/\\d+[lLgG]?/\))]
insert[insert(+)plain(              kind = :integer)]
insert[insert(+)plain(            end)]
insert[insert(+)]
insert[insert(+)plain(          elsif match = scan(/'''|"""/\))]
insert[insert(+)plain(            after_def = value_expected = false)]
insert[insert(+)plain(            state = :multiline_string)]
insert[insert(+)plain(            tokens << [:open, :string])]
insert[insert(+)plain(            string_delimiter = match)]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          # TODO: record.'name' syntax)]
insert[insert(+)plain(          elsif match = scan(/["']/\))]
insert[insert(+)plain(            after_def = value_expected = false)]
insert[insert(+)plain(            state = match == '/' ? :regexp : :string)]
insert[insert(+)plain(            tokens << [:open, state])]
insert[insert(+)plain(            string_delimiter = match)]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)]
insert[insert(+)plain(          elsif value_expected && (match = scan(/\\//\)\))]
insert[insert(+)plain(            after_def = value_expected = false)]
insert[insert(+)plain(            tokens << [:open, :regexp])]
insert[insert(+)plain(            state = :regexp)]
insert[insert(+)plain(            string_delimiter = '/')]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/ @ #{IDENT} /ox\))]
insert[insert(+)plain(            after_def = value_expected = false)]
insert[insert(+)plain(            kind = :annotation)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/\\//\))]
insert[insert(+)plain(            after_def = false)]
insert[insert(+)plain(            value_expected = true)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            getch)]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)]
insert[insert(+)plain(          end)]
insert[insert(+)]
insert[insert(+)plain(        when :string, :regexp, :multiline_string)]
insert[insert(+)plain(          if scan(STRING_CONTENT_PATTERN[string_delimiter]\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(            )]
insert[insert(+)plain(          elsif match = scan(state == :multiline_string ? /'''|"""/ : /["'\\/]/\))]
insert[insert(+)plain(            tokens << [match, :delimiter])]
insert[insert(+)plain(            if state == :regexp)]
insert[insert(+)plain(              # TODO: regexp modifiers? s, m, x, i?)]
insert[insert(+)plain(              modifiers = scan(/[ix]+/\))]
insert[insert(+)plain(              tokens << [modifiers, :modifier] if modifiers && !modifiers.empty?)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            state = :string if state == :multiline_string)]
insert[insert(+)plain(            tokens << [:close, state])]
insert[insert(+)plain(            string_delimiter = nil)]
insert[insert(+)plain(            after_def = value_expected = false)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif (state == :string || state == :multiline_string\) &&)]
insert[insert(+)plain(              (match = scan(/ \\\\ (?: #{ESCAPE} | #{UNICODE_ESCAPE} \) /mox\)\))]
insert[insert(+)plain(            if string_delimiter[0] == ?' && !(match == "\\\\\\\\" || match == "\\\\'"\))]
insert[insert(+)plain(              kind = :content)]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              kind = :char)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          elsif state == :regexp && scan(/ \\\\ (?: #{REGEXP_ESCAPE} | #{UNICODE_ESCAPE} \) /mox\))]
insert[insert(+)plain(            kind = :char)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/ \\$ #{IDENT} /mox\))]
insert[insert(+)plain(            tokens << [:open, :inline])]
insert[insert(+)plain(            tokens << ['$', :inline_delimiter])]
insert[insert(+)plain(            match = match[1..-1])]
insert[insert(+)plain(            tokens << [match, IDENT_KIND[match]])]
insert[insert(+)plain(            tokens << [:close, :inline])]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif match = scan(/ \\$ \\{ /x\))]
insert[insert(+)plain(            tokens << [:open, :inline])]
insert[insert(+)plain(            tokens << ['${', :inline_delimiter])]
insert[insert(+)plain(            inline_block_stack << [state, string_delimiter, inline_block_paren_depth])]
insert[insert(+)plain(            inline_block_paren_depth = 1)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/ \\$ /mx\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/ \\\\. /mx\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/ \\\\ | \\n /x\))]
insert[insert(+)plain(            tokens << [:close, state])]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(            after_def = value_expected = false)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            raise_inspect "else case \\" reached; %p not handled." % peek(1\), tokens)]
insert[insert(+)plain(          end)]
insert[insert(+)]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          raise_inspect 'Unknown state', tokens)]
insert[insert(+)]
insert[insert(+)plain(        end)]
insert[insert(+)]
insert[insert(+)plain(        match ||= matched)]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
insert[insert(+)plain(          raise_inspect 'Error token %p in line %d' %)]
insert[insert(+)plain(            [[match, kind], line], tokens)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        raise_inspect 'Empty token', tokens unless match)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        last_token = match unless [:space, :comment, :doctype].include? kind)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        tokens << [match, kind])]
insert[insert(+)]
insert[insert(+)plain(      end)]
insert[insert(+)]
insert[insert(+)plain(      if [:multiline_string, :string, :regexp].include? state)]
insert[insert(+)plain(        tokens << [:close, state])]
insert[insert(+)plain(      end)]
insert[insert(+)]
insert[insert(+)plain(      tokens)]
insert[insert(+)plain(    end)]
insert[insert(+)]
insert[insert(+)plain(  end)]
insert[insert(+)]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/scanners/rhtml.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/rhtml.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/rhtml.rb	(revision 500\))]
change[change(@@)plain( -4,13 +4,14 )change(@@)]
comment(   load :html)
comment(   load :ruby)
comment( )
delete[delete(-)plain(  # RHTML Scanner)]
delete[delete(-)plain(  #)]
delete[delete(-)plain(  # $Id$)]
insert[insert(+)plain(  # Scanner for HTML ERB templates.)]
comment(   class RHTML < Scanner)
comment( )
comment(     include Streamable)
comment(     register_for :rhtml)
insert[insert(+)plain(    title 'HTML ERB Template')]
insert[insert(+)plain(    )]
insert[insert(+)plain(    KINDS_NOT_LOC = HTML::KINDS_NOT_LOC)]
comment( )
comment(     ERB_RUBY_BLOCK = /)
comment(       <%(?!%\)[=-]?)
change[change(@@)plain( -22,13 +23,13 )change(@@)]
comment(         \)*)
comment(       \))
comment(       (?: -?%> \)?)
delete[delete(-)plain(    /x)]
insert[insert(+)plain(    /x  # :nodoc:)]
comment( )
comment(     START_OF_ERB = /)
comment(       <%(?!%\))
delete[delete(-)plain(    /x)]
insert[insert(+)plain(    /x  # :nodoc:)]
comment( )
delete[delete(-)plain(  private)]
insert[insert(+)plain(  protected)]
comment( )
comment(     def setup)
comment(       @ruby_scanner = CodeRay.scanner :ruby, :tokens => @tokens, :keep_tokens => true)
head[head(Index: )plain(lib/coderay/scanners/debug.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/debug.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/debug.rb	(revision 500\))]
change[change(@@)plain( -6,6 +6,8 )change(@@)]
comment( )
comment(     include Streamable)
comment(     register_for :debug)
insert[insert(+)plain(    file_extension 'raydebug')]
insert[insert(+)plain(    title 'CodeRay Token Dump')]
comment( )
comment(   protected)
comment(     def scan_tokens tokens, options)
head[head(Index: )plain(lib/coderay/scanners/php.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/php.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/php.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,532 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Scanners)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  load :html)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # Scanner for PHP.)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Original by Stefan Walk.)]
insert[insert(+)plain(  class PHP < Scanner)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    register_for :php)]
insert[insert(+)plain(    file_extension 'php')]
insert[insert(+)plain(    )]
insert[insert(+)plain(    KINDS_NOT_LOC = HTML::KINDS_NOT_LOC)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def setup)]
insert[insert(+)plain(      @html_scanner = CodeRay.scanner :html, :tokens => @tokens, :keep_tokens => true, :keep_state => true)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def reset_instance)]
insert[insert(+)plain(      super)]
insert[insert(+)plain(      @html_scanner.reset)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    module Words  # :nodoc:)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      # according to http://www.php.net/manual/en/reserved.keywords.php)]
insert[insert(+)plain(      KEYWORDS = %w[)]
insert[insert(+)plain(        abstract and array as break case catch class clone const continue declare default do else elseif)]
insert[insert(+)plain(        enddeclare endfor endforeach endif endswitch endwhile extends final for foreach function global)]
insert[insert(+)plain(        goto if implements interface instanceof namespace new or private protected public static switch)]
insert[insert(+)plain(        throw try use var while xor)]
insert[insert(+)plain(        cfunction old_function)]
insert[insert(+)plain(      ])]
insert[insert(+)plain(      )]
insert[insert(+)plain(      TYPES = %w[ int integer float double bool boolean string array object resource ])]
insert[insert(+)plain(      )]
insert[insert(+)plain(      LANGUAGE_CONSTRUCTS = %w[)]
insert[insert(+)plain(        die echo empty exit eval include include_once isset list)]
insert[insert(+)plain(        require require_once return print unset)]
insert[insert(+)plain(      ])]
insert[insert(+)plain(      )]
insert[insert(+)plain(      CLASSES = %w[ Directory stdClass __PHP_Incomplete_Class exception php_user_filter Closure ])]
insert[insert(+)plain(      )]
insert[insert(+)plain(      # according to http://php.net/quickref.php on 2009-04-21;)]
insert[insert(+)plain(      # all functions with _ excluded (module functions\) and selected additional functions)]
insert[insert(+)plain(      BUILTIN_FUNCTIONS = %w[)]
insert[insert(+)plain(        abs acos acosh addcslashes addslashes aggregate array arsort ascii2ebcdic asin asinh asort assert atan atan2)]
insert[insert(+)plain(        atanh basename bcadd bccomp bcdiv bcmod bcmul bcpow bcpowmod bcscale bcsqrt bcsub bin2hex bindec)]
insert[insert(+)plain(        bindtextdomain bzclose bzcompress bzdecompress bzerrno bzerror bzerrstr bzflush bzopen bzread bzwrite)]
insert[insert(+)plain(        calculhmac ceil chdir checkdate checkdnsrr chgrp chmod chop chown chr chroot clearstatcache closedir closelog)]
insert[insert(+)plain(        compact constant copy cos cosh count crc32 crypt current date dcgettext dcngettext deaggregate decbin dechex)]
insert[insert(+)plain(        decoct define defined deg2rad delete dgettext die dirname diskfreespace dl dngettext doubleval each)]
insert[insert(+)plain(        ebcdic2ascii echo empty end ereg eregi escapeshellarg escapeshellcmd eval exec exit exp explode expm1 extract)]
insert[insert(+)plain(        fclose feof fflush fgetc fgetcsv fgets fgetss file fileatime filectime filegroup fileinode filemtime fileowner)]
insert[insert(+)plain(        fileperms filepro filesize filetype floatval flock floor flush fmod fnmatch fopen fpassthru fprintf fputcsv)]
insert[insert(+)plain(        fputs fread frenchtojd fscanf fseek fsockopen fstat ftell ftok ftruncate fwrite getallheaders getcwd getdate)]
insert[insert(+)plain(        getenv gethostbyaddr gethostbyname gethostbynamel getimagesize getlastmod getmxrr getmygid getmyinode getmypid)]
insert[insert(+)plain(        getmyuid getopt getprotobyname getprotobynumber getrandmax getrusage getservbyname getservbyport gettext)]
insert[insert(+)plain(        gettimeofday gettype glob gmdate gmmktime gmstrftime gregoriantojd gzclose gzcompress gzdecode gzdeflate)]
insert[insert(+)plain(        gzencode gzeof gzfile gzgetc gzgets gzgetss gzinflate gzopen gzpassthru gzputs gzread gzrewind gzseek gztell)]
insert[insert(+)plain(        gzuncompress gzwrite hash header hebrev hebrevc hexdec htmlentities htmlspecialchars hypot iconv idate)]
insert[insert(+)plain(        implode include intval ip2long iptcembed iptcparse isset)]
insert[insert(+)plain(        jddayofweek jdmonthname jdtofrench jdtogregorian jdtojewish jdtojulian jdtounix jewishtojd join jpeg2wbmp)]
insert[insert(+)plain(        juliantojd key krsort ksort lcfirst lchgrp lchown levenshtein link linkinfo list localeconv localtime log)]
insert[insert(+)plain(        log10 log1p long2ip lstat ltrim mail main max md5 metaphone mhash microtime min mkdir mktime msql natcasesort)]
insert[insert(+)plain(        natsort next ngettext nl2br nthmac octdec opendir openlog)]
insert[insert(+)plain(        ord overload pack passthru pathinfo pclose pfsockopen phpcredits phpinfo phpversion pi png2wbmp popen pos pow)]
insert[insert(+)plain(        prev print printf putenv quotemeta rad2deg rand range rawurldecode rawurlencode readdir readfile readgzfile)]
insert[insert(+)plain(        readline readlink realpath recode rename require reset rewind rewinddir rmdir round rsort rtrim scandir)]
insert[insert(+)plain(        serialize setcookie setlocale setrawcookie settype sha1 shuffle signeurlpaiement sin sinh sizeof sleep snmpget)]
insert[insert(+)plain(        snmpgetnext snmprealwalk snmpset snmpwalk snmpwalkoid sort soundex split spliti sprintf sqrt srand sscanf stat)]
insert[insert(+)plain(        strcasecmp strchr strcmp strcoll strcspn strftime stripcslashes stripos stripslashes stristr strlen)]
insert[insert(+)plain(        strnatcasecmp strnatcmp strncasecmp strncmp strpbrk strpos strptime strrchr strrev strripos strrpos strspn)]
insert[insert(+)plain(        strstr strtok strtolower strtotime strtoupper strtr strval substr symlink syslog system tan tanh tempnam)]
insert[insert(+)plain(        textdomain time tmpfile touch trim uasort ucfirst ucwords uksort umask uniqid unixtojd unlink unpack)]
insert[insert(+)plain(        unserialize unset urldecode urlencode usleep usort vfprintf virtual vprintf vsprintf wordwrap)]
insert[insert(+)plain(        array_change_key_case array_chunk array_combine array_count_values array_diff array_diff_assoc)]
insert[insert(+)plain(        array_diff_key array_diff_uassoc array_diff_ukey array_fill array_fill_keys array_filter array_flip)]
insert[insert(+)plain(        array_intersect array_intersect_assoc array_intersect_key array_intersect_uassoc array_intersect_ukey)]
insert[insert(+)plain(        array_key_exists array_keys array_map array_merge array_merge_recursive array_multisort array_pad)]
insert[insert(+)plain(        array_pop array_product array_push array_rand array_reduce array_reverse array_search array_shift)]
insert[insert(+)plain(        array_slice array_splice array_sum array_udiff array_udiff_assoc array_udiff_uassoc array_uintersect)]
insert[insert(+)plain(        array_uintersect_assoc array_uintersect_uassoc array_unique array_unshift array_values array_walk)]
insert[insert(+)plain(        array_walk_recursive)]
insert[insert(+)plain(        assert_options base_convert base64_decode base64_encode)]
insert[insert(+)plain(        chunk_split class_exists class_implements class_parents)]
insert[insert(+)plain(        count_chars debug_backtrace debug_print_backtrace debug_zval_dump)]
insert[insert(+)plain(        error_get_last error_log error_reporting extension_loaded)]
insert[insert(+)plain(        file_exists file_get_contents file_put_contents load_file)]
insert[insert(+)plain(        func_get_arg func_get_args func_num_args function_exists)]
insert[insert(+)plain(        get_browser get_called_class get_cfg_var get_class get_class_methods get_class_vars)]
insert[insert(+)plain(        get_current_user get_declared_classes get_declared_interfaces get_defined_constants)]
insert[insert(+)plain(        get_defined_functions get_defined_vars get_extension_funcs get_headers get_html_translation_table)]
insert[insert(+)plain(        get_include_path get_included_files get_loaded_extensions get_magic_quotes_gpc get_magic_quotes_runtime)]
insert[insert(+)plain(        get_meta_tags get_object_vars get_parent_class get_required_filesget_resource_type)]
insert[insert(+)plain(        gc_collect_cycles gc_disable gc_enable gc_enabled)]
insert[insert(+)plain(        halt_compiler headers_list headers_sent highlight_file highlight_string)]
insert[insert(+)plain(        html_entity_decode htmlspecialchars_decode)]
insert[insert(+)plain(        in_array include_once inclued_get_data)]
insert[insert(+)plain(        is_a is_array is_binary is_bool is_buffer is_callable is_dir is_double is_executable is_file is_finite)]
insert[insert(+)plain(        is_float is_infinite is_int is_integer is_link is_long is_nan is_null is_numeric is_object is_readable)]
insert[insert(+)plain(        is_real is_resource is_scalar is_soap_fault is_string is_subclass_of is_unicode is_uploaded_file)]
insert[insert(+)plain(        is_writable is_writeable)]
insert[insert(+)plain(        locale_get_default locale_set_default)]
insert[insert(+)plain(        number_format override_function parse_str parse_url)]
insert[insert(+)plain(        php_check_syntax php_ini_loaded_file php_ini_scanned_files php_logo_guid php_sapi_name)]
insert[insert(+)plain(        php_strip_whitespace php_uname)]
insert[insert(+)plain(        preg_filter preg_grep preg_last_error preg_match preg_match_all preg_quote preg_replace)]
insert[insert(+)plain(        preg_replace_callback preg_split print_r)]
insert[insert(+)plain(        require_once register_shutdown_function register_tick_function)]
insert[insert(+)plain(        set_error_handler set_exception_handler set_file_buffer set_include_path)]
insert[insert(+)plain(        set_magic_quotes_runtime set_time_limit shell_exec)]
insert[insert(+)plain(        str_getcsv str_ireplace str_pad str_repeat str_replace str_rot13 str_shuffle str_split str_word_count)]
insert[insert(+)plain(        strip_tags substr_compare substr_count substr_replace)]
insert[insert(+)plain(        time_nanosleep time_sleep_until)]
insert[insert(+)plain(        token_get_all token_name trigger_error)]
insert[insert(+)plain(        unregister_tick_function use_soap_error_handler user_error)]
insert[insert(+)plain(        utf8_decode utf8_encode var_dump var_export)]
insert[insert(+)plain(        version_compare)]
insert[insert(+)plain(        zend_logo_guid zend_thread_id zend_version)]
insert[insert(+)plain(        create_function call_user_func_array)]
insert[insert(+)plain(        posix_access posix_ctermid posix_get_last_error posix_getcwd posix_getegid)]
insert[insert(+)plain(        posix_geteuid posix_getgid posix_getgrgid posix_getgrnam posix_getgroups)]
insert[insert(+)plain(        posix_getlogin posix_getpgid posix_getpgrp posix_getpid posix_getppid)]
insert[insert(+)plain(        posix_getpwnam posix_getpwuid posix_getrlimit posix_getsid posix_getuid)]
insert[insert(+)plain(        posix_initgroups posix_isatty posix_kill posix_mkfifo posix_mknod)]
insert[insert(+)plain(        posix_setegid posix_seteuid posix_setgid posix_setpgid posix_setsid)]
insert[insert(+)plain(        posix_setuid posix_strerror posix_times posix_ttyname posix_uname)]
insert[insert(+)plain(        pcntl_alarm pcntl_exec pcntl_fork pcntl_getpriority pcntl_setpriority)]
insert[insert(+)plain(        pcntl_signal pcntl_signal_dispatch pcntl_sigprocmask pcntl_sigtimedwait)]
insert[insert(+)plain(        pcntl_sigwaitinfo pcntl_wait pcntl_waitpid pcntl_wexitstatus pcntl_wifexited)]
insert[insert(+)plain(        pcntl_wifsignaled pcntl_wifstopped pcntl_wstopsig pcntl_wtermsig)]
insert[insert(+)plain(      ])]
insert[insert(+)plain(      # TODO: more built-in PHP functions?)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      EXCEPTIONS = %w[)]
insert[insert(+)plain(        E_ERROR E_WARNING E_PARSE E_NOTICE E_CORE_ERROR E_CORE_WARNING E_COMPILE_ERROR E_COMPILE_WARNING)]
insert[insert(+)plain(        E_USER_ERROR E_USER_WARNING E_USER_NOTICE E_DEPRECATED E_USER_DEPRECATED E_ALL E_STRICT)]
insert[insert(+)plain(      ])]
insert[insert(+)plain(      )]
insert[insert(+)plain(      CONSTANTS = %w[)]
insert[insert(+)plain(        null true false self parent)]
insert[insert(+)plain(        __LINE__ __DIR__ __FILE__ __LINE__)]
insert[insert(+)plain(        __CLASS__ __NAMESPACE__ __METHOD__ __FUNCTION__)]
insert[insert(+)plain(        PHP_VERSION PHP_MAJOR_VERSION PHP_MINOR_VERSION PHP_RELEASE_VERSION PHP_VERSION_ID PHP_EXTRA_VERSION PHP_ZTS)]
insert[insert(+)plain(        PHP_DEBUG PHP_MAXPATHLEN PHP_OS PHP_SAPI PHP_EOL PHP_INT_MAX PHP_INT_SIZE DEFAULT_INCLUDE_PATH)]
insert[insert(+)plain(        PEAR_INSTALL_DIR PEAR_EXTENSION_DIR PHP_EXTENSION_DIR PHP_PREFIX PHP_BINDIR PHP_LIBDIR PHP_DATADIR)]
insert[insert(+)plain(        PHP_SYSCONFDIR PHP_LOCALSTATEDIR PHP_CONFIG_FILE_PATH PHP_CONFIG_FILE_SCAN_DIR PHP_SHLIB_SUFFIX)]
insert[insert(+)plain(        PHP_OUTPUT_HANDLER_START PHP_OUTPUT_HANDLER_CONT PHP_OUTPUT_HANDLER_END)]
insert[insert(+)plain(        __COMPILER_HALT_OFFSET__)]
insert[insert(+)plain(        EXTR_OVERWRITE EXTR_SKIP EXTR_PREFIX_SAME EXTR_PREFIX_ALL EXTR_PREFIX_INVALID EXTR_PREFIX_IF_EXISTS)]
insert[insert(+)plain(        EXTR_IF_EXISTS SORT_ASC SORT_DESC SORT_REGULAR SORT_NUMERIC SORT_STRING CASE_LOWER CASE_UPPER COUNT_NORMAL)]
insert[insert(+)plain(        COUNT_RECURSIVE ASSERT_ACTIVE ASSERT_CALLBACK ASSERT_BAIL ASSERT_WARNING ASSERT_QUIET_EVAL CONNECTION_ABORTED)]
insert[insert(+)plain(        CONNECTION_NORMAL CONNECTION_TIMEOUT INI_USER INI_PERDIR INI_SYSTEM INI_ALL M_E M_LOG2E M_LOG10E M_LN2 M_LN10)]
insert[insert(+)plain(        M_PI M_PI_2 M_PI_4 M_1_PI M_2_PI M_2_SQRTPI M_SQRT2 M_SQRT1_2 CRYPT_SALT_LENGTH CRYPT_STD_DES CRYPT_EXT_DES)]
insert[insert(+)plain(        CRYPT_MD5 CRYPT_BLOWFISH DIRECTORY_SEPARATOR SEEK_SET SEEK_CUR SEEK_END LOCK_SH LOCK_EX LOCK_UN LOCK_NB)]
insert[insert(+)plain(        HTML_SPECIALCHARS HTML_ENTITIES ENT_COMPAT ENT_QUOTES ENT_NOQUOTES INFO_GENERAL INFO_CREDITS)]
insert[insert(+)plain(        INFO_CONFIGURATION INFO_MODULES INFO_ENVIRONMENT INFO_VARIABLES INFO_LICENSE INFO_ALL CREDITS_GROUP)]
insert[insert(+)plain(        CREDITS_GENERAL CREDITS_SAPI CREDITS_MODULES CREDITS_DOCS CREDITS_FULLPAGE CREDITS_QA CREDITS_ALL STR_PAD_LEFT)]
insert[insert(+)plain(        STR_PAD_RIGHT STR_PAD_BOTH PATHINFO_DIRNAME PATHINFO_BASENAME PATHINFO_EXTENSION PATH_SEPARATOR CHAR_MAX)]
insert[insert(+)plain(        LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_ALL LC_MESSAGES ABDAY_1 ABDAY_2 ABDAY_3 ABDAY_4 ABDAY_5)]
insert[insert(+)plain(        ABDAY_6 ABDAY_7 DAY_1 DAY_2 DAY_3 DAY_4 DAY_5 DAY_6 DAY_7 ABMON_1 ABMON_2 ABMON_3 ABMON_4 ABMON_5 ABMON_6)]
insert[insert(+)plain(        ABMON_7 ABMON_8 ABMON_9 ABMON_10 ABMON_11 ABMON_12 MON_1 MON_2 MON_3 MON_4 MON_5 MON_6 MON_7 MON_8 MON_9)]
insert[insert(+)plain(        MON_10 MON_11 MON_12 AM_STR PM_STR D_T_FMT D_FMT T_FMT T_FMT_AMPM ERA ERA_YEAR ERA_D_T_FMT ERA_D_FMT ERA_T_FMT)]
insert[insert(+)plain(        ALT_DIGITS INT_CURR_SYMBOL CURRENCY_SYMBOL CRNCYSTR MON_DECIMAL_POINT MON_THOUSANDS_SEP MON_GROUPING)]
insert[insert(+)plain(        POSITIVE_SIGN NEGATIVE_SIGN INT_FRAC_DIGITS FRAC_DIGITS P_CS_PRECEDES P_SEP_BY_SPACE N_CS_PRECEDES)]
insert[insert(+)plain(        N_SEP_BY_SPACE P_SIGN_POSN N_SIGN_POSN DECIMAL_POINT RADIXCHAR THOUSANDS_SEP THOUSEP GROUPING YESEXPR NOEXPR)]
insert[insert(+)plain(        YESSTR NOSTR CODESET LOG_EMERG LOG_ALERT LOG_CRIT LOG_ERR LOG_WARNING LOG_NOTICE LOG_INFO LOG_DEBUG LOG_KERN)]
insert[insert(+)plain(        LOG_USER LOG_MAIL LOG_DAEMON LOG_AUTH LOG_SYSLOG LOG_LPR LOG_NEWS LOG_UUCP LOG_CRON LOG_AUTHPRIV LOG_LOCAL0)]
insert[insert(+)plain(        LOG_LOCAL1 LOG_LOCAL2 LOG_LOCAL3 LOG_LOCAL4 LOG_LOCAL5 LOG_LOCAL6 LOG_LOCAL7 LOG_PID LOG_CONS LOG_ODELAY)]
insert[insert(+)plain(        LOG_NDELAY LOG_NOWAIT LOG_PERROR)]
insert[insert(+)plain(      ])]
insert[insert(+)plain(      )]
insert[insert(+)plain(      PREDEFINED = %w[)]
insert[insert(+)plain(        $GLOBALS $_SERVER $_GET $_POST $_FILES $_REQUEST $_SESSION $_ENV)]
insert[insert(+)plain(        $_COOKIE $php_errormsg $HTTP_RAW_POST_DATA $http_response_header)]
insert[insert(+)plain(        $argc $argv)]
insert[insert(+)plain(      ])]
insert[insert(+)plain(      )]
insert[insert(+)plain(      IDENT_KIND = CaseIgnoringWordList.new(:ident\).)]
insert[insert(+)plain(        add(KEYWORDS, :reserved\).)]
insert[insert(+)plain(        add(TYPES, :pre_type\).)]
insert[insert(+)plain(        add(LANGUAGE_CONSTRUCTS, :reserved\).)]
insert[insert(+)plain(        add(BUILTIN_FUNCTIONS, :predefined\).)]
insert[insert(+)plain(        add(CLASSES, :pre_constant\).)]
insert[insert(+)plain(        add(EXCEPTIONS, :exception\).)]
insert[insert(+)plain(        add(CONSTANTS, :pre_constant\))]
insert[insert(+)plain(      )]
insert[insert(+)plain(      VARIABLE_KIND = WordList.new(:local_variable\).)]
insert[insert(+)plain(        add(PREDEFINED, :predefined\))]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    module RE  # :nodoc:)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      PHP_START = /)]
insert[insert(+)plain(        <script\\s+[^>]*?language\\s*=\\s*"php"[^>]*?> |)]
insert[insert(+)plain(        <script\\s+[^>]*?language\\s*=\\s*'php'[^>]*?> |)]
insert[insert(+)plain(        <\\?php\\d? |)]
insert[insert(+)plain(        <\\?(?!xml\))]
insert[insert(+)plain(      /xi)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      PHP_END = %r!)]
insert[insert(+)plain(        </script> |)]
insert[insert(+)plain(        \\?>)]
insert[insert(+)plain(      !xi)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      HTML_INDICATOR = /<!DOCTYPE html|<(?:html|body|div|p\)[> ]/i)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      IDENTIFIER = /[a-z_\\x7f-\\xFF][a-z0-9_\\x7f-\\xFF]*/i)]
insert[insert(+)plain(      VARIABLE = /\\$#{IDENTIFIER}/)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      OPERATOR = /)]
insert[insert(+)plain(        \\.(?!\\d\)=? |      # dot that is not decimal point, string concatenation)]
insert[insert(+)plain(        && | \\|\\| |       # logic)]
insert[insert(+)plain(        :: | -> | => |    # scope, member, dictionary)]
insert[insert(+)plain(        \\+\\+ | -- |       # increment, decrement)]
insert[insert(+)plain(        [,;?:(\)\\[\\]{}] |  # simple delimiters)]
insert[insert(+)plain(        [-+*\\/%&|^]=? |   # ordinary math, binary logic, assignment shortcuts)]
insert[insert(+)plain(        [~$] |            # whatever)]
insert[insert(+)plain(        =& |              # reference assignment)]
insert[insert(+)plain(        [=!]=?=? | <> |   # comparison and assignment)]
insert[insert(+)plain(        <<=? | >>=? | [<>]=?  # comparison and shift)]
insert[insert(+)plain(      /x)]
insert[insert(+)plain(      )]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def scan_tokens tokens, options)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      if check(RE::PHP_START\) ||  # starts with <?)]
insert[insert(+)plain(       (match?(/\\s*<\\S/\) && exist?(RE::PHP_START\)\) || # starts with tag and contains <?)]
insert[insert(+)plain(       exist?(RE::HTML_INDICATOR\) ||)]
insert[insert(+)plain(       check(/.{1,100}#{RE::PHP_START}/om\)  # PHP start after max 100 chars)]
insert[insert(+)plain(        # is HTML with embedded PHP, so start with HTML)]
insert[insert(+)plain(        states = [:initial])]
insert[insert(+)plain(      else)]
insert[insert(+)plain(        # is just PHP, so start with PHP surrounded by HTML)]
insert[insert(+)plain(        states = [:initial, :php])]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      label_expected = true)]
insert[insert(+)plain(      case_expected = false)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      heredoc_delimiter = nil)]
insert[insert(+)plain(      delimiter = nil)]
insert[insert(+)plain(      modifier = nil)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      until eos?)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        match = nil)]
insert[insert(+)plain(        kind = nil)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        case states.last)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        when :initial  # HTML)]
insert[insert(+)plain(          if scan RE::PHP_START)]
insert[insert(+)plain(            kind = :inline_delimiter)]
insert[insert(+)plain(            label_expected = true)]
insert[insert(+)plain(            states << :php)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            match = scan_until(/(?=#{RE::PHP_START}\)/o\) || scan_until(/\\z/\))]
insert[insert(+)plain(            @html_scanner.tokenize match unless match.empty?)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        when :php)]
insert[insert(+)plain(          if match = scan(/\\s+/\))]
insert[insert(+)plain(            tokens << [match, :space])]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(%r! (?m: \\/\\* (?: .*? \\*\\/ | .* \) \) | (?://|\\#\) .*? (?=#{RE::PHP_END}|$\) !xo\))]
insert[insert(+)plain(            kind = :comment)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(RE::IDENTIFIER\))]
insert[insert(+)plain(            kind = Words::IDENT_KIND[match])]
insert[insert(+)plain(            if kind == :ident && label_expected && check(/:(?!:\)/\))]
insert[insert(+)plain(              kind = :label)]
insert[insert(+)plain(              label_expected = true)]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              label_expected = false)]
insert[insert(+)plain(              if kind == :ident && match =~ /^[A-Z]/)]
insert[insert(+)plain(                kind = :constant)]
insert[insert(+)plain(              elsif kind == :reserved)]
insert[insert(+)plain(                case match)]
insert[insert(+)plain(                when 'class')]
insert[insert(+)plain(                  states << :class_expected)]
insert[insert(+)plain(                when 'function')]
insert[insert(+)plain(                  states << :function_expected)]
insert[insert(+)plain(                when 'case', 'default')]
insert[insert(+)plain(                  case_expected = true)]
insert[insert(+)plain(                end)]
insert[insert(+)plain(              elsif match == 'b' && check(/['"]/\)  # binary string literal)]
insert[insert(+)plain(                modifier = match)]
insert[insert(+)plain(                next)]
insert[insert(+)plain(              end)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/(?:\\d+\\.\\d*|\\d*\\.\\d+\)(?:e[-+]?\\d+\)?|\\d+e[-+]?\\d+/i\))]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            kind = :float)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/0x[0-9a-fA-F]+/\))]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            kind = :hex)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/\\d+/\))]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            kind = :integer)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/'/\))]
insert[insert(+)plain(            tokens << [:open, :string])]
insert[insert(+)plain(            if modifier)]
insert[insert(+)plain(              tokens << [modifier, :modifier])]
insert[insert(+)plain(              modifier = nil)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)plain(            states.push :sqstring)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/["`]/\))]
insert[insert(+)plain(            tokens << [:open, :string])]
insert[insert(+)plain(            if modifier)]
insert[insert(+)plain(              tokens << [modifier, :modifier])]
insert[insert(+)plain(              modifier = nil)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            delimiter = match)]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)plain(            states.push :dqstring)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(RE::VARIABLE\))]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            kind = Words::VARIABLE_KIND[match])]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/\\{/\))]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(            label_expected = true)]
insert[insert(+)plain(            states.push :php)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/\\}/\))]
insert[insert(+)plain(            if states.size == 1)]
insert[insert(+)plain(              kind = :error)]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              states.pop)]
insert[insert(+)plain(              if states.last.is_a?(::Array\))]
insert[insert(+)plain(                delimiter = states.last[1])]
insert[insert(+)plain(                states[-1] = states.last[0])]
insert[insert(+)plain(                tokens << [matched, :delimiter])]
insert[insert(+)plain(                tokens << [:close, :inline])]
insert[insert(+)plain(                next)]
insert[insert(+)plain(              else)]
insert[insert(+)plain(                kind = :operator)]
insert[insert(+)plain(                label_expected = true)]
insert[insert(+)plain(              end)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/@/\))]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            kind = :exception)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan RE::PHP_END)]
insert[insert(+)plain(            kind = :inline_delimiter)]
insert[insert(+)plain(            states = [:initial])]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/<<<(?:(#{RE::IDENTIFIER}\)|"(#{RE::IDENTIFIER}\)"|'(#{RE::IDENTIFIER}\)'\)/o\))]
insert[insert(+)plain(            tokens << [:open, :string])]
insert[insert(+)plain(            warn 'heredoc in heredoc?' if heredoc_delimiter)]
insert[insert(+)plain(            heredoc_delimiter = Regexp.escape(self[1] || self[2] || self[3]\))]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)plain(            states.push self[3] ? :sqstring : :dqstring)]
insert[insert(+)plain(            heredoc_delimiter = /#{heredoc_delimiter}(?=;?$\)/)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/#{RE::OPERATOR}/o\))]
insert[insert(+)plain(            label_expected = match == ';')]
insert[insert(+)plain(            if case_expected)]
insert[insert(+)plain(              label_expected = true if match == ':')]
insert[insert(+)plain(              case_expected = false)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            getch)]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        when :sqstring)]
insert[insert(+)plain(          if scan(heredoc_delimiter ? /[^\\\\\\n]+/ : /[^'\\\\]+/\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif !heredoc_delimiter && scan(/'/\))]
insert[insert(+)plain(            tokens << [matched, :delimiter])]
insert[insert(+)plain(            tokens << [:close, :string])]
insert[insert(+)plain(            delimiter = nil)]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            states.pop)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif heredoc_delimiter && match = scan(/\\n/\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(            if scan heredoc_delimiter)]
insert[insert(+)plain(              tokens << ["\\n", :content])]
insert[insert(+)plain(              tokens << [matched, :delimiter])]
insert[insert(+)plain(              tokens << [:close, :string])]
insert[insert(+)plain(              heredoc_delimiter = nil)]
insert[insert(+)plain(              label_expected = false)]
insert[insert(+)plain(              states.pop)]
insert[insert(+)plain(              next)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          elsif scan(heredoc_delimiter ? /\\\\\\\\/ : /\\\\[\\\\'\\n]/\))]
insert[insert(+)plain(            kind = :char)]
insert[insert(+)plain(          elsif scan(/\\\\./m\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif scan(/\\\\/\))]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        when :dqstring)]
insert[insert(+)plain(          if scan(heredoc_delimiter ? /[^${\\\\\\n]+/ : (delimiter == '"' ? /[^"${\\\\]+/ : /[^`${\\\\]+/\)\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif !heredoc_delimiter && scan(delimiter == '"' ? /"/ : /`/\))]
insert[insert(+)plain(            tokens << [matched, :delimiter])]
insert[insert(+)plain(            tokens << [:close, :string])]
insert[insert(+)plain(            delimiter = nil)]
insert[insert(+)plain(            label_expected = false)]
insert[insert(+)plain(            states.pop)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif heredoc_delimiter && match = scan(/\\n/\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(            if scan heredoc_delimiter)]
insert[insert(+)plain(              tokens << ["\\n", :content])]
insert[insert(+)plain(              tokens << [matched, :delimiter])]
insert[insert(+)plain(              tokens << [:close, :string])]
insert[insert(+)plain(              heredoc_delimiter = nil)]
insert[insert(+)plain(              label_expected = false)]
insert[insert(+)plain(              states.pop)]
insert[insert(+)plain(              next)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          elsif scan(/\\\\(?:x[0-9A-Fa-f]{1,2}|[0-7]{1,3}\)/\))]
insert[insert(+)plain(            kind = :char)]
insert[insert(+)plain(          elsif scan(heredoc_delimiter ? /\\\\[nrtvf\\\\$]/ : (delimiter == '"' ? /\\\\[nrtvf\\\\$"]/ : /\\\\[nrtvf\\\\$`]/\)\))]
insert[insert(+)plain(            kind = :char)]
insert[insert(+)plain(          elsif scan(/\\\\./m\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif scan(/\\\\/\))]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(          elsif match = scan(/#{RE::VARIABLE}/o\))]
insert[insert(+)plain(            kind = :local_variable)]
insert[insert(+)plain(            if check(/\\[#{RE::IDENTIFIER}\\]/o\))]
insert[insert(+)plain(              tokens << [:open, :inline])]
insert[insert(+)plain(              tokens << [match, :local_variable])]
insert[insert(+)plain(              tokens << [scan(/\\[/\), :operator])]
insert[insert(+)plain(              tokens << [scan(/#{RE::IDENTIFIER}/o\), :ident])]
insert[insert(+)plain(              tokens << [scan(/\\]/\), :operator])]
insert[insert(+)plain(              tokens << [:close, :inline])]
insert[insert(+)plain(              next)]
insert[insert(+)plain(            elsif check(/\\[/\))]
insert[insert(+)plain(              match << scan(/\\[['"]?#{RE::IDENTIFIER}?['"]?\\]?/o\))]
insert[insert(+)plain(              kind = :error)]
insert[insert(+)plain(            elsif check(/->#{RE::IDENTIFIER}/o\))]
insert[insert(+)plain(              tokens << [:open, :inline])]
insert[insert(+)plain(              tokens << [match, :local_variable])]
insert[insert(+)plain(              tokens << [scan(/->/\), :operator])]
insert[insert(+)plain(              tokens << [scan(/#{RE::IDENTIFIER}/o\), :ident])]
insert[insert(+)plain(              tokens << [:close, :inline])]
insert[insert(+)plain(              next)]
insert[insert(+)plain(            elsif check(/->/\))]
insert[insert(+)plain(              match << scan(/->/\))]
insert[insert(+)plain(              kind = :error)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          elsif match = scan(/\\{/\))]
insert[insert(+)plain(            if check(/\\$/\))]
insert[insert(+)plain(              kind = :delimiter)]
insert[insert(+)plain(              states[-1] = [states.last, delimiter])]
insert[insert(+)plain(              delimiter = nil)]
insert[insert(+)plain(              states.push :php)]
insert[insert(+)plain(              tokens << [:open, :inline])]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              kind = :string)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          elsif scan(/\\$\\{#{RE::IDENTIFIER}\\}/o\))]
insert[insert(+)plain(            kind = :local_variable)]
insert[insert(+)plain(          elsif scan(/\\$/\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        when :class_expected)]
insert[insert(+)plain(          if scan(/\\s+/\))]
insert[insert(+)plain(            kind = :space)]
insert[insert(+)plain(          elsif match = scan(/#{RE::IDENTIFIER}/o\))]
insert[insert(+)plain(            kind = :class)]
insert[insert(+)plain(            states.pop)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            states.pop)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        when :function_expected)]
insert[insert(+)plain(          if scan(/\\s+/\))]
insert[insert(+)plain(            kind = :space)]
insert[insert(+)plain(          elsif scan(/&/\))]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          elsif match = scan(/#{RE::IDENTIFIER}/o\))]
insert[insert(+)plain(            kind = :function)]
insert[insert(+)plain(            states.pop)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            states.pop)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          raise_inspect 'Unknown state!', tokens, states)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        match ||= matched)]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
insert[insert(+)plain(          raise_inspect 'Error token %p in line %d' %)]
insert[insert(+)plain(            [[match, kind], line], tokens, states)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        raise_inspect 'Empty token', tokens, states unless match)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        tokens << [match, kind])]
insert[insert(+)plain(        )]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      tokens)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/scanners/css.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/css.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/css.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,211 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Scanners)]
insert[insert(+)]
insert[insert(+)plain(  class CSS < Scanner)]
insert[insert(+)]
insert[insert(+)plain(    register_for :css)]
insert[insert(+)]
insert[insert(+)plain(    KINDS_NOT_LOC = [)]
insert[insert(+)plain(      :comment,)]
insert[insert(+)plain(      :class, :pseudo_class, :type,)]
insert[insert(+)plain(      :constant, :directive,)]
insert[insert(+)plain(      :key, :value, :operator, :color, :float,)]
insert[insert(+)plain(      :error, :important,)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    module RE  # :nodoc:)]
insert[insert(+)plain(      NonASCII = /[\\x80-\\xFF]/)]
insert[insert(+)plain(      Hex = /[0-9a-fA-F]/)]
insert[insert(+)plain(      Unicode = /\\\\#{Hex}{1,6}(?:\\r\\n|\\s\)?/ # differs from standard because it allows uppercase hex too)]
insert[insert(+)plain(      Escape = /#{Unicode}|\\\\[^\\r\\n\\f0-9a-fA-F]/)]
insert[insert(+)plain(      NMChar = /[-_a-zA-Z0-9]|#{NonASCII}|#{Escape}/)]
insert[insert(+)plain(      NMStart = /[_a-zA-Z]|#{NonASCII}|#{Escape}/)]
insert[insert(+)plain(      NL = /\\r\\n|\\r|\\n|\\f/)]
insert[insert(+)plain(      String1 = /"(?:[^\\n\\r\\f\\\\"]|\\\\#{NL}|#{Escape}\)*"?/  # FIXME: buggy regexp)]
insert[insert(+)plain(      String2 = /'(?:[^\\n\\r\\f\\\\']|\\\\#{NL}|#{Escape}\)*'?/  # FIXME: buggy regexp)]
insert[insert(+)plain(      String = /#{String1}|#{String2}/)]
insert[insert(+)]
insert[insert(+)plain(      HexColor = /#(?:#{Hex}{6}|#{Hex}{3}\)/)]
insert[insert(+)plain(      Color = /#{HexColor}/)]
insert[insert(+)]
insert[insert(+)plain(      Num = /-?(?:[0-9]+|[0-9]*\\.[0-9]+\)/)]
insert[insert(+)plain(      Name = /#{NMChar}+/)]
insert[insert(+)plain(      Ident = /-?#{NMStart}#{NMChar}*/)]
insert[insert(+)plain(      AtKeyword = /@#{Ident}/)]
insert[insert(+)plain(      Percentage = /#{Num}%/)]
insert[insert(+)]
insert[insert(+)plain(      reldimensions = %w[em ex px])]
insert[insert(+)plain(      absdimensions = %w[in cm mm pt pc])]
insert[insert(+)plain(      Unit = Regexp.union(*(reldimensions + absdimensions\)\))]
insert[insert(+)]
insert[insert(+)plain(      Dimension = /#{Num}#{Unit}/)]
insert[insert(+)]
insert[insert(+)plain(      Comment = %r! /\\* (?: .*? \\*/ | .* \) !mx)]
insert[insert(+)plain(      Function = /(?:url|alpha\)\\((?:[^\)\\n\\r\\f]|\\\\\\\)\)*\\\)?/)]
insert[insert(+)]
insert[insert(+)plain(      Id = /##{Name}/)]
insert[insert(+)plain(      Class = /\\.#{Name}/)]
insert[insert(+)plain(      PseudoClass = /:#{Name}/)]
insert[insert(+)plain(      AttributeSelector = /\\[[^\\]]*\\]?/)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def scan_tokens tokens, options)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      value_expected = nil)]
insert[insert(+)plain(      states = [:initial])]
insert[insert(+)]
insert[insert(+)plain(      until eos?)]
insert[insert(+)]
insert[insert(+)plain(        kind = nil)]
insert[insert(+)plain(        match = nil)]
insert[insert(+)]
insert[insert(+)plain(        if scan(/\\s+/\))]
insert[insert(+)plain(          kind = :space)]
insert[insert(+)]
insert[insert(+)plain(        elsif case states.last)]
insert[insert(+)plain(          when :initial, :media)]
insert[insert(+)plain(            if scan(/(?>#{RE::Ident}\)(?!\\(\)|\\*/ox\))]
insert[insert(+)plain(              kind = :type)]
insert[insert(+)plain(            elsif scan RE::Class)]
insert[insert(+)plain(              kind = :class)]
insert[insert(+)plain(            elsif scan RE::Id)]
insert[insert(+)plain(              kind = :constant)]
insert[insert(+)plain(            elsif scan RE::PseudoClass)]
insert[insert(+)plain(              kind = :pseudo_class)]
insert[insert(+)plain(            elsif match = scan(RE::AttributeSelector\))]
insert[insert(+)plain(              # TODO: Improve highlighting inside of attribute selectors.)]
insert[insert(+)plain(              tokens << [:open, :string])]
insert[insert(+)plain(              tokens << [match[0,1], :delimiter])]
insert[insert(+)plain(              tokens << [match[1..-2], :content] if match.size > 2)]
insert[insert(+)plain(              tokens << [match[-1,1], :delimiter] if match[-1] == ?])]
insert[insert(+)plain(              tokens << [:close, :string])]
insert[insert(+)plain(              next)]
insert[insert(+)plain(            elsif match = scan(/@media/\))]
insert[insert(+)plain(              kind = :directive)]
insert[insert(+)plain(              states.push :media_before_name)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          when :block)]
insert[insert(+)plain(            if scan(/(?>#{RE::Ident}\)(?!\\(\)/ox\))]
insert[insert(+)plain(              if value_expected)]
insert[insert(+)plain(                kind = :value)]
insert[insert(+)plain(              else)]
insert[insert(+)plain(                kind = :key)]
insert[insert(+)plain(              end)]
insert[insert(+)plain(            end)]
insert[insert(+)]
insert[insert(+)plain(          when :media_before_name)]
insert[insert(+)plain(            if scan RE::Ident)]
insert[insert(+)plain(              kind = :type)]
insert[insert(+)plain(              states[-1] = :media_after_name)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          when :media_after_name)]
insert[insert(+)plain(            if scan(/\\{/\))]
insert[insert(+)plain(              kind = :operator)]
insert[insert(+)plain(              states[-1] = :media)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          when :comment)]
insert[insert(+)plain(            if scan(/(?:[^*\\s]|\\*(?!\\/\)\)+/\))]
insert[insert(+)plain(              kind = :comment)]
insert[insert(+)plain(            elsif scan(/\\*\\//\))]
insert[insert(+)plain(              kind = :comment)]
insert[insert(+)plain(              states.pop)]
insert[insert(+)plain(            elsif scan(/\\s+/\))]
insert[insert(+)plain(              kind = :space)]
insert[insert(+)plain(            end)]
insert[insert(+)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            raise_inspect 'Unknown state', tokens)]
insert[insert(+)]
insert[insert(+)plain(          end)]
insert[insert(+)]
insert[insert(+)plain(        elsif scan(/\\/\\*/\))]
insert[insert(+)plain(          kind = :comment)]
insert[insert(+)plain(          states.push :comment)]
insert[insert(+)]
insert[insert(+)plain(        elsif scan(/\\{/\))]
insert[insert(+)plain(          value_expected = false)]
insert[insert(+)plain(          kind = :operator)]
insert[insert(+)plain(          states.push :block)]
insert[insert(+)]
insert[insert(+)plain(        elsif scan(/\\}/\))]
insert[insert(+)plain(          value_expected = false)]
insert[insert(+)plain(          if states.last == :block || states.last == :media)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(            states.pop)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(          end)]
insert[insert(+)]
insert[insert(+)plain(        elsif match = scan(/#{RE::String}/o\))]
insert[insert(+)plain(          tokens << [:open, :string])]
insert[insert(+)plain(          tokens << [match[0, 1], :delimiter])]
insert[insert(+)plain(          tokens << [match[1..-2], :content] if match.size > 2)]
insert[insert(+)plain(          tokens << [match[-1, 1], :delimiter] if match.size >= 2)]
insert[insert(+)plain(          tokens << [:close, :string])]
insert[insert(+)plain(          next)]
insert[insert(+)]
insert[insert(+)plain(        elsif match = scan(/#{RE::Function}/o\))]
insert[insert(+)plain(          tokens << [:open, :string])]
insert[insert(+)plain(          start = match[/^\\w+\\(/])]
insert[insert(+)plain(          tokens << [start, :delimiter])]
insert[insert(+)plain(          if match[-1] == ?\))]
insert[insert(+)plain(            tokens << [match[start.size..-2], :content])]
insert[insert(+)plain(            tokens << ['\)', :delimiter])]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            tokens << [match[start.size..-1], :content])]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          tokens << [:close, :string])]
insert[insert(+)plain(          next)]
insert[insert(+)]
insert[insert(+)plain(        elsif scan(/(?: #{RE::Dimension} | #{RE::Percentage} | #{RE::Num} \)/ox\))]
insert[insert(+)plain(          kind = :float)]
insert[insert(+)]
insert[insert(+)plain(        elsif scan(/#{RE::Color}/o\))]
insert[insert(+)plain(          kind = :color)]
insert[insert(+)]
insert[insert(+)plain(        elsif scan(/! *important/\))]
insert[insert(+)plain(          kind = :important)]
insert[insert(+)]
insert[insert(+)plain(        elsif scan(/rgb\\([^(\)\\n]*\\\)?/\))]
insert[insert(+)plain(          kind = :color)]
insert[insert(+)]
insert[insert(+)plain(        elsif scan(/#{RE::AtKeyword}/o\))]
insert[insert(+)plain(          kind = :directive)]
insert[insert(+)]
insert[insert(+)plain(        elsif match = scan(/ [+>:;,.=(\)\\/] /x\))]
insert[insert(+)plain(          if match == ':')]
insert[insert(+)plain(            value_expected = true)]
insert[insert(+)plain(          elsif match == ';')]
insert[insert(+)plain(            value_expected = false)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          kind = :operator)]
insert[insert(+)]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          getch)]
insert[insert(+)plain(          kind = :error)]
insert[insert(+)]
insert[insert(+)plain(        end)]
insert[insert(+)]
insert[insert(+)plain(        match ||= matched)]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
insert[insert(+)plain(          raise_inspect 'Error token %p in line %d' %)]
insert[insert(+)plain(            [[match, kind], line], tokens)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        raise_inspect 'Empty token', tokens unless match)]
insert[insert(+)]
insert[insert(+)plain(        tokens << [match, kind])]
insert[insert(+)]
insert[insert(+)plain(      end)]
insert[insert(+)]
insert[insert(+)plain(      tokens)]
insert[insert(+)plain(    end)]
insert[insert(+)]
insert[insert(+)plain(  end)]
insert[insert(+)]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/scanners/sql.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/sql.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/sql.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,176 )change(@@)]
insert[insert(+)plain(module CodeRay module Scanners)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # by Josh Goebel)]
insert[insert(+)plain(  class SQL < Scanner)]
insert[insert(+)]
insert[insert(+)plain(    register_for :sql)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    RESERVED_WORDS = %w()]
insert[insert(+)plain(      all and as before begin by case collate)]
insert[insert(+)plain(      constraint create else end engine exists)]
insert[insert(+)plain(      for foreign from group if inner is join key)]
insert[insert(+)plain(      like not on or order outer primary references replace)]
insert[insert(+)plain(      then to trigger union using values when where)]
insert[insert(+)plain(      left)]
insert[insert(+)plain(    \))]
insert[insert(+)plain(    )]
insert[insert(+)plain(    OBJECTS = %w()]
insert[insert(+)plain(      database databases table tables column columns index)]
insert[insert(+)plain(    \))]
insert[insert(+)plain(    )]
insert[insert(+)plain(    COMMANDS = %w()]
insert[insert(+)plain(      add alter comment create delete drop grant insert into select update set)]
insert[insert(+)plain(      show)]
insert[insert(+)plain(    \))]
insert[insert(+)plain(    )]
insert[insert(+)plain(    PREDEFINED_TYPES = %w()]
insert[insert(+)plain(      char varchar enum binary text tinytext mediumtext)]
insert[insert(+)plain(      longtext blob tinyblob mediumblob longblob timestamp)]
insert[insert(+)plain(      date time datetime year double decimal float int)]
insert[insert(+)plain(      integer tinyint mediumint bigint smallint unsigned bit)]
insert[insert(+)plain(      bool boolean hex bin oct)]
insert[insert(+)plain(    \))]
insert[insert(+)plain(    )]
insert[insert(+)plain(    PREDEFINED_FUNCTIONS = %w( sum cast substring abs pi count min max avg \))]
insert[insert(+)plain(    )]
insert[insert(+)plain(    DIRECTIVES = %w( auto_increment unique default charset \))]
insert[insert(+)plain(    )]
insert[insert(+)plain(    PREDEFINED_CONSTANTS = %w( null true false \))]
insert[insert(+)plain(    )]
insert[insert(+)plain(    IDENT_KIND = CaseIgnoringWordList.new(:ident\).)]
insert[insert(+)plain(      add(RESERVED_WORDS, :reserved\).)]
insert[insert(+)plain(      add(OBJECTS, :type\).)]
insert[insert(+)plain(      add(COMMANDS, :class\).)]
insert[insert(+)plain(      add(PREDEFINED_TYPES, :pre_type\).)]
insert[insert(+)plain(      add(PREDEFINED_CONSTANTS, :pre_constant\).)]
insert[insert(+)plain(      add(PREDEFINED_FUNCTIONS, :predefined\).)]
insert[insert(+)plain(      add(DIRECTIVES, :directive\))]
insert[insert(+)plain(    )]
insert[insert(+)plain(    ESCAPE = / [rbfntv\\n\\\\\\/'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} | . /mx)]
insert[insert(+)plain(    UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} /x)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    STRING_PREFIXES = /[xnb]|_\\w+/i)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def scan_tokens tokens, options)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      state = :initial)]
insert[insert(+)plain(      string_type = nil)]
insert[insert(+)plain(      string_content = '')]
insert[insert(+)plain(      )]
insert[insert(+)plain(      until eos?)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        kind = nil)]
insert[insert(+)plain(        match = nil)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        if state == :initial)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          if scan(/ \\s+ | \\\\\\n /x\))]
insert[insert(+)plain(            kind = :space)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/^(?:--\\s?|#\).*/\))]
insert[insert(+)plain(            kind = :comment)]
insert[insert(+)plain(            )]
insert[insert(+)plain(          elsif scan(%r( /\\* (!\)? (?: .*? \\*/ | .* \) \)mx\))]
insert[insert(+)plain(            kind = self[1] ? :directive : :comment)]
insert[insert(+)plain(            )]
insert[insert(+)plain(          elsif scan(/ [-+*\\/=<>;,!&^|(\)\\[\\]{}~%] | \\.(?!\\d\) /x\))]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(            )]
insert[insert(+)plain(          elsif scan(/(#{STRING_PREFIXES}\)?([`"']\)/o\))]
insert[insert(+)plain(            prefix = self[1])]
insert[insert(+)plain(            string_type = self[2])]
insert[insert(+)plain(            tokens << [:open, :string])]
insert[insert(+)plain(            tokens << [prefix, :modifier] if prefix)]
insert[insert(+)plain(            match = string_type)]
insert[insert(+)plain(            state = :string)]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)plain(            )]
insert[insert(+)plain(          elsif match = scan(/ @? [A-Za-z_][A-Za-z_0-9]* /x\))]
insert[insert(+)plain(            kind = match[0] == ?@ ? :variable : IDENT_KIND[match.downcase])]
insert[insert(+)plain(            )]
insert[insert(+)plain(          elsif scan(/0[xX][0-9A-Fa-f]+/\))]
insert[insert(+)plain(            kind = :hex)]
insert[insert(+)plain(            )]
insert[insert(+)plain(          elsif scan(/0[0-7]+(?![89.eEfF]\)/\))]
insert[insert(+)plain(            kind = :oct)]
insert[insert(+)plain(            )]
insert[insert(+)plain(          elsif scan(/(?>\\d+\)(?![.eEfF]\)/\))]
insert[insert(+)plain(            kind = :integer)]
insert[insert(+)plain(            )]
insert[insert(+)plain(          elsif scan(/\\d[fF]|\\d*\\.\\d+(?:[eE][+-]?\\d+\)?|\\d+[eE][+-]?\\d+/\))]
insert[insert(+)plain(            kind = :float)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif scan(/\\\\N/\))]
insert[insert(+)plain(            kind = :pre_constant)]
insert[insert(+)plain(            )]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            getch)]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(            )]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        elsif state == :string)]
insert[insert(+)plain(          if match = scan(/[^\\\\"'`]+/\))]
insert[insert(+)plain(            string_content << match)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif match = scan(/["'`]/\))]
insert[insert(+)plain(            if string_type == match)]
insert[insert(+)plain(              if peek(1\) == string_type  # doubling means escape)]
insert[insert(+)plain(                string_content << string_type << getch)]
insert[insert(+)plain(                next)]
insert[insert(+)plain(              end)]
insert[insert(+)plain(              unless string_content.empty?)]
insert[insert(+)plain(                tokens << [string_content, :content])]
insert[insert(+)plain(                string_content = '')]
insert[insert(+)plain(              end)]
insert[insert(+)plain(              tokens << [matched, :delimiter])]
insert[insert(+)plain(              tokens << [:close, :string])]
insert[insert(+)plain(              state = :initial)]
insert[insert(+)plain(              string_type = nil)]
insert[insert(+)plain(              next)]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              string_content << match)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif scan(/ \\\\ (?: #{ESCAPE} | #{UNICODE_ESCAPE} \) /mox\))]
insert[insert(+)plain(            unless string_content.empty?)]
insert[insert(+)plain(              tokens << [string_content, :content])]
insert[insert(+)plain(              string_content = '')]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            kind = :char)]
insert[insert(+)plain(          elsif match = scan(/ \\\\ . /mox\))]
insert[insert(+)plain(            string_content << match)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif scan(/ \\\\ | $ /x\))]
insert[insert(+)plain(            unless string_content.empty?)]
insert[insert(+)plain(              tokens << [string_content, :content])]
insert[insert(+)plain(              string_content = '')]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            raise "else case \\" reached; %p not handled." % peek(1\), tokens)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          raise 'else-case reached', tokens)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        match ||= matched)]
insert[insert(+)plain(        unless kind)]
insert[insert(+)plain(          raise_inspect 'Error token %p in line %d' %)]
insert[insert(+)plain(            [[match, kind], line], tokens, state)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        raise_inspect 'Empty token', tokens unless match)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        tokens << [match, kind])]
insert[insert(+)plain(        )]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      tokens)]
insert[insert(+)plain(      )]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end end)]
change[change(\\ )plain(No newline at end of file)]
head[head(Index: )plain(lib/coderay/scanners/xml.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/xml.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/xml.rb	(revision 500\))]
change[change(@@)plain( -3,15 +3,14 )change(@@)]
comment( )
comment(   load :html)
comment( )
delete[delete(-)plain(  # XML Scanner)]
insert[insert(+)plain(  # Scanner for XML.)]
comment(   #)
delete[delete(-)plain(  # $Id$)]
delete[delete(-)plain(  #)]
comment(   # Currently this is the same scanner as Scanners::HTML.)
comment(   class XML < HTML)
comment( )
comment(     register_for :xml)
delete[delete(-)]
insert[insert(+)plain(    file_extension 'xml')]
insert[insert(+)plain(    )]
comment(   end)
comment( )
comment( end)
head[head(Index: )plain(lib/coderay/scanners/yaml.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/yaml.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/yaml.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,142 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Scanners)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # Scanner for YAML.)]
insert[insert(+)plain(  #)]
insert[insert(+)plain(  # Based on the YAML scanner from Syntax by Jamis Buck.)]
insert[insert(+)plain(  class YAML < Scanner)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    register_for :yaml)]
insert[insert(+)plain(    file_extension 'yml')]
insert[insert(+)plain(    )]
insert[insert(+)plain(    KINDS_NOT_LOC = :all)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def scan_tokens tokens, options)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      value_expected = nil)]
insert[insert(+)plain(      state = :initial)]
insert[insert(+)plain(      key_indent = indent = 0)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      until eos?)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        kind = nil)]
insert[insert(+)plain(        match = nil)]
insert[insert(+)plain(        key_indent = nil if bol?)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        if match = scan(/ +[\\t ]*/\))]
insert[insert(+)plain(          kind = :space)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        elsif match = scan(/\\n+/\))]
insert[insert(+)plain(          kind = :space)]
insert[insert(+)plain(          state = :initial if match.index(?\\n\))]
insert[insert(+)plain(          )]
insert[insert(+)plain(        elsif match = scan(/#.*/\))]
insert[insert(+)plain(          kind = :comment)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        elsif bol? and case)]
insert[insert(+)plain(          when match = scan(/---|\\.\\.\\./\))]
insert[insert(+)plain(            tokens << [:open, :head])]
insert[insert(+)plain(            tokens << [match, :head])]
insert[insert(+)plain(            tokens << [:close, :head])]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          when match = scan(/%.*/\))]
insert[insert(+)plain(            tokens << [match, :doctype])]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        elsif state == :value and case)]
insert[insert(+)plain(          when !check(/(?:"[^"]*"\)(?=: |:$\)/\) && scan(/"/\))]
insert[insert(+)plain(            tokens << [:open, :string])]
insert[insert(+)plain(            tokens << [matched, :delimiter])]
insert[insert(+)plain(            tokens << [matched, :content] if scan(/ [^"\\\\]* (?: \\\\. [^"\\\\]* \)* /mx\))]
insert[insert(+)plain(            tokens << [matched, :delimiter] if scan(/"/\))]
insert[insert(+)plain(            tokens << [:close, :string])]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          when match = scan(/[|>][-+]?/\))]
insert[insert(+)plain(            tokens << [:open, :string])]
insert[insert(+)plain(            tokens << [match, :delimiter])]
insert[insert(+)plain(            string_indent = key_indent || column(pos - match.size - 1\))]
insert[insert(+)plain(            tokens << [matched, :content] if scan(/(?:\\n+ {#{string_indent + 1}}.*\)+/\))]
insert[insert(+)plain(            tokens << [:close, :string])]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          when match = scan(/(?![!"*&]\).+?(?=$|\\s+#\)/\))]
insert[insert(+)plain(            tokens << [match, :string])]
insert[insert(+)plain(            string_indent = key_indent || column(pos - match.size - 1\))]
insert[insert(+)plain(            tokens << [matched, :string] if scan(/(?:\\n+ {#{string_indent + 1}}.*\)+/\))]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        elsif case)]
insert[insert(+)plain(          when match = scan(/[-:](?= |$\)/\))]
insert[insert(+)plain(            state = :value if state == :colon && (match == ':' || match == '-'\))]
insert[insert(+)plain(            state = :value if state == :initial && match == '-')]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          when match = scan(/[,{}\\[\\]]/\))]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(          when state == :initial && match = scan(/[\\w.(\) ]*\\S(?=: |:$\)/\))]
insert[insert(+)plain(            kind = :key)]
insert[insert(+)plain(            key_indent = column(pos - match.size - 1\))]
insert[insert(+)plain(            # tokens << [key_indent.inspect, :debug])]
insert[insert(+)plain(            state = :colon)]
insert[insert(+)plain(          when match = scan(/(?:"[^"\\n]*"|'[^'\\n]*'\)(?=: |:$\)/\))]
insert[insert(+)plain(            tokens << [:open, :key])]
insert[insert(+)plain(            tokens << [match[0,1], :delimiter])]
insert[insert(+)plain(            tokens << [match[1..-2], :content])]
insert[insert(+)plain(            tokens << [match[-1,1], :delimiter])]
insert[insert(+)plain(            tokens << [:close, :key])]
insert[insert(+)plain(            key_indent = column(pos - match.size - 1\))]
insert[insert(+)plain(            # tokens << [key_indent.inspect, :debug])]
insert[insert(+)plain(            state = :colon)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          when scan(/(![\\w\\/]+\)(:([\\w:]+\)\)?/\))]
insert[insert(+)plain(            tokens << [self[1], :type])]
insert[insert(+)plain(            if self[2])]
insert[insert(+)plain(              tokens << [':', :operator])]
insert[insert(+)plain(              tokens << [self[3], :class])]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          when scan(/&\\S+/\))]
insert[insert(+)plain(            kind = :variable)]
insert[insert(+)plain(          when scan(/\\*\\w+/\))]
insert[insert(+)plain(            kind = :global_variable)]
insert[insert(+)plain(          when scan(/<</\))]
insert[insert(+)plain(            kind = :class_variable)]
insert[insert(+)plain(          when scan(/\\d\\d:\\d\\d:\\d\\d/\))]
insert[insert(+)plain(            kind = :oct)]
insert[insert(+)plain(          when scan(/\\d\\d\\d\\d-\\d\\d-\\d\\d\\s\\d\\d:\\d\\d:\\d\\d(\\.\\d+\)? [-+]\\d\\d:\\d\\d/\))]
insert[insert(+)plain(            kind = :oct)]
insert[insert(+)plain(          when scan(/:\\w+/\))]
insert[insert(+)plain(            kind = :symbol)]
insert[insert(+)plain(          when scan(/[^:\\s]+(:(?! |$\)[^:\\s]*\)* .*/\))]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(          when scan(/[^:\\s]+(:(?! |$\)[^:\\s]*\)*/\))]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          getch)]
insert[insert(+)plain(          kind = :error)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        match ||= matched)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
insert[insert(+)plain(          raise_inspect 'Error token %p in line %d' %)]
insert[insert(+)plain(            [[match, kind], line], tokens)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        raise_inspect 'Empty token', tokens unless match)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        tokens << [match, kind])]
insert[insert(+)plain(        )]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      tokens)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/scanners/html.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/html.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/html.rb	(revision 500\))]
change[change(@@)plain( -2,17 +2,25 )change(@@)]
comment( module Scanners)
comment( )
comment(   # HTML Scanner)
delete[delete(-)plain(  #)]
delete[delete(-)plain(  # $Id$)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Alias: +xhtml+)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # See also: Scanners::XML)]
comment(   class HTML < Scanner)
comment( )
comment(     include Streamable)
comment(     register_for :html)
delete[delete(-)]
delete[delete(-)plain(    ATTR_NAME = /[\\w.:-]+/)]
delete[delete(-)plain(    ATTR_VALUE_UNQUOTED = ATTR_NAME)]
delete[delete(-)plain(    TAG_END = /\\/?>/)]
delete[delete(-)plain(    HEX = /[0-9a-fA-F]/)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    KINDS_NOT_LOC = [)]
insert[insert(+)plain(      :comment, :doctype, :preprocessor,)]
insert[insert(+)plain(      :tag, :attribute_name, :operator,)]
insert[insert(+)plain(      :attribute_value, :delimiter, :content,)]
insert[insert(+)plain(      :plain, :entity, :error,)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    ATTR_NAME = /[\\w.:-]+/  # :nodoc:)]
insert[insert(+)plain(    TAG_END = /\\/?>/  # :nodoc:)]
insert[insert(+)plain(    HEX = /[0-9a-fA-F]/  # :nodoc:)]
comment(     ENTITY = /)
comment(       &)
comment(       (?:)
change[change(@@)plain( -26,19 +34,21 )change(@@)]
comment(         \))
comment(       \))
comment(       ;)
delete[delete(-)plain(    /ox)]
delete[delete(-)]
insert[insert(+)plain(    /ox  # :nodoc:)]
insert[insert(+)plain(    )]
comment(     PLAIN_STRING_CONTENT = {)
comment(       "'" => /[^&'>\\n]+/,)
comment(       '"' => /[^&">\\n]+/,)
delete[delete(-)plain(    })]
delete[delete(-)]
delete[delete(-)plain(    def reset)]
insert[insert(+)plain(    }  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def reset  # :nodoc:)]
insert[insert(+)plain(      # FIXME: why not overwrite reset_instance?)]
comment(       super)
comment(       @state = :initial)
comment(     end)
delete[delete(-)]
delete[delete(-)plain(  private)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
comment(     def setup)
comment(       @state = :initial)
comment(       @plain_string_content = nil)
change[change(@@)plain( -65,14 +75,14 )change(@@)]
comment(             if scan(/<!--.*?-->/m\))
comment(               kind = :comment)
comment(             elsif scan(/<!DOCTYPE.*?>/m\))
delete[delete(-)plain(              kind = :preprocessor)]
insert[insert(+)plain(              kind = :doctype)]
comment(             elsif scan(/<\\?xml.*?\\?>/m\))
comment(               kind = :preprocessor)
comment(             elsif scan(/<\\?.*?\\?>|<%.*?%>/m\))
comment(               kind = :comment)
delete[delete(-)plain(            elsif scan(/<\\/[-\\w_.:]*>/m\))]
insert[insert(+)plain(            elsif scan(/<\\/[-\\w.:]*>/m\))]
comment(               kind = :tag)
delete[delete(-)plain(            elsif match = scan(/<[-\\w_.:]+>?/m\))]
insert[insert(+)plain(            elsif match = scan(/<[-\\w.:]+>?/m\))]
comment(               kind = :tag)
comment(               state = :attribute unless match[-1] == ?>)
comment(             elsif scan(/[^<>&]+/\))
change[change(@@)plain( -112,7 +122,7 )change(@@)]
comment(             end)
comment( )
comment(           when :attribute_value)
delete[delete(-)plain(            if scan(/#{ATTR_VALUE_UNQUOTED}/o\))]
insert[insert(+)plain(            if scan(/#{ATTR_NAME}/o\))]
comment(               kind = :attribute_value)
comment(               state = :attribute)
comment(             elsif match = scan(/["']/\))
change[change(@@)plain( -154,7 +164,7 )change(@@)]
comment(         end)
comment( )
comment(         match ||= matched)
delete[delete(-)plain(        if $DEBUG and not kind)]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
comment(           raise_inspect 'Error token %p in line %d' %)
comment(             [[match, kind], line], tokens, state)
comment(         end)
head[head(Index: )plain(lib/coderay/scanners/scheme.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/scheme.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/scheme.rb	(revision 500\))]
change[change(@@)plain( -2,72 +2,77 )change(@@)]
comment(   module Scanners)
comment( )
comment(     # Scheme scanner for CodeRay (by closure\).)
insert[insert(+)plain(    # )]
comment(     # Thanks to murphy for putting CodeRay into public.)
comment(     class Scheme < Scanner)
comment(       )
insert[insert(+)plain(      # TODO: function defs)]
insert[insert(+)plain(      # TODO: built-in functions)]
insert[insert(+)plain(      )]
comment(       register_for :scheme)
delete[delete(-)plain(      file_extension :scm)]
insert[insert(+)plain(      file_extension 'scm')]
comment( )
comment(       CORE_FORMS = %w[)
comment(         lambda let let* letrec syntax-case define-syntax let-syntax)
comment(         letrec-syntax begin define quote if or and cond case do delay)
comment(         quasiquote set! cons force call-with-current-continuation call/cc)
delete[delete(-)plain(      ])]
delete[delete(-)]
insert[insert(+)plain(      ]  # :nodoc:)]
insert[insert(+)plain(      )]
comment(       IDENT_KIND = CaseIgnoringWordList.new(:ident\).)
delete[delete(-)plain(        add(CORE_FORMS, :reserved\))]
insert[insert(+)plain(        add(CORE_FORMS, :reserved\)  # :nodoc:)]
comment(       )
comment(       #IDENTIFIER_INITIAL = /[a-z!@\\$%&\\*\\/\\:<=>\\?~_\\^]/i)
comment(       #IDENTIFIER_SUBSEQUENT = /#{IDENTIFIER_INITIAL}|\\d|\\.|\\+|-/)
comment(       #IDENTIFIER = /#{IDENTIFIER_INITIAL}#{IDENTIFIER_SUBSEQUENT}*|\\+|-|\\.{3}/)
delete[delete(-)plain(      IDENTIFIER = /[a-zA-Z!@$%&*\\/:<=>?~_^][\\w!@$%&*\\/:<=>?~^.+\\-]*|[+-]|\\.\\.\\./)]
delete[delete(-)plain(      DIGIT = /\\d/)]
delete[delete(-)plain(      DIGIT10 = DIGIT)]
delete[delete(-)plain(      DIGIT16 = /[0-9a-f]/i)]
delete[delete(-)plain(      DIGIT8 = /[0-7]/)]
delete[delete(-)plain(      DIGIT2 = /[01]/)]
delete[delete(-)plain(      RADIX16 = /\\#x/i)]
delete[delete(-)plain(      RADIX8 = /\\#o/i)]
delete[delete(-)plain(      RADIX2 = /\\#b/i)]
delete[delete(-)plain(      RADIX10 = /\\#d/i)]
delete[delete(-)plain(      EXACTNESS = /#i|#e/i)]
delete[delete(-)plain(      SIGN = /[\\+-]?/)]
delete[delete(-)plain(      EXP_MARK = /[esfdl]/i)]
delete[delete(-)plain(      EXP = /#{EXP_MARK}#{SIGN}#{DIGIT}+/)]
delete[delete(-)plain(      SUFFIX = /#{EXP}?/)]
delete[delete(-)plain(      PREFIX10 = /#{RADIX10}?#{EXACTNESS}?|#{EXACTNESS}?#{RADIX10}?/)]
delete[delete(-)plain(      PREFIX16 = /#{RADIX16}#{EXACTNESS}?|#{EXACTNESS}?#{RADIX16}/)]
delete[delete(-)plain(      PREFIX8 = /#{RADIX8}#{EXACTNESS}?|#{EXACTNESS}?#{RADIX8}/)]
delete[delete(-)plain(      PREFIX2 = /#{RADIX2}#{EXACTNESS}?|#{EXACTNESS}?#{RADIX2}/)]
delete[delete(-)plain(      UINT10 = /#{DIGIT10}+#*/)]
delete[delete(-)plain(      UINT16 = /#{DIGIT16}+#*/)]
delete[delete(-)plain(      UINT8 = /#{DIGIT8}+#*/)]
delete[delete(-)plain(      UINT2 = /#{DIGIT2}+#*/)]
delete[delete(-)plain(      DECIMAL = /#{DIGIT10}+#+\\.#*#{SUFFIX}|#{DIGIT10}+\\.#{DIGIT10}*#*#{SUFFIX}|\\.#{DIGIT10}+#*#{SUFFIX}|#{UINT10}#{EXP}/)]
delete[delete(-)plain(      UREAL10 = /#{UINT10}\\/#{UINT10}|#{DECIMAL}|#{UINT10}/)]
delete[delete(-)plain(      UREAL16 = /#{UINT16}\\/#{UINT16}|#{UINT16}/)]
delete[delete(-)plain(      UREAL8 = /#{UINT8}\\/#{UINT8}|#{UINT8}/)]
delete[delete(-)plain(      UREAL2 = /#{UINT2}\\/#{UINT2}|#{UINT2}/)]
delete[delete(-)plain(      REAL10 = /#{SIGN}#{UREAL10}/)]
delete[delete(-)plain(      REAL16 = /#{SIGN}#{UREAL16}/)]
delete[delete(-)plain(      REAL8 = /#{SIGN}#{UREAL8}/)]
delete[delete(-)plain(      REAL2 = /#{SIGN}#{UREAL2}/)]
delete[delete(-)plain(      IMAG10 = /i|#{UREAL10}i/)]
delete[delete(-)plain(      IMAG16 = /i|#{UREAL16}i/)]
delete[delete(-)plain(      IMAG8 = /i|#{UREAL8}i/)]
delete[delete(-)plain(      IMAG2 = /i|#{UREAL2}i/)]
delete[delete(-)plain(      COMPLEX10 = /#{REAL10}@#{REAL10}|#{REAL10}\\+#{IMAG10}|#{REAL10}-#{IMAG10}|\\+#{IMAG10}|-#{IMAG10}|#{REAL10}/)]
delete[delete(-)plain(      COMPLEX16 = /#{REAL16}@#{REAL16}|#{REAL16}\\+#{IMAG16}|#{REAL16}-#{IMAG16}|\\+#{IMAG16}|-#{IMAG16}|#{REAL16}/)]
delete[delete(-)plain(      COMPLEX8 = /#{REAL8}@#{REAL8}|#{REAL8}\\+#{IMAG8}|#{REAL8}-#{IMAG8}|\\+#{IMAG8}|-#{IMAG8}|#{REAL8}/)]
delete[delete(-)plain(      COMPLEX2 = /#{REAL2}@#{REAL2}|#{REAL2}\\+#{IMAG2}|#{REAL2}-#{IMAG2}|\\+#{IMAG2}|-#{IMAG2}|#{REAL2}/)]
delete[delete(-)plain(      NUM10 = /#{PREFIX10}?#{COMPLEX10}/)]
delete[delete(-)plain(      NUM16 = /#{PREFIX16}#{COMPLEX16}/)]
delete[delete(-)plain(      NUM8 = /#{PREFIX8}#{COMPLEX8}/)]
delete[delete(-)plain(      NUM2 = /#{PREFIX2}#{COMPLEX2}/)]
delete[delete(-)plain(      NUM = /#{NUM10}|#{NUM16}|#{NUM8}|#{NUM2}/)]
delete[delete(-)plain(    )]
delete[delete(-)plain(    private)]
delete[delete(-)plain(      def scan_tokens tokens,options)]
insert[insert(+)plain(      IDENTIFIER = /[a-zA-Z!@$%&*\\/:<=>?~_^][\\w!@$%&*\\/:<=>?~^.+\\-]*|[+-]|\\.\\.\\./  # :nodoc:)]
insert[insert(+)plain(      DIGIT = /\\d/  # :nodoc:)]
insert[insert(+)plain(      DIGIT10 = /\\d/  # :nodoc:)]
insert[insert(+)plain(      DIGIT16 = /[0-9a-f]/i  # :nodoc:)]
insert[insert(+)plain(      DIGIT8 = /[0-7]/  # :nodoc:)]
insert[insert(+)plain(      DIGIT2 = /[01]/  # :nodoc:)]
insert[insert(+)plain(      RADIX16 = /\\#x/i  # :nodoc:)]
insert[insert(+)plain(      RADIX8 = /\\#o/i  # :nodoc:)]
insert[insert(+)plain(      RADIX2 = /\\#b/i  # :nodoc:)]
insert[insert(+)plain(      RADIX10 = /\\#d/i  # :nodoc:)]
insert[insert(+)plain(      EXACTNESS = /#i|#e/i  # :nodoc:)]
insert[insert(+)plain(      SIGN = /[\\+-]?/  # :nodoc:)]
insert[insert(+)plain(      EXP_MARK = /[esfdl]/i  # :nodoc:)]
insert[insert(+)plain(      EXP = /#{EXP_MARK}#{SIGN}#{DIGIT}+/  # :nodoc:)]
insert[insert(+)plain(      SUFFIX = /#{EXP}?/  # :nodoc:)]
insert[insert(+)plain(      PREFIX10 = /#{RADIX10}?#{EXACTNESS}?|#{EXACTNESS}?#{RADIX10}?/  # :nodoc:)]
insert[insert(+)plain(      PREFIX16 = /#{RADIX16}#{EXACTNESS}?|#{EXACTNESS}?#{RADIX16}/  # :nodoc:)]
insert[insert(+)plain(      PREFIX8 = /#{RADIX8}#{EXACTNESS}?|#{EXACTNESS}?#{RADIX8}/  # :nodoc:)]
insert[insert(+)plain(      PREFIX2 = /#{RADIX2}#{EXACTNESS}?|#{EXACTNESS}?#{RADIX2}/  # :nodoc:)]
insert[insert(+)plain(      UINT10 = /#{DIGIT10}+#*/  # :nodoc:)]
insert[insert(+)plain(      UINT16 = /#{DIGIT16}+#*/  # :nodoc:)]
insert[insert(+)plain(      UINT8 = /#{DIGIT8}+#*/  # :nodoc:)]
insert[insert(+)plain(      UINT2 = /#{DIGIT2}+#*/  # :nodoc:)]
insert[insert(+)plain(      DECIMAL = /#{DIGIT10}+#+\\.#*#{SUFFIX}|#{DIGIT10}+\\.#{DIGIT10}*#*#{SUFFIX}|\\.#{DIGIT10}+#*#{SUFFIX}|#{UINT10}#{EXP}/  # :nodoc:)]
insert[insert(+)plain(      UREAL10 = /#{UINT10}\\/#{UINT10}|#{DECIMAL}|#{UINT10}/  # :nodoc:)]
insert[insert(+)plain(      UREAL16 = /#{UINT16}\\/#{UINT16}|#{UINT16}/  # :nodoc:)]
insert[insert(+)plain(      UREAL8 = /#{UINT8}\\/#{UINT8}|#{UINT8}/  # :nodoc:)]
insert[insert(+)plain(      UREAL2 = /#{UINT2}\\/#{UINT2}|#{UINT2}/  # :nodoc:)]
insert[insert(+)plain(      REAL10 = /#{SIGN}#{UREAL10}/  # :nodoc:)]
insert[insert(+)plain(      REAL16 = /#{SIGN}#{UREAL16}/  # :nodoc:)]
insert[insert(+)plain(      REAL8 = /#{SIGN}#{UREAL8}/  # :nodoc:)]
insert[insert(+)plain(      REAL2 = /#{SIGN}#{UREAL2}/  # :nodoc:)]
insert[insert(+)plain(      IMAG10 = /i|#{UREAL10}i/  # :nodoc:)]
insert[insert(+)plain(      IMAG16 = /i|#{UREAL16}i/  # :nodoc:)]
insert[insert(+)plain(      IMAG8 = /i|#{UREAL8}i/  # :nodoc:)]
insert[insert(+)plain(      IMAG2 = /i|#{UREAL2}i/  # :nodoc:)]
insert[insert(+)plain(      COMPLEX10 = /#{REAL10}@#{REAL10}|#{REAL10}\\+#{IMAG10}|#{REAL10}-#{IMAG10}|\\+#{IMAG10}|-#{IMAG10}|#{REAL10}/  # :nodoc:)]
insert[insert(+)plain(      COMPLEX16 = /#{REAL16}@#{REAL16}|#{REAL16}\\+#{IMAG16}|#{REAL16}-#{IMAG16}|\\+#{IMAG16}|-#{IMAG16}|#{REAL16}/  # :nodoc:)]
insert[insert(+)plain(      COMPLEX8 = /#{REAL8}@#{REAL8}|#{REAL8}\\+#{IMAG8}|#{REAL8}-#{IMAG8}|\\+#{IMAG8}|-#{IMAG8}|#{REAL8}/  # :nodoc:)]
insert[insert(+)plain(      COMPLEX2 = /#{REAL2}@#{REAL2}|#{REAL2}\\+#{IMAG2}|#{REAL2}-#{IMAG2}|\\+#{IMAG2}|-#{IMAG2}|#{REAL2}/  # :nodoc:)]
insert[insert(+)plain(      NUM10 = /#{PREFIX10}?#{COMPLEX10}/  # :nodoc:)]
insert[insert(+)plain(      NUM16 = /#{PREFIX16}#{COMPLEX16}/  # :nodoc:)]
insert[insert(+)plain(      NUM8 = /#{PREFIX8}#{COMPLEX8}/  # :nodoc:)]
insert[insert(+)plain(      NUM2 = /#{PREFIX2}#{COMPLEX2}/  # :nodoc:)]
insert[insert(+)plain(      NUM = /#{NUM10}|#{NUM16}|#{NUM8}|#{NUM2}/  # :nodoc:)]
insert[insert(+)plain(      )]
insert[insert(+)plain(    protected)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      def scan_tokens tokens, options)]
comment(         )
comment(         state = :initial)
comment(         ident_kind = IDENT_KIND)
change[change(@@)plain( -80,7 +85,7 )change(@@)]
comment(             if scan(/ \\s+ | \\\\\\n /x\))
comment(               kind = :space)
comment(             elsif scan(/['\\(\\[\\\)\\]]|#\\(/\))
delete[delete(-)plain(              kind = :operator_fat)]
insert[insert(+)plain(              kind = :operator  # FIXME: was :operator_fat)]
comment(             elsif scan(/;.*/\))
comment(               kind = :comment)
comment(             elsif scan(/#\\\\(?:newline|space|.?\)/\))
change[change(@@)plain( -120,15 +125,15 )change(@@)]
comment(           end)
comment(           )
comment(           match ||= matched)
delete[delete(-)plain(          if $DEBUG and not kind)]
insert[insert(+)plain(          if $CODERAY_DEBUG and not kind)]
comment(             raise_inspect 'Error token %p in line %d' %)
delete[delete(-)plain(            [[match, kind], line], tokens)]
insert[insert(+)plain(              [[match, kind], line], tokens)]
comment(           end)
comment(           raise_inspect 'Empty token', tokens, state unless match)
comment(           )
comment(           tokens << [match, kind])
comment(           )
delete[delete(-)plain(        end  # until eos)]
insert[insert(+)plain(        end)]
comment(         )
comment(         if state == :string)
comment(           tokens << [:close, :string])
change[change(@@)plain( -136,7 +141,7 )change(@@)]
comment(         )
comment(         tokens)
comment(         )
delete[delete(-)plain(      end #scan_tokens)]
delete[delete(-)plain(    end #class)]
delete[delete(-)plain(  end #module scanners)]
delete[delete(-)plain(end #module coderay)]
change[change(\\ )plain(No newline at end of file)]
insert[insert(+)plain(      end)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(end)]
change[change(\\ )plain(No newline at end of file)]
head[head(Index: )plain(lib/coderay/scanners/java_script.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/java_script.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/java_script.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,229 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Scanners)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # Scanner for JavaScript.)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Aliases: +ecmascript+, +ecma_script+, +javascript+)]
insert[insert(+)plain(  class JavaScript < Scanner)]
insert[insert(+)]
insert[insert(+)plain(    include Streamable)]
insert[insert(+)]
insert[insert(+)plain(    register_for :java_script)]
insert[insert(+)plain(    file_extension 'js')]
insert[insert(+)]
insert[insert(+)plain(    # The actual JavaScript keywords.)]
insert[insert(+)plain(    KEYWORDS = %w[)]
insert[insert(+)plain(      break case catch continue default delete do else)]
insert[insert(+)plain(      finally for function if in instanceof new)]
insert[insert(+)plain(      return switch throw try typeof var void while with)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    PREDEFINED_CONSTANTS = %w[)]
insert[insert(+)plain(      false null true undefined NaN Infinity)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    MAGIC_VARIABLES = %w[ this arguments ]  # :nodoc: arguments was introduced in JavaScript 1.4)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    KEYWORDS_EXPECTING_VALUE = WordList.new.add %w[)]
insert[insert(+)plain(      case delete in instanceof new return throw typeof with)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    # Reserved for future use.)]
insert[insert(+)plain(    RESERVED_WORDS = %w[)]
insert[insert(+)plain(      abstract boolean byte char class debugger double enum export extends)]
insert[insert(+)plain(      final float goto implements import int interface long native package)]
insert[insert(+)plain(      private protected public short static super synchronized throws transient)]
insert[insert(+)plain(      volatile)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    IDENT_KIND = WordList.new(:ident\).)]
insert[insert(+)plain(      add(RESERVED_WORDS, :reserved\).)]
insert[insert(+)plain(      add(PREDEFINED_CONSTANTS, :pre_constant\).)]
insert[insert(+)plain(      add(MAGIC_VARIABLES, :local_variable\).)]
insert[insert(+)plain(      add(KEYWORDS, :keyword\)  # :nodoc:)]
insert[insert(+)]
insert[insert(+)plain(    ESCAPE = / [bfnrtv\\n\\\\'"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} /x  # :nodoc:)]
insert[insert(+)plain(    UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} /x  # :nodoc:)]
insert[insert(+)plain(    REGEXP_ESCAPE =  / [bBdDsSwW] /x  # :nodoc:)]
insert[insert(+)plain(    STRING_CONTENT_PATTERN = {)]
insert[insert(+)plain(      "'" => /[^\\\\']+/,)]
insert[insert(+)plain(      '"' => /[^\\\\"]+/,)]
insert[insert(+)plain(      '/' => /[^\\\\\\/]+/,)]
insert[insert(+)plain(    }  # :nodoc:)]
insert[insert(+)plain(    KEY_CHECK_PATTERN = {)]
insert[insert(+)plain(      "'" => / [^\\\\']* (?: \\\\.? [^\\\\']* \)* '? \\s* : /x,)]
insert[insert(+)plain(      '"' => / [^\\\\"]* (?: \\\\.? [^\\\\"]* \)* "? \\s* : /x,)]
insert[insert(+)plain(    }  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def scan_tokens tokens, options)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      state = :initial)]
insert[insert(+)plain(      string_delimiter = nil)]
insert[insert(+)plain(      value_expected = true)]
insert[insert(+)plain(      key_expected = false)]
insert[insert(+)plain(      function_expected = false)]
insert[insert(+)]
insert[insert(+)plain(      until eos?)]
insert[insert(+)]
insert[insert(+)plain(        kind = nil)]
insert[insert(+)plain(        match = nil)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        case state)]
insert[insert(+)]
insert[insert(+)plain(        when :initial)]
insert[insert(+)]
insert[insert(+)plain(          if match = scan(/ \\s+ | \\\\\\n /x\))]
insert[insert(+)plain(            value_expected = true if !value_expected && match.index(?\\n\))]
insert[insert(+)plain(            tokens << [match, :space])]
insert[insert(+)plain(            next)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(%r! // [^\\n\\\\]* (?: \\\\. [^\\n\\\\]* \)* | /\\* (?: .*? \\*/ | .* \) !mx\))]
insert[insert(+)plain(            value_expected = true)]
insert[insert(+)plain(            kind = :comment)]
insert[insert(+)]
insert[insert(+)plain(          elsif check(/\\.?\\d/\))]
insert[insert(+)plain(            key_expected = value_expected = false)]
insert[insert(+)plain(            if scan(/0[xX][0-9A-Fa-f]+/\))]
insert[insert(+)plain(              kind = :hex)]
insert[insert(+)plain(            elsif scan(/(?>0[0-7]+\)(?![89.eEfF]\)/\))]
insert[insert(+)plain(              kind = :oct)]
insert[insert(+)plain(            elsif scan(/\\d+[fF]|\\d*\\.\\d+(?:[eE][+-]?\\d+\)?[fF]?|\\d+[eE][+-]?\\d+[fF]?/\))]
insert[insert(+)plain(              kind = :float)]
insert[insert(+)plain(            elsif scan(/\\d+/\))]
insert[insert(+)plain(              kind = :integer)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif value_expected && match = scan(/<([[:alpha:]]\\w*\) (?: [^\\/>]*\\/> | .*?<\\/\\1>\)/xim\))]
insert[insert(+)plain(            # FIXME: scan over nested tags)]
insert[insert(+)plain(            xml_scanner.tokenize match)]
insert[insert(+)plain(            value_expected = false)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(            )]
insert[insert(+)plain(          elsif match = scan(/ [-+*=<>?:;,!&^|(\\[{~%]+ | \\.(?!\\d\) /x\))]
insert[insert(+)plain(            value_expected = true)]
insert[insert(+)plain(            last_operator = match[-1])]
insert[insert(+)plain(            key_expected = (last_operator == ?{\) || (last_operator == ?,\))]
insert[insert(+)plain(            function_expected = false)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/ [\)\\]}]+ /x\))]
insert[insert(+)plain(            function_expected = key_expected = value_expected = false)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)]
insert[insert(+)plain(          elsif match = scan(/ [$a-zA-Z_][A-Za-z_0-9$]* /x\))]
insert[insert(+)plain(            kind = IDENT_KIND[match])]
insert[insert(+)plain(            value_expected = (kind == :keyword\) && KEYWORDS_EXPECTING_VALUE[match])]
insert[insert(+)plain(            # TODO: labels)]
insert[insert(+)plain(            if kind == :ident)]
insert[insert(+)plain(              if match.index(?$\)  # $ allowed inside an identifier)]
insert[insert(+)plain(                kind = :predefined)]
insert[insert(+)plain(              elsif function_expected)]
insert[insert(+)plain(                kind = :function)]
insert[insert(+)plain(              elsif check(/\\s*[=:]\\s*function\\b/\))]
insert[insert(+)plain(                kind = :function)]
insert[insert(+)plain(              elsif key_expected && check(/\\s*:/\))]
insert[insert(+)plain(                kind = :key)]
insert[insert(+)plain(              end)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            function_expected = (kind == :keyword\) && (match == 'function'\))]
insert[insert(+)plain(            key_expected = false)]
insert[insert(+)plain(          )]
insert[insert(+)plain(          elsif match = scan(/["']/\))]
insert[insert(+)plain(            if key_expected && check(KEY_CHECK_PATTERN[match]\))]
insert[insert(+)plain(              state = :key)]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              state = :string)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            tokens << [:open, state])]
insert[insert(+)plain(            string_delimiter = match)]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)]
insert[insert(+)plain(          elsif value_expected && (match = scan(/\\/(?=\\S\)/\)\))]
insert[insert(+)plain(            tokens << [:open, :regexp])]
insert[insert(+)plain(            state = :regexp)]
insert[insert(+)plain(            string_delimiter = '/')]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)]
insert[insert(+)plain(          elsif scan(/ \\/ /x\))]
insert[insert(+)plain(            value_expected = true)]
insert[insert(+)plain(            key_expected = false)]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            getch)]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)]
insert[insert(+)plain(          end)]
insert[insert(+)]
insert[insert(+)plain(        when :string, :regexp, :key)]
insert[insert(+)plain(          if scan(STRING_CONTENT_PATTERN[string_delimiter]\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif match = scan(/["'\\/]/\))]
insert[insert(+)plain(            tokens << [match, :delimiter])]
insert[insert(+)plain(            if state == :regexp)]
insert[insert(+)plain(              modifiers = scan(/[gim]+/\))]
insert[insert(+)plain(              tokens << [modifiers, :modifier] if modifiers && !modifiers.empty?)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(            tokens << [:close, state])]
insert[insert(+)plain(            string_delimiter = nil)]
insert[insert(+)plain(            key_expected = value_expected = false)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif state != :regexp && (match = scan(/ \\\\ (?: #{ESCAPE} | #{UNICODE_ESCAPE} \) /mox\)\))]
insert[insert(+)plain(            if string_delimiter == "'" && !(match == "\\\\\\\\" || match == "\\\\'"\))]
insert[insert(+)plain(              kind = :content)]
insert[insert(+)plain(            else)]
insert[insert(+)plain(              kind = :char)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          elsif state == :regexp && scan(/ \\\\ (?: #{ESCAPE} | #{REGEXP_ESCAPE} | #{UNICODE_ESCAPE} \) /mox\))]
insert[insert(+)plain(            kind = :char)]
insert[insert(+)plain(          elsif scan(/\\\\./m\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif scan(/ \\\\ | $ /x\))]
insert[insert(+)plain(            tokens << [:close, state])]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(            key_expected = value_expected = false)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            raise_inspect "else case \\" reached; %p not handled." % peek(1\), tokens)]
insert[insert(+)plain(          end)]
insert[insert(+)]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          raise_inspect 'Unknown state', tokens)]
insert[insert(+)]
insert[insert(+)plain(        end)]
insert[insert(+)]
insert[insert(+)plain(        match ||= matched)]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
insert[insert(+)plain(          raise_inspect 'Error token %p in line %d' %)]
insert[insert(+)plain(            [[match, kind], line], tokens)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        raise_inspect 'Empty token', tokens unless match)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        tokens << [match, kind])]
insert[insert(+)]
insert[insert(+)plain(      end)]
insert[insert(+)]
insert[insert(+)plain(      if [:string, :regexp].include? state)]
insert[insert(+)plain(        tokens << [:close, state])]
insert[insert(+)plain(      end)]
insert[insert(+)]
insert[insert(+)plain(      tokens)]
insert[insert(+)plain(    end)]
insert[insert(+)]
insert[insert(+)plain(  protected)]
insert[insert(+)]
insert[insert(+)plain(    def reset_instance)]
insert[insert(+)plain(      super)]
insert[insert(+)plain(      @xml_scanner.reset if defined? @xml_scanner)]
insert[insert(+)plain(    end)]
insert[insert(+)]
insert[insert(+)plain(    def xml_scanner)]
insert[insert(+)plain(      @xml_scanner ||= CodeRay.scanner :xml, :tokens => @tokens, :keep_tokens => true, :keep_state => false)]
insert[insert(+)plain(    end)]
insert[insert(+)]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/scanners/delphi.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/delphi.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/delphi.rb	(revision 500\))]
change[change(@@)plain( -1,9 +1,13 )change(@@)]
comment( module CodeRay)
comment( module Scanners)
comment(   )
insert[insert(+)plain(  # Scanner for the Delphi language (Object Pascal\).)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Alias: +pascal+)]
comment(   class Delphi < Scanner)
delete[delete(-)]
insert[insert(+)plain(    )]
comment(     register_for :delphi)
insert[insert(+)plain(    file_extension 'pas')]
comment(     )
comment(     RESERVED_WORDS = [)
comment(       'and', 'array', 'as', 'at', 'asm', 'at', 'begin', 'case', 'class',)
change[change(@@)plain( -15,9 +19,9 )change(@@)]
comment(       'procedure', 'program', 'property', 'raise', 'record', 'repeat',)
comment(       'resourcestring', 'set', 'shl', 'shr', 'string', 'then', 'threadvar',)
comment(       'to', 'try', 'type', 'unit', 'until', 'uses', 'var', 'while', 'with',)
delete[delete(-)plain(      'xor', 'on')]
delete[delete(-)plain(    ])]
delete[delete(-)]
insert[insert(+)plain(      'xor', 'on',)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
comment(     DIRECTIVES = [)
comment(       'absolute', 'abstract', 'assembler', 'at', 'automated', 'cdecl',)
comment(       'contains', 'deprecated', 'dispid', 'dynamic', 'export',)
change[change(@@)plain( -26,19 +30,20 )change(@@)]
comment(       'package', 'pascal', 'platform', 'private', 'protected', 'public',)
comment(       'published', 'read', 'readonly', 'register', 'reintroduce',)
comment(       'requires', 'resident', 'safecall', 'stdcall', 'stored', 'varargs',)
delete[delete(-)plain(      'virtual', 'write', 'writeonly')]
delete[delete(-)plain(    ])]
delete[delete(-)]
delete[delete(-)plain(    IDENT_KIND = CaseIgnoringWordList.new(:ident, caching=true\).)]
insert[insert(+)plain(      'virtual', 'write', 'writeonly',)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    IDENT_KIND = CaseIgnoringWordList.new(:ident\).)]
comment(       add(RESERVED_WORDS, :reserved\).)
delete[delete(-)plain(      add(DIRECTIVES, :directive\))]
insert[insert(+)plain(      add(DIRECTIVES, :directive\)  # :nodoc:)]
comment(     )
delete[delete(-)plain(    NAME_FOLLOWS = CaseIgnoringWordList.new(false, caching=true\).)]
delete[delete(-)plain(      add(%w(procedure function .\)\))]
delete[delete(-)]
delete[delete(-)plain(  private)]
insert[insert(+)plain(    NAME_FOLLOWS = CaseIgnoringWordList.new(false\).)]
insert[insert(+)plain(      add(%w(procedure function .\)\)  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
comment(     def scan_tokens tokens, options)
delete[delete(-)]
insert[insert(+)plain(      )]
comment(       state = :initial)
comment(       last_token = '')
comment( )
change[change(@@)plain( -129,7 +134,7 )change(@@)]
comment(         end)
comment(         )
comment(         match ||= matched)
delete[delete(-)plain(        if $DEBUG and not kind)]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
comment(           raise_inspect 'Error token %p in line %d' %)
comment(             [[match, kind], line], tokens, state)
comment(         end)
head[head(Index: )plain(lib/coderay/scanners/nitro_xhtml.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/nitro_xhtml.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/nitro_xhtml.rb	(revision 500\))]
change[change(@@)plain( -5,13 +5,17 )change(@@)]
comment(   load :ruby)
comment( )
comment(   # Nitro XHTML Scanner)
delete[delete(-)plain(  #)]
delete[delete(-)plain(  # $Id$)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Alias: +nitro+)]
comment(   class NitroXHTML < Scanner)
comment( )
comment(     include Streamable)
comment(     register_for :nitro_xhtml)
delete[delete(-)]
insert[insert(+)plain(    file_extension :xhtml)]
insert[insert(+)plain(    title 'Nitro XHTML')]
insert[insert(+)plain(    )]
insert[insert(+)plain(    KINDS_NOT_LOC = HTML::KINDS_NOT_LOC)]
insert[insert(+)plain(    )]
comment(     NITRO_RUBY_BLOCK = /)
comment(       <\\?r)
comment(       (?>)
change[change(@@)plain( -33,7 +37,7 )change(@@)]
comment(         (?> %(?!>\) [^%]* \)*)
comment(       \))
comment(       (?: %> \)?)
delete[delete(-)plain(    /mx)]
insert[insert(+)plain(    /mx  # :nodoc:)]
comment( )
comment(     NITRO_VALUE_BLOCK = /)
comment(       \\#)
change[change(@@)plain( -50,28 +54,27 )change(@@)]
comment(       | \\[ [^\\]]* \\]?)
comment(       | \\\\ [^\\\\]* \\\\?)
comment(       \))
delete[delete(-)plain(    /x)]
insert[insert(+)plain(    /x  # :nodoc:)]
comment( )
comment(     NITRO_ENTITY = /)
comment(       % (?: \\#\\d+ | \\w+ \) ;)
delete[delete(-)plain(    /)]
insert[insert(+)plain(    /  # :nodoc:)]
comment( )
comment(     START_OF_RUBY = /)
comment(       (?=[<\\#%]\))
comment(       < (?: \\?r | % | ruby> \))
comment(     | \\# [{(|])
comment(     | % (?: \\#\\d+ | \\w+ \) ;)
delete[delete(-)plain(    /x)]
insert[insert(+)plain(    /x  # :nodoc:)]
comment( )
delete[delete(-)plain(    CLOSING_PAREN = Hash.new do |h, p|)]
delete[delete(-)plain(      h[p] = p)]
delete[delete(-)plain(    end.update( {)]
insert[insert(+)plain(    CLOSING_PAREN = Hash.new { |h, p| h[p] = p }  # :nodoc:)]
insert[insert(+)plain(    CLOSING_PAREN.update( {)]
comment(       '(' => '\)',)
comment(       '[' => ']',)
comment(       '{' => '}',)
comment(     } \))
comment( )
delete[delete(-)plain(  private)]
insert[insert(+)plain(  protected)]
comment( )
comment(     def setup)
comment(       @ruby_scanner = CodeRay.scanner :ruby, :tokens => @tokens, :keep_tokens => true)
change[change(@@)plain( -119,6 +122,7 )change(@@)]
comment( )
comment(         else)
comment(           raise_inspect 'else-case reached!', tokens)
insert[insert(+)plain(          )]
comment(         end)
comment( )
comment(       end)
head[head(Index: )plain(lib/coderay/scanners/plaintext.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/plaintext.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/plaintext.rb	(revision 500\))]
change[change(@@)plain( -1,15 +1,24 )change(@@)]
comment( module CodeRay)
comment( module Scanners)
delete[delete(-)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # Scanner for plain text.)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Yields just one token of the kind :plain.)]
insert[insert(+)plain(  # )]
insert[insert(+)plain(  # Alias: +plain+)]
comment(   class Plaintext < Scanner)
comment( )
comment(     register_for :plaintext, :plain)
insert[insert(+)plain(    title 'Plain text')]
comment(     )
comment(     include Streamable)
delete[delete(-)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    KINDS_NOT_LOC = [:plain]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
comment(     def scan_tokens tokens, options)
delete[delete(-)plain(      text = (scan_until(/\\z/\) || ''\))]
delete[delete(-)plain(      tokens << [text, :plain])]
insert[insert(+)plain(      tokens << [string, :plain])]
comment(     end)
comment( )
comment(   end)
head[head(Index: )plain(lib/coderay/scanners/diff.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/diff.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/diff.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,105 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Scanners)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  class Diff < Scanner)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    register_for :diff)]
insert[insert(+)plain(    title 'diff output')]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def scan_tokens tokens, options)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      line_kind = nil)]
insert[insert(+)plain(      state = :initial)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      until eos?)]
insert[insert(+)plain(        kind = match = nil)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        if match = scan(/\\n/\))]
insert[insert(+)plain(          if line_kind)]
insert[insert(+)plain(            tokens << [:end_line, line_kind])]
insert[insert(+)plain(            line_kind = nil)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          tokens << [match, :space])]
insert[insert(+)plain(          next)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        case state)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        when :initial)]
insert[insert(+)plain(          if match = scan(/--- |\\+\\+\\+ |=+|_+/\))]
insert[insert(+)plain(            tokens << [:begin_line, line_kind = :head])]
insert[insert(+)plain(            tokens << [match, :head])]
insert[insert(+)plain(            next unless match = scan(/.+/\))]
insert[insert(+)plain(            kind = :plain)]
insert[insert(+)plain(          elsif match = scan(/Index: |Property changes on: /\))]
insert[insert(+)plain(            tokens << [:begin_line, line_kind = :head])]
insert[insert(+)plain(            tokens << [match, :head])]
insert[insert(+)plain(            next unless match = scan(/.+/\))]
insert[insert(+)plain(            kind = :plain)]
insert[insert(+)plain(          elsif match = scan(/Added: /\))]
insert[insert(+)plain(            tokens << [:begin_line, line_kind = :head])]
insert[insert(+)plain(            tokens << [match, :head])]
insert[insert(+)plain(            next unless match = scan(/.+/\))]
insert[insert(+)plain(            kind = :plain)]
insert[insert(+)plain(            state = :added)]
insert[insert(+)plain(          elsif match = scan(/\\\\ /\))]
insert[insert(+)plain(            tokens << [:begin_line, line_kind = :change])]
insert[insert(+)plain(            tokens << [match, :change])]
insert[insert(+)plain(            next unless match = scan(/.+/\))]
insert[insert(+)plain(            kind = :plain)]
insert[insert(+)plain(          elsif scan(/(@@\)((?>[^@\\n]*\)\)(@@\)/\))]
insert[insert(+)plain(            tokens << [:begin_line, line_kind = :change])]
insert[insert(+)plain(            tokens << [self[1], :change])]
insert[insert(+)plain(            tokens << [self[2], :plain])]
insert[insert(+)plain(            tokens << [self[3], :change])]
insert[insert(+)plain(            next unless match = scan(/.+/\))]
insert[insert(+)plain(            kind = :plain)]
insert[insert(+)plain(          elsif match = scan(/\\+/\))]
insert[insert(+)plain(            tokens << [:begin_line, line_kind = :insert])]
insert[insert(+)plain(            tokens << [match, :insert])]
insert[insert(+)plain(            next unless match = scan(/.+/\))]
insert[insert(+)plain(            kind = :plain)]
insert[insert(+)plain(          elsif match = scan(/-/\))]
insert[insert(+)plain(            tokens << [:begin_line, line_kind = :delete])]
insert[insert(+)plain(            tokens << [match, :delete])]
insert[insert(+)plain(            next unless match = scan(/.+/\))]
insert[insert(+)plain(            kind = :plain)]
insert[insert(+)plain(          elsif scan(/ .*/\))]
insert[insert(+)plain(            kind = :comment)]
insert[insert(+)plain(          elsif scan(/.+/\))]
insert[insert(+)plain(            tokens << [:begin_line, line_kind = :head])]
insert[insert(+)plain(            kind = :plain)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            raise_inspect 'else case rached')]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        when :added)]
insert[insert(+)plain(          if match = scan(/   \\+/\))]
insert[insert(+)plain(            tokens << [:begin_line, line_kind = :insert])]
insert[insert(+)plain(            tokens << [match, :insert])]
insert[insert(+)plain(            next unless match = scan(/.+/\))]
insert[insert(+)plain(            kind = :plain)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        match ||= matched)]
insert[insert(+)plain(        if $DEBUG and not kind)]
insert[insert(+)plain(          raise_inspect 'Error token %p in line %d' %)]
insert[insert(+)plain(            [[match, kind], line], tokens)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        raise_inspect 'Empty token', tokens unless match)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        tokens << [match, kind])]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      tokens << [:end_line, line_kind] if line_kind)]
insert[insert(+)plain(      tokens)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/scanners/json.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/json.rb	(revision 0\))]
head[head(+++ )plain(lib/coderay/scanners/json.rb	(revision 500\))]
change[change(@@)plain( -0,0 +1,115 )change(@@)]
insert[insert(+)plain(module CodeRay)]
insert[insert(+)plain(module Scanners)]
insert[insert(+)plain(  )]
insert[insert(+)plain(  # Scanner for JSON (JavaScript Object Notation\).)]
insert[insert(+)plain(  class JSON < Scanner)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    include Streamable)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    register_for :json)]
insert[insert(+)plain(    file_extension 'json')]
insert[insert(+)plain(    )]
insert[insert(+)plain(    KINDS_NOT_LOC = [)]
insert[insert(+)plain(      :float, :char, :content, :delimiter,)]
insert[insert(+)plain(      :error, :integer, :operator, :value,)]
insert[insert(+)plain(    ]  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    CONSTANTS = %w( true false null \)  # :nodoc:)]
insert[insert(+)plain(    IDENT_KIND = WordList.new(:key\).add(CONSTANTS, :value\)  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    ESCAPE = / [bfnrt\\\\"\\/] /x  # :nodoc:)]
insert[insert(+)plain(    UNICODE_ESCAPE =  / u[a-fA-F0-9]{4} /x  # :nodoc:)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  protected)]
insert[insert(+)plain(    )]
insert[insert(+)plain(    def scan_tokens tokens, options)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      state = :initial)]
insert[insert(+)plain(      stack = [])]
insert[insert(+)plain(      string_delimiter = nil)]
insert[insert(+)plain(      key_expected = false)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      until eos?)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        kind = nil)]
insert[insert(+)plain(        match = nil)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        case state)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        when :initial)]
insert[insert(+)plain(          if match = scan(/ \\s+ | \\\\\\n /x\))]
insert[insert(+)plain(            tokens << [match, :space])]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif match = scan(/ [:,\\[{\\]}] /x\))]
insert[insert(+)plain(            kind = :operator)]
insert[insert(+)plain(            case match)]
insert[insert(+)plain(            when '{' then stack << :object; key_expected = true)]
insert[insert(+)plain(            when '[' then stack << :array)]
insert[insert(+)plain(            when ':' then key_expected = false)]
insert[insert(+)plain(            when ',' then key_expected = true if stack.last == :object)]
insert[insert(+)plain(            when '}', ']' then stack.pop  # no error recovery, but works for valid JSON)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          elsif match = scan(/ true | false | null /x\))]
insert[insert(+)plain(            kind = IDENT_KIND[match])]
insert[insert(+)plain(          elsif match = scan(/-?(?:0|[1-9]\\d*\)/\))]
insert[insert(+)plain(            kind = :integer)]
insert[insert(+)plain(            if scan(/\\.\\d+(?:[eE][-+]?\\d+\)?|[eE][-+]?\\d+/\))]
insert[insert(+)plain(              match << matched)]
insert[insert(+)plain(              kind = :float)]
insert[insert(+)plain(            end)]
insert[insert(+)plain(          elsif match = scan(/"/\))]
insert[insert(+)plain(            state = key_expected ? :key : :string)]
insert[insert(+)plain(            tokens << [:open, state])]
insert[insert(+)plain(            kind = :delimiter)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            getch)]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        when :string, :key)]
insert[insert(+)plain(          if scan(/[^\\\\"]+/\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif scan(/"/\))]
insert[insert(+)plain(            tokens << ['"', :delimiter])]
insert[insert(+)plain(            tokens << [:close, state])]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(            next)]
insert[insert(+)plain(          elsif scan(/ \\\\ (?: #{ESCAPE} | #{UNICODE_ESCAPE} \) /mox\))]
insert[insert(+)plain(            kind = :char)]
insert[insert(+)plain(          elsif scan(/\\\\./m\))]
insert[insert(+)plain(            kind = :content)]
insert[insert(+)plain(          elsif scan(/ \\\\ | $ /x\))]
insert[insert(+)plain(            tokens << [:close, :delimiter])]
insert[insert(+)plain(            kind = :error)]
insert[insert(+)plain(            state = :initial)]
insert[insert(+)plain(          else)]
insert[insert(+)plain(            raise_inspect "else case \\" reached; %p not handled." % peek(1\), tokens)]
insert[insert(+)plain(          end)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        else)]
insert[insert(+)plain(          raise_inspect 'Unknown state', tokens)]
insert[insert(+)plain(          )]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        match ||= matched)]
insert[insert(+)plain(        if $CODERAY_DEBUG and not kind)]
insert[insert(+)plain(          raise_inspect 'Error token %p in line %d' %)]
insert[insert(+)plain(            [[match, kind], line], tokens)]
insert[insert(+)plain(        end)]
insert[insert(+)plain(        raise_inspect 'Empty token', tokens unless match)]
insert[insert(+)plain(        )]
insert[insert(+)plain(        tokens << [match, kind])]
insert[insert(+)plain(        )]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      if [:string, :key].include? state)]
insert[insert(+)plain(        tokens << [:close, state])]
insert[insert(+)plain(      end)]
insert[insert(+)plain(      )]
insert[insert(+)plain(      tokens)]
insert[insert(+)plain(    end)]
insert[insert(+)plain(    )]
insert[insert(+)plain(  end)]
insert[insert(+)plain(  )]
insert[insert(+)plain(end)]
insert[insert(+)plain(end)]
head[head(Index: )plain(lib/coderay/scanners/_map.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay/scanners/_map.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay/scanners/_map.rb	(revision 500\))]
change[change(@@)plain( -1,13 +1,20 )change(@@)]
comment( module CodeRay)
comment( module Scanners)
comment( )
delete[delete(-)plain(  map :cpp => :c,)]
insert[insert(+)plain(  map \\)]
insert[insert(+)plain(    :cplusplus => :cpp,)]
insert[insert(+)plain(    :'c++' => :cpp,)]
insert[insert(+)plain(    :ecmascript => :java_script,)]
insert[insert(+)plain(    :ecma_script => :java_script,)]
insert[insert(+)plain(    :irb => :ruby,)]
insert[insert(+)plain(    :javascript => :java_script,)]
insert[insert(+)plain(    :js => :java_script,)]
insert[insert(+)plain(    :nitro => :nitro_xhtml,)]
insert[insert(+)plain(    :pascal => :delphi,)]
insert[insert(+)plain(    :patch => :diff,)]
comment(     :plain => :plaintext,)
delete[delete(-)plain(    :pascal => :delphi,)]
delete[delete(-)plain(    :irb => :ruby,)]
delete[delete(-)plain(    :xml => :html,)]
delete[delete(-)plain(    :xhtml => :nitro_xhtml,)]
delete[delete(-)plain(    :nitro => :nitro_xhtml)]
insert[insert(+)plain(    :xhtml => :html,)]
insert[insert(+)plain(    :yml => :yaml)]
comment( )
comment(   default :plain)
comment( )
head[head(Index: )plain(lib/coderay.rb)]
head[head(===================================================================)]
head[head(--- )plain(lib/coderay.rb	(revision 250\))]
head[head(+++ )plain(lib/coderay.rb	(revision 500\))]
change[change(@@)plain( -1,7 +1,5 )change(@@)]
comment( # = CodeRay Library)
comment( #)
delete[delete(-)plain(# $Id$)]
delete[delete(-)plain(#)]
comment( # CodeRay is a Ruby library for syntax highlighting.)
comment( #)
comment( # I try to make CodeRay easy to use and intuitive, but at the same time fully featured, complete,)
change[change(@@)plain( -16,7 +14,7 )change(@@)]
comment( # )
comment( # Here's a fancy graphic to light up this gray docu:)
comment( # )
delete[delete(-)plain(# http://rd.cYcnus.de/coderay/scheme.png)]
insert[insert(+)plain(# http://cycnus.de/raindark/coderay/scheme.png)]
comment( # )
comment( # == Documentation)
comment( #)
change[change(@@)plain( -130,13 +128,14 )change(@@)]
comment( module CodeRay)
comment( )
comment(   # Version: Major.Minor.Teeny[.Revision])
delete[delete(-)plain(  # Major: 0 for pre-release)]
delete[delete(-)plain(  # Minor: odd for beta, even for stable)]
delete[delete(-)plain(  # Teeny: development state)]
delete[delete(-)plain(  # Revision: Subversion Revision number (generated on rake\))]
delete[delete(-)plain(  VERSION = '0.7.9')]
insert[insert(+)plain(  # Major: 0 for pre-stable, 1 for stable)]
insert[insert(+)plain(  # Minor: feature milestone)]
insert[insert(+)plain(  # Teeny: development state, 0 for pre-release)]
insert[insert(+)plain(  # Revision: Subversion Revision number (generated on rake gem:make\))]
insert[insert(+)plain(  VERSION = '0.9.1')]
comment( )
comment(   require 'coderay/tokens')
insert[insert(+)plain(  require 'coderay/token_classes')]
comment(   require 'coderay/scanner')
comment(   require 'coderay/encoder')
comment(   require 'coderay/duo')
head[head(Index: )plain(lib/README)]
head[head(===================================================================)]
head[head(--- )plain(lib/README	(revision 0\))]
head[head(+++ )plain(lib/README	(revision 500\))]
change[change(@@)plain( -0,0 +1,129 )change(@@)]
insert[insert(+)plain(= CodeRay)]
insert[insert(+)]
insert[insert(+)plain([- Tired of blue'n'gray? Try the original version of this documentation on)]
insert[insert(+)plain(coderay.rubychan.de[http://coderay.rubychan.de/doc/] (use Ctrl+Click to open it in its own frame.\) -])]
insert[insert(+)]
insert[insert(+)plain(== About)]
insert[insert(+)plain(CodeRay is a Ruby library for syntax highlighting.)]
insert[insert(+)]
insert[insert(+)plain(Syntax highlighting means: You put your code in, and you get it back colored;)]
insert[insert(+)plain(Keywords, strings, floats, comments - all in different colors.)]
insert[insert(+)plain(And with line numbers.)]
insert[insert(+)]
insert[insert(+)plain(*Syntax* *Highlighting*...)]
insert[insert(+)plain(* makes code easier to read and maintain)]
insert[insert(+)plain(* lets you detect syntax errors faster)]
insert[insert(+)plain(* helps you to understand the syntax of a language)]
insert[insert(+)plain(* looks nice)]
insert[insert(+)plain(* is what everybody should have on their website)]
insert[insert(+)plain(* solves all your problems and makes the girls run after you)]
insert[insert(+)]
insert[insert(+)plain(Version: 0.9.1)]
insert[insert(+)plain(Author:: murphy (Kornelius Kalnbach\))]
insert[insert(+)plain(Contact:: murphy rubychan de)]
insert[insert(+)plain(Website:: coderay.rubychan.de[http://coderay.rubychan.de])]
insert[insert(+)plain(License:: GNU LGPL; see LICENSE file in the main directory.)]
insert[insert(+)]
insert[insert(+)plain(== Installation)]
insert[insert(+)]
insert[insert(+)plain(You need RubyGems[http://rubyforge.org/frs/?group_id=126].)]
insert[insert(+)]
insert[insert(+)plain( % gem install coderay)]
insert[insert(+)]
insert[insert(+)]
insert[insert(+)plain(=== Dependencies)]
insert[insert(+)]
insert[insert(+)plain(CodeRay needs Ruby 1.8.6 or later. It also runs with Ruby 1.9.1+ and JRuby 1.1+.)]
insert[insert(+)]
insert[insert(+)]
insert[insert(+)plain(== Example Usage)]
insert[insert(+)plain((Forgive me, but this is not highlighted.\))]
insert[insert(+)]
insert[insert(+)plain( require 'coderay')]
insert[insert(+)plain( )]
insert[insert(+)plain( tokens = CodeRay.scan "puts 'Hello, world!'", :ruby)]
insert[insert(+)plain( page = tokens.html :line_numbers => :inline, :wrap => :page)]
insert[insert(+)plain( puts page)]
insert[insert(+)]
insert[insert(+)]
insert[insert(+)plain(== Documentation)]
insert[insert(+)]
insert[insert(+)plain(See CodeRay.)]
insert[insert(+)]
insert[insert(+)plain(Please report errors in this documentation to <murphy rubychan de>.)]
insert[insert(+)]
insert[insert(+)]
insert[insert(+)plain(== Credits)]
insert[insert(+)]
insert[insert(+)plain(=== Special Thanks to)]
insert[insert(+)]
insert[insert(+)plain(* licenser (Heinz N. Gies\) for ending my QBasic career, inventing the Coder)]
insert[insert(+)plain(  project and the input/output plugin system.)]
insert[insert(+)plain(  CodeRay would not exist without him.)]
insert[insert(+)plain(* bovi (Daniel Bovensiepen\) for helping me out on various occasions.)]
insert[insert(+)]
insert[insert(+)plain(=== Thanks to)]
insert[insert(+)]
insert[insert(+)plain(* Caleb Clausen for writing RubyLexer (see)]
insert[insert(+)plain(  http://rubyforge.org/projects/rubylexer\) and lots of very interesting mail)]
insert[insert(+)plain(  traffic)]
insert[insert(+)plain(* birkenfeld (Georg Brandl\) and mitsuhiku (Arnim Ronacher\) for PyKleur, now pygments.)]
insert[insert(+)plain(  You guys rock!)]
insert[insert(+)plain(* Jamis Buck for writing Syntax (see http://rubyforge.org/projects/syntax\))]
insert[insert(+)plain(  I got some useful ideas from it.)]
insert[insert(+)plain(* Doug Kearns and everyone else who worked on ruby.vim - it not only helped me)]
insert[insert(+)plain(  coding CodeRay, but also gave me a wonderful target to reach for the Ruby)]
insert[insert(+)plain(  scanner.)]
insert[insert(+)plain(* everyone who uses CodeBB on http://www.rubyforen.de and http://www.python-forum.de)]
insert[insert(+)plain(* iGEL, magichisoka, manveru, WoNDo and everyone I forgot from rubyforen.de)]
insert[insert(+)plain(* Dethix from ruby-mine.de)]
insert[insert(+)plain(* zickzackw)]
insert[insert(+)plain(* Dookie (who is no longer with us...\) and Leonidas from http://www.python-forum.de)]
insert[insert(+)plain(* Andreas Schwarz for finding out that CaseIgnoringWordList was not case)]
insert[insert(+)plain(  ignoring! Such things really make you write tests.)]
insert[insert(+)plain(* closure for the first version of the Scheme scanner.)]
insert[insert(+)plain(* Stefan Walk for the first version of the JavaScript scanner.)]
insert[insert(+)plain(* Josh Goebel for another version of the JavaScript scanner and a Diff scanner.)]
insert[insert(+)plain(* Jonathan Younger for pointing out the licence confusion caused by wrong LICENSE file.)]
insert[insert(+)plain(* Jeremy Hinegardner for finding the shebang-on-empty-file bug in FileType.)]
insert[insert(+)plain(* Charles Oliver Nutter and Yehuda Katz for helping me benchmark CodeRay on JRuby.)]
insert[insert(+)plain(* Andreas Neuhaus for pointing out a markup bug in coderay/for_redcloth.)]
insert[insert(+)plain(* 0xf30fc7 for the FileType patch concerning Delphi file extensions.)]
insert[insert(+)plain(* The folks at redmine.org - thank you for using and fixing CodeRay!)]
insert[insert(+)plain(* matz and all Ruby gods and gurus)]
insert[insert(+)plain(* The inventors of: the computer, the internet, the true color display, HTML &)]
insert[insert(+)plain(  CSS, VIM, Ruby, pizza, microwaves, guitars, scouting, programming, anime, )]
insert[insert(+)plain(  manga, coke and green ice tea.)]
insert[insert(+)]
insert[insert(+)plain(Where would we be without all those people?)]
insert[insert(+)]
insert[insert(+)plain(=== Created using)]
insert[insert(+)]
insert[insert(+)plain(* Ruby[http://ruby-lang.org/])]
insert[insert(+)plain(* Chihiro (my Sony VAIO laptop\); Henrietta (my old MacBook\);)]
insert[insert(+)plain(  Triella, born Rico (my new MacBook\); as well as)]
insert[insert(+)plain(  Seras and Hikari (my PCs\))]
insert[insert(+)plain(* RDE[http://homepage2.nifty.com/sakazuki/rde_e.html],)]
insert[insert(+)plain(  VIM[http://vim.org] and TextMate[http://macromates.com])]
insert[insert(+)plain(* Subversion[http://subversion.tigris.org/])]
insert[insert(+)plain(* Redmine[http://redmine.org/])]
insert[insert(+)plain(* Firefox[http://www.mozilla.org/products/firefox/],)]
insert[insert(+)plain(  Firebug[http://getfirebug.com/], Safari[http://www.apple.com/safari/], and)]
insert[insert(+)plain(  Thunderbird[http://www.mozilla.org/products/thunderbird/])]
insert[insert(+)plain(* RubyGems[http://docs.rubygems.org/] and Rake[http://rake.rubyforge.org/])]
insert[insert(+)plain(* TortoiseSVN[http://tortoisesvn.tigris.org/] using Apache via)]
insert[insert(+)plain(  XAMPP[http://www.apachefriends.org/en/xampp.html])]
insert[insert(+)plain(* RDoc (though I'm quite unsatisfied with it\))]
insert[insert(+)plain(* Microsoft Windows (yes, I confess!\) and MacOS X)]
insert[insert(+)plain(* GNUWin32, MinGW and some other tools to make the shell under windows a bit)]
insert[insert(+)plain(  less useless)]
insert[insert(+)plain(* Term::ANSIColor[http://term-ansicolor.rubyforge.org/])]
insert[insert(+)plain(* PLEAC[http://pleac.sourceforge.net/] code examples)]
insert[insert(+)]
insert[insert(+)plain(=== Free)]
insert[insert(+)]
insert[insert(+)plain(* As you can see, CodeRay was created under heavy use of *free* software.)]
insert[insert(+)plain(* So CodeRay is also *free*.)]
insert[insert(+)plain(* If you use CodeRay to create software, think about making this software)]
insert[insert(+)plain(  *free*, too.)]
insert[insert(+)plain(* Thanks :\))]

head[head(Property changes on: )plain(lib/README)]
head[head(___________________________________________________________________)]
head[head(Added: )plain(svn:keywords)]
insert[insert(   +)plain( Id)]
head[head(Added: )plain(svn:mergeinfo)]

