reserved(module) class(CodeRay)
	reserved(module) class(Scanners)

reserved(class) class(Ruby) operator(<) constant(Scanner)

	constant(RESERVED_WORDS) operator(=) operator([)
		string<delimiter(')content(and)delimiter(')>operator(,) string<delimiter(')content(def)delimiter(')>operator(,) string<delimiter(')content(end)delimiter(')>operator(,) string<delimiter(')content(in)delimiter(')>operator(,) string<delimiter(')content(or)delimiter(')>operator(,) string<delimiter(')content(unless)delimiter(')>operator(,) string<delimiter(')content(begin)delimiter(')>operator(,)
		string<delimiter(')content(defined?)delimiter(')>operator(,) string<delimiter(')content(ensure)delimiter(')>operator(,) string<delimiter(')content(module)delimiter(')>operator(,) string<delimiter(')content(redo)delimiter(')>operator(,) string<delimiter(')content(super)delimiter(')>operator(,) string<delimiter(')content(until)delimiter(')>operator(,)
		string<delimiter(')content(BEGIN)delimiter(')>operator(,) string<delimiter(')content(break)delimiter(')>operator(,) string<delimiter(')content(do)delimiter(')>operator(,) string<delimiter(')content(next)delimiter(')>operator(,) string<delimiter(')content(rescue)delimiter(')>operator(,) string<delimiter(')content(then)delimiter(')>operator(,)
		string<delimiter(')content(when)delimiter(')>operator(,) string<delimiter(')content(END)delimiter(')>operator(,) string<delimiter(')content(case)delimiter(')>operator(,) string<delimiter(')content(else)delimiter(')>operator(,) string<delimiter(')content(for)delimiter(')>operator(,) string<delimiter(')content(retry)delimiter(')>operator(,)
		string<delimiter(')content(while)delimiter(')>operator(,) string<delimiter(')content(alias)delimiter(')>operator(,) string<delimiter(')content(class)delimiter(')>operator(,) string<delimiter(')content(elsif)delimiter(')>operator(,) string<delimiter(')content(if)delimiter(')>operator(,) string<delimiter(')content(not)delimiter(')>operator(,) string<delimiter(')content(return)delimiter(')>operator(,)
		string<delimiter(')content(undef)delimiter(')>operator(,) string<delimiter(')content(yield)delimiter(')>operator(,)
	operator(])

	constant(DEF_KEYWORDS) operator(=) operator([)string<delimiter(')content(def)delimiter(')>operator(])
	constant(MODULE_KEYWORDS) operator(=) operator([)string<delimiter(')content(class)delimiter(')>operator(,) string<delimiter(')content(module)delimiter(')>operator(])
	constant(DEF_NEW_STATE) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:initial)operator(\))operator(.)
		ident(add)operator(()constant(DEF_KEYWORDS)operator(,) symbol(:def_expected)operator(\))operator(.)
		ident(add)operator(()constant(MODULE_KEYWORDS)operator(,) symbol(:module_expected)operator(\))

	constant(WORDS_ALLOWING_REGEXP) operator(=) operator([)
		string<delimiter(')content(and)delimiter(')>operator(,) string<delimiter(')content(or)delimiter(')>operator(,) string<delimiter(')content(not)delimiter(')>operator(,) string<delimiter(')content(while)delimiter(')>operator(,) string<delimiter(')content(until)delimiter(')>operator(,) string<delimiter(')content(unless)delimiter(')>operator(,) string<delimiter(')content(if)delimiter(')>operator(,) string<delimiter(')content(elsif)delimiter(')>operator(,) string<delimiter(')content(when)delimiter(')>
	operator(])
	constant(REGEXP_ALLOWED) operator(=) constant(WordList)operator(.)ident(new)operator(()pre_constant(false)operator(\))operator(.)
		ident(add)operator(()constant(WORDS_ALLOWING_REGEXP)operator(,) symbol(:set)operator(\))

	constant(PREDEFINED_CONSTANTS) operator(=) operator([)
		string<delimiter(')content(nil)delimiter(')>operator(,) string<delimiter(')content(true)delimiter(')>operator(,) string<delimiter(')content(false)delimiter(')>operator(,) string<delimiter(')content(self)delimiter(')>operator(,)
		string<delimiter(')content(DATA)delimiter(')>operator(,) string<delimiter(')content(ARGV)delimiter(')>operator(,) string<delimiter(')content(ARGF)delimiter(')>operator(,) string<delimiter(')content(__FILE__)delimiter(')>operator(,) string<delimiter(')content(__LINE__)delimiter(')>operator(,)
	operator(])

	constant(IDENT_KIND) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)
		ident(add)operator(()constant(RESERVED_WORDS)operator(,) symbol(:reserved)operator(\))operator(.)
		ident(add)operator(()constant(PREDEFINED_CONSTANTS)operator(,) symbol(:pre_constant)operator(\))

	constant(METHOD_NAME) operator(=) regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( [?!]? )delimiter(/)modifier(xo)>
	constant(METHOD_NAME_EX) operator(=) regexp<delimiter(/)content(
	 )inline<inline_delimiter(#{)constant(METHOD_NAME)inline_delimiter(})>content(  # common methods: split, foo=, empty?, gsub!
	 | )char(\\*)char(\\*)content(?         # multiplication and power
	 | [-+~]@?       # plus, minus
	 | [)char(\\/)content(%&|^`]     # division, modulo or format strings, &and, |or, ^xor, `system`
	 | )char(\\[)char(\\])content(=?        # array getter and setter
	 | <=?>? | >=?   # comparison, rocket operator
	 | << | >>       # append or shift left, shift right
	 | ===?          # simple equality and case equality
	)delimiter(/)modifier(ox)>
	constant(GLOBAL_VARIABLE) operator(=) regexp<delimiter(/)content( )char(\\$)content( (?: )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( | )char(\\d)content(+ | [~&+`'=)char(\\/)content(,;_.<>!@0$?*":F)char(\\\\)content(] | -[a-zA-Z_0-9] \) )delimiter(/)modifier(ox)>

	constant(DOUBLEQ) operator(=) regexp<delimiter(/)content( "  [^")char(\\#)char(\\\\)content(]*  (?: (?: )char(\\#)char(\\{)content(.*?)char(\\})content( | )char(\\#)content((?:$"\)?  | )char(\\\\)content(. \) [^")char(\\#)char(\\\\)content(]*  \)* "?  )delimiter(/)modifier(ox)>
	constant(SINGLEQ) operator(=) regexp<delimiter(/)content( '  [^')char(\\\\)content(]*    (?:                              )char(\\\\)content(.   [^')char(\\\\)content(]*    \)* '?  )delimiter(/)modifier(ox)>
	constant(STRING)  operator(=) regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(SINGLEQ)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(DOUBLEQ)inline_delimiter(})>content( )delimiter(/)modifier(ox)>
	constant(SHELL)   operator(=) regexp<delimiter(/)content( `  [^`)char(\\#)char(\\\\)content(]*  (?: (?: )char(\\#)char(\\{)content(.*?)char(\\})content( | )char(\\#)content((?:$`\)?  | )char(\\\\)content(. \) [^`)char(\\#)char(\\\\)content(]*  \)* `?  )delimiter(/)modifier(ox)>
	constant(REGEXP)  operator(=) regexp<delimiter(/)content( )char(\\/)content( [^)char(\\/)char(\\#)char(\\\\)content(]* (?: (?: )char(\\#)char(\\{)content(.*?)char(\\})content( | )char(\\#)content((?:$)char(\\/)content(\)? | )char(\\\\)content(. \) [^)char(\\/)char(\\#)char(\\\\)content(]* \)* )char(\\/)content(? )delimiter(/)modifier(ox)>

	constant(DECIMAL) operator(=) regexp<delimiter(/)char(\\d)content(+(?:_)char(\\d)content(+\)*)delimiter(/)>  comment(# doesn't recognize 09 as octal error)
	constant(OCTAL) operator(=) regexp<delimiter(/)content(0_?[0-7]+(?:_[0-7]+\)*)delimiter(/)>
	constant(HEXADECIMAL) operator(=) regexp<delimiter(/)content(0x[0-9A-Fa-f]+(?:_[0-9A-Fa-f]+\)*)delimiter(/)>
	constant(BINARY) operator(=) regexp<delimiter(/)content(0b[01]+(?:_[01]+\)*)delimiter(/)>

	constant(EXPONENT) operator(=) regexp<delimiter(/)content( [eE] [+-]? )inline<inline_delimiter(#{)constant(DECIMAL)inline_delimiter(})>content( )delimiter(/)modifier(ox)>
	constant(FLOAT) operator(=) regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(DECIMAL)inline_delimiter(})>content( (?: )inline<inline_delimiter(#{)constant(EXPONENT)inline_delimiter(})>content( | )char(\\.)content( )inline<inline_delimiter(#{)constant(DECIMAL)inline_delimiter(})>content( )inline<inline_delimiter(#{)constant(EXPONENT)inline_delimiter(})>content(? \) )delimiter(/)>
	constant(INTEGER) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(OCTAL)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(HEXADECIMAL)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(BINARY)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(DECIMAL)inline_delimiter(})>delimiter(/)>

	reserved(def) method(reset)
		reserved(super)
		instance_variable(@regexp_allowed) operator(=) pre_constant(false)
	reserved(end)

	reserved(def) method(next_token)
		reserved(return) reserved(if) instance_variable(@scanner)operator(.)ident(eos?)

		ident(kind) operator(=) symbol(:error)
		reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(\))  comment(# in every state)
			ident(kind) operator(=) symbol(:space)
			instance_variable(@regexp_allowed) operator(=) symbol(:set) reserved(if) instance_variable(@regexp_allowed) reserved(or) instance_variable(@scanner)operator(.)ident(matched)operator(.)ident(index)operator(()integer(?\\n)operator(\))  comment(# delayed flag setting)

		reserved(elsif) instance_variable(@state) operator(==) symbol(:def_expected)
			reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( (?: (?:)inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content((?:)char(\\.)content(|::\)\)* | (?:@@?|$\)? )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content((?:)char(\\.)content(|::\) \) )inline<inline_delimiter(#{)constant(METHOD_NAME_EX)inline_delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))
				ident(kind) operator(=) symbol(:method)
				instance_variable(@state) operator(=) symbol(:initial)
			reserved(else)
				instance_variable(@scanner)operator(.)ident(getch)
			reserved(end)
			instance_variable(@state) operator(=) symbol(:initial)

		reserved(elsif) instance_variable(@state) operator(==) symbol(:module_expected)
			reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(<<)delimiter(/)>operator(\))
				ident(kind) operator(=) symbol(:operator)
			reserved(else)
				reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( (?: )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( (?:)char(\\.)content(|::\)\)* )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))
					ident(kind) operator(=) symbol(:method)
				reserved(else)
					instance_variable(@scanner)operator(.)ident(getch)
				reserved(end)
				instance_variable(@state) operator(=) symbol(:initial)
			reserved(end)

		reserved(elsif) comment(# state == :initial)
			comment(# IDENTIFIERS, KEYWORDS)
			reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(GLOBAL_VARIABLE)operator(\))
				ident(kind) operator(=) symbol(:global_variable)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( @@ )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))
				ident(kind) operator(=) symbol(:class_variable)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( @ )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))
				ident(kind) operator(=) symbol(:instance_variable)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( __END__)char(\\n)content( ( (?!)char(\\#)content(CODE)char(\\#)content(\) .* \)? | )char(\\#)content([^)char(\\n)content(]* | =begin(?=)char(\\s)content(\).*? )char(\\n)content(=end(?=)char(\\s)content(|)char(\\z)content(\)(?:[^)char(\\n)content(]*\)? )delimiter(/)modifier(mx)>operator(\))
				ident(kind) operator(=) symbol(:comment)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(METHOD_NAME)operator(\))
				reserved(if) instance_variable(@last_token_dot)
					ident(kind) operator(=) symbol(:ident)
				reserved(else)
					ident(matched) operator(=) instance_variable(@scanner)operator(.)ident(matched)
					ident(kind) operator(=) constant(IDENT_KIND)operator([)ident(matched)operator(])
					reserved(if) ident(kind) operator(==) symbol(:ident) reserved(and) ident(matched) operator(=)operator(~) regexp<delimiter(/)content(^[A-Z])delimiter(/)>
						ident(kind) operator(=) symbol(:constant)
					reserved(elsif) ident(kind) operator(==) symbol(:reserved)
						instance_variable(@state) operator(=) constant(DEF_NEW_STATE)operator([)ident(matched)operator(])
						instance_variable(@regexp_allowed) operator(=) constant(REGEXP_ALLOWED)operator([)ident(matched)operator(])
					reserved(end)
				reserved(end)

			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(STRING)operator(\))
				ident(kind) operator(=) symbol(:string)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(SHELL)operator(\))
				ident(kind) operator(=) symbol(:shell)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(<<
				(?:
					([a-zA-Z_0-9]+\)
						(?: .*? ^)char(\\1)content($ | .* \)
				|
					-([a-zA-Z_0-9]+\)
						(?: .*? ^)char(\\s)content(*)char(\\2)content($ | .* \)
				|
					([")char(\\')content(`]\) (.+?\) )char(\\3)content(
						(?: .*? ^)char(\\4)content($ | .* \)
				|
					- ([")char(\\')content(`]\) (.+?\) )char(\\5)content(
						(?: .*? ^)char(\\s)content(*)char(\\6)content($ | .* \)
				\)
			)delimiter(/)modifier(mxo)>operator(\))
				ident(kind) operator(=) symbol(:string)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\/)delimiter(/)>operator(\)) reserved(and) instance_variable(@regexp_allowed)
				instance_variable(@scanner)operator(.)ident(unscan)
				instance_variable(@scanner)operator(.)ident(scan)operator(()constant(REGEXP)operator(\))
				ident(kind) operator(=) symbol(:regexp)
regexp<delimiter(/)content(%(?:[Qqxrw](?:)char(\\()content([^\)#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^\)#)char(\\\\)char(\\\\)content(]*\)*)char(\\\))content(?|)char(\\[)content([^)char(\\])content(#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^)char(\\])content(#)char(\\\\)char(\\\\)content(]*\)*)char(\\])content(?|)char(\\{)content([^}#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^}#)char(\\\\)char(\\\\)content(]*\)*)char(\\})content(?|<[^>#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^>#)char(\\\\)char(\\\\)content(]*\)*>?|([^a-zA-Z)char(\\\\)char(\\\\)content(]\)(?:(?!)char(\\1)content(\)[^#)char(\\\\)char(\\\\)content(]\)*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)(?:(?!)char(\\1)content(\)[^#)char(\\\\)char(\\\\)content(]\)*\)*)char(\\1)content(?\)|)char(\\()content([^\)#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^\)#)char(\\\\)char(\\\\)content(]*\)*)char(\\\))content(?|)char(\\[)content([^)char(\\])content(#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^)char(\\])content(#)char(\\\\)char(\\\\)content(]*\)*)char(\\])content(?|)char(\\{)content([^}#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^}#)char(\\\\)char(\\\\)content(]*\)*)char(\\})content(?|<[^>#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)[^>#)char(\\\\)char(\\\\)content(]*\)*>?|([^a-zA-Z)char(\\s)char(\\\\)char(\\\\)content(]\)(?:(?!)char(\\2)content(\)[^#)char(\\\\)char(\\\\)content(]\)*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#|)char(\\\\)char(\\\\)content(.\)(?:(?!)char(\\2)content(\)[^#)char(\\\\)char(\\\\)content(]\)*\)*)char(\\2)content(?|)char(\\\\)char(\\\\)content([^#)char(\\\\)char(\\\\)content(]*(?:(?:#)char(\\{)content(.*?)char(\\})content(|#\)[^#)char(\\\\)char(\\\\)content(]*\)*)char(\\\\)char(\\\\)content(?\))delimiter(/)>
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(:(?:)inline<inline_delimiter(#{)constant(GLOBAL_VARIABLE)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(METHOD_NAME_EX)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(STRING)inline_delimiter(})>content(\))delimiter(/)modifier(ox)>operator(\))
				ident(kind) operator(=) symbol(:symbol)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(
				)char(\\?)content( (?:
					[^)char(\\s)char(\\\\)content(]
				|
					)char(\\\\)content( (?:M-)char(\\\\)content(C-|C-)char(\\\\)content(M-|M-)char(\\\\)content(c|c)char(\\\\)content(M-|c|C-|M-\)\)? (?: )char(\\\\)content( (?: . | [0-7]{3} | x[0-9A-Fa-f][0-9A-Fa-f] \)
				\)
			)delimiter(/)modifier(mox)>operator(\))
				ident(kind) operator(=) symbol(:integer)

			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( [-+*)char(\\/)content(%=<>;,|&!(\))char(\\[)char(\\])content({}~?] | )char(\\.)char(\\.)content(?)char(\\.)content(? | ::? )delimiter(/)modifier(x)>operator(\))
				ident(kind) operator(=) symbol(:operator)
				instance_variable(@regexp_allowed) operator(=) symbol(:set) reserved(if) instance_variable(@scanner)operator(.)ident(matched)operator([)integer(-1)operator(,)integer(1)operator(]) operator(=)operator(~) regexp<delimiter(/)content([~=!<>|&^,)char(\\()char(\\[)content(+)char(\\-)char(\\/)char(\\*)content(%])char(\\z)delimiter(/)>
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(FLOAT)operator(\))
				ident(kind) operator(=) symbol(:float)
			reserved(elsif) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(INTEGER)operator(\))
				ident(kind) operator(=) symbol(:integer)
			reserved(else)
				instance_variable(@scanner)operator(.)ident(getch)
			reserved(end)
		reserved(end)

		ident(token) operator(=) constant(Token)operator(.)ident(new) instance_variable(@scanner)operator(.)ident(matched)operator(,) ident(kind)

		reserved(if) ident(kind) operator(==) symbol(:regexp)
			ident(token)operator(.)ident(text) operator(<<) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content([eimnosux]*)delimiter(/)>operator(\))
		reserved(end)

		instance_variable(@regexp_allowed) operator(=) operator(()instance_variable(@regexp_allowed) operator(==) symbol(:set)operator(\))  comment(# delayed flag setting)

		ident(token)
	reserved(end)
reserved(end)

ident(register) constant(Ruby)operator(,) string<delimiter(')content(ruby)delimiter(')>operator(,) string<delimiter(')content(rb)delimiter(')>

	reserved(end)
reserved(end)
reserved(class) class(Set)
  ident(include) constant(Enumerable)

  comment(# Creates a new set containing the given objects.)
  reserved(def) pre_constant(self)operator(.)ident([])operator(()operator(*)ident(ary)operator(\))
    ident(new)operator(()ident(ary)operator(\))
  reserved(end)

  comment(# Creates a new set containing the elements of the given enumerable)
  comment(# object.)
  comment(#)
  comment(# If a block is given, the elements of enum are preprocessed by the)
  comment(# given block.)
  reserved(def) method(initialize)operator(()ident(enum) operator(=) pre_constant(nil)operator(,) operator(&)ident(block)operator(\)) comment(# :yields: o)
    instance_variable(@hash) operator(||=) constant(Hash)operator(.)ident(new)

    ident(enum)operator(.)ident(nil?) reserved(and) reserved(return)

    reserved(if) ident(block)
      ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) ident(add)operator(()ident(block)operator([)ident(o)operator(])operator(\)) operator(})
    reserved(else)
      ident(merge)operator(()ident(enum)operator(\))
    reserved(end)
  reserved(end)

  comment(# Copy internal hash.)
  reserved(def) method(initialize_copy)operator(()ident(orig)operator(\))
    instance_variable(@hash) operator(=) ident(orig)operator(.)ident(instance_eval)operator({)instance_variable(@hash)operator(})operator(.)ident(dup)
  reserved(end)

  comment(# Returns the number of elements.)
  reserved(def) method(size)
    instance_variable(@hash)operator(.)ident(size)
  reserved(end)
  reserved(alias) method(length) method(size)

  comment(# Returns true if the set contains no elements.)
  reserved(def) method(empty?)
    instance_variable(@hash)operator(.)ident(empty?)
  reserved(end)

  comment(# Removes all elements and returns self.)
  reserved(def) method(clear)
    instance_variable(@hash)operator(.)ident(clear)
    pre_constant(self)
  reserved(end)

  comment(# Replaces the contents of the set with the contents of the given)
  comment(# enumerable object and returns self.)
  reserved(def) method(replace)operator(()ident(enum)operator(\))
    reserved(if) ident(enum)operator(.)ident(class) operator(==) pre_constant(self)operator(.)ident(class)
      instance_variable(@hash)operator(.)ident(replace)operator(()ident(enum)operator(.)ident(instance_eval) operator({) instance_variable(@hash) operator(})operator(\))
    reserved(else)
      ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
      ident(clear)
      ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) ident(add)operator(()ident(o)operator(\)) operator(})
    reserved(end)

    pre_constant(self)
  reserved(end)

  comment(# Converts the set to an array.  The order of elements is uncertain.)
  reserved(def) method(to_a)
    instance_variable(@hash)operator(.)ident(keys)
  reserved(end)

  reserved(def) method(flatten_merge)operator(()ident(set)operator(,) ident(seen) operator(=) constant(Set)operator(.)ident(new)operator(\))
    ident(set)operator(.)ident(each) operator({) operator(|)ident(e)operator(|)
      reserved(if) ident(e)operator(.)ident(is_a?)operator(()constant(Set)operator(\))
	reserved(if) ident(seen)operator(.)ident(include?)operator(()ident(e_id) operator(=) ident(e)operator(.)ident(object_id)operator(\))
	  ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(tried to flatten recursive Set)delimiter(")>
	reserved(end)

	ident(seen)operator(.)ident(add)operator(()ident(e_id)operator(\))
	ident(flatten_merge)operator(()ident(e)operator(,) ident(seen)operator(\))
	ident(seen)operator(.)ident(delete)operator(()ident(e_id)operator(\))
      reserved(else)
	ident(add)operator(()ident(e)operator(\))
      reserved(end)
    operator(})

    pre_constant(self)
  reserved(end)
  ident(protected) symbol(:flatten_merge)

  comment(# Returns a new set that is a copy of the set, flattening each)
  comment(# containing set recursively.)
  reserved(def) method(flatten)
    pre_constant(self)operator(.)ident(class)operator(.)ident(new)operator(.)ident(flatten_merge)operator(()pre_constant(self)operator(\))
  reserved(end)

  comment(# Equivalent to Set#flatten, but replaces the receiver with the)
  comment(# result in place.  Returns nil if no modifications were made.)
  reserved(def) method(flatten!)
    reserved(if) ident(detect) operator({) operator(|)ident(e)operator(|) ident(e)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) operator(})
      ident(replace)operator(()ident(flatten)operator(()operator(\))operator(\))
    reserved(else)
      pre_constant(nil)
    reserved(end)
  reserved(end)

  comment(# Returns true if the set contains the given object.)
  reserved(def) method(include?)operator(()ident(o)operator(\))
    instance_variable(@hash)operator(.)ident(include?)operator(()ident(o)operator(\))
  reserved(end)
  reserved(alias) method(member?) method(include?)

  comment(# Returns true if the set is a superset of the given set.)
  reserved(def) method(superset?)operator(()ident(set)operator(\))
    ident(set)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be a set)delimiter(")>
    reserved(return) pre_constant(false) reserved(if) ident(size) operator(<) ident(set)operator(.)ident(size)
    ident(set)operator(.)ident(all?) operator({) operator(|)ident(o)operator(|) ident(include?)operator(()ident(o)operator(\)) operator(})
  reserved(end)

  comment(# Returns true if the set is a proper superset of the given set.)
  reserved(def) method(proper_superset?)operator(()ident(set)operator(\))
    ident(set)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be a set)delimiter(")>
    reserved(return) pre_constant(false) reserved(if) ident(size) operator(<=) ident(set)operator(.)ident(size)
    ident(set)operator(.)ident(all?) operator({) operator(|)ident(o)operator(|) ident(include?)operator(()ident(o)operator(\)) operator(})
  reserved(end)

  comment(# Returns true if the set is a subset of the given set.)
  reserved(def) method(subset?)operator(()ident(set)operator(\))
    ident(set)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be a set)delimiter(")>
    reserved(return) pre_constant(false) reserved(if) ident(set)operator(.)ident(size) operator(<) ident(size)
    ident(all?) operator({) operator(|)ident(o)operator(|) ident(set)operator(.)ident(include?)operator(()ident(o)operator(\)) operator(})
  reserved(end)

  comment(# Returns true if the set is a proper subset of the given set.)
  reserved(def) method(proper_subset?)operator(()ident(set)operator(\))
    ident(set)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be a set)delimiter(")>
    reserved(return) pre_constant(false) reserved(if) ident(set)operator(.)ident(size) operator(<=) ident(size)
    ident(all?) operator({) operator(|)ident(o)operator(|) ident(set)operator(.)ident(include?)operator(()ident(o)operator(\)) operator(})
  reserved(end)

  comment(# Calls the given block once for each element in the set, passing)
  comment(# the element as parameter.)
  reserved(def) method(each)
    instance_variable(@hash)operator(.)ident(each_key) operator({) operator(|)ident(o)operator(|) reserved(yield)operator(()ident(o)operator(\)) operator(})
    pre_constant(self)
  reserved(end)

  comment(# Adds the given object to the set and returns self.  Use +merge+ to)
  comment(# add several elements at once.)
  reserved(def) method(add)operator(()ident(o)operator(\))
    instance_variable(@hash)operator([)ident(o)operator(]) operator(=) pre_constant(true)
    pre_constant(self)
  reserved(end)
  reserved(alias) method(<<) method(add)

  comment(# Adds the given object to the set and returns self.  If the)
  comment(# object is already in the set, returns nil.)
  reserved(def) method(add?)operator(()ident(o)operator(\))
    reserved(if) ident(include?)operator(()ident(o)operator(\))
      pre_constant(nil)
    reserved(else)
      ident(add)operator(()ident(o)operator(\))
    reserved(end)
  reserved(end)

  comment(# Deletes the given object from the set and returns self.  Use +subtract+ to)
  comment(# delete several items at once.)
  reserved(def) method(delete)operator(()ident(o)operator(\))
    instance_variable(@hash)operator(.)ident(delete)operator(()ident(o)operator(\))
    pre_constant(self)
  reserved(end)

  comment(# Deletes the given object from the set and returns self.  If the)
  comment(# object is not in the set, returns nil.)
  reserved(def) method(delete?)operator(()ident(o)operator(\))
    reserved(if) ident(include?)operator(()ident(o)operator(\))
      ident(delete)operator(()ident(o)operator(\))
    reserved(else)
      pre_constant(nil)
    reserved(end)
  reserved(end)

  comment(# Deletes every element of the set for which block evaluates to)
  comment(# true, and returns self.)
  reserved(def) method(delete_if)
    instance_variable(@hash)operator(.)ident(delete_if) operator({) operator(|)ident(o)operator(,)operator(|) reserved(yield)operator(()ident(o)operator(\)) operator(})
    pre_constant(self)
  reserved(end)

  comment(# Do collect(\) destructively.)
  reserved(def) method(collect!)
    ident(set) operator(=) pre_constant(self)operator(.)ident(class)operator(.)ident(new)
    ident(each) operator({) operator(|)ident(o)operator(|) ident(set) operator(<<) reserved(yield)operator(()ident(o)operator(\)) operator(})
    ident(replace)operator(()ident(set)operator(\))
  reserved(end)
  reserved(alias) method(map!) method(collect!)

  comment(# Equivalent to Set#delete_if, but returns nil if no changes were)
  comment(# made.)
  reserved(def) method(reject!)
    ident(n) operator(=) ident(size)
    ident(delete_if) operator({) operator(|)ident(o)operator(|) reserved(yield)operator(()ident(o)operator(\)) operator(})
    ident(size) operator(==) ident(n) operator(?) pre_constant(nil) operator(:) pre_constant(self)
  reserved(end)

  comment(# Merges the elements of the given enumerable object to the set and)
  comment(# returns self.)
  reserved(def) method(merge)operator(()ident(enum)operator(\))
    reserved(if) ident(enum)operator(.)ident(is_a?)operator(()constant(Set)operator(\))
      instance_variable(@hash)operator(.)ident(update)operator(()ident(enum)operator(.)ident(instance_eval) operator({) instance_variable(@hash) operator(})operator(\))
    reserved(else)
      ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
      ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) ident(add)operator(()ident(o)operator(\)) operator(})
    reserved(end)

    pre_constant(self)
  reserved(end)

  comment(# Deletes every element that appears in the given enumerable object)
  comment(# and returns self.)
  reserved(def) method(subtract)operator(()ident(enum)operator(\))
    ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
    ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) ident(delete)operator(()ident(o)operator(\)) operator(})
    pre_constant(self)
  reserved(end)

  comment(# Returns a new set built by merging the set and the elements of the)
  comment(# given enumerable object.)
  reserved(def) method(|)operator(()ident(enum)operator(\))
    ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
    ident(dup)operator(.)ident(merge)operator(()ident(enum)operator(\))
  reserved(end)
  reserved(alias) method(+) method(|)		comment(##)
  reserved(alias) method(union) method(|)		comment(##)

  comment(# Returns a new set built by duplicating the set, removing every)
  comment(# element that appears in the given enumerable object.)
  reserved(def) method(-)operator(()ident(enum)operator(\))
    ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
    ident(dup)operator(.)ident(subtract)operator(()ident(enum)operator(\))
  reserved(end)
  reserved(alias) method(difference) method(-)	comment(##)

  comment(# Returns a new array containing elements common to the set and the)
  comment(# given enumerable object.)
  reserved(def) method(&)operator(()ident(enum)operator(\))
    ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
    ident(n) operator(=) pre_constant(self)operator(.)ident(class)operator(.)ident(new)
    ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) ident(n)operator(.)ident(add)operator(()ident(o)operator(\)) reserved(if) ident(include?)operator(()ident(o)operator(\)) operator(})
    ident(n)
  reserved(end)
  reserved(alias) method(intersection) method(&)	comment(##)

  comment(# Returns a new array containing elements exclusive between the set)
  comment(# and the given enumerable object.  (set ^ enum\) is equivalent to)
  comment(# ((set | enum\) - (set & enum\)\).)
  reserved(def) method(^)operator(()ident(enum)operator(\))
    ident(enum)operator(.)ident(is_a?)operator(()constant(Enumerable)operator(\)) reserved(or) ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(value must be enumerable)delimiter(")>
    ident(n) operator(=) ident(dup)
    ident(enum)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) reserved(if) ident(n)operator(.)ident(include?)operator(()ident(o)operator(\)) reserved(then) ident(n)operator(.)ident(delete)operator(()ident(o)operator(\)) reserved(else) ident(n)operator(.)ident(add)operator(()ident(o)operator(\)) reserved(end) operator(})
    ident(n)
  reserved(end)

  comment(# Returns true if two sets are equal.  The equality of each couple)
  comment(# of elements is defined according to Object#eql?.)
  reserved(def) method(==)operator(()ident(set)operator(\))
    ident(equal?)operator(()ident(set)operator(\)) reserved(and) reserved(return) pre_constant(true)

    ident(set)operator(.)ident(is_a?)operator(()constant(Set)operator(\)) operator(&&) ident(size) operator(==) ident(set)operator(.)ident(size) reserved(or) reserved(return) pre_constant(false)

    ident(hash) operator(=) instance_variable(@hash)operator(.)ident(dup)
    ident(set)operator(.)ident(all?) operator({) operator(|)ident(o)operator(|) ident(hash)operator(.)ident(include?)operator(()ident(o)operator(\)) operator(})
  reserved(end)

  reserved(def) method(hash)	comment(# :nodoc:)
    instance_variable(@hash)operator(.)ident(hash)
  reserved(end)

  reserved(def) method(eql?)operator(()ident(o)operator(\))	comment(# :nodoc:)
    reserved(return) pre_constant(false) reserved(unless) ident(o)operator(.)ident(is_a?)operator(()constant(Set)operator(\))
    instance_variable(@hash)operator(.)ident(eql?)operator(()ident(o)operator(.)ident(instance_eval)operator({)instance_variable(@hash)operator(})operator(\))
  reserved(end)

  comment(# Classifies the set by the return value of the given block and)
  comment(# returns a hash of {value => set of elements} pairs.  The block is)
  comment(# called once for each element of the set, passing the element as)
  comment(# parameter.)
  comment(#)
  comment(# e.g.:)
  comment(#)
  comment(#   require 'set')
  comment(#   files = Set.new(Dir.glob("*.rb"\)\))
  comment(#   hash = files.classify { |f| File.mtime(f\).year })
  comment(#   p hash    # => {2000=>#<Set: {"a.rb", "b.rb"}>,)
  comment(#             #     2001=>#<Set: {"c.rb", "d.rb", "e.rb"}>,)
  comment(#             #     2002=>#<Set: {"f.rb"}>})
  reserved(def) method(classify) comment(# :yields: o)
    ident(h) operator(=) operator({)operator(})

    ident(each) operator({) operator(|)ident(i)operator(|)
      ident(x) operator(=) reserved(yield)operator(()ident(i)operator(\))
      operator(()ident(h)operator([)ident(x)operator(]) operator(||=) pre_constant(self)operator(.)ident(class)operator(.)ident(new)operator(\))operator(.)ident(add)operator(()ident(i)operator(\))
    operator(})

    ident(h)
  reserved(end)

  comment(# Divides the set into a set of subsets according to the commonality)
  comment(# defined by the given block.)
  comment(#)
  comment(# If the arity of the block is 2, elements o1 and o2 are in common)
  comment(# if block.call(o1, o2\) is true.  Otherwise, elements o1 and o2 are)
  comment(# in common if block.call(o1\) == block.call(o2\).)
  comment(#)
  comment(# e.g.:)
  comment(#)
  comment(#   require 'set')
  comment(#   numbers = Set[1, 3, 4, 6, 9, 10, 11])
  comment(#   set = numbers.divide { |i,j| (i - j\).abs == 1 })
  comment(#   p set     # => #<Set: {#<Set: {1}>,)
  comment(#             #            #<Set: {11, 9, 10}>,)
  comment(#             #            #<Set: {3, 4}>,)
  comment(#             #            #<Set: {6}>}>)
  reserved(def) method(divide)operator(()operator(&)ident(func)operator(\))
    reserved(if) ident(func)operator(.)ident(arity) operator(==) integer(2)
      ident(require) string<delimiter(')content(tsort)delimiter(')>

      reserved(class) operator(<<) class(dig) operator(=) operator({)operator(})		comment(# :nodoc:)
	ident(include) constant(TSort)

	reserved(alias) method(tsort_each_node) method(each_key)
	reserved(def) method(tsort_each_child)operator(()ident(node)operator(,) operator(&)ident(block)operator(\))
	  ident(fetch)operator(()ident(node)operator(\))operator(.)ident(each)operator(()operator(&)ident(block)operator(\))
	reserved(end)
      reserved(end)

      ident(each) operator({) operator(|)ident(u)operator(|)
	ident(dig)operator([)ident(u)operator(]) operator(=) ident(a) operator(=) operator([)operator(])
	ident(each)operator({) operator(|)ident(v)operator(|) ident(func)operator(.)ident(call)operator(()ident(u)operator(,) ident(v)operator(\)) reserved(and) ident(a) operator(<<) ident(v) operator(})
      operator(})

      ident(set) operator(=) constant(Set)operator(.)ident(new)operator(()operator(\))
      ident(dig)operator(.)ident(each_strongly_connected_component) operator({) operator(|)ident(css)operator(|)
	ident(set)operator(.)ident(add)operator(()pre_constant(self)operator(.)ident(class)operator(.)ident(new)operator(()ident(css)operator(\))operator(\))
      operator(})
      ident(set)
    reserved(else)
      constant(Set)operator(.)ident(new)operator(()ident(classify)operator(()operator(&)ident(func)operator(\))operator(.)ident(values)operator(\))
    reserved(end)
  reserved(end)

  constant(InspectKey) operator(=) symbol(:__inspect_key__)         comment(# :nodoc:)

  comment(# Returns a string containing a human-readable representation of the)
  comment(# set. ("#<Set: {element1, element2, ...}>"\))
  reserved(def) method(inspect)
    ident(ids) operator(=) operator(()constant(Thread)operator(.)ident(current)operator([)constant(InspectKey)operator(]) operator(||=) operator([)operator(])operator(\))

    reserved(if) ident(ids)operator(.)ident(include?)operator(()ident(object_id)operator(\))
      reserved(return) ident(sprintf)operator(()string<delimiter(')content(#<%s: {...}>)delimiter(')>operator(,) pre_constant(self)operator(.)ident(class)operator(.)ident(name)operator(\))
    reserved(end)

    reserved(begin)
      ident(ids) operator(<<) ident(object_id)
      reserved(return) ident(sprintf)operator(()string<delimiter(')content(#<%s: {%s}>)delimiter(')>operator(,) pre_constant(self)operator(.)ident(class)operator(,) ident(to_a)operator(.)ident(inspect)operator([)integer(1)operator(..)integer(-2)operator(])operator(\))
    reserved(ensure)
      ident(ids)operator(.)ident(pop)
    reserved(end)
  reserved(end)

  reserved(def) method(pretty_print)operator(()ident(pp)operator(\))	comment(# :nodoc:)
    ident(pp)operator(.)ident(text) ident(sprintf)operator(()string<delimiter(')content(#<%s: {)delimiter(')>operator(,) pre_constant(self)operator(.)ident(class)operator(.)ident(name)operator(\))
    ident(pp)operator(.)ident(nest)operator(()integer(1)operator(\)) operator({)
      ident(pp)operator(.)ident(seplist)operator(()pre_constant(self)operator(\)) operator({) operator(|)ident(o)operator(|)
	ident(pp)operator(.)ident(pp) ident(o)
      operator(})
    operator(})
    ident(pp)operator(.)ident(text) string<delimiter(")content(}>)delimiter(")>
  reserved(end)

  reserved(def) method(pretty_print_cycle)operator(()ident(pp)operator(\))	comment(# :nodoc:)
    ident(pp)operator(.)ident(text) ident(sprintf)operator(()string<delimiter(')content(#<%s: {%s}>)delimiter(')>operator(,) pre_constant(self)operator(.)ident(class)operator(.)ident(name)operator(,) ident(empty?) operator(?) string<delimiter(')delimiter(')> operator(:) string<delimiter(')content(...)delimiter(')>operator(\))
  reserved(end)
reserved(end)

comment(# SortedSet implements a set which elements are sorted in order.  See Set.)
reserved(class) class(SortedSet) operator(<) constant(Set)
  class_variable(@@setup) operator(=) pre_constant(false)

  reserved(class) operator(<<) class(self)
    reserved(def) method([])operator(()operator(*)ident(ary)operator(\))	comment(# :nodoc:)
      ident(new)operator(()ident(ary)operator(\))
    reserved(end)

    reserved(def) method(setup)	comment(# :nodoc:)
      class_variable(@@setup) reserved(and) reserved(return)

      reserved(begin)
	ident(require) string<delimiter(')content(rbtree)delimiter(')>

	ident(module_eval) string<delimiter(%{)content(
	  def initialize(*args, &block\)
	    @hash = RBTree.new
	    super
	  end
	)delimiter(})>
      reserved(rescue) constant(LoadError)
	ident(module_eval) string<delimiter(%{)content(
	  def initialize(*args, &block\)
	    @keys = nil
	    super
	  end

	  def clear
	    @keys = nil
	    super
	  end

	  def replace(enum\)
	    @keys = nil
	    super
	  end

	  def add(o\)
	    @keys = nil
	    @hash[o] = true
	    self
	  end
	  alias << add

	  def delete(o\)
	    @keys = nil
	    @hash.delete(o\)
	    self
	  end

	  def delete_if
	    n = @hash.size
	    @hash.delete_if )nesting_delimiter({)content( |o,| yield(o\) )nesting_delimiter(})content(
	    @keys = nil if @hash.size != n
	    self
	  end

	  def merge(enum\)
	    @keys = nil
	    super
	  end

	  def each
	    to_a.each )nesting_delimiter({)content( |o| yield(o\) )nesting_delimiter(})content(
	  end

	  def to_a
	    (@keys = @hash.keys\).sort! unless @keys
	    @keys
	  end
	)delimiter(})>
      reserved(end)

      class_variable(@@setup) operator(=) pre_constant(true)
    reserved(end)
  reserved(end)

  reserved(def) method(initialize)operator(()operator(*)ident(args)operator(,) operator(&)ident(block)operator(\))	comment(# :nodoc:)
    constant(SortedSet)operator(.)ident(setup)
    ident(initialize)operator(()operator(*)ident(args)operator(,) operator(&)ident(block)operator(\))
  reserved(end)
reserved(end)

reserved(module) class(Enumerable)
  comment(# Makes a set from the enumerable object with given arguments.)
  reserved(def) method(to_set)operator(()ident(klass) operator(=) constant(Set)operator(,) operator(*)ident(args)operator(,) operator(&)ident(block)operator(\))
    ident(klass)operator(.)ident(new)operator(()pre_constant(self)operator(,) operator(*)ident(args)operator(,) operator(&)ident(block)operator(\))
  reserved(end)
reserved(end)

comment(# =begin)
comment(# == RestricedSet class)
comment(# RestricedSet implements a set with restrictions defined by a given)
comment(# block.)
comment(#)
comment(# === Super class)
comment(#     Set)
comment(#)
comment(# === Class Methods)
comment(# --- RestricedSet::new(enum = nil\) { |o| ... })
comment(# --- RestricedSet::new(enum = nil\) { |rset, o| ... })
comment(#     Creates a new restricted set containing the elements of the given)
comment(#     enumerable object.  Restrictions are defined by the given block.)
comment(#)
comment(#     If the block's arity is 2, it is called with the RestrictedSet)
comment(#     itself and an object to see if the object is allowed to be put in)
comment(#     the set.)
comment(#)
comment(#     Otherwise, the block is called with an object to see if the object)
comment(#     is allowed to be put in the set.)
comment(#)
comment(# === Instance Methods)
comment(# --- restriction_proc)
comment(#     Returns the restriction procedure of the set.)
comment(#)
comment(# =end)
comment(#)
comment(# class RestricedSet < Set)
comment(#   def initialize(*args, &block\))
comment(#     @proc = block or raise ArgumentError, "missing a block")
comment(#)
comment(#     if @proc.arity == 2)
comment(#       instance_eval %{)
comment(# 	def add(o\))
comment(# 	  @hash[o] = true if @proc.call(self, o\))
comment(# 	  self)
comment(# 	end)
comment(# 	alias << add)
comment(#)
comment(# 	def add?(o\))
comment(# 	  if include?(o\) || !@proc.call(self, o\))
comment(# 	    nil)
comment(# 	  else)
comment(# 	    @hash[o] = true)
comment(# 	    self)
comment(# 	  end)
comment(# 	end)
comment(#)
comment(# 	def replace(enum\))
comment(# 	  enum.is_a?(Enumerable\) or raise ArgumentError, "value must be enumerable")
comment(# 	  clear)
comment(# 	  enum.each { |o| add(o\) })
comment(#)
comment(# 	  self)
comment(# 	end)
comment(#)
comment(# 	def merge(enum\))
comment(# 	  enum.is_a?(Enumerable\) or raise ArgumentError, "value must be enumerable")
comment(# 	  enum.each { |o| add(o\) })
comment(#)
comment(# 	  self)
comment(# 	end)
comment(#       })
comment(#     else)
comment(#       instance_eval %{)
comment(# 	def add(o\))
comment(#         if @proc.call(o\))
comment(# 	    @hash[o] = true)
comment(#         end)
comment(# 	  self)
comment(# 	end)
comment(# 	alias << add)
comment(#)
comment(# 	def add?(o\))
comment(# 	  if include?(o\) || !@proc.call(o\))
comment(# 	    nil)
comment(# 	  else)
comment(# 	    @hash[o] = true)
comment(# 	    self)
comment(# 	  end)
comment(# 	end)
comment(#       })
comment(#     end)
comment(#)
comment(#     super(*args\))
comment(#   end)
comment(#)
comment(#   def restriction_proc)
comment(#     @proc)
comment(#   end)
comment(# end)

reserved(if) global_variable($0) operator(==) pre_constant(__FILE__)
  ident(eval) pre_constant(DATA)operator(.)ident(read)operator(,) pre_constant(nil)operator(,) global_variable($0)operator(,) pre_constant(__LINE__)operator(+)integer(4)
reserved(end)

comment(# = rweb - CGI Support Library)
comment(#)
comment(# Author:: Johannes Barre (mailto:rweb@igels.net\))
comment(# Copyright:: Copyright (c\) 2003, 04 by Johannes Barre)
comment(# License:: GNU Lesser General Public License (COPYING, http://www.gnu.org/copyleft/lesser.html\))
comment(# Version:: 0.1.0)
comment(# CVS-ID:: $Id: rweb.rb 6 2004-06-16 15:56:26Z igel $)
comment(#)
comment(# == What is Rweb?)
comment(# Rweb is a replacement for the cgi class included in the ruby distribution.)
comment(#)
comment(# == How to use)
comment(#)
comment(# === Basics)
comment(#)
comment(# This class is made to be as easy as possible to use. An example:)
comment(#)
comment(# 	require "rweb")
comment(#)
comment(# 	web = Rweb.new)
comment(# 	web.out do)
comment(# 		web.puts "Hello world!")
comment(# 	end)
comment(#)
comment(# The visitor will get a simple "Hello World!" in his browser. Please notice,)
comment(# that won't set html-tags for you, so you should better do something like this:)
comment(#)
comment(# 	require "rweb")
comment(#)
comment(# 	web = Rweb.new)
comment(# 	web.out do)
comment(# 		web.puts "<html><body>Hello world!</body></html>")
comment(# 	end)
comment(#)
comment(# === Set headers)
comment(# Of course, it's also possible to tell the browser, that the content of this)
comment(# page is plain text instead of html code:)
comment(#)
comment(# 	require "rweb")
comment(#)
comment(# 	web = Rweb.new)
comment(# 	web.out do)
comment(# 		web.header("content-type: text/plain"\))
comment(# 		web.puts "Hello plain world!")
comment(# 	end)
comment(#)
comment(# Please remember, headers can't be set after the page content has been send.)
comment(# You have to set all nessessary headers before the first puts oder print. It's)
comment(# possible to cache the content until everything is complete. Doing it this)
comment(# way, you can set headers everywhere.)
comment(#)
comment(# If you set a header twice, the second header will replace the first one. The)
comment(# header name is not casesensitive, it will allways converted in to the)
comment(# capitalised form suggested by the w3c (http://w3.org\))
comment(#)
comment(# === Set cookies)
comment(# Setting cookies is quite easy:)
comment(# 	include 'rweb')
comment(#)
comment(# 	web = Rweb.new)
comment(# 	Cookie.new("Visits", web.cookies['visits'].to_i +1\))
comment(# 	web.out do)
comment(# 		web.puts "Welcome back! You visited this page #{web.cookies['visits'].to_i +1} times")
comment(# 	end)
comment(#)
comment(# See the class Cookie for more details.)
comment(#)
comment(# === Get form and cookie values)
comment(# There are four ways to submit data from the browser to the server and your)
comment(# ruby script: via GET, POST, cookies and file upload. Rweb doesn't support)
comment(# file upload by now.)
comment(#)
comment(# 	include 'rweb')
comment(#)
comment(# 	web = Rweb.new)
comment(# 	web.out do)
comment(# 		web.print "action: #{web.get['action']} ")
comment(# 		web.puts "The value of the cookie 'visits' is #{web.cookies['visits']}")
comment(# 		web.puts "The post parameter 'test['x']' is #{web.post['test']['x']}")
comment(# 	end)

constant(RWEB_VERSION) operator(=) string<delimiter(")content(0.1.0)delimiter(")>
constant(RWEB) operator(=) string<delimiter(")content(rweb/)inline<inline_delimiter(#{)constant(RWEB_VERSION)inline_delimiter(})>delimiter(")>

comment(#require 'rwebcookie' -> edit by bunny :-\))

reserved(class) class(Rweb)
    comment(# All parameter submitted via the GET method are available in attribute)
		comment(# get. This is Hash, where every parameter is available as a key-value)
		comment(# pair.)
		comment(#)
		comment(# If your input tag has a name like this one, it's value will be available)
		comment(# as web.get["fieldname"])
		comment(#  <input name="fieldname">)
		comment(# You can submit values as a Hash)
		comment(#  <input name="text['index']">)
		comment(#  <input name="text['index2']">)
		comment(# will be available as)
		comment(#  web.get["text"]["index"])
		comment(#  web.get["text"]["index2"])
		comment(# Integers are also possible)
		comment(#  <input name="int[2]">)
		comment(#  <input name="int[3]['hi']>)
		comment(# will be available as)
		comment(#  web.get["int"][2])
		comment(#  web.get["int"][3]["hi"])
		comment(# If you specify no index, the lowest unused index will be used:)
		comment(#  <input name="int[]"><!-- First Field -->)
		comment(#  <input name="int[]"><!-- Second one -->)
		comment(# will be available as)
		comment(#  web.get["int"][0] # First Field)
		comment(#  web.get["int"][1] # Second one)
		comment(# Please notice, this doesn'd work like you might expect:)
		comment(#  <input name="text[index]">)
		comment(# It will not be available as web.get["text"]["index"] but)
		comment(#  web.get["text[index]"])
    ident(attr_reader) symbol(:get)

    comment(# All parameters submitted via POST are available in the attribute post. It)
		comment(# works like the get attribute.)
		comment(#  <input name="text[0]">)
		comment(# will be available as)
		comment(#  web.post["text"][0])
		ident(attr_reader) symbol(:post)

    comment(# All cookies submitted by the browser are available in cookies. This is a)
		comment(# Hash, where every cookie is a key-value pair.)
		ident(attr_reader) symbol(:cookies)

    comment(# The name of the browser identification is submitted as USER_AGENT and)
		comment(# available in this attribute.)
		ident(attr_reader) symbol(:user_agent)

    comment(# The IP address of the client.)
		ident(attr_reader) symbol(:remote_addr)

    comment(# Creates a new Rweb object. This should only done once. You can set various)
    comment(# options via the settings hash.)
    comment(#)
    comment(# "cache" => true: Everything you script send to the client will be cached)
    comment(# until the end of the out block or until flush is called. This way, you)
    comment(# can modify headers and cookies even after printing something to the client.)
    comment(#)
    comment(# "safe" => level: Changes the $SAFE attribute. By default, $SAFE will be set)
    comment(# to 1. If $SAFE is already higher than this value, it won't be changed.)
    comment(#)
    comment(# "silend" => true: Normaly, Rweb adds automaticly a header like this)
    comment(# "X-Powered-By: Rweb/x.x.x (Ruby/y.y.y\)". With the silend option you can)
    comment(# suppress this.)
    reserved(def) method(initialize) operator(()ident(settings) operator(=) operator({)operator(})operator(\))
        comment(# {{{)
        instance_variable(@header) operator(=) operator({)operator(})
        instance_variable(@cookies) operator(=) operator({)operator(})
        instance_variable(@get) operator(=) operator({)operator(})
        instance_variable(@post) operator(=) operator({)operator(})

        comment(# Internal attributes)
        instance_variable(@status) operator(=) pre_constant(nil)
        instance_variable(@reasonPhrase) operator(=) pre_constant(nil)
        instance_variable(@setcookies) operator(=) operator([)operator(])
        instance_variable(@output_started) operator(=) pre_constant(false)operator(;)
        instance_variable(@output_allowed) operator(=) pre_constant(false)operator(;)

        instance_variable(@mod_ruby) operator(=) pre_constant(false)
        instance_variable(@env) operator(=) constant(ENV)operator(.)ident(to_hash)

        reserved(if) reserved(defined?)operator(()constant(MOD_RUBY)operator(\))
            instance_variable(@output_method) operator(=) string<delimiter(")content(mod_ruby)delimiter(")>
            instance_variable(@mod_ruby) operator(=) pre_constant(true)
        reserved(elsif) instance_variable(@env)operator([)string<delimiter(')content(SERVER_SOFTWARE)delimiter(')>operator(]) operator(=)operator(~) regexp<delimiter(/)content(^Microsoft-IIS)delimiter(/)modifier(i)>
            instance_variable(@output_method) operator(=) string<delimiter(")content(nph)delimiter(")>
        reserved(else)
            instance_variable(@output_method) operator(=) string<delimiter(")content(ph)delimiter(")>
        reserved(end)

        reserved(unless) ident(settings)operator(.)ident(is_a?)operator(()constant(Hash)operator(\))
            ident(raise) constant(TypeError)operator(,) string<delimiter(")content(settings must be a Hash)delimiter(")>
        reserved(end)
        instance_variable(@settings) operator(=) ident(settings)

        reserved(unless) instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(safe)delimiter(")>operator(\))
            instance_variable(@settings)operator([)string<delimiter(")content(safe)delimiter(")>operator(]) operator(=) integer(1)
        reserved(end)

        reserved(if) global_variable($SAFE) operator(<) instance_variable(@settings)operator([)string<delimiter(")content(safe)delimiter(")>operator(])
            global_variable($SAFE) operator(=) instance_variable(@settings)operator([)string<delimiter(")content(safe)delimiter(")>operator(])
        reserved(end)

        reserved(unless) instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(cache)delimiter(")>operator(\))
            instance_variable(@settings)operator([)string<delimiter(")content(cache)delimiter(")>operator(]) operator(=) pre_constant(false)
        reserved(end)

        comment(# mod_ruby sets no QUERY_STRING variable, if no GET-Parameters are given)
        reserved(unless) instance_variable(@env)operator(.)ident(has_key?)operator(()string<delimiter(")content(QUERY_STRING)delimiter(")>operator(\))
            instance_variable(@env)operator([)string<delimiter(")content(QUERY_STRING)delimiter(")>operator(]) operator(=) string<delimiter(")delimiter(")>
        reserved(end)

        comment(# Now we split the QUERY_STRING by the seperators & and ; or, if)
        comment(# specified, settings['get seperator'])
        reserved(unless) instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(get seperator)delimiter(")>operator(\))
            ident(get_args) operator(=) instance_variable(@env)operator([)string<delimiter(')content(QUERY_STRING)delimiter(')>operator(])operator(.)ident(split)operator(()regexp<delimiter(/)content([&;])delimiter(/)>operator(\))
        reserved(else)
            ident(get_args) operator(=) instance_variable(@env)operator([)string<delimiter(')content(QUERY_STRING)delimiter(')>operator(])operator(.)ident(split)operator(()instance_variable(@settings)operator([)string<delimiter(')content(get seperator)delimiter(')>operator(])operator(\))
        reserved(end)

        ident(get_args)operator(.)ident(each) reserved(do) operator(|) ident(arg) operator(|)
            ident(arg_key)operator(,) ident(arg_val) operator(=) ident(arg)operator(.)ident(split)operator(()regexp<delimiter(/)content(=)delimiter(/)>operator(,) integer(2)operator(\))
            ident(arg_key) operator(=) constant(Rweb)operator(::)ident(unescape)operator(()ident(arg_key)operator(\))
            ident(arg_val) operator(=) constant(Rweb)operator(::)ident(unescape)operator(()ident(arg_val)operator(\))

            comment(# Parse names like name[0], name['text'] or name[])
            ident(pattern) operator(=) regexp<delimiter(/)content(^(.+\))char(\\[)content(("[^)char(\\])content(]*"|'[^)char(\\])content(]*'|[0-9]*\))char(\\])content($)delimiter(/)>
            ident(keys) operator(=) operator([)operator(])
            reserved(while) ident(match) operator(=) ident(pattern)operator(.)ident(match)operator(()ident(arg_key)operator(\))
                ident(arg_key) operator(=) ident(match)operator([)integer(1)operator(])
                ident(keys) operator(=) operator([)ident(match)operator([)integer(2)operator(])operator(]) operator(+) ident(keys)
            reserved(end)
            ident(keys) operator(=) operator([)ident(arg_key)operator(]) operator(+) ident(keys)

            ident(akt) operator(=) instance_variable(@get)
            ident(last) operator(=) pre_constant(nil)
            ident(lastkey) operator(=) pre_constant(nil)
            ident(keys)operator(.)ident(each) reserved(do) operator(|)ident(key)operator(|)
                reserved(if) ident(key) operator(==) string<delimiter(")delimiter(")>
                    comment(# No key specified (like in "test[]"\), so we use the)
                    comment(# lowerst unused Integer as key)
                    ident(key) operator(=) integer(0)
                    reserved(while) ident(akt)operator(.)ident(has_key?)operator(()ident(key)operator(\))
                        ident(key) operator(+=) integer(1)
                    reserved(end)
                reserved(elsif) regexp<delimiter(/)content(^[0-9]*$)delimiter(/)> operator(=)operator(~) ident(key)
                    comment(# If the index is numerical convert it to an Integer)
                    ident(key) operator(=) ident(key)operator(.)ident(to_i)
                reserved(elsif) ident(key)operator([)integer(0)operator(])operator(.)ident(chr) operator(==) string<delimiter(")content(')delimiter(")> operator(||) ident(key)operator([)integer(0)operator(])operator(.)ident(chr) operator(==) string<delimiter(')content(")delimiter(')>
                    ident(key) operator(=) ident(key)operator([)integer(1)operator(,) ident(key)operator(.)ident(length)operator(()operator(\)) operator(-)integer(2)operator(])
                reserved(end)
                reserved(if) operator(!)ident(akt)operator(.)ident(has_key?)operator(()ident(key)operator(\)) operator(||) operator(!)ident(akt)operator([)ident(key)operator(])operator(.)ident(class) operator(==) constant(Hash)
                    comment(# create an empty Hash if there isn't already one)
                    ident(akt)operator([)ident(key)operator(]) operator(=) operator({)operator(})
                reserved(end)
                ident(last) operator(=) ident(akt)
                ident(lastkey) operator(=) ident(key)
                ident(akt) operator(=) ident(akt)operator([)ident(key)operator(])
            reserved(end)
            ident(last)operator([)ident(lastkey)operator(]) operator(=) ident(arg_val)
        reserved(end)

        reserved(if) instance_variable(@env)operator([)string<delimiter(')content(REQUEST_METHOD)delimiter(')>operator(]) operator(==) string<delimiter(")content(POST)delimiter(")>
            reserved(if) instance_variable(@env)operator(.)ident(has_key?)operator(()string<delimiter(")content(CONTENT_TYPE)delimiter(")>operator(\)) operator(&&) instance_variable(@env)operator([)string<delimiter(')content(CONTENT_TYPE)delimiter(')>operator(]) operator(==) string<delimiter(")content(application/x-www-form-urlencoded)delimiter(")> operator(&&) instance_variable(@env)operator(.)ident(has_key?)operator(()string<delimiter(')content(CONTENT_LENGTH)delimiter(')>operator(\))
                reserved(unless) instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(post seperator)delimiter(")>operator(\))
                    ident(post_args) operator(=) global_variable($stdin)operator(.)ident(read)operator(()instance_variable(@env)operator([)string<delimiter(')content(CONTENT_LENGTH)delimiter(')>operator(])operator(.)ident(to_i)operator(\))operator(.)ident(split)operator(()regexp<delimiter(/)content([&;])delimiter(/)>operator(\))
                reserved(else)
                    ident(post_args) operator(=) global_variable($stdin)operator(.)ident(read)operator(()instance_variable(@env)operator([)string<delimiter(')content(CONTENT_LENGTH)delimiter(')>operator(])operator(.)ident(to_i)operator(\))operator(.)ident(split)operator(()instance_variable(@settings)operator([)string<delimiter(')content(post seperator)delimiter(')>operator(])operator(\))
                reserved(end)
                ident(post_args)operator(.)ident(each) reserved(do) operator(|) ident(arg) operator(|)
                    ident(arg_key)operator(,) ident(arg_val) operator(=) ident(arg)operator(.)ident(split)operator(()regexp<delimiter(/)content(=)delimiter(/)>operator(,) integer(2)operator(\))
                    ident(arg_key) operator(=) constant(Rweb)operator(::)ident(unescape)operator(()ident(arg_key)operator(\))
                    ident(arg_val) operator(=) constant(Rweb)operator(::)ident(unescape)operator(()ident(arg_val)operator(\))

                    comment(# Parse names like name[0], name['text'] or name[])
                    ident(pattern) operator(=) regexp<delimiter(/)content(^(.+\))char(\\[)content(("[^)char(\\])content(]*"|'[^)char(\\])content(]*'|[0-9]*\))char(\\])content($)delimiter(/)>
                    ident(keys) operator(=) operator([)operator(])
                    reserved(while) ident(match) operator(=) ident(pattern)operator(.)ident(match)operator(()ident(arg_key)operator(\))
                        ident(arg_key) operator(=) ident(match)operator([)integer(1)operator(])
                        ident(keys) operator(=) operator([)ident(match)operator([)integer(2)operator(])operator(]) operator(+) ident(keys)
                    reserved(end)
                    ident(keys) operator(=) operator([)ident(arg_key)operator(]) operator(+) ident(keys)

                    ident(akt) operator(=) instance_variable(@post)
                    ident(last) operator(=) pre_constant(nil)
                    ident(lastkey) operator(=) pre_constant(nil)
                    ident(keys)operator(.)ident(each) reserved(do) operator(|)ident(key)operator(|)
                        reserved(if) ident(key) operator(==) string<delimiter(")delimiter(")>
                            comment(# No key specified (like in "test[]"\), so we use)
                            comment(# the lowerst unused Integer as key)
                            ident(key) operator(=) integer(0)
                            reserved(while) ident(akt)operator(.)ident(has_key?)operator(()ident(key)operator(\))
                                ident(key) operator(+=) integer(1)
                            reserved(end)
                        reserved(elsif) regexp<delimiter(/)content(^[0-9]*$)delimiter(/)> operator(=)operator(~) ident(key)
                            comment(# If the index is numerical convert it to an Integer)
                            ident(key) operator(=) ident(key)operator(.)ident(to_i)
                        reserved(elsif) ident(key)operator([)integer(0)operator(])operator(.)ident(chr) operator(==) string<delimiter(")content(')delimiter(")> operator(||) ident(key)operator([)integer(0)operator(])operator(.)ident(chr) operator(==) string<delimiter(')content(")delimiter(')>
                            ident(key) operator(=) ident(key)operator([)integer(1)operator(,) ident(key)operator(.)ident(length)operator(()operator(\)) operator(-)integer(2)operator(])
                        reserved(end)
                        reserved(if) operator(!)ident(akt)operator(.)ident(has_key?)operator(()ident(key)operator(\)) operator(||) operator(!)ident(akt)operator([)ident(key)operator(])operator(.)ident(class) operator(==) constant(Hash)
                            comment(# create an empty Hash if there isn't already one)
                            ident(akt)operator([)ident(key)operator(]) operator(=) operator({)operator(})
                        reserved(end)
                        ident(last) operator(=) ident(akt)
                        ident(lastkey) operator(=) ident(key)
                        ident(akt) operator(=) ident(akt)operator([)ident(key)operator(])
                    reserved(end)
                    ident(last)operator([)ident(lastkey)operator(]) operator(=) ident(arg_val)
                reserved(end)
            reserved(else)
                comment(# Maybe we should print a warning here?)
                global_variable($stderr)operator(.)ident(print)operator(()string<delimiter(")content(Unidentified form data recived and discarded.)delimiter(")>operator(\))
            reserved(end)
        reserved(end)

        reserved(if) instance_variable(@env)operator(.)ident(has_key?)operator(()string<delimiter(")content(HTTP_COOKIE)delimiter(")>operator(\))
            ident(cookie) operator(=) instance_variable(@env)operator([)string<delimiter(')content(HTTP_COOKIE)delimiter(')>operator(])operator(.)ident(split)operator(()regexp<delimiter(/)content(; ?)delimiter(/)>operator(\))
            ident(cookie)operator(.)ident(each) reserved(do) operator(|) ident(c) operator(|)
                ident(cookie_key)operator(,) ident(cookie_val) operator(=) ident(c)operator(.)ident(split)operator(()regexp<delimiter(/)content(=)delimiter(/)>operator(,) integer(2)operator(\))

                instance_variable(@cookies) operator([)constant(Rweb)operator(::)ident(unescape)operator(()ident(cookie_key)operator(\))operator(]) operator(=) constant(Rweb)operator(::)ident(unescape)operator(()ident(cookie_val)operator(\))
            reserved(end)
        reserved(end)

        reserved(if) reserved(defined?)operator(()instance_variable(@env)operator([)string<delimiter(')content(HTTP_USER_AGENT)delimiter(')>operator(])operator(\))
            instance_variable(@user_agent) operator(=) instance_variable(@env)operator([)string<delimiter(')content(HTTP_USER_AGENT)delimiter(')>operator(])
        reserved(else)
            instance_variable(@user_agent) operator(=) pre_constant(nil)operator(;)
        reserved(end)

        reserved(if) reserved(defined?)operator(()instance_variable(@env)operator([)string<delimiter(')content(REMOTE_ADDR)delimiter(')>operator(])operator(\))
            instance_variable(@remote_addr) operator(=) instance_variable(@env)operator([)string<delimiter(')content(REMOTE_ADDR)delimiter(')>operator(])
        reserved(else)
            instance_variable(@remote_addr) operator(=) pre_constant(nil)
        reserved(end)
        comment(# }}})
    reserved(end)

    comment(# Prints a String to the client. If caching is enabled, the String will)
    comment(# buffered until the end of the out block ends.)
    reserved(def) method(print)operator(()ident(str) operator(=) string<delimiter(")delimiter(")>operator(\))
        comment(# {{{)
        reserved(unless) instance_variable(@output_allowed)
            ident(raise) string<delimiter(")content(You just can write to output inside of a Rweb::out-block)delimiter(")>
        reserved(end)

        reserved(if) instance_variable(@settings)operator([)string<delimiter(")content(cache)delimiter(")>operator(])
            instance_variable(@buffer) operator(+=) operator([)ident(str)operator(.)ident(to_s)operator(])
        reserved(else)
            reserved(unless) instance_variable(@output_started)
                ident(sendHeaders)
            reserved(end)
            global_variable($stdout)operator(.)ident(print)operator(()ident(str)operator(\))
        reserved(end)
        pre_constant(nil)
        comment(# }}})
    reserved(end)

    comment(# Prints a String to the client and adds a line break at the end. Please)
		comment(# remember, that a line break is not visible in HTML, use the <br> HTML-Tag)
		comment(# for this. If caching is enabled, the String will buffered until the end)
		comment(# of the out block ends.)
    reserved(def) method(puts)operator(()ident(str) operator(=) string<delimiter(")delimiter(")>operator(\))
        comment(# {{{)
        pre_constant(self)operator(.)ident(print)operator(()ident(str) operator(+) string<delimiter(")char(\\n)delimiter(")>operator(\))
        comment(# }}})
    reserved(end)

		comment(# Alias to print.)
    reserved(def) method(write)operator(()ident(str) operator(=) string<delimiter(")delimiter(")>operator(\))
        comment(# {{{)
        pre_constant(self)operator(.)ident(print)operator(()ident(str)operator(\))
        comment(# }}})
    reserved(end)

    comment(# If caching is enabled, all cached data are send to the cliend and the)
		comment(# cache emptied.)
    reserved(def) method(flush)
        comment(# {{{)
        reserved(unless) instance_variable(@output_allowed)
            ident(raise) string<delimiter(")content(You can't use flush outside of a Rweb::out-block)delimiter(")>
        reserved(end)
        ident(buffer) operator(=) instance_variable(@buffer)operator(.)ident(join)

        reserved(unless) instance_variable(@output_started)
            ident(sendHeaders)
        reserved(end)
        global_variable($stdout)operator(.)ident(print)operator(()ident(buffer)operator(\))

        instance_variable(@buffer) operator(=) operator([)operator(])
        comment(# }}})
    reserved(end)

    comment(# Sends one or more header to the client. All headers are cached just)
		comment(# before body data are send to the client. If the same header are set)
		comment(# twice, only the last value is send.)
		comment(#)
		comment(# Example:)
		comment(#  web.header("Last-Modified: Mon, 16 Feb 2004 20:15:41 GMT"\))
		comment(#  web.header("Location: http://www.ruby-lang.org"\))
		comment(#)
		comment(# You can specify more than one header at the time by doing something like)
		comment(# this:)
		comment(#  web.header("Content-Type: text/plain\\nContent-Length: 383"\))
		comment(# or)
		comment(#  web.header(["Content-Type: text/plain", "Content-Length: 383"]\))
    reserved(def) method(header)operator(()ident(str)operator(\))
        comment(# {{{)
        reserved(if) instance_variable(@output_started)
            ident(raise) string<delimiter(")content(HTTP-Headers are already send. You can't change them after output has started!)delimiter(")>
        reserved(end)
        reserved(unless) instance_variable(@output_allowed)
            ident(raise) string<delimiter(")content(You just can set headers inside of a Rweb::out-block)delimiter(")>
        reserved(end)
        reserved(if) ident(str)operator(.)ident(is_a?)constant(Array)
            ident(str)operator(.)ident(each) reserved(do) operator(|) ident(value) operator(|)
                pre_constant(self)operator(.)ident(header)operator(()ident(value)operator(\))
            reserved(end)

        reserved(elsif) ident(str)operator(.)ident(split)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))operator(.)ident(length) operator(>) integer(1)
            ident(str)operator(.)ident(split)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))operator(.)ident(each) reserved(do) operator(|) ident(value) operator(|)
                pre_constant(self)operator(.)ident(header)operator(()ident(value)operator(\))
            reserved(end)

        reserved(elsif) ident(str)operator(.)ident(is_a?) constant(String)
            ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\r)delimiter(/)>operator(,) string<delimiter(")delimiter(")>operator(\))

            reserved(if) operator(()ident(str) operator(=)operator(~) regexp<delimiter(/)content(^HTTP)char(\\/)content(1)char(\\.)content([01] [0-9]{3} ?.*$)delimiter(/)>operator(\)) operator(==) integer(0)
                ident(pattern) operator(=) regexp<delimiter(/)content(^HTTP)char(\\/)content(1.[01] ([0-9]{3}\) ?(.*\)$)delimiter(/)>

                ident(result) operator(=) ident(pattern)operator(.)ident(match)operator(()ident(str)operator(\))
                pre_constant(self)operator(.)ident(setstatus)operator(()ident(result)operator([)integer(0)operator(])operator(,) ident(result)operator([)integer(1)operator(])operator(\))
            reserved(elsif) operator(()ident(str) operator(=)operator(~) regexp<delimiter(/)content(^status: [0-9]{3} ?.*$)delimiter(/)modifier(i)>operator(\)) operator(==) integer(0)
                ident(pattern) operator(=) regexp<delimiter(/)content(^status: ([0-9]{3}\) ?(.*\)$)delimiter(/)modifier(i)>

                ident(result) operator(=) ident(pattern)operator(.)ident(match)operator(()ident(str)operator(\))
                pre_constant(self)operator(.)ident(setstatus)operator(()ident(result)operator([)integer(0)operator(])operator(,) ident(result)operator([)integer(1)operator(])operator(\))
            reserved(else)
                ident(a) operator(=) ident(str)operator(.)ident(split)operator(()regexp<delimiter(/)content(: ?)delimiter(/)>operator(,) integer(2)operator(\))

                instance_variable(@header)operator([)ident(a)operator([)integer(0)operator(])operator(.)ident(downcase)operator(]) operator(=) ident(a)operator([)integer(1)operator(])
            reserved(end)
        reserved(end)
        comment(# }}})
    reserved(end)

    comment(# Changes the status of this page. There are several codes like "200 OK",)
		comment(# "302 Found", "404 Not Found" or "500 Internal Server Error". A list of)
		comment(# all codes is available at)
		comment(# http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10)
		comment(#)
		comment(# You can just send the code number, the reason phrase will be added)
		comment(# automaticly with the recommendations from the w3c if not specified. If)
		comment(# you set the status twice or more, only the last status will be send.)
		comment(# Examples:)
		comment(#  web.status("401 Unauthorized"\))
		comment(#  web.status("410 Sad but true, this lonely page is gone :("\))
		comment(#  web.status(206\))
		comment(#  web.status("400"\))
		comment(#)
		comment(# The default status is "200 OK". If a "Location" header is set, the)
		comment(# default status is "302 Found".)
    reserved(def) method(status)operator(()ident(str)operator(\))
        comment(# {{{)
        reserved(if) instance_variable(@output_started)
            ident(raise) string<delimiter(")content(HTTP-Headers are already send. You can't change them after output has started!)delimiter(")>
        reserved(end)
        reserved(unless) instance_variable(@output_allowed)
            ident(raise) string<delimiter(")content(You just can set headers inside of a Rweb::out-block)delimiter(")>
        reserved(end)
        reserved(if) ident(str)operator(.)ident(is_a?)constant(Integer)
            instance_variable(@status) operator(=) ident(str)
        reserved(elsif) ident(str)operator(.)ident(is_a?)constant(String)
            ident(p1) operator(=) regexp<delimiter(/)content(^([0-9]{3}\) ?(.*\)$)delimiter(/)>
            ident(p2) operator(=) regexp<delimiter(/)content(^HTTP)char(\\/)content(1)char(\\.)content([01] ([0-9]{3}\) ?(.*\)$)delimiter(/)>
            ident(p3) operator(=) regexp<delimiter(/)content(^status: ([0-9]{3}\) ?(.*\)$)delimiter(/)modifier(i)>

            reserved(if) operator(()ident(a) operator(=) ident(p1)operator(.)ident(match)operator(()ident(str)operator(\))operator(\)) operator(==) pre_constant(nil)
                reserved(if) operator(()ident(a) operator(=) ident(p2)operator(.)ident(match)operator(()ident(str)operator(\))operator(\)) operator(==) pre_constant(nil)
                    reserved(if) operator(()ident(a) operator(=) ident(p3)operator(.)ident(match)operator(()ident(str)operator(\))operator(\)) operator(==) pre_constant(nil)
                        ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(Invalid argument)delimiter(")>operator(,) ident(caller)
                    reserved(end)
                reserved(end)
            reserved(end)
            instance_variable(@status) operator(=) ident(a)operator([)integer(1)operator(])operator(.)ident(to_i)
            reserved(if) ident(a)operator([)integer(2)operator(]) operator(!=) string<delimiter(")delimiter(")>
                instance_variable(@reasonPhrase) operator(=) ident(a)operator([)integer(2)operator(])
            reserved(else)
                instance_variable(@reasonPhrase) operator(=) ident(getReasonPhrase)operator(()instance_variable(@status)operator(\))
            reserved(end)
        reserved(else)
            ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(Argument of setstatus must be integer or string)delimiter(")>operator(,) ident(caller)
        reserved(end)
        comment(# }}})
    reserved(end)

    comment(# Handles the output of your content and rescues all exceptions. Send all)
		comment(# data in the block to this method. For example:)
		comment(#  web.out do)
		comment(#      web.header("Content-Type: text/plain"\))
		comment(#      web.puts("Hello, plain world!"\))
		comment(#  end)
    reserved(def) method(out)
        comment(# {{{)
        instance_variable(@output_allowed) operator(=) pre_constant(true)
        instance_variable(@buffer) operator(=) operator([)operator(])operator(;) comment(# We use an array as buffer, because it's more performant :\))

        reserved(begin)
            reserved(yield)
        reserved(rescue) constant(Exception) operator(=)operator(>) ident(exception)
            global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(Ruby exception rescued ()inline<inline_delimiter(#{)ident(exception)operator(.)ident(class)inline_delimiter(})>content(\): )inline<inline_delimiter(#{)ident(exception)operator(.)ident(message)inline_delimiter(})>delimiter(")>
            global_variable($stderr)operator(.)ident(puts) ident(exception)operator(.)ident(backtrace)operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))

            reserved(unless) instance_variable(@output_started)
                pre_constant(self)operator(.)ident(setstatus)operator(()integer(500)operator(\))
                instance_variable(@header) operator(=) operator({)operator(})
            reserved(end)

            reserved(unless) operator(()instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(hide errors)delimiter(")>operator(\)) reserved(and) instance_variable(@settings)operator([)string<delimiter(")content(hide errors)delimiter(")>operator(]) operator(==) pre_constant(true)operator(\))
                reserved(unless) instance_variable(@output_started)
                    pre_constant(self)operator(.)ident(header)operator(()string<delimiter(")content(Content-Type: text/html)delimiter(")>operator(\))
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<!DOCTYPE HTML PUBLIC )char(\\")content(-//W3C//DTD HTML 4.01 Strict//EN)char(\\")content( )char(\\")content(http://www.w3.org/TR/html4/strict.dtd)char(\\")content(>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<html>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<head>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<title>500 Internal Server Error</title>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(</head>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<body>)delimiter(")>
                reserved(end)
                reserved(if) instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(content-type)delimiter(")>operator(\)) reserved(and) operator(()instance_variable(@header)operator([)string<delimiter(")content(content-type)delimiter(")>operator(]) operator(=)operator(~) regexp<delimiter(/)content(^text)char(\\/)content(html)delimiter(/)modifier(i)>operator(\)) operator(==) integer(0)
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<h1>Internal Server Error</h1>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<p>The server encountered an exception and was unable to complete your request.</p>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<p>The exception has provided the following information:</p>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(<pre style=)char(\\")content(background: #FFCCCC; border: black solid 2px; margin-left: 2cm; margin-right: 2cm; padding: 2mm;)char(\\")content(><b>)inline<inline_delimiter(#{)ident(exception)operator(.)ident(class)inline_delimiter(})>content(</b>: )inline<inline_delimiter(#{)ident(exception)operator(.)ident(message)inline_delimiter(})>content( <b>on</b>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts)
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")inline<inline_delimiter(#{)ident(exception)operator(.)ident(backtrace)operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))inline_delimiter(})>content(</pre>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(</body>)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(</html>)delimiter(")>
                reserved(else)
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(The server encountered an exception and was unable to complete your request)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")content(The exception has provided the following information:)delimiter(")>
                    pre_constant(self)operator(.)ident(puts) string<delimiter(")inline<inline_delimiter(#{)ident(exception)operator(.)ident(class)inline_delimiter(})>content(: )inline<inline_delimiter(#{)ident(exception)operator(.)ident(message)inline_delimiter(})>delimiter(")>
                    pre_constant(self)operator(.)ident(puts)
                    pre_constant(self)operator(.)ident(puts) ident(exception)operator(.)ident(backtrace)operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))
                reserved(end)
            reserved(end)
        reserved(end)

        reserved(if) instance_variable(@settings)operator([)string<delimiter(")content(cache)delimiter(")>operator(])
            ident(buffer) operator(=) instance_variable(@buffer)operator(.)ident(join)

            reserved(unless) instance_variable(@output_started)
                reserved(unless) instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(content-length)delimiter(")>operator(\))
                    pre_constant(self)operator(.)ident(header)operator(()string<delimiter(")content(content-length: )inline<inline_delimiter(#{)ident(buffer)operator(.)ident(length)inline_delimiter(})>delimiter(")>operator(\))
                reserved(end)

                ident(sendHeaders)
            reserved(end)
            global_variable($stdout)operator(.)ident(print)operator(()ident(buffer)operator(\))
        reserved(elsif) operator(!)instance_variable(@output_started)
            ident(sendHeaders)
        reserved(end)
        instance_variable(@output_allowed) operator(=) pre_constant(false)operator(;)
        comment(# }}})
    reserved(end)

    comment(# Decodes URL encoded data, %20 for example stands for a space.)
    reserved(def) constant(Rweb)operator(.)ident(unescape)operator(()ident(str)operator(\))
        comment(# {{{)
        reserved(if) reserved(defined?) ident(str) reserved(and) ident(str)operator(.)ident(is_a?) constant(String)
            ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\+)delimiter(/)>operator(,) string<delimiter(")content( )delimiter(")>operator(\))
            ident(str)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(%.{2})delimiter(/)>operator(\)) reserved(do) operator(|) ident(s) operator(|)
                ident(s)operator([)integer(1)operator(,)integer(2)operator(])operator(.)ident(hex)operator(.)ident(chr)
            reserved(end)
        reserved(end)
        comment(# }}})
    reserved(end)

    ident(protected)
    reserved(def) method(sendHeaders)
        comment(# {{{)

        constant(Cookie)operator(.)ident(disallow) comment(# no more cookies can be set or modified)
        reserved(if) operator(!)operator(()instance_variable(@settings)operator(.)ident(has_key?)operator(()string<delimiter(")content(silent)delimiter(")>operator(\)) reserved(and) instance_variable(@settings)operator([)string<delimiter(")content(silent)delimiter(")>operator(]) operator(==) pre_constant(true)operator(\)) reserved(and) operator(!)instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(x-powered-by)delimiter(")>operator(\))
            reserved(if) instance_variable(@mod_ruby)
                ident(header)operator(()string<delimiter(")content(x-powered-by: )inline<inline_delimiter(#{)constant(RWEB)inline_delimiter(})>content( (Ruby/)inline<inline_delimiter(#{)constant(RUBY_VERSION)inline_delimiter(})>content(, )inline<inline_delimiter(#{)constant(MOD_RUBY)inline_delimiter(})>content(\))delimiter(")>operator(\))operator(;)
            reserved(else)
                ident(header)operator(()string<delimiter(")content(x-powered-by: )inline<inline_delimiter(#{)constant(RWEB)inline_delimiter(})>content( (Ruby/)inline<inline_delimiter(#{)constant(RUBY_VERSION)inline_delimiter(})>content(\))delimiter(")>operator(\))operator(;)
            reserved(end)
        reserved(end)

        reserved(if) instance_variable(@output_method) operator(==) string<delimiter(")content(ph)delimiter(")>
            reserved(if) operator(()operator(()instance_variable(@status) operator(==) pre_constant(nil) reserved(or) instance_variable(@status) operator(==) integer(200)operator(\)) reserved(and) operator(!)instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(content-type)delimiter(")>operator(\)) reserved(and) operator(!)instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(location)delimiter(")>operator(\))operator(\))
                ident(header)operator(()string<delimiter(")content(content-type: text/html)delimiter(")>operator(\))
            reserved(end)

            reserved(if) instance_variable(@status) operator(!=) pre_constant(nil)
                global_variable($stdout)operator(.)ident(print) string<delimiter(")content(Status: )inline<inline_delimiter(#{)instance_variable(@status)inline_delimiter(})>content( )inline<inline_delimiter(#{)instance_variable(@reasonPhrase)inline_delimiter(})>char(\\r)char(\\n)delimiter(")>
            reserved(end)

            instance_variable(@header)operator(.)ident(each) reserved(do) operator(|)ident(key)operator(,) ident(value)operator(|)
                ident(key) operator(=) ident(key) operator(*)integer(1) comment(# "unfreeze" key :\))
                ident(key)operator([)integer(0)operator(]) operator(=) ident(key)operator([)integer(0)operator(,)integer(1)operator(])operator(.)ident(upcase!)operator([)integer(0)operator(])

                ident(key) operator(=) ident(key)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(-[a-z])delimiter(/)>operator(\)) reserved(do) operator(|)ident(char)operator(|)
                    string<delimiter(")content(-)delimiter(")> operator(+) ident(char)operator([)integer(1)operator(,)integer(1)operator(])operator(.)ident(upcase)
                reserved(end)

                global_variable($stdout)operator(.)ident(print) string<delimiter(")inline<inline_delimiter(#{)ident(key)inline_delimiter(})>content(: )inline<inline_delimiter(#{)ident(value)inline_delimiter(})>char(\\r)char(\\n)delimiter(")>
            reserved(end)
            ident(cookies) operator(=) constant(Cookie)operator(.)ident(getHttpHeader) comment(# Get all cookies as an HTTP Header)
            reserved(if) ident(cookies)
                global_variable($stdout)operator(.)ident(print) ident(cookies)
            reserved(end)

            global_variable($stdout)operator(.)ident(print) string<delimiter(")char(\\r)char(\\n)delimiter(")>

        reserved(elsif) instance_variable(@output_method) operator(==) string<delimiter(")content(nph)delimiter(")>
        reserved(elsif) instance_variable(@output_method) operator(==) string<delimiter(")content(mod_ruby)delimiter(")>
            ident(r) operator(=) constant(Apache)operator(.)ident(request)

            reserved(if) operator(()operator(()instance_variable(@status) operator(==) pre_constant(nil) reserved(or) instance_variable(@status) operator(==) integer(200)operator(\)) reserved(and) operator(!)instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(content-type)delimiter(")>operator(\)) reserved(and) operator(!)instance_variable(@header)operator(.)ident(has_key?)operator(()string<delimiter(")content(location)delimiter(")>operator(\))operator(\))
                ident(header)operator(()string<delimiter(")content(text/html)delimiter(")>operator(\))
            reserved(end)

            reserved(if) instance_variable(@status) operator(!=) pre_constant(nil)
                ident(r)operator(.)ident(status_line) operator(=) string<delimiter(")inline<inline_delimiter(#{)instance_variable(@status)inline_delimiter(})>content( )inline<inline_delimiter(#{)instance_variable(@reasonPhrase)inline_delimiter(})>delimiter(")>
            reserved(end)

            ident(r)operator(.)ident(send_http_header)
            instance_variable(@header)operator(.)ident(each) reserved(do) operator(|)ident(key)operator(,) ident(value)operator(|)
                ident(key) operator(=) ident(key) operator(*)integer(1) comment(# "unfreeze" key :\))

                ident(key)operator([)integer(0)operator(]) operator(=) ident(key)operator([)integer(0)operator(,)integer(1)operator(])operator(.)ident(upcase!)operator([)integer(0)operator(])
                ident(key) operator(=) ident(key)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(-[a-z])delimiter(/)>operator(\)) reserved(do) operator(|)ident(char)operator(|)
                    string<delimiter(")content(-)delimiter(")> operator(+) ident(char)operator([)integer(1)operator(,)integer(1)operator(])operator(.)ident(upcase)
                reserved(end)
                ident(puts) string<delimiter(")inline<inline_delimiter(#{)ident(key)inline_delimiter(})>content(: )inline<inline_delimiter(#{)ident(value)operator(.)ident(class)inline_delimiter(})>delimiter(")>
                comment(#r.headers_out[key] = value)
            reserved(end)
        reserved(end)
        instance_variable(@output_started) operator(=) pre_constant(true)
        comment(# }}})
    reserved(end)

    reserved(def) method(getReasonPhrase) operator(()ident(status)operator(\))
        comment(# {{{)
        reserved(if) ident(status) operator(==) integer(100)
            string<delimiter(")content(Continue)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(101)
            string<delimiter(")content(Switching Protocols)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(200)
            string<delimiter(")content(OK)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(201)
            string<delimiter(")content(Created)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(202)
            string<delimiter(")content(Accepted)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(203)
            string<delimiter(")content(Non-Authoritative Information)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(204)
            string<delimiter(")content(No Content)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(205)
            string<delimiter(")content(Reset Content)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(206)
            string<delimiter(")content(Partial Content)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(300)
            string<delimiter(")content(Multiple Choices)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(301)
            string<delimiter(")content(Moved Permanently)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(302)
            string<delimiter(")content(Found)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(303)
            string<delimiter(")content(See Other)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(304)
            string<delimiter(")content(Not Modified)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(305)
            string<delimiter(")content(Use Proxy)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(307)
            string<delimiter(")content(Temporary Redirect)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(400)
            string<delimiter(")content(Bad Request)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(401)
            string<delimiter(")content(Unauthorized)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(402)
            string<delimiter(")content(Payment Required)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(403)
            string<delimiter(")content(Forbidden)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(404)
            string<delimiter(")content(Not Found)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(405)
            string<delimiter(")content(Method Not Allowed)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(406)
            string<delimiter(")content(Not Acceptable)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(407)
            string<delimiter(")content(Proxy Authentication Required)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(408)
            string<delimiter(")content(Request Time-out)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(409)
            string<delimiter(")content(Conflict)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(410)
            string<delimiter(")content(Gone)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(411)
            string<delimiter(")content(Length Required)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(412)
            string<delimiter(")content(Precondition Failed)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(413)
            string<delimiter(")content(Request Entity Too Large)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(414)
            string<delimiter(")content(Request-URI Too Large)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(415)
            string<delimiter(")content(Unsupported Media Type)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(416)
            string<delimiter(")content(Requested range not satisfiable)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(417)
            string<delimiter(")content(Expectation Failed)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(500)
            string<delimiter(")content(Internal Server Error)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(501)
            string<delimiter(")content(Not Implemented)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(502)
            string<delimiter(")content(Bad Gateway)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(503)
            string<delimiter(")content(Service Unavailable)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(504)
            string<delimiter(")content(Gateway Time-out)delimiter(")>
        reserved(elsif) ident(status) operator(==) integer(505)
            string<delimiter(")content(HTTP Version not supported)delimiter(")>
        reserved(else)
            ident(raise) string<delimiter(")content(Unknown Statuscode. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1 for more information.)delimiter(")>
        reserved(end)
        comment(# }}})
    reserved(end)
reserved(end)

reserved(class) class(Cookie)
	ident(attr_reader) symbol(:name)operator(,) symbol(:value)operator(,) symbol(:maxage)operator(,) symbol(:path)operator(,) symbol(:domain)operator(,) symbol(:secure)operator(,) symbol(:comment)

	comment(# Sets a cookie. Please see below for details of the attributes.)
	reserved(def) method(initialize) operator(()ident(name)operator(,) ident(value) operator(=) pre_constant(nil)operator(,) ident(maxage) operator(=) pre_constant(nil)operator(,) ident(path) operator(=) pre_constant(nil)operator(,) ident(domain) operator(=) pre_constant(nil)operator(,) ident(secure) operator(=) pre_constant(false)operator(\))
		comment(# {{{)
		comment(# HTTP headers (Cookies are a HTTP header\) can only set, while no content)
		comment(# is send. So an exception will be raised, when @@allowed is set to false)
		comment(# and a new cookie has set.)
		reserved(unless) reserved(defined?)operator(()class_variable(@@allowed)operator(\))
			class_variable(@@allowed) operator(=) pre_constant(true)
		reserved(end)
		reserved(unless) class_variable(@@allowed)
			ident(raise) string<delimiter(")content(You can't set cookies after the HTTP headers are send.)delimiter(")>
		reserved(end)

		reserved(unless) reserved(defined?)operator(()class_variable(@@list)operator(\))
			class_variable(@@list) operator(=) operator([)operator(])
		reserved(end)
		class_variable(@@list) operator(+=) operator([)pre_constant(self)operator(])

		reserved(unless) reserved(defined?)operator(()class_variable(@@type)operator(\))
			class_variable(@@type) operator(=) string<delimiter(")content(netscape)delimiter(")>
		reserved(end)

		reserved(unless) ident(name)operator(.)ident(class) operator(==) constant(String)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The name of a cookie must be a string)delimiter(")>operator(,) ident(caller)
		reserved(end)
		reserved(if) ident(value)operator(.)ident(class)operator(.)ident(superclass) operator(==) constant(Integer) operator(||) ident(value)operator(.)ident(class) operator(==) constant(Float)
			ident(value) operator(=) ident(value)operator(.)ident(to_s)
		reserved(elsif) ident(value)operator(.)ident(class) operator(!=) constant(String) operator(&&) ident(value) operator(!=) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The value of a cookie must be a string, integer, float or nil)delimiter(")>operator(,) ident(caller)
		reserved(end)
		reserved(if) ident(maxage)operator(.)ident(class) operator(==) constant(Time)
			ident(maxage) operator(=) ident(maxage) operator(-) constant(Time)operator(.)ident(now)
		reserved(elsif) operator(!)ident(maxage)operator(.)ident(class)operator(.)ident(superclass) operator(==) constant(Integer)  operator(||) operator(!)ident(maxage) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The maxage date of a cookie must be an Integer or Time object or nil.)delimiter(")>operator(,) ident(caller)
		reserved(end)
		reserved(unless) ident(path)operator(.)ident(class) operator(==) constant(String)  operator(||) ident(path) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The path of a cookie must be nil or a string)delimiter(")>operator(,) ident(caller)
		reserved(end)
		reserved(unless) ident(domain)operator(.)ident(class) operator(==) constant(String)  operator(||) ident(domain) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The value of a cookie must be nil or a string)delimiter(")>operator(,) ident(caller)
		reserved(end)
		reserved(unless) ident(secure) operator(==) pre_constant(true)  operator(||) ident(secure) operator(==) pre_constant(false)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The secure field of a cookie must be true or false)delimiter(")>operator(,) ident(caller)
		reserved(end)

		instance_variable(@name)operator(,) instance_variable(@value)operator(,) instance_variable(@maxage)operator(,) instance_variable(@path)operator(,) instance_variable(@domain)operator(,) instance_variable(@secure) operator(=) ident(name)operator(,) ident(value)operator(,) ident(maxage)operator(,) ident(path)operator(,) ident(domain)operator(,) ident(secure)
		instance_variable(@comment) operator(=) pre_constant(nil)
		comment(# }}})
	reserved(end)

	comment(# Modifies the value of this cookie. The information you want to store. If the)
	comment(# value is nil, the cookie will be deleted by the client.)
	comment(#)
	comment(# This attribute can be a String, Integer or Float object or nil.)
	reserved(def) method(value=)operator(()ident(value)operator(\))
		comment(# {{{)
		reserved(if) ident(value)operator(.)ident(class)operator(.)ident(superclass) operator(==) constant(Integer) operator(||) ident(value)operator(.)ident(class) operator(==) constant(Float)
			ident(value) operator(=) ident(value)operator(.)ident(to_s)
		reserved(elsif) ident(value)operator(.)ident(class) operator(!=) constant(String) operator(&&) ident(value) operator(!=) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The value of a cookie must be a string, integer, float or nil)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@value) operator(=) ident(value)
		comment(# }}})
	reserved(end)

	comment(# Modifies the maxage of this cookie. This attribute defines the lifetime of)
	comment(# the cookie, in seconds. A value of 0 means the cookie should be discarded)
	comment(# imediatly. If it set to nil, the cookie will be deleted when the browser)
	comment(# will be closed.)
	comment(#)
	comment(# Attention: This is different from other implementations like PHP, where you)
	comment(# gives the seconds since 1/1/1970 0:00:00 GMT.)
	comment(#)
	comment(# This attribute must be an Integer or Time object or nil.)
	reserved(def) method(maxage=)operator(()ident(maxage)operator(\))
		comment(# {{{)
		reserved(if) ident(maxage)operator(.)ident(class) operator(==) constant(Time)
			ident(maxage) operator(=) ident(maxage) operator(-) constant(Time)operator(.)ident(now)
		reserved(elsif) ident(maxage)operator(.)ident(class)operator(.)ident(superclass) operator(==) constant(Integer)  operator(||) operator(!)ident(maxage) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The maxage of a cookie must be an Interger or Time object or nil.)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@maxage) operator(=) ident(maxage)
		comment(# }}})
	reserved(end)

	comment(# Modifies the path value of this cookie. The client will send this cookie)
	comment(# only, if the requested document is this directory or a subdirectory of it.)
	comment(#)
	comment(# The value of the attribute must be a String object or nil.)
	reserved(def) method(path=)operator(()ident(path)operator(\))
		comment(# {{{)
		reserved(unless) ident(path)operator(.)ident(class) operator(==) constant(String)  operator(||) ident(path) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The path of a cookie must be nil or a string)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@path) operator(=) ident(path)
		comment(# }}})
	reserved(end)

	comment(# Modifies the domain value of this cookie. The client will send this cookie)
	comment(# only if it's connected with this domain (or a subdomain, if the first)
	comment(# character is a dot like in ".ruby-lang.org"\))
	comment(#)
	comment(# The value of this attribute must be a String or nil.)
	reserved(def) method(domain=)operator(()ident(domain)operator(\))
		comment(# {{{)
		reserved(unless) ident(domain)operator(.)ident(class) operator(==) constant(String)  operator(||) ident(domain) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The domain of a cookie must be a String or nil.)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@domain) operator(=) ident(domain)
		comment(# }}})
	reserved(end)

	comment(# Modifies the secure flag of this cookie. If it's true, the client will only)
	comment(# send this cookie if it is secured connected with us.)
	comment(#)
	comment(# The value od this attribute has to be true or false.)
	reserved(def) method(secure=)operator(()ident(secure)operator(\))
		comment(# {{{)
		reserved(unless) ident(secure) operator(==) pre_constant(true)  operator(||) ident(secure) operator(==) pre_constant(false)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The secure field of a cookie must be true or false)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@secure) operator(=) ident(secure)
		comment(# }}})
	reserved(end)

	comment(# Modifies the comment value of this cookie. The comment won't be send, if)
	comment(# type is "netscape".)
	reserved(def) method(comment=)operator(()ident(comment)operator(\))
		comment(# {{{)
		reserved(unless) ident(comment)operator(.)ident(class) operator(==) constant(String) operator(||) ident(comment) operator(==) pre_constant(nil)
			ident(raise) constant(TypeError)operator(,) string<delimiter(")content(The comment of a cookie must be a string or nil)delimiter(")>operator(,) ident(caller)
		reserved(end)
		instance_variable(@comment) operator(=) ident(comment)
		comment(# }}})
	reserved(end)

	comment(# Changes the type of all cookies.)
	comment(# Allowed values are RFC2109 and netscape (default\).)
	reserved(def) constant(Cookie)operator(.)ident(type)operator(=)operator(()ident(type)operator(\))
		comment(# {{{)
		reserved(unless) class_variable(@@allowed)
			ident(raise) string<delimiter(")content(The cookies are allready send, so you can't change the type anymore.)delimiter(")>
		reserved(end)
		reserved(unless) ident(type)operator(.)ident(downcase) operator(==) string<delimiter(")content(rfc2109)delimiter(")> operator(&&) ident(type)operator(.)ident(downcase) operator(==) string<delimiter(")content(netscape)delimiter(")>
			ident(raise) string<delimiter(")content(The type of the cookies must be )char(\\")content(RFC2109)char(\\")content( or )char(\\")content(netscape)char(\\")content(.)delimiter(")>
		reserved(end)
		class_variable(@@type) operator(=) ident(type)operator(;)
		comment(# }}})
	reserved(end)

	comment(# After sending this message, no cookies can be set or modified. Use it, when)
	comment(# HTTP-Headers are send. Rweb does this for you.)
	reserved(def) constant(Cookie)operator(.)ident(disallow)
		comment(# {{{)
		class_variable(@@allowed) operator(=) pre_constant(false)
		pre_constant(true)
		comment(# }}})
	reserved(end)

	comment(# Returns a HTTP header (type String\) with all cookies. Rweb does this for)
	comment(# you.)
	reserved(def) constant(Cookie)operator(.)ident(getHttpHeader)
		comment(# {{{)
		reserved(if) reserved(defined?)operator(()class_variable(@@list)operator(\))
			reserved(if) class_variable(@@type) operator(==) string<delimiter(")content(netscape)delimiter(")>
				ident(str) operator(=) string<delimiter(")delimiter(")>
				class_variable(@@list)operator(.)ident(each) reserved(do) operator(|)ident(cookie)operator(|)
					reserved(if) ident(cookie)operator(.)ident(value) operator(==) pre_constant(nil)
						ident(cookie)operator(.)ident(maxage) operator(=) integer(0)
						ident(cookie)operator(.)ident(value) operator(=) string<delimiter(")delimiter(")>
					reserved(end)
					comment(# TODO: Name and value should be escaped!)
					ident(str) operator(+=) string<delimiter(")content(Set-Cookie: )inline<inline_delimiter(#{)ident(cookie)operator(.)ident(name)inline_delimiter(})>content(=)inline<inline_delimiter(#{)ident(cookie)operator(.)ident(value)inline_delimiter(})>delimiter(")>
					reserved(unless) ident(cookie)operator(.)ident(maxage) operator(==) pre_constant(nil)
						ident(expire) operator(=) constant(Time)operator(.)ident(now) operator(+) ident(cookie)operator(.)ident(maxage)
						ident(expire)operator(.)ident(gmtime)
						ident(str) operator(+=) string<delimiter(")content(; Expire=)inline<inline_delimiter(#{)ident(expire)operator(.)ident(strftime)operator(()string<delimiter(")content(%a, %d-%b-%Y %H:%M:%S %Z)delimiter(")>operator(\))inline_delimiter(})>delimiter(")>
					reserved(end)
					reserved(unless) ident(cookie)operator(.)ident(domain) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Domain=)inline<inline_delimiter(#{)ident(cookie)operator(.)ident(domain)inline_delimiter(})>delimiter(")>
					reserved(end)
					reserved(unless) ident(cookie)operator(.)ident(path) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Path=)inline<inline_delimiter(#{)ident(cookie)operator(.)ident(path)inline_delimiter(})>delimiter(")>
					reserved(end)
					reserved(if) ident(cookie)operator(.)ident(secure)
						ident(str) operator(+=) string<delimiter(")content(; Secure)delimiter(")>
					reserved(end)
					ident(str) operator(+=) string<delimiter(")char(\\r)char(\\n)delimiter(")>
				reserved(end)
				reserved(return) ident(str)
			reserved(else) comment(# type == "RFC2109")
				ident(str) operator(=) string<delimiter(")content(Set-Cookie: )delimiter(")>
				ident(comma) operator(=) pre_constant(false)operator(;)

				class_variable(@@list)operator(.)ident(each) reserved(do) operator(|)ident(cookie)operator(|)
					reserved(if) ident(cookie)operator(.)ident(value) operator(==) pre_constant(nil)
						ident(cookie)operator(.)ident(maxage) operator(=) integer(0)
						ident(cookie)operator(.)ident(value) operator(=) string<delimiter(")delimiter(")>
					reserved(end)
					reserved(if) ident(comma)
						ident(str) operator(+=) string<delimiter(")content(,)delimiter(")>
					reserved(end)
					ident(comma) operator(=) pre_constant(true)

					ident(str) operator(+=) string<delimiter(")inline<inline_delimiter(#{)ident(cookie)operator(.)ident(name)inline_delimiter(})>content(=)char(\\")inline<inline_delimiter(#{)ident(cookie)operator(.)ident(value)inline_delimiter(})>char(\\")delimiter(")>
					reserved(unless) ident(cookie)operator(.)ident(maxage) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Max-Age=)char(\\")inline<inline_delimiter(#{)ident(cookie)operator(.)ident(maxage)inline_delimiter(})>char(\\")delimiter(")>
					reserved(end)
					reserved(unless) ident(cookie)operator(.)ident(domain) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Domain=)char(\\")inline<inline_delimiter(#{)ident(cookie)operator(.)ident(domain)inline_delimiter(})>char(\\")delimiter(")>
					reserved(end)
					reserved(unless) ident(cookie)operator(.)ident(path) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Path=)char(\\")inline<inline_delimiter(#{)ident(cookie)operator(.)ident(path)inline_delimiter(})>char(\\")delimiter(")>
					reserved(end)
					reserved(if) ident(cookie)operator(.)ident(secure)
						ident(str) operator(+=) string<delimiter(")content(; Secure)delimiter(")>
					reserved(end)
					reserved(unless) ident(cookie)operator(.)ident(comment) operator(==) pre_constant(nil)
						ident(str) operator(+=) string<delimiter(")content(; Comment=)char(\\")inline<inline_delimiter(#{)ident(cookie)operator(.)ident(comment)inline_delimiter(})>char(\\")delimiter(")>
					reserved(end)
					ident(str) operator(+=) string<delimiter(")content(; Version=)char(\\")content(1)char(\\")delimiter(")>
				reserved(end)
				ident(str)
			reserved(end)
		reserved(else)
			pre_constant(false)
		reserved(end)
		comment(# }}})
	reserved(end)
reserved(end)

ident(require) string<delimiter(')content(strscan)delimiter(')>

reserved(module) class(BBCode)
	constant(DEBUG) operator(=) pre_constant(true)

	ident(use) string<delimiter(')content(encoder)delimiter(')>operator(,) string<delimiter(')content(tags)delimiter(')>operator(,) string<delimiter(')content(tagstack)delimiter(')>operator(,) string<delimiter(')content(smileys)delimiter(')>

comment(=begin
	The Parser class takes care of the encoding.
	It scans the given BBCode (as plain text\), finds tags
	and smilies and also makes links of urls in text.

	Normal text is send directly to the encoder.

	If a tag was found, an instance of a Tag subclass is created
	to handle the case.

	The @tagstack manages tag nesting and ensures valid HTML.
=end)

	reserved(class) class(Parser)
		reserved(class) class(Attribute)
			comment(# flatten and use only one empty_arg)
			reserved(def) pre_constant(self)operator(.)ident(create) ident(attr)
				ident(attr) operator(=) ident(flatten) ident(attr)
				reserved(return) class_variable(@@empty_attr) reserved(if) ident(attr)operator(.)ident(empty?)
				ident(new) ident(attr)
			reserved(end)

			ident(private_class_method) symbol(:new)

			comment(# remove leading and trailing whitespace; concat lines)
			reserved(def) pre_constant(self)operator(.)ident(flatten) ident(attr)
				ident(attr)operator(.)ident(strip)operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(,) string<delimiter(')content( )delimiter(')>operator(\))
				comment(# -> ^ and $ can only match at begin and end now)
			reserved(end)

			constant(ATTRIBUTE_SCAN) operator(=) regexp<delimiter(/)content(
				(?!$\)  # don't match at end
				)char(\\s)content(*
				( # $1 = key
					[^=)char(\\s)char(\\])content(")char(\\\\)content(]*
					(?:
						(?: )char(\\\\)content(. | "[^")char(\\\\)content(]*(?:)char(\\\\)content(.[^")char(\\\\)content(]*\)*"? \)
						[^=)char(\\s)char(\\])content(")char(\\\\)content(]*
					\)*
				\)
				(?:
					=
					( # $2 = value
						[^)char(\\s)char(\\])content(")char(\\\\)content(]*
						(?:
							(?: )char(\\\\)content(. | "[^")char(\\\\)content(]*(?:)char(\\\\)content(.[^")char(\\\\)content(]*\)*"? \)
							[^)char(\\s)char(\\])content(")char(\\\\)content(]*
						\)*
					\)?
				\)?
				)char(\\s)content(*
			)delimiter(/)modifier(x)>

			reserved(def) pre_constant(self)operator(.)ident(parse) ident(source)
				ident(source) operator(=) ident(source)operator(.)ident(dup)
				comment(# empty_tag: the tag looks like [... /])
				comment(# slice!: this deletes the \\s*/] at the end)
				comment(# \\s+ because [url=http://rubybb.org/forum/] is NOT an empty tag.)
				comment(# In RubyBBCode, you can use [url=http://rubybb.org/forum/ /], and this has to be)
				comment(# interpreted correctly.)
				ident(empty_tag) operator(=) ident(source)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(^:)delimiter(/)>operator(,) string<delimiter(')content(=)delimiter(')>operator(\)) reserved(or) ident(source)operator(.)ident(slice!)operator(()regexp<delimiter(/)char(\\/)content($)delimiter(/)>operator(\))
				ident(debug) string<delimiter(')content(PARSE: )delimiter(')> operator(+) ident(source)operator(.)ident(inspect) operator(+) string<delimiter(')content( => )delimiter(')> operator(+) ident(empty_tag)operator(.)ident(inspect)
				comment(#-> we have now an attr that's EITHER empty OR begins and ends with non-whitespace.)

				ident(attr) operator(=) constant(Hash)operator(.)ident(new)
				ident(attr)operator([)symbol(:flags)operator(]) operator(=) operator([)operator(])
				ident(source)operator(.)ident(scan)operator(()constant(ATTRIBUTE_SCAN)operator(\)) operator({) operator(|)ident(key)operator(,) ident(value)operator(|)
					reserved(if) reserved(not) ident(value)
						ident(attr)operator([)symbol(:flags)operator(]) operator(<<) ident(unescape)operator(()ident(key)operator(\))
					reserved(else)
						reserved(next) reserved(if) ident(value)operator(.)ident(empty?) reserved(and) ident(key)operator(.)ident(empty?)
						ident(attr)operator([)ident(unescape)operator(()ident(key)operator(\))operator(]) operator(=) ident(unescape)operator(()ident(value)operator(\))
					reserved(end)
				operator(})
				ident(debug) ident(attr)operator(.)ident(inspect)

				reserved(return) ident(empty_tag)operator(,) ident(attr)
			reserved(end)

			reserved(def) pre_constant(self)operator(.)ident(unescape_char) ident(esc)
				ident(esc)operator([)integer(1)operator(])
			reserved(end)

			reserved(def) pre_constant(self)operator(.)ident(unquote) ident(qt)
				ident(qt)operator([)integer(1)operator(..)integer(-1)operator(])operator(.)ident(chomp)operator(()string<delimiter(')content(")delimiter(')>operator(\))operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\\\)content(.)delimiter(/)>operator(\)) operator({) operator(|)ident(esc)operator(|) ident(unescape_char) ident(esc) operator(})
			reserved(end)

			reserved(def) pre_constant(self)operator(.)ident(unescape) ident(str)
				ident(str)operator(.)ident(gsub)operator(()regexp<delimiter(/)content( ()char(\\\\)content(.\) | (" [^")char(\\\\)content(]* (?:)char(\\\\)content(.[^")char(\\\\)content(]*\)* "?\) )delimiter(/)modifier(x)>operator(\)) operator({)
					reserved(if) global_variable($1)
						ident(unescape_char) global_variable($1)
					reserved(else)
						ident(unquote) global_variable($2)
					reserved(end)
				operator(})
			reserved(end)

			ident(include) constant(Enumerable)
			reserved(def) method(each) operator(&)ident(block)
				instance_variable(@args)operator(.)ident(each)operator(()operator(&)ident(block)operator(\))
			reserved(end)

			ident(attr_reader) symbol(:source)operator(,) symbol(:args)operator(,) symbol(:value)

			reserved(def) method(initialize) ident(source)
				instance_variable(@source) operator(=) ident(source)
				ident(debug) string<delimiter(')content(Attribute#new(%p\))delimiter(')> operator(%) ident(source)
				instance_variable(@empty_tag)operator(,) instance_variable(@attr) operator(=) constant(Attribute)operator(.)ident(parse) ident(source)
				instance_variable(@value) operator(=) instance_variable(@attr)operator([)string<delimiter(')delimiter(')>operator(])operator(.)ident(to_s)
			reserved(end)

			reserved(def) method(empty?)
				pre_constant(self) operator(==) class_variable(@@empty_attr)
			reserved(end)

			reserved(def) method(empty_tag?)
				instance_variable(@empty_tag)
			reserved(end)

			reserved(def) method([]) operator(*)ident(keys)
				ident(res) operator(=) instance_variable(@attr)operator([)operator(*)ident(keys)operator(])
			reserved(end)

			reserved(def) method(flags)
				ident(attr)operator([)symbol(:flags)operator(])
			reserved(end)

			reserved(def) method(to_s)
				instance_variable(@attr)
			reserved(end)

			reserved(def) method(inspect)
				string<delimiter(')content(ATTR[)delimiter(')> operator(+) instance_variable(@attr)operator(.)ident(inspect) operator(+) operator(()instance_variable(@empty_tag) operator(?) string<delimiter(')content( | empty tag)delimiter(')> operator(:) string<delimiter(')delimiter(')>operator(\)) operator(+) string<delimiter(')content(])delimiter(')>
			reserved(end)
		reserved(end)
		reserved(class) class(Attribute)
			class_variable(@@empty_attr) operator(=) ident(new) string<delimiter(')delimiter(')>
		reserved(end)
	reserved(end)

	reserved(class) class(Parser)
		reserved(def) constant(Parser)operator(.)ident(flatten) ident(str)
			comment(# replace mac & dos newlines with unix style)
			ident(str)operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\r)char(\\n)content(?)delimiter(/)>operator(,) string<delimiter(")char(\\n)delimiter(")>operator(\))
		reserved(end)

		reserved(def) method(initialize) ident(input) operator(=) string<delimiter(')delimiter(')>
			comment(# input manager)
			instance_variable(@scanner) operator(=) constant(StringScanner)operator(.)ident(new) string<delimiter(')delimiter(')>
			comment(# output manager)
			instance_variable(@encoder) operator(=) constant(Encoder)operator(.)ident(new)
			instance_variable(@output) operator(=) string<delimiter(')delimiter(')>
			comment(# tag manager)
			instance_variable(@tagstack) operator(=) constant(TagStack)operator(.)ident(new)operator(()instance_variable(@encoder)operator(\))

			instance_variable(@do_magic) operator(=) pre_constant(true)
			comment(# set the input)
			ident(feed) ident(input)
		reserved(end)

		comment(# if you want, you can feed a parser instance after creating,)
		comment(# or even feed it repeatedly.)
		reserved(def) method(feed) ident(food)
			instance_variable(@scanner)operator(.)ident(string) operator(=) constant(Parser)operator(.)ident(flatten) ident(food)
		reserved(end)

		comment(# parse through the string using parse_token)
		reserved(def) method(parse)
			ident(parse_token) reserved(until) instance_variable(@scanner)operator(.)ident(eos?)
			instance_variable(@tagstack)operator(.)ident(close_all)
			instance_variable(@output) operator(=) ident(parse_magic) instance_variable(@encoder)operator(.)ident(output)
		reserved(end)

		reserved(def) method(output)
			instance_variable(@output)
		reserved(end)

	comment(# ok, internals start here)
	ident(private)
		comment(# the default output functions. everything should use them or the tags.)
		reserved(def) method(add_text) ident(text) operator(=) instance_variable(@scanner)operator(.)ident(matched)
			instance_variable(@encoder)operator(.)ident(add_text) ident(text)
		reserved(end)

		comment(# use this carefully)
		reserved(def) method(add_html) ident(html)
			instance_variable(@encoder)operator(.)ident(add_html) ident(html)
		reserved(end)

		comment(# highlights the text as error)
		reserved(def) method(add_garbage) ident(garbage)
			ident(add_html) string<delimiter(')content(<span class="error">)delimiter(')> reserved(if) constant(DEBUG)
			ident(add_text) ident(garbage)
			ident(add_html) string<delimiter(')content(</span>)delimiter(')> reserved(if) constant(DEBUG)
		reserved(end)

		comment(# unknown and incorrectly nested tags are ignored and)
		comment(# sent as plaintext (garbage in - garbage out\).)
		comment(# in debug mode, garbage is marked with lime background.)
		reserved(def) method(garbage_out) ident(start)
			instance_variable(@scanner)operator(.)ident(pos) operator(=) ident(start)
			ident(garbage) operator(=) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(.)delimiter(/)modifier(m)>operator(\))
			ident(debug) string<delimiter(')content(GARBAGE: )delimiter(')> operator(+) ident(garbage)
			ident(add_garbage) ident(garbage)
		reserved(end)

		comment(# simple text; everything but [, \\[ allowed)
		constant(SIMPLE_TEXT_SCAN_) operator(=) regexp<delimiter(/)content(
			[^)char(\\[)char(\\\\)content(]*    # normal*
			(?:         # (
			)char(\\\\)content(.?        #   special
			[^)char(\\[)char(\\\\)content(]*    #   normal*
			\)*          # \)*
		)delimiter(/)modifier(mx)>
		constant(SIMPLE_TEXT_SCAN) operator(=) regexp<delimiter(/)content([^)char(\\[)content(]+)delimiter(/)>

comment(=begin

	WHAT IS A TAG?
	==============

	Tags in BBCode can be much more than just a simple [b].
	I use many terms here to differ the parts of each tag.

	Basic scheme:
	    [         code        ]
	TAG START   TAG INFO   TAG END

	Most tags need a second tag to close the range it opened.
	This is done with CLOSING TAGS:
		[/code]
	or by using empty tags that have no content and close themselfes:
		[url=winamp.com /]
	You surely know this from HTML.
	These slashes define the TAG KIND = normal|closing|empty and
	cannot be	used together.

	Everything between [ and ] and expluding the slashes is called the
	TAG INFO.	This info may contain:
	- TAG ID
	- TAG NAME including the tag id
	- attributes

	The TAG ID is the first char of the info:

	TAG       | ID
	----------+----
	[quote]   | q
	[&plusmn] | &
	["[b]"]   | "
	[/url]    | u
	[---]     | -

	As you can see, the tag id shows the TAG TYPE, it can be a
	normal tag,	a formatting tag or an entity.
	Therefor, the parser first scans the id to decide how to go
	on with parsing.
=end)
		comment(# tag)
		comment(# TODO more complex expression allowing)
		comment(#   [quote="[ladico]"] and [quote=\\[ladico\\]] to be correct tags)
		constant(TAG_BEGIN_SCAN) operator(=) regexp<delimiter(/)content(
			)char(\\[)content(             # tag start
			( )char(\\/)content( \)?        # $1 = closing tag?
			( [^)char(\\])content(] \)      # $2 = tag id
		)delimiter(/)modifier(x)>
		constant(TAG_END_SCAN) operator(=) regexp<delimiter(/)content(
			[^)char(\\])content(]*         # rest that was not handled
			)char(\\])content(?            # tag end
		)delimiter(/)modifier(x)>
		constant(CLOSE_TAG_SCAN) operator(=) regexp<delimiter(/)content(
			( [^)char(\\])content(]* \)     # $1 = the rest of the tag info
			( )char(\\/)content( \)?        # $2 = empty tag?
			)char(\\])content(?            # tag end
		)delimiter(/)modifier(x)>
		constant(UNCLOSED_TAG_SCAN) operator(=) regexp<delimiter(/)content( )char(\\[)content( )delimiter(/)modifier(x)>

		constant(CLASSIC_TAG_SCAN) operator(=) regexp<delimiter(/)content( [a-z]* )delimiter(/)modifier(ix)>

		constant(SEPARATOR_TAG_SCAN) operator(=) regexp<delimiter(/)content( )char(\\*)content(* )delimiter(/)modifier(x)>

		constant(FORMAT_TAG_SCAN) operator(=) regexp<delimiter(/)content( -- -* )delimiter(/)modifier(x)>

		constant(QUOTED_SCAN) operator(=) regexp<delimiter(/)content(
			(            # $1 = quoted text
				[^")char(\\\\)content(]*    # normal*
				(?:        # (
					)char(\\\\)content(.      # 	special
					[^")char(\\\\)content(]*  # 	normal*
				\)*         # \)*
			\)
			"?           # end quote "
		)delimiter(/)modifier(mx)>

		constant(ENTITY_SCAN) operator(=) regexp<delimiter(/)content(
			( [^;)char(\\])content(]+ \)  # $1 = entity code
			;?           # optional ending semicolon
		)delimiter(/)modifier(ix)>

		constant(SMILEY_SCAN) operator(=) constant(Smileys)operator(::)constant(SMILEY_PATTERN)

		comment(# this is the main parser loop that separates)
		comment(#   text - everything until "[")
		comment(# from)
		comment(#   tags - starting with "[", ending with "]")
		reserved(def) method(parse_token)
			reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(SIMPLE_TEXT_SCAN)operator(\))
				ident(add_text)
			reserved(else)
				ident(handle_tag)
			reserved(end)
		reserved(end)

		reserved(def) method(handle_tag)
			ident(tag_start) operator(=) instance_variable(@scanner)operator(.)ident(pos)

			reserved(unless) instance_variable(@scanner)operator(.)ident(scan) constant(TAG_BEGIN_SCAN)
				ident(garbage_out) ident(tag_start)
				reserved(return)
			reserved(end)

			ident(closing)operator(,) ident(id) operator(=) instance_variable(@scanner)operator([)integer(1)operator(])operator(,) instance_variable(@scanner)operator([)integer(2)operator(])
			comment(#debug 'handle_tag(%p\)' % @scanner.matched)

			ident(handled) operator(=)
				reserved(case) ident(id)

					reserved(when) regexp<delimiter(/)content([a-z])delimiter(/)modifier(i)>
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(CLASSIC_TAG_SCAN)operator(\))
							reserved(if) ident(handle_classic_tag)operator(()ident(id) operator(+) instance_variable(@scanner)operator(.)ident(matched)operator(,) ident(closing)operator(\))
								ident(already_closed) operator(=) pre_constant(true)
							reserved(end)
						reserved(end)

					reserved(when) string<delimiter(')content(*)delimiter(')>
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(SEPARATOR_TAG_SCAN)operator(\))
							ident(handle_asterisk) ident(tag_start)operator(,) ident(id) operator(+) instance_variable(@scanner)operator(.)ident(matched)
							pre_constant(true)
						reserved(end)

					reserved(when) string<delimiter(')content(-)delimiter(')>
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(FORMAT_TAG_SCAN)operator(\))
							comment(#format = id + @scanner.matched)
							instance_variable(@encoder)operator(.)ident(add_html) string<delimiter(")char(\\n)content(<hr>)char(\\n)delimiter(")>
							pre_constant(true)
						reserved(end)

					reserved(when) string<delimiter(')content(")delimiter(')>
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(QUOTED_SCAN)operator(\))
							instance_variable(@encoder)operator(.)ident(add_text) ident(unescape)operator(()instance_variable(@scanner)operator([)integer(1)operator(])operator(\))
							pre_constant(true)
						reserved(end)

					reserved(when) string<delimiter(')content(&)delimiter(')>
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(ENTITY_SCAN)operator(\))
							instance_variable(@encoder)operator(.)ident(add_entity) instance_variable(@scanner)operator([)integer(1)operator(])
							pre_constant(true)
						reserved(end)

					reserved(when) constant(Smileys)operator(::)constant(SMILEY_START_CHARSET)
						instance_variable(@scanner)operator(.)ident(pos) operator(=) instance_variable(@scanner)operator(.)ident(pos) operator(-) integer(1)  comment(# (ungetch\))
						reserved(if) instance_variable(@scanner)operator(.)ident(scan)operator(()constant(SMILEY_SCAN)operator(\))
							instance_variable(@encoder)operator(.)ident(add_html) constant(Smileys)operator(.)ident(smiley_to_image)operator(()instance_variable(@scanner)operator(.)ident(matched)operator(\))
							pre_constant(true)
						reserved(end)

				reserved(end) comment(# case)

			reserved(return) ident(garbage_out)operator(()ident(tag_start)operator(\)) reserved(unless) ident(handled)

			instance_variable(@scanner)operator(.)ident(scan)operator(()constant(TAG_END_SCAN)operator(\)) reserved(unless) ident(already_closed)
		reserved(end)

		constant(ATTRIBUTES_SCAN) operator(=) regexp<delimiter(/)content(
			(
				[^)char(\\])content(")char(\\\\)content(]*
				(?:
					(?:
						)char(\\\\)content(.
					|
						"
						[^")char(\\\\)content(]*
						(?:
							)char(\\\\)content(.
							[^")char(\\\\)content(]*
						\)*
						"?
					\)
					[^)char(\\])content(")char(\\\\)content(]*
				\)*
			\)
			)char(\\])content(?
		)delimiter(/)modifier(x)>

		reserved(def) method(handle_classic_tag) ident(name)operator(,) ident(closing)
			ident(debug) string<delimiter(')content(TAG: )delimiter(')> operator(+) operator(()ident(closing) operator(?) string<delimiter(')content(/)delimiter(')> operator(:) string<delimiter(')delimiter(')>operator(\)) operator(+) ident(name)
			comment(# flatten)
			ident(name)operator(.)ident(downcase!)
			ident(tag_class) operator(=) constant(TAG_LIST)operator([)ident(name)operator(])
			reserved(return) reserved(unless) ident(tag_class)

			comment(#debug((opening ? 'OPEN ' : 'CLOSE '\) + tag_class.name\))

			comment(# create an attribute object to handle it)
			instance_variable(@scanner)operator(.)ident(scan)operator(()constant(ATTRIBUTES_SCAN)operator(\))
			comment(#debug name + ':' + @scanner[1])
			ident(attr) operator(=) constant(Attribute)operator(.)ident(create) instance_variable(@scanner)operator([)integer(1)operator(])
			comment(#debug 'ATTRIBUTES %p ' % attr #unless attr.empty?)

			comment(#debug 'closing: %p; name=%s, attr=%p' % [closing, name, attr])

			comment(# OPEN)
			reserved(if) reserved(not) ident(closing) reserved(and) ident(tag) operator(=) instance_variable(@tagstack)operator(.)ident(try_open_class)operator(()ident(tag_class)operator(,) ident(attr)operator(\))
				comment(#debug 'opening')
				ident(tag)operator(.)ident(do_open) instance_variable(@scanner)
				comment(# this should be done by the tag itself.)
				reserved(if) ident(attr)operator(.)ident(empty_tag?)
					ident(tag)operator(.)ident(handle_empty)
					instance_variable(@tagstack)operator(.)ident(close_tag)
				reserved(elsif) ident(tag)operator(.)ident(special_content?)
					ident(handle_special_content)operator(()ident(tag)operator(\))
					instance_variable(@tagstack)operator(.)ident(close_tag)
					comment(#        # ignore asterisks directly after the opening; these are phpBBCode)
					comment(#        elsif tag.respond_to? :asterisk)
					comment(#          debug 'SKIP ASTERISKS: ' if @scanner.skip(ASTERISK_TAGS_SCAN\))
				reserved(end)

			comment(# CLOSE)
			reserved(elsif) instance_variable(@tagstack)operator(.)ident(try_close_class)operator(()ident(tag_class)operator(\))
				comment(#debug 'closing')
				comment(# GARBAGE)
			reserved(else)
				reserved(return)
			reserved(end)

			pre_constant(true)
		reserved(end)

		reserved(def) method(handle_asterisk) ident(tag_start)operator(,) ident(stars)
			comment(#debug 'ASTERISK: ' + stars.to_s)
			comment(# rule for asterisk tags: they belong to the last tag)
			comment(# that handles them. tags opened after this tag are closed.)
			comment(# if no open tag uses them, all are closed.)
			ident(tag) operator(=) instance_variable(@tagstack)operator(.)ident(close_all_until) operator({) operator(|)ident(tag)operator(|) ident(tag)operator(.)ident(respond_to?) symbol(:asterisk) operator(})
			reserved(unless) ident(tag) reserved(and) ident(tag)operator(.)ident(asterisk) ident(stars)operator(,) instance_variable(@scanner)
				ident(garbage_out) ident(tag_start)
			reserved(end)
		reserved(end)

		reserved(def) method(handle_special_content) ident(tag)
			ident(scanned) operator(=) instance_variable(@scanner)operator(.)ident(scan_until)operator(()ident(tag)operator(.)ident(closing_tag)operator(\))
			reserved(if) ident(scanned)
				ident(scanned)operator(.)ident(slice!)operator(()operator(-)operator(()instance_variable(@scanner)operator(.)ident(matched)operator(.)ident(size)operator(\))operator(..)integer(-1)operator(\))
			reserved(else)
				ident(scanned) operator(=) instance_variable(@scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(.*)delimiter(/)modifier(m)>operator(\))operator(.)ident(to_s)
			reserved(end)
			comment(#debug 'SPECIAL CONTENT: ' + scanned)
			ident(tag)operator(.)ident(handle_content)operator(()ident(scanned)operator(\))
		reserved(end)

		reserved(def) method(unescape) ident(text)
			comment(# input: correctly formatted quoted string (without the quotes\))
			ident(text)operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\\\)content((?:([")char(\\\\)content(]\)|.\))delimiter(/)>operator(\)) operator({) global_variable($1) reserved(or) global_variable($&) operator(})
		reserved(end)


		comment(# MAGIC FEAUTURES)

		constant(URL_PATTERN) operator(=) regexp<delimiter(/)content((?:(?:www|ftp\))char(\\.)content(|(?>)char(\\w)content({3,}\):)char(\\/)char(\\/)content(\))char(\\S)content(+)delimiter(/)>
		constant(EMAIL_PATTERN) operator(=) regexp<delimiter(/)content((?>[)char(\\w)char(\\-)content(_.]+\)@[)char(\\w)char(\\-)char(\\.)content(]+)char(\\.)char(\\w)content(+)delimiter(/)>

		constant(HAS_MAGIC) operator(=) regexp<delimiter(/)content([&@)inline<inline_delimiter(#{)constant(Smileys)operator(::)constant(SMILEY_START_CHARS)inline_delimiter(})>content(]|(?i:www|ftp\))delimiter(/)>

		constant(MAGIC_PATTERN) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(()content(\\W)content(|^\)(%s\))delimiter(')> operator(%)
			operator([)constant(Smileys)operator(::)constant(MAGIC_SMILEY_PATTERN)operator(,) constant(URL_PATTERN)operator(,) constant(EMAIL_PATTERN)operator(])operator(.)ident(map) operator({) operator(|)ident(pattern)operator(|)
				ident(pattern)operator(.)ident(to_s)
			operator(})operator(.)ident(join)operator(()string<delimiter(')content(|)delimiter(')>operator(\)) operator(\))

		constant(IS_SMILEY_PATTERN) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(^%s)delimiter(')> operator(%) constant(Smileys)operator(::)constant(SMILEY_START_CHARSET)operator(.)ident(to_s) operator(\))
		constant(IS_URL_PATTERN) operator(=) regexp<delimiter(/)content(^(?:(?i:www|ftp\))char(\\.)content(|(?>)char(\\w)content(+\):)char(\\/)char(\\/)content(\))delimiter(/)>
		constant(URL_STARTS_WITH_PROTOCOL) operator(=) regexp<delimiter(/)content(^)char(\\w)content(+:)char(\\/)char(\\/)delimiter(/)>
		constant(IS_EMAIL_PATTERN) operator(=) regexp<delimiter(/)content(^[)char(\\w)char(\\-)content(_.]+@)delimiter(/)>

		reserved(def) method(to_magic) ident(text)
			comment(#      debug MAGIC_PATTERN.to_s)
			ident(text)operator(.)ident(gsub!)operator(()constant(MAGIC_PATTERN)operator(\)) operator({)
				ident(magic) operator(=) global_variable($2)
				global_variable($1) operator(+) reserved(case) ident(magic)
					reserved(when) constant(IS_SMILEY_PATTERN)
						constant(Smileys)operator(.)ident(smiley_to_img) ident(magic)
					reserved(when) constant(IS_URL_PATTERN)
						ident(last) operator(=) ident(magic)operator(.)ident(slice_punctation!)  comment(# no punctation in my URL)
						ident(href) operator(=) ident(magic)
						ident(href)operator(.)ident(insert)operator(()integer(0)operator(,) string<delimiter(')content(http://)delimiter(')>operator(\)) reserved(unless) ident(magic) operator(=)operator(~) constant(URL_STARTS_WITH_PROTOCOL)
						string<delimiter(')content(<a href=")delimiter(')> operator(+) ident(href) operator(+) string<delimiter(')content(">)delimiter(')> operator(+) ident(magic) operator(+) string<delimiter(')content(</a>)delimiter(')> operator(+) ident(last)
					reserved(when) constant(IS_EMAIL_PATTERN)
						ident(last) operator(=) ident(magic)operator(.)ident(slice_punctation!)
						string<delimiter(')content(<a href="mailto:)delimiter(')> operator(+) ident(magic) operator(+) string<delimiter(')content(">)delimiter(')> operator(+) ident(magic) operator(+) string<delimiter(')content(</a>)delimiter(')> operator(+) ident(last)
				reserved(else)
					ident(raise) string<delimiter(')content({{{)delimiter(')> operator(+) ident(magic) operator(+) string<delimiter(')content(}}})delimiter(')>
				reserved(end)
			operator(})
			ident(text)
		reserved(end)

		comment(# handles smileys and urls)
		reserved(def) method(parse_magic) ident(html)
			reserved(return) ident(html) reserved(unless) instance_variable(@do_magic)
			ident(scanner) operator(=) constant(StringScanner)operator(.)ident(new) ident(html)
			ident(out) operator(=) string<delimiter(')delimiter(')>
			reserved(while) ident(scanner)operator(.)ident(rest?)
				reserved(if) ident(scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( < (?: a)char(\\s)content( .*? <)char(\\/)content(a> | pre)char(\\W)content( .*? <)char(\\/)content(pre> | [^>]* > \) )delimiter(/)modifier(mx)>operator(\))
					ident(out) operator(<<) ident(scanner)operator(.)ident(matched)
				reserved(elsif) ident(scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content( [^<]+ )delimiter(/)modifier(x)>operator(\))
					ident(out) operator(<<) ident(to_magic)operator(()ident(scanner)operator(.)ident(matched)operator(\))

				comment(# this should never happen)
				reserved(elsif) ident(scanner)operator(.)ident(scan)operator(()regexp<delimiter(/)content(.)delimiter(/)modifier(m)>operator(\))
					ident(raise) string<delimiter(')content(ERROR: else case reached)delimiter(')>
				reserved(end)
			reserved(end)
			ident(out)
		reserved(end)
	reserved(end)  comment(# Parser)
reserved(end)

reserved(class) class(String)
	reserved(def) method(slice_punctation!)
		ident(slice!)operator(()regexp<delimiter(/)content([.:,!)char(\\?)content(]+$)delimiter(/)>operator(\))operator(.)ident(to_s)  comment(# return '' instead of nil)
	reserved(end)
reserved(end)

comment(#)
comment(# = Grammar)
comment(#)
comment(# An implementation of common algorithms on grammars.)
comment(#)
comment(# This is used by Shinobu, a visualization tool for educating compiler-building.)
comment(#)
comment(# Thanks to Andreas Kunert for his wonderful LR(k\) Pamphlet (German, see http://www.informatik.hu-berlin.de/~kunert/papers/lr-analyse\), and Aho/Sethi/Ullman for their Dragon Book.)
comment(#)
comment(# Homepage::  http://shinobu.cYcnus.de (not existing yet\))
comment(# Author::    murphy (Kornelius Kalnbach\))
comment(# Copyright:: (cc\) 2005 cYcnus)
comment(# License::   GPL)
comment(# Version:: 0.2.0 (2005-03-27\))

ident(require) string<delimiter(')content(set_hash)delimiter(')>
ident(require) string<delimiter(')content(ctype)delimiter(')>
ident(require) string<delimiter(')content(tools)delimiter(')>
ident(require) string<delimiter(')content(rules)delimiter(')>
ident(require) string<delimiter(')content(trace)delimiter(')>

ident(require) string<delimiter(')content(first)delimiter(')>
ident(require) string<delimiter(')content(follow)delimiter(')>

comment(# = Grammar)
comment(#)
comment(# == Syntax)
comment(#)
comment(# === Rules)
comment(#)
comment(# Each line is a rule.)
comment(# The syntax is)
comment(#)
comment(# 	left - right)
comment(#)
comment(# where +left+ and +right+ can be uppercase and lowercase letters,)
comment(# and <code>-</code> can be any combination of <, >, - or whitespace.)
comment(#)
comment(# === Symbols)
comment(#)
comment(# Uppercase letters stand for meta symbols, lowercase for terminals.)
comment(#)
comment(# You can make epsilon-derivations by leaving <code><right></code> empty.)
comment(#)
comment(# === Example)
comment(# 	S - Ac)
comment(# 	A - Sc)
comment(# 	A - b)
comment(# 	A -)
reserved(class) class(Grammar)

	ident(attr_reader) symbol(:tracer)
	comment(# Creates a new Grammar.)
	comment(# If $trace is true, the algorithms explain (textual\) what they do to $stdout.)
	reserved(def) method(initialize) ident(data)operator(,) ident(tracer) operator(=) constant(Tracer)operator(.)ident(new)
		instance_variable(@tracer) operator(=) ident(tracer)
		instance_variable(@rules) operator(=) constant(Rules)operator(.)ident(new)
		instance_variable(@terminals)operator(,) instance_variable(@meta_symbols) operator(=) constant(SortedSet)operator(.)ident(new)operator(,) constant(Array)operator(.)ident(new)
		instance_variable(@start_symbol) operator(=) pre_constant(nil)
		ident(add_rules) ident(data)
	reserved(end)

	ident(attr_reader) symbol(:meta_symbols)operator(,) symbol(:terminals)operator(,) symbol(:rules)operator(,) symbol(:start_symbol)

	ident(alias_method) symbol(:sigma)operator(,) symbol(:terminals)
	ident(alias_method) symbol(:alphabet)operator(,) symbol(:terminals)
	ident(alias_method) symbol(:variables)operator(,) symbol(:meta_symbols)
	ident(alias_method) symbol(:nonterminals)operator(,) symbol(:meta_symbols)

	comment(# A string representation of the grammar for debugging.)
	reserved(def) method(inspect) ident(productions_too) operator(=) pre_constant(false)
		string<delimiter(')content(Grammar(meta symbols: %s; alphabet: %s; productions: [%s]; start symbol: %s\))delimiter(')> operator(%)
			operator([)
				ident(meta_symbols)operator(.)ident(join)operator(()string<delimiter(')content(, )delimiter(')>operator(\))operator(,)
				ident(terminals)operator(.)ident(join)operator(()string<delimiter(')content(, )delimiter(')>operator(\))operator(,)
				reserved(if) ident(productions_too)
					instance_variable(@rules)operator(.)ident(inspect)
				reserved(else)
					instance_variable(@rules)operator(.)ident(size)
				reserved(end)operator(,)
				ident(start_symbol)
			operator(])
	reserved(end)

	comment(# Add rules to the grammar. +rules+ should be a String or respond to +scan+ in a similar way.)
	comment(#)
	comment(# Syntax: see Grammar.)
	reserved(def) method(add_rules) ident(grammar)
		instance_variable(@rules) operator(=) constant(Rules)operator(.)ident(parse) ident(grammar) reserved(do) operator(|)ident(rule)operator(|)
			instance_variable(@start_symbol) operator(||=) ident(rule)operator(.)ident(left)
			instance_variable(@meta_symbols) operator(<<) ident(rule)operator(.)ident(left)
			instance_variable(@terminals)operator(.)ident(merge) ident(rule)operator(.)ident(right)operator(.)ident(split)operator(()string<delimiter(')delimiter(')>operator(\))operator(.)ident(select) operator({) operator(|)ident(s)operator(|) ident(terminal?) ident(s) operator(})
		reserved(end)
		instance_variable(@meta_symbols)operator(.)ident(uniq!)
		ident(update)
	reserved(end)

	comment(# Returns a hash acting as FIRST operator, so that)
	comment(# <code>first["ABC"]</code> is FIRST(ABC\).)
	comment(# See http://en.wikipedia.org/wiki/LL_parser "Constructing an LL(1\) parsing table" for details.)
	reserved(def) method(first)
		ident(first_operator)
	reserved(end)

	comment(# Returns a hash acting as FOLLOW operator, so that)
	comment(# <code>first["A"]</code> is FOLLOW(A\).)
	comment(# See http://en.wikipedia.org/wiki/LL_parser "Constructing an LL(1\) parsing table" for details.)
	reserved(def) method(follow)
		ident(follow_operator)
	reserved(end)

	constant(LLError) operator(=) constant(Class)operator(.)ident(new)operator(()constant(Exception)operator(\))
	constant(LLErrorType1) operator(=) constant(Class)operator(.)ident(new)operator(()constant(LLError)operator(\))
	constant(LLErrorType2) operator(=) constant(Class)operator(.)ident(new)operator(()constant(LLError)operator(\))

	comment(# Tests if the grammar is LL(1\).)
	reserved(def) method(ll1?)
		reserved(begin)
			reserved(for) ident(meta) reserved(in) instance_variable(@meta_symbols)
				ident(first_sets) operator(=) instance_variable(@rules)operator([)ident(meta)operator(])operator(.)ident(map) operator({) operator(|)ident(alpha)operator(|) ident(first)operator([)ident(alpha)operator(]) operator(})
				ident(first_sets)operator(.)ident(inject)operator(()constant(Set)operator([)operator(])operator(\)) reserved(do) operator(|)ident(already_used)operator(,) ident(another_first_set)operator(|)
					reserved(unless) ident(already_used)operator(.)ident(disjoint?) ident(another_first_set)
						ident(raise) constant(LLErrorType1)
					reserved(end)
					ident(already_used)operator(.)ident(merge) ident(another_first_set)
				reserved(end)

				reserved(if) ident(first)operator([)ident(meta)operator(])operator(.)ident(include?) constant(EPSILON) reserved(and) reserved(not) ident(first)operator([)ident(meta)operator(])operator(.)ident(disjoint?) ident(follow)operator([)ident(meta)operator(])
					ident(raise) constant(LLErrorType2)
				reserved(end)
			reserved(end)
		reserved(rescue) constant(LLError)
			pre_constant(false)
		reserved(else)
			pre_constant(true)
		reserved(end)
	reserved(end)

ident(private)

	reserved(def) method(first_operator)
		instance_variable(@first) operator(||=) constant(FirstOperator)operator(.)ident(new) pre_constant(self)
	reserved(end)

	reserved(def) method(follow_operator)
		instance_variable(@follow) operator(||=) constant(FollowOperator)operator(.)ident(new) pre_constant(self)
	reserved(end)

	reserved(def) method(update)
		instance_variable(@first) operator(=) instance_variable(@follow) operator(=) pre_constant(nil)
	reserved(end)

reserved(end)

reserved(if) global_variable($0) operator(==) pre_constant(__FILE__)
  ident(eval) pre_constant(DATA)operator(.)ident(read)operator(,) pre_constant(nil)operator(,) global_variable($0)operator(,) pre_constant(__LINE__)operator(+)integer(4)
reserved(end)

ident(require) string<delimiter(')content(test/unit)delimiter(')>

reserved(class) class(TestCaseGrammar) operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)

	ident(include) constant(Grammar)operator(::)constant(Symbols)

	reserved(def) method(fifo) ident(s)
		constant(Set)operator([)operator(*)ident(s)operator(.)ident(split)operator(()string<delimiter(')delimiter(')>operator(\))operator(])
	reserved(end)

	reserved(def) method(test_fifo)
		ident(assert_equal) constant(Set)operator([)operator(])operator(,) ident(fifo)operator(()string<delimiter(')delimiter(')>operator(\))
		ident(assert_equal) constant(Set)operator([)constant(EPSILON)operator(,) constant(END_OF_INPUT)operator(,) string<delimiter(')content(x)delimiter(')>operator(,) string<delimiter(')content(Y)delimiter(')>operator(])operator(,) ident(fifo)operator(()string<delimiter(')content(?xY$)delimiter(')>operator(\))
	reserved(end)

	constant(TEST_GRAMMAR_1) operator(=) string<delimiter(<<-EOG)>string<content(
S - ABCD
A - a
A -
B - b
B -
C - c
C -
D - S
D -)delimiter(
	EOG)>

	reserved(def) method(test_symbols)
		ident(assert) constant(EPSILON)
		ident(assert) constant(END_OF_INPUT)
	reserved(end)

	reserved(def) method(test_first_1)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_1)

		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(first) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) constant(EPSILON)operator(])operator(,) ident(f)operator([)string<delimiter(')content(A)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(b)delimiter(')>operator(,) constant(EPSILON)operator(])operator(,) ident(f)operator([)string<delimiter(')content(B)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(c)delimiter(')>operator(,) constant(EPSILON)operator(])operator(,) ident(f)operator([)string<delimiter(')content(C)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(b)delimiter(')>operator(,) string<delimiter(')content(c)delimiter(')>operator(,) constant(EPSILON)operator(])operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
	reserved(end)

	reserved(def) method(test_follow_1)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_1)

		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(follow) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(b)delimiter(')>operator(,) string<delimiter(')content(c)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(A)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(b)delimiter(')>operator(,) string<delimiter(')content(c)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(B)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(b)delimiter(')>operator(,) string<delimiter(')content(c)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(C)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
	reserved(end)


	constant(TEST_GRAMMAR_2) operator(=) string<delimiter(<<-EOG)>string<content(
S - Ed
E - EpT
E - EmT
E - T
T - TuF
T - TdF
T - F
F - i
F - n
F - aEz)delimiter(
	EOG)>

	reserved(def) method(test_first_2)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_2)

		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(first) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(n)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(n)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(n)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(n)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
	reserved(end)

	reserved(def) method(test_follow_2)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_2)

		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(follow) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(m)delimiter(')>operator(,) string<delimiter(')content(d)delimiter(')>operator(,) string<delimiter(')content(z)delimiter(')>operator(,) string<delimiter(')content(p)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(m)delimiter(')>operator(,) string<delimiter(')content(d)delimiter(')>operator(,) string<delimiter(')content(z)delimiter(')>operator(,) string<delimiter(')content(p)delimiter(')>operator(,) string<delimiter(')content(u)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(m)delimiter(')>operator(,) string<delimiter(')content(d)delimiter(')>operator(,) string<delimiter(')content(z)delimiter(')>operator(,) string<delimiter(')content(p)delimiter(')>operator(,) string<delimiter(')content(u)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
	reserved(end)

	constant(LLError) operator(=) constant(Grammar)operator(::)constant(LLError)

	constant(TEST_GRAMMAR_3) operator(=) string<delimiter(<<-EOG)>string<content(
E - TD
D - pTD
D -
T - FS
S - uFS
S -
S - p
F - aEz
F - i)delimiter(
	EOG)>

	constant(NoError) operator(=) constant(Class)operator(.)ident(new)operator(()constant(Exception)operator(\))

	reserved(def) method(test_first_3)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_3)

		comment(# Grammar 3 is LL(1\), so all first-sets must be disjoint.)
		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(first) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(EPSILON)operator(,) string<delimiter(')content(p)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(EPSILON)operator(,) string<delimiter(')content(u)delimiter(')>operator(,) string<delimiter(')content(p)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
		reserved(for) ident(m) reserved(in) ident(g)operator(.)ident(meta_symbols)
			ident(r) operator(=) ident(g)operator(.)ident(rules)operator([)ident(m)operator(])
			ident(firsts) operator(=) ident(r)operator(.)ident(map) operator({) operator(|)ident(x)operator(|) ident(f)operator([)ident(x)operator(]) operator(})operator(.)ident(to_set)
			ident(assert_nothing_raised) reserved(do)
				ident(firsts)operator(.)ident(inject)operator(()constant(Set)operator(.)ident(new)operator(\)) reserved(do) operator(|)ident(already_used)operator(,) ident(another_first_set)operator(|)
					ident(raise) constant(LLError)operator(,) string<delimiter(')content(not disjoint!)delimiter(')> reserved(unless) ident(already_used)operator(.)ident(disjoint?) ident(another_first_set)
					ident(already_used)operator(.)ident(merge) ident(another_first_set)
				reserved(end)
			reserved(end)
		reserved(end)
	reserved(end)

	reserved(def) method(test_follow_3)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_3)

		comment(# Grammar 3 is not LL(1\), because epsilon is in FIRST(S\),)
		comment(# but FIRST(S\) and FOLLOW(S\) are not disjoint.)
		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(follow) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(z)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(z)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(z)delimiter(')>operator(,) string<delimiter(')content(p)delimiter(')>operator(,) string<delimiter(')content(u)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(p)delimiter(')>operator(,) string<delimiter(')content(z)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(p)delimiter(')>operator(,) string<delimiter(')content(z)delimiter(')>operator(,) constant(END_OF_INPUT)operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
		reserved(for) ident(m) reserved(in) ident(g)operator(.)ident(meta_symbols)
			ident(first_m) operator(=) ident(g)operator(.)ident(first)operator([)ident(m)operator(])
			reserved(next) reserved(unless) ident(first_m)operator(.)ident(include?) constant(EPSILON)
			ident(assert_raise)operator(()ident(m) operator(==) string<delimiter(')content(S)delimiter(')> operator(?) constant(LLError) operator(:) constant(NoError)operator(\)) reserved(do)
				reserved(if) ident(first_m)operator(.)ident(disjoint?) ident(f)operator([)ident(m)operator(])
					ident(raise) constant(NoError)  comment(# this is fun :D)
				reserved(else)
					ident(raise) constant(LLError)
				reserved(end)
			reserved(end)
		reserved(end)
	reserved(end)

	constant(TEST_GRAMMAR_3b) operator(=) string<delimiter(<<-EOG)>string<content(
E - TD
D - pTD
D - PTD
D -
T - FS
S - uFS
S -
F - aEz
F - i
P - p)delimiter(
	EOG)>

	reserved(def) method(test_first_3b)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_3b)

		comment(# Grammar 3b is NOT LL(1\), since not all first-sets are disjoint.)
		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(first) operator(})
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(EPSILON)operator(,) string<delimiter(')content(p)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(p)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(P)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)string<delimiter(')content(a)delimiter(')>operator(,) string<delimiter(')content(i)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(\))
		ident(assert_equal)operator(()constant(Set)operator([)constant(EPSILON)operator(,) string<delimiter(')content(u)delimiter(')>operator(])operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(\))
		reserved(for) ident(m) reserved(in) ident(g)operator(.)ident(meta_symbols)
			ident(r) operator(=) ident(g)operator(.)ident(rules)operator([)ident(m)operator(])
			ident(firsts) operator(=) ident(r)operator(.)ident(map) operator({) operator(|)ident(x)operator(|) ident(f)operator([)ident(x)operator(]) operator(})
			ident(assert_raise)operator(()ident(m) operator(==) string<delimiter(')content(D)delimiter(')> operator(?) constant(LLError) operator(:) constant(NoError)operator(\)) reserved(do)
				ident(firsts)operator(.)ident(inject)operator(()constant(Set)operator(.)ident(new)operator(\)) reserved(do) operator(|)ident(already_used)operator(,) ident(another_first_set)operator(|)
					ident(raise) constant(LLError)operator(,) string<delimiter(')content(not disjoint!)delimiter(')> reserved(unless) ident(already_used)operator(.)ident(disjoint?) ident(another_first_set)
					ident(already_used)operator(.)ident(merge) ident(another_first_set)
				reserved(end)
				ident(raise) constant(NoError)
			reserved(end)
		reserved(end)
	reserved(end)

	reserved(def) method(test_follow_3b)
		ident(g) operator(=) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_3b)

		comment(# Although Grammar 3b is NOT LL(1\), the FOLLOW-condition is satisfied.)
		ident(f) operator(=) pre_constant(nil)
		ident(assert_nothing_raised) operator({) ident(f) operator(=) ident(g)operator(.)ident(follow) operator(})
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(z$)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(E)delimiter(')>operator(])operator(,) string<delimiter(')content(E)delimiter(')>operator(\))
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(z$)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(D)delimiter(')>operator(])operator(,) string<delimiter(')content(D)delimiter(')>operator(\))
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(ai)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(P)delimiter(')>operator(])operator(,) string<delimiter(')content(P)delimiter(')>operator(\))
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(z$pu)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(F)delimiter(')>operator(])operator(,) string<delimiter(')content(F)delimiter(')>operator(\))
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(z$p)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(T)delimiter(')>operator(])operator(,) string<delimiter(')content(T)delimiter(')>operator(\))
		ident(assert_equal)operator(()ident(fifo)operator(()string<delimiter(')content(z$p)delimiter(')>operator(\))operator(,) ident(f)operator([)string<delimiter(')content(S)delimiter(')>operator(])operator(,) string<delimiter(')content(S)delimiter(')>operator(\))
		reserved(for) ident(m) reserved(in) ident(g)operator(.)ident(meta_symbols)
			ident(first_m) operator(=) ident(g)operator(.)ident(first)operator([)ident(m)operator(])
			reserved(next) reserved(unless) ident(first_m)operator(.)ident(include?) constant(EPSILON)
			ident(assert_raise)operator(()constant(NoError)operator(\)) reserved(do)
				reserved(if) ident(first_m)operator(.)ident(disjoint?) ident(f)operator([)ident(m)operator(])
					ident(raise) constant(NoError)  comment(# this is fun :D)
				reserved(else)
					ident(raise) constant(LLError)
				reserved(end)
			reserved(end)
		reserved(end)
	reserved(end)

	reserved(def) method(test_ll1?)
		ident(assert_equal) pre_constant(false)operator(,) constant(Grammar)operator(.)ident(new)operator(()constant(TEST_GRAMMAR_3)operator(\))operator(.)ident(ll1?)operator(,) string<delimiter(')content(Grammar 3)delimiter(')>
		ident(assert_equal) pre_constant(false)operator(,) constant(Grammar)operator(.)ident(new)operator(()constant(TEST_GRAMMAR_3b)operator(\))operator(.)ident(ll1?)operator(,) string<delimiter(')content(Grammar 3b)delimiter(')>
	reserved(end)

	reserved(def) method(test_new)
		ident(assert_nothing_raised) operator({) constant(Grammar)operator(.)ident(new) string<delimiter(')delimiter(')> operator(})
		ident(assert_nothing_raised) operator({) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_1) operator(})
		ident(assert_nothing_raised) operator({) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_2) operator(})
		ident(assert_nothing_raised) operator({) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_3) operator(})
		ident(assert_nothing_raised) operator({) constant(Grammar)operator(.)ident(new) constant(TEST_GRAMMAR_1) operator(+) constant(TEST_GRAMMAR_2) operator(+) constant(TEST_GRAMMAR_3) operator(})
		ident(assert_raise)operator(()constant(ArgumentError)operator(\)) operator({) constant(Grammar)operator(.)ident(new) string<delimiter(')content(S - ?)delimiter(')> operator(})
	reserved(end)
reserved(end)

comment(# vim:foldmethod=syntax)

comment(#!/usr/bin/env ruby)

ident(require) string<delimiter(')content(fox12)delimiter(')>

ident(include) constant(Fox)

reserved(class) class(Window) operator(<) constant(FXMainWindow)
	reserved(def) method(initialize)operator(()ident(app)operator(\))
		reserved(super)operator(()ident(app)operator(,) ident(app)operator(.)ident(appName) operator(+) string<delimiter(")content(: First Set Calculation)delimiter(")>operator(,) pre_constant(nil)operator(,) pre_constant(nil)operator(,) constant(DECOR_ALL)operator(,) integer(0)operator(,) integer(0)operator(,) integer(800)operator(,) integer(600)operator(,) integer(0)operator(,) integer(0)operator(\))

		comment(# {{{ menubar)
		ident(menubar) operator(=) constant(FXMenuBar)operator(.)ident(new)operator(()pre_constant(self)operator(,) constant(LAYOUT_SIDE_TOP)operator(|)constant(LAYOUT_FILL_X)operator(\))

		ident(filemenu) operator(=) constant(FXMenuPane)operator(.)ident(new)operator(()pre_constant(self)operator(\))

		constant(FXMenuCommand)operator(.)ident(new)operator(()ident(filemenu)operator(,) string<delimiter(")content(&Start)char(\\t)content(Ctl-S)char(\\t)content(Start the application.)delimiter(")>operator(,) pre_constant(nil)operator(,) ident(getApp)operator(()operator(\))operator(\))operator(.)ident(connect)operator(()constant(SEL_COMMAND)operator(,) ident(method)operator(()symbol(:start)operator(\))operator(\))
		constant(FXMenuCommand)operator(.)ident(new)operator(()ident(filemenu)operator(,) string<delimiter(")content(&Quit)char(\\t)content(Alt-F4)char(\\t)content(Quit the application.)delimiter(")>operator(,) pre_constant(nil)operator(,) ident(getApp)operator(()operator(\))operator(,) constant(FXApp)operator(::)constant(ID_QUIT)operator(\))
		constant(FXMenuTitle)operator(.)ident(new)operator(()ident(menubar)operator(,) string<delimiter(")content(&File)delimiter(")>operator(,) pre_constant(nil)operator(,) ident(filemenu)operator(\))
		comment(# }}} menubar)

		comment(# {{{ statusbar)
		instance_variable(@statusbar) operator(=) constant(FXStatusBar)operator(.)ident(new)operator(()pre_constant(self)operator(,) constant(LAYOUT_SIDE_BOTTOM)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(STATUSBAR_WITH_DRAGCORNER)operator(\))
		comment(# }}} statusbar)

		comment(# {{{ window content)
		ident(horizontalsplitt) operator(=) constant(FXSplitter)operator(.)ident(new)operator(()pre_constant(self)operator(,) constant(SPLITTER_VERTICAL)operator(|)constant(LAYOUT_SIDE_TOP)operator(|)constant(LAYOUT_FILL)operator(\))


		instance_variable(@productions) operator(=) constant(FXList)operator(.)ident(new)operator(()ident(horizontalsplitt)operator(,) pre_constant(nil)operator(,) integer(0)operator(,) constant(LAYOUT_SIDE_TOP)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FIX_HEIGHT)operator(|)constant(LIST_SINGLESELECT)operator(\))
		instance_variable(@productions)operator(.)ident(height) operator(=) integer(100)

		instance_variable(@result) operator(=) constant(FXTable)operator(.)ident(new)operator(()ident(horizontalsplitt)operator(,) pre_constant(nil)operator(,) integer(0)operator(,) constant(LAYOUT_FILL)operator(\))
		instance_variable(@result)operator(.)ident(height) operator(=) integer(200)
		instance_variable(@result)operator(.)ident(setTableSize)operator(()integer(2)operator(,) integer(2)operator(,) pre_constant(false)operator(\))
		instance_variable(@result)operator(.)ident(rowHeaderWidth) operator(=) integer(0)

		ident(header) operator(=) instance_variable(@result)operator(.)ident(columnHeader)
		ident(header)operator(.)ident(setItemText) integer(0)operator(,) string<delimiter(')content(X)delimiter(')>
		ident(header)operator(.)ident(setItemText) integer(1)operator(,) string<delimiter(')content(FIRST(X\))delimiter(')>
		reserved(for) ident(item) reserved(in) ident(header)
			ident(item)operator(.)ident(justification) operator(=) constant(FXHeaderItem)operator(::)constant(CENTER_X)
		reserved(end)

		instance_variable(@debug) operator(=) constant(FXText)operator(.)ident(new)operator(()ident(horizontalsplitt)operator(,) pre_constant(nil)operator(,) integer(0)operator(,) constant(LAYOUT_SIDE_BOTTOM)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FIX_HEIGHT)operator(\))
		instance_variable(@debug)operator(.)ident(height) operator(=) integer(200)

		comment(# }}} window content)
	reserved(end)

	reserved(def) method(load_grammar) ident(grammar)
		instance_variable(@tracer) operator(=) constant(FirstTracer)operator(.)ident(new)operator(()pre_constant(self)operator(\))
		instance_variable(@grammar) operator(=) constant(Grammar)operator(.)ident(new) ident(grammar)operator(,) instance_variable(@tracer)
		instance_variable(@rules_indexes) operator(=) constant(Hash)operator(.)ident(new)
		instance_variable(@grammar)operator(.)ident(rules)operator(.)ident(each_with_index) reserved(do) operator(|)ident(rule)operator(,) ident(i)operator(|)
			instance_variable(@productions)operator(.)ident(appendItem) ident(rule)operator(.)ident(inspect)
			instance_variable(@rules_indexes)operator([)ident(rule)operator(]) operator(=) ident(i)
		reserved(end)
	reserved(end)

	reserved(def) method(create)
		reserved(super)
		ident(show)operator(()constant(PLACEMENT_SCREEN)operator(\))
	reserved(end)

	reserved(def) method(rule) ident(rule)
		instance_variable(@productions)operator(.)ident(selectItem) instance_variable(@rules_indexes)operator([)ident(rule)operator(])
		ident(sleep) float(0.1)
	reserved(end)

	reserved(def) method(iterate) ident(i)
		ident(setTitle) ident(i)operator(.)ident(to_s)
		ident(sleep) float(0.1)
	reserved(end)

	reserved(def) method(missing) ident(what)
		instance_variable(@debug)operator(.)ident(appendText) ident(what) operator(+) string<delimiter(")char(\\n)delimiter(")>
		ident(sleep) float(0.1)
	reserved(end)

	reserved(def) method(start) ident(sender)operator(,) ident(sel)operator(,) ident(pointer)
		constant(Thread)operator(.)ident(new) reserved(do)
			reserved(begin)
				instance_variable(@grammar)operator(.)ident(first)
			reserved(rescue) operator(=)operator(>) ident(boom)
				instance_variable(@debug)operator(.)ident(appendText) operator([)ident(boom)operator(.)ident(to_s)operator(,) operator(*)ident(boom)operator(.)ident(backtrace)operator(])operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))
			reserved(end)
		reserved(end)
	reserved(end)

reserved(end)

global_variable($:) operator(<<) string<delimiter(')content(grammar)delimiter(')>
ident(require) string<delimiter(')content(grammar)delimiter(')>

ident(require) string<delimiter(')content(first_tracer)delimiter(')>

ident(app) operator(=) constant(FXApp)operator(.)ident(new)operator(()string<delimiter(")content(Shinobu)delimiter(")>operator(,) string<delimiter(")content(cYcnus)delimiter(")>operator(\))

comment(# fenster erzeugen)
ident(window) operator(=) constant(Window)operator(.)ident(new) ident(app)

reserved(unless) pre_constant(ARGV)operator(.)ident(empty?)
	ident(grammar) operator(=) constant(File)operator(.)ident(read)operator(()pre_constant(ARGV)operator(.)ident(first)operator(\))
reserved(else)
	ident(grammar) operator(=) string<delimiter(<<-EOG1)>string<content(
Z --> S
S --> Sb
S --> bAa
A --> aSc
A --> a
A --> aSb)delimiter(
	EOG1)>
reserved(end)

ident(window)operator(.)ident(load_grammar) ident(grammar)

ident(app)operator(.)ident(create)
ident(app)operator(.)ident(run)

ident(require) string<delimiter(')content(erb)delimiter(')>
ident(require) string<delimiter(')content(ftools)delimiter(')>
ident(require) string<delimiter(')content(yaml)delimiter(')>
ident(require) string<delimiter(')content(redcloth)delimiter(')>

reserved(module) class(WhyTheLuckyStiff)
	reserved(class) class(Book)
		ident(attr_accessor) symbol(:author)operator(,) symbol(:title)operator(,) symbol(:terms)operator(,) symbol(:image)operator(,) symbol(:teaser)operator(,)
			symbol(:chapters)operator(,) symbol(:expansion_paks)operator(,) symbol(:encoding)operator(,) symbol(:credits)
		reserved(def) method([]) ident(x)
			instance_variable(@lang)operator(.)ident(fetch)operator(()ident(x)operator(\)) reserved(do)
				ident(warn) ident(warning) operator(=) string<delimiter(")content([not translated: ')inline<inline_delimiter(#{)ident(x)inline_delimiter(})>content('!])delimiter(")>
				ident(warning)
			reserved(end)
		reserved(end)
	reserved(end)

	reserved(def) constant(Book)operator(::)ident(load)operator(() ident(file_name) operator(\))
		constant(YAML)operator(::)ident(load)operator(() constant(File)operator(.)ident(open)operator(() ident(file_name) operator(\)) operator(\))
	reserved(end)

	reserved(class) class(Section)
		ident(attr_accessor) symbol(:index)operator(,) symbol(:header)operator(,) symbol(:content)
		reserved(def) method(initialize)operator(() ident(i)operator(,) ident(h)operator(,) ident(c) operator(\))
			instance_variable(@index)operator(,) instance_variable(@header)operator(,) instance_variable(@content) operator(=) ident(i)operator(,) ident(h)operator(,) constant(RedCloth)operator(::)ident(new)operator(() ident(c)operator(.)ident(to_s) operator(\))
		reserved(end)
	reserved(end)

	reserved(class) class(Sidebar)
		ident(attr_accessor) symbol(:title)operator(,) symbol(:content)
	reserved(end)

	constant(YAML)operator(::)ident(add_domain_type)operator(() string<delimiter(')content(whytheluckystiff.net,2003)delimiter(')>operator(,) string<delimiter(')content(sidebar)delimiter(')> operator(\)) reserved(do) operator(|)ident(taguri)operator(,) ident(val)operator(|)
		constant(YAML)operator(::)ident(object_maker)operator(() constant(Sidebar)operator(,) string<delimiter(')content(title)delimiter(')> operator(=)operator(>) ident(val)operator(.)ident(keys)operator(.)ident(first)operator(,) string<delimiter(')content(content)delimiter(')> operator(=)operator(>) constant(RedCloth)operator(::)ident(new)operator(() ident(val)operator(.)ident(values)operator(.)ident(first) operator(\)) operator(\))
	reserved(end)
	reserved(class) class(Chapter)
		ident(attr_accessor) symbol(:index)operator(,) symbol(:title)operator(,) symbol(:sections)
		reserved(def) method(initialize)operator(() ident(i)operator(,) ident(t)operator(,) ident(sects) operator(\))
			instance_variable(@index) operator(=) ident(i)
			instance_variable(@title) operator(=) ident(t)
			ident(i) operator(=) integer(0)
			instance_variable(@sections) operator(=) ident(sects)operator(.)ident(collect) reserved(do) operator(|)ident(s)operator(|)
				reserved(if) ident(s)operator(.)ident(respond_to?)operator(() symbol(:keys) operator(\))
					ident(i) operator(+=) integer(1)
					constant(Section)operator(.)ident(new)operator(() ident(i)operator(,) ident(s)operator(.)ident(keys)operator(.)ident(first)operator(,) ident(s)operator(.)ident(values)operator(.)ident(first) operator(\))
				reserved(else)
					ident(s)
				reserved(end)
			reserved(end)
		reserved(end)
	reserved(end)

	constant(YAML)operator(::)ident(add_domain_type)operator(() string<delimiter(')content(whytheluckystiff.net,2003)delimiter(')>operator(,) string<delimiter(')content(book)delimiter(')> operator(\)) reserved(do) operator(|)ident(taguri)operator(,) ident(val)operator(|)
		operator([)string<delimiter(')content(chapters)delimiter(')>operator(,) string<delimiter(')content(expansion_paks)delimiter(')>operator(])operator(.)ident(each) reserved(do) operator(|)ident(chaptype)operator(|)
			ident(i) operator(=) integer(0)
			ident(val)operator([)ident(chaptype)operator(])operator(.)ident(collect!) reserved(do) operator(|)ident(c)operator(|)
				ident(i) operator(+=) integer(1)
				constant(Chapter)operator(::)ident(new)operator(() ident(i)operator(,) ident(c)operator(.)ident(keys)operator(.)ident(first)operator(,) ident(c)operator(.)ident(values)operator(.)ident(first) operator(\))
			reserved(end)
		reserved(end)
		ident(val)operator([)string<delimiter(')content(teaser)delimiter(')>operator(])operator(.)ident(collect!) reserved(do) operator(|)ident(t)operator(|)
			constant(Section)operator(::)ident(new)operator(() integer(1)operator(,) ident(t)operator(.)ident(keys)operator(.)ident(first)operator(,) ident(t)operator(.)ident(values)operator(.)ident(first) operator(\))
		reserved(end)
		ident(val)operator([)string<delimiter(')content(terms)delimiter(')>operator(]) operator(=) constant(RedCloth)operator(::)ident(new)operator(() ident(val)operator([)string<delimiter(')content(terms)delimiter(')>operator(]) operator(\))
		constant(YAML)operator(::)ident(object_maker)operator(() constant(Book)operator(,) ident(val) operator(\))
	reserved(end)

	reserved(class) class(Image)
		ident(attr_accessor) symbol(:file_name)
	reserved(end)

	constant(YAML)operator(::)ident(add_domain_type)operator(() string<delimiter(')content(whytheluckystiff.net,2003)delimiter(')>operator(,) string<delimiter(')content(img)delimiter(')> operator(\)) reserved(do) operator(|)ident(taguri)operator(,) ident(val)operator(|)
		constant(YAML)operator(::)ident(object_maker)operator(() constant(Image)operator(,) string<delimiter(')content(file_name)delimiter(')> operator(=)operator(>) string<delimiter(")content(i/)delimiter(")> operator(+) ident(val) operator(\))
	reserved(end)
reserved(end)

comment(#)
comment(# Convert the book to HTML)
comment(#)
reserved(if) pre_constant(__FILE__) operator(==) global_variable($0)
	reserved(unless) pre_constant(ARGV)operator([)integer(0)operator(])
		ident(puts) string<delimiter(")content(Usage: )inline<inline_delimiter(#{)global_variable($0)inline_delimiter(})>content( [/path/to/save/html])delimiter(")>
		ident(exit)
	reserved(end)

	ident(site_path) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
	ident(book) operator(=) constant(WhyTheLuckyStiff)operator(::)constant(Book)operator(::)ident(load)operator(() string<delimiter(')content(poignant.yml)delimiter(')> operator(\))
	ident(chapter) operator(=) pre_constant(nil)

	comment(# Write index page)
	ident(index_tpl) operator(=) constant(ERB)operator(::)ident(new)operator(() constant(File)operator(.)ident(open)operator(() string<delimiter(')content(index.erb)delimiter(')> operator(\))operator(.)ident(read) operator(\))
	constant(File)operator(.)ident(open)operator(() constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) string<delimiter(')content(index.html)delimiter(')> operator(\))operator(,) string<delimiter(')content(w)delimiter(')> operator(\)) reserved(do) operator(|)ident(out)operator(|)
		ident(out) operator(<<) ident(index_tpl)operator(.)ident(result)
	reserved(end)

	ident(book)operator(.)ident(chapters) operator(=) ident(book)operator(.)ident(chapters)operator([)integer(0)operator(,)integer(3)operator(]) reserved(if) pre_constant(ARGV)operator(.)ident(include?) string<delimiter(')content(-fast)delimiter(')>

	comment(# Write chapter pages)
	ident(chapter_tpl) operator(=) constant(ERB)operator(::)ident(new)operator(() constant(File)operator(.)ident(open)operator(() string<delimiter(')content(chapter.erb)delimiter(')> operator(\))operator(.)ident(read) operator(\))
	ident(book)operator(.)ident(chapters)operator(.)ident(each) reserved(do) operator(|)ident(chapter)operator(|)
		constant(File)operator(.)ident(open)operator(() constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) string<delimiter(")content(chapter-)inline<inline_delimiter(#{) ident(chapter)operator(.)ident(index) inline_delimiter(})>content(.html)delimiter(")> operator(\))operator(,) string<delimiter(')content(w)delimiter(')> operator(\)) reserved(do) operator(|)ident(out)operator(|)
			ident(out) operator(<<) ident(chapter_tpl)operator(.)ident(result)
		reserved(end)
	reserved(end)
	ident(exit) reserved(if) pre_constant(ARGV)operator(.)ident(include?) string<delimiter(')content(-fast)delimiter(')>

	comment(# Write expansion pak pages)
	ident(expak_tpl) operator(=) constant(ERB)operator(::)ident(new)operator(() constant(File)operator(.)ident(open)operator(() string<delimiter(')content(expansion-pak.erb)delimiter(')> operator(\))operator(.)ident(read) operator(\))
	ident(book)operator(.)ident(expansion_paks)operator(.)ident(each) reserved(do) operator(|)ident(pak)operator(|)
		constant(File)operator(.)ident(open)operator(() constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) string<delimiter(")content(expansion-pak-)inline<inline_delimiter(#{) ident(pak)operator(.)ident(index) inline_delimiter(})>content(.html)delimiter(")> operator(\))operator(,) string<delimiter(')content(w)delimiter(')> operator(\)) reserved(do) operator(|)ident(out)operator(|)
			ident(out) operator(<<) ident(expak_tpl)operator(.)ident(result)operator(() ident(binding) operator(\))
		reserved(end)
	reserved(end)

	comment(# Write printable version)
	ident(print_tpl) operator(=) constant(ERB)operator(::)ident(new)operator(() constant(File)operator(.)ident(open)operator(() string<delimiter(')content(print.erb)delimiter(')> operator(\))operator(.)ident(read) operator(\))
	constant(File)operator(.)ident(open)operator(() constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) string<delimiter(")content(print.html)delimiter(")> operator(\))operator(,) string<delimiter(')content(w)delimiter(')> operator(\)) reserved(do) operator(|)ident(out)operator(|)
		ident(out) operator(<<) ident(print_tpl)operator(.)ident(result)
	reserved(end)

	comment(# Copy css + images into site)
	ident(copy_list) operator(=) operator([)string<delimiter(")content(guide.css)delimiter(")>operator(]) operator(+)
		constant(Dir)operator([)string<delimiter(")content(i/*)delimiter(")>operator(])operator(.)ident(find_all) operator({) operator(|)ident(image)operator(|) ident(image) operator(=)operator(~) regexp<delimiter(/)char(\\.)content((gif|jpg|png\)$)delimiter(/)> operator(})

	constant(File)operator(.)ident(makedirs)operator(() constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) string<delimiter(")content(i)delimiter(")> operator(\)) operator(\))
	ident(copy_list)operator(.)ident(each) reserved(do) operator(|)ident(copy_file)operator(|)
		constant(File)operator(.)ident(copy)operator(() ident(copy_file)operator(,) constant(File)operator(.)ident(join)operator(() ident(site_path)operator(,) ident(copy_file) operator(\)) operator(\))
	reserved(end)
reserved(end)

comment(#!/usr/bin/env ruby)

ident(require) string<delimiter(')content(fox)delimiter(')>
reserved(begin)
  ident(require) string<delimiter(')content(opengl)delimiter(')>
reserved(rescue) constant(LoadError)
  ident(require) string<delimiter(')content(fox/missingdep)delimiter(')>
  constant(MSG) operator(=) string<delimiter(<<EOM)>string<content(
  Sorry, this example depends on the OpenGL extension. Please
  check the Ruby Application Archives for an appropriate
  download site.)delimiter(
EOM)>
  ident(missingDependency)operator(()constant(MSG)operator(\))
reserved(end)


ident(include) constant(Fox)
ident(include) constant(Math)

constant(Deg2Rad) operator(=) constant(Math)operator(::)constant(PI) operator(/) integer(180)

constant(D_MAX) operator(=) integer(6)
constant(SQUARE_SIZE) operator(=) float(2.0) operator(/) constant(D_MAX)
constant(SQUARE_DISTANCE) operator(=) float(4.0) operator(/) constant(D_MAX)
constant(AMPLITUDE) operator(=) constant(SQUARE_SIZE)
constant(LAMBDA) operator(=) constant(D_MAX)operator(.)ident(to_f) operator(/) integer(2)

reserved(class) class(GLTestWindow) operator(<) constant(FXMainWindow)

  comment(# How often our timer will fire (in milliseconds\))
  constant(TIMER_INTERVAL) operator(=) integer(500)

  comment(# Rotate the boxes when a timer message is received)
  reserved(def) method(onTimeout)operator(()ident(sender)operator(,) ident(sel)operator(,) ident(ptr)operator(\))
    instance_variable(@angle) operator(+=) float(10.0)
comment(#    @size = 0.5 + 0.2 * Math.cos(Deg2Rad * @angle\))
    ident(drawScene)operator(()operator(\))
    instance_variable(@timer) operator(=) ident(getApp)operator(()operator(\))operator(.)ident(addTimeout)operator(()constant(TIMER_INTERVAL)operator(,) ident(method)operator(()symbol(:onTimeout)operator(\))operator(\))
  reserved(end)

  comment(# Rotate the boxes when a chore message is received)
  reserved(def) method(onChore)operator(()ident(sender)operator(,) ident(sel)operator(,) ident(ptr)operator(\))
    instance_variable(@angle) operator(+=) float(10.0)
comment(#    @angle %= 360.0)
comment(#    @size = 0.5 + 0.2 * Math.cos(Deg2Rad * @angle\))
    ident(drawScene)operator(()operator(\))
    instance_variable(@chore) operator(=) ident(getApp)operator(()operator(\))operator(.)ident(addChore)operator(()ident(method)operator(()symbol(:onChore)operator(\))operator(\))
  reserved(end)

  comment(# Draw the GL scene)
  reserved(def) method(drawScene)
    ident(lightPosition) operator(=) operator([)float(15.0)operator(,) float(10.0)operator(,) float(5.0)operator(,) float(1.0)operator(])
    ident(lightAmbient)  operator(=) operator([) float(0.1)operator(,)  float(0.1)operator(,) float(0.1)operator(,) float(1.0)operator(])
    ident(lightDiffuse)  operator(=) operator([) float(0.9)operator(,)  float(0.9)operator(,) float(0.9)operator(,) float(1.0)operator(])
    ident(redMaterial)   operator(=) operator([) float(0.0)operator(,)  float(0.0)operator(,) float(1.0)operator(,) float(1.0)operator(])
    ident(blueMaterial)  operator(=) operator([) float(0.0)operator(,)  float(1.0)operator(,) float(0.0)operator(,) float(1.0)operator(])

    ident(width) operator(=) instance_variable(@glcanvas)operator(.)ident(width)operator(.)ident(to_f)
    ident(height) operator(=) instance_variable(@glcanvas)operator(.)ident(height)operator(.)ident(to_f)
    ident(aspect) operator(=) ident(width)operator(/)ident(height)

    comment(# Make context current)
    instance_variable(@glcanvas)operator(.)ident(makeCurrent)operator(()operator(\))

    constant(GL)operator(.)ident(Viewport)operator(()integer(0)operator(,) integer(0)operator(,) instance_variable(@glcanvas)operator(.)ident(width)operator(,) instance_variable(@glcanvas)operator(.)ident(height)operator(\))

    constant(GL)operator(.)ident(ClearColor)operator(()float(1.0)operator(/)integer(256)operator(,) float(0.0)operator(,) float(5.0)operator(/)integer(256)operator(,) float(1.0)operator(\))
    constant(GL)operator(.)ident(Clear)operator(()constant(GL)operator(::)constant(COLOR_BUFFER_BIT)operator(|)constant(GL)operator(::)constant(DEPTH_BUFFER_BIT)operator(\))
    constant(GL)operator(.)ident(Enable)operator(()constant(GL)operator(::)constant(DEPTH_TEST)operator(\))

    constant(GL)operator(.)ident(Disable)operator(()constant(GL)operator(::)constant(DITHER)operator(\))

    constant(GL)operator(.)ident(MatrixMode)operator(()constant(GL)operator(::)constant(PROJECTION)operator(\))
    constant(GL)operator(.)ident(LoadIdentity)operator(()operator(\))
    constant(GLU)operator(.)ident(Perspective)operator(()float(30.0)operator(,) ident(aspect)operator(,) float(1.0)operator(,) float(100.0)operator(\))

    constant(GL)operator(.)ident(MatrixMode)operator(()constant(GL)operator(::)constant(MODELVIEW)operator(\))
    constant(GL)operator(.)ident(LoadIdentity)operator(()operator(\))
    constant(GLU)operator(.)ident(LookAt)operator(()float(5.0)operator(,) float(10.0)operator(,) float(15.0)operator(,) float(0.0)operator(,) float(0.0)operator(,) float(0.0)operator(,) float(0.0)operator(,) float(1.0)operator(,) float(0.0)operator(\))

    constant(GL)operator(.)ident(ShadeModel)operator(()constant(GL)operator(::)constant(SMOOTH)operator(\))
    constant(GL)operator(.)ident(Light)operator(()constant(GL)operator(::)constant(LIGHT0)operator(,) constant(GL)operator(::)constant(POSITION)operator(,) ident(lightPosition)operator(\))
    constant(GL)operator(.)ident(Light)operator(()constant(GL)operator(::)constant(LIGHT0)operator(,) constant(GL)operator(::)constant(AMBIENT)operator(,) ident(lightAmbient)operator(\))
    constant(GL)operator(.)ident(Light)operator(()constant(GL)operator(::)constant(LIGHT0)operator(,) constant(GL)operator(::)constant(DIFFUSE)operator(,) ident(lightDiffuse)operator(\))
    constant(GL)operator(.)ident(Enable)operator(()constant(GL)operator(::)constant(LIGHT0)operator(\))
    constant(GL)operator(.)ident(Enable)operator(()constant(GL)operator(::)constant(LIGHTING)operator(\))

    constant(GL)operator(.)ident(Rotated)operator(()float(0.1)operator(*)instance_variable(@angle)operator(,) float(0.0)operator(,) float(1.0)operator(,) float(0.0)operator(\))
    reserved(for) ident(x) reserved(in) operator(-)constant(D_MAX)operator(..)constant(D_MAX)
      reserved(for) ident(y) reserved(in) operator(-)constant(D_MAX)operator(..)constant(D_MAX)
        ident(h1) operator(=) operator(()ident(x) operator(+) ident(y) operator(-) integer(2)operator(\))operator(.)ident(abs)
        ident(h2) operator(=) operator(()ident(y) operator(-) ident(x) operator(+) integer(1)operator(\))operator(.)ident(abs)
        constant(GL)operator(.)constant(PushMatrix)
        ident(c) operator(=) operator([)integer(1)operator(,) integer(0)operator(,) integer(0)operator(,) integer(1)operator(])
        constant(GL)operator(.)ident(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(AMBIENT)operator(,) ident(c)operator(\))
        constant(GL)operator(.)ident(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(DIFFUSE)operator(,) ident(c)operator(\))

        constant(GL)operator(.)ident(Translated)operator(()
          ident(y) operator(*) constant(SQUARE_DISTANCE)operator(,)
          constant(AMPLITUDE) operator(*) ident(h1)operator(,)
          ident(x) operator(*) constant(SQUARE_DISTANCE)
        operator(\))

        constant(GL)operator(.)ident(Begin)operator(()constant(GL)operator(::)constant(TRIANGLE_STRIP)operator(\))
          constant(GL)operator(.)ident(Normal)operator(()float(1.0)operator(,) float(0.0)operator(,) float(0.0)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
        constant(GL)operator(.)constant(End)

        constant(GL)operator(.)constant(PopMatrix)

        constant(GL)operator(.)constant(PushMatrix)
        ident(c) operator(=) operator([)integer(0)operator(,) integer(0)operator(,) integer(1)operator(,) integer(1)operator(])
        constant(GL)operator(.)ident(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(AMBIENT)operator(,) ident(c)operator(\))
        constant(GL)operator(.)ident(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(DIFFUSE)operator(,) ident(c)operator(\))

        constant(GL)operator(.)ident(Translated)operator(()
          ident(y) operator(*) constant(SQUARE_DISTANCE)operator(,)
          constant(AMPLITUDE) operator(*) ident(h2)operator(,)
          ident(x) operator(*) constant(SQUARE_DISTANCE)
        operator(\))

        constant(GL)operator(.)ident(Begin)operator(()constant(GL)operator(::)constant(TRIANGLE_STRIP)operator(\))
          constant(GL)operator(.)ident(Normal)operator(()float(1.0)operator(,) float(0.0)operator(,) float(0.0)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
        constant(GL)operator(.)constant(End)

        constant(GL)operator(.)constant(PopMatrix)

        constant(GL)operator(.)constant(PushMatrix)
        ident(c) operator(=) operator([)float(0.0) operator(+) operator(()ident(x)operator(/)float(10.0)operator(\))operator(,) float(0.0) operator(+) operator(()ident(y)operator(/)float(10.0)operator(\))operator(,) integer(0)operator(,) integer(1)operator(])
        constant(GL)operator(.)ident(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(AMBIENT)operator(,) ident(c)operator(\))
        constant(GL)operator(.)ident(Material)operator(()constant(GL)operator(::)constant(FRONT)operator(,) constant(GL)operator(::)constant(DIFFUSE)operator(,) ident(c)operator(\))

        constant(GL)operator(.)ident(Translated)operator(()
          ident(y) operator(*) constant(SQUARE_DISTANCE)operator(,)
          integer(0)operator(,)
          ident(x) operator(*) constant(SQUARE_DISTANCE)
        operator(\))

        constant(GL)operator(.)ident(Begin)operator(()constant(GL)operator(::)constant(TRIANGLE_STRIP)operator(\))
          constant(GL)operator(.)ident(Normal)operator(()float(1.0)operator(,) float(0.0)operator(,) float(0.0)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(-)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(-)constant(SQUARE_SIZE)operator(\))
          constant(GL)operator(.)ident(Vertex)operator(()operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(,) operator(+)constant(SQUARE_SIZE)operator(\))
        constant(GL)operator(.)constant(End)

        constant(GL)operator(.)constant(PopMatrix)
      reserved(end)
    reserved(end)

    comment(# Swap if it is double-buffered)
    reserved(if) instance_variable(@glvisual)operator(.)ident(isDoubleBuffer)
      instance_variable(@glcanvas)operator(.)ident(swapBuffers)
    reserved(end)

    comment(# Make context non-current)
    instance_variable(@glcanvas)operator(.)ident(makeNonCurrent)
  reserved(end)

  reserved(def) method(initialize)operator(()ident(app)operator(\))
    comment(# Invoke the base class initializer)
    reserved(super)operator(()ident(app)operator(,) string<delimiter(")content(OpenGL Test Application)delimiter(")>operator(,) pre_constant(nil)operator(,) pre_constant(nil)operator(,) constant(DECOR_ALL)operator(,) integer(0)operator(,) integer(0)operator(,) integer(1024)operator(,) integer(768)operator(\))

    comment(# Construct the main window elements)
    ident(frame) operator(=) constant(FXHorizontalFrame)operator(.)ident(new)operator(()pre_constant(self)operator(,) constant(LAYOUT_SIDE_TOP)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FILL_Y)operator(\))
    ident(frame)operator(.)ident(padLeft)operator(,) ident(frame)operator(.)ident(padRight) operator(=) integer(0)operator(,) integer(0)
    ident(frame)operator(.)ident(padTop)operator(,) ident(frame)operator(.)ident(padBottom) operator(=) integer(0)operator(,) integer(0)

    comment(# Left pane to contain the glcanvas)
    ident(glcanvasFrame) operator(=) constant(FXVerticalFrame)operator(.)ident(new)operator(()ident(frame)operator(,)
      constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FILL_Y)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(glcanvasFrame)operator(.)ident(padLeft)operator(,) ident(glcanvasFrame)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(glcanvasFrame)operator(.)ident(padTop)operator(,) ident(glcanvasFrame)operator(.)ident(padBottom) operator(=) integer(10)operator(,) integer(10)

    comment(# Label above the glcanvas)
    constant(FXLabel)operator(.)ident(new)operator(()ident(glcanvasFrame)operator(,) string<delimiter(")content(OpenGL Canvas Frame)delimiter(")>operator(,) pre_constant(nil)operator(,)
      constant(JUSTIFY_CENTER_X)operator(|)constant(LAYOUT_FILL_X)operator(\))

    comment(# Horizontal divider line)
    constant(FXHorizontalSeparator)operator(.)ident(new)operator(()ident(glcanvasFrame)operator(,) constant(SEPARATOR_GROOVE)operator(|)constant(LAYOUT_FILL_X)operator(\))

    comment(# Drawing glcanvas)
    ident(glpanel) operator(=) constant(FXVerticalFrame)operator(.)ident(new)operator(()ident(glcanvasFrame)operator(,) operator(()constant(FRAME_SUNKEN)operator(|)constant(FRAME_THICK)operator(|)
      constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FILL_Y)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))operator(\))
    ident(glpanel)operator(.)ident(padLeft)operator(,) ident(glpanel)operator(.)ident(padRight) operator(=) integer(0)operator(,) integer(0)
    ident(glpanel)operator(.)ident(padTop)operator(,) ident(glpanel)operator(.)ident(padBottom) operator(=) integer(0)operator(,) integer(0)

    comment(# A visual to draw OpenGL)
    instance_variable(@glvisual) operator(=) constant(FXGLVisual)operator(.)ident(new)operator(()ident(getApp)operator(()operator(\))operator(,) constant(VISUAL_DOUBLEBUFFER)operator(\))

    comment(# Drawing glcanvas)
    instance_variable(@glcanvas) operator(=) constant(FXGLCanvas)operator(.)ident(new)operator(()ident(glpanel)operator(,) instance_variable(@glvisual)operator(,) pre_constant(nil)operator(,) integer(0)operator(,)
      constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_FILL_Y)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    instance_variable(@glcanvas)operator(.)ident(connect)operator(()constant(SEL_PAINT)operator(\)) operator({)
      ident(drawScene)
    operator(})
    instance_variable(@glcanvas)operator(.)ident(connect)operator(()constant(SEL_CONFIGURE)operator(\)) operator({)
      reserved(if) instance_variable(@glcanvas)operator(.)ident(makeCurrent)
        constant(GL)operator(.)ident(Viewport)operator(()integer(0)operator(,) integer(0)operator(,) instance_variable(@glcanvas)operator(.)ident(width)operator(,) instance_variable(@glcanvas)operator(.)ident(height)operator(\))
        instance_variable(@glcanvas)operator(.)ident(makeNonCurrent)
      reserved(end)
    operator(})

    comment(# Right pane for the buttons)
    ident(buttonFrame) operator(=) constant(FXVerticalFrame)operator(.)ident(new)operator(()ident(frame)operator(,) constant(LAYOUT_FILL_Y)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(buttonFrame)operator(.)ident(padLeft)operator(,) ident(buttonFrame)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(buttonFrame)operator(.)ident(padTop)operator(,) ident(buttonFrame)operator(.)ident(padBottom) operator(=) integer(10)operator(,) integer(10)

    comment(# Label above the buttons)
    constant(FXLabel)operator(.)ident(new)operator(()ident(buttonFrame)operator(,) string<delimiter(")content(Button Frame)delimiter(")>operator(,) pre_constant(nil)operator(,)
      constant(JUSTIFY_CENTER_X)operator(|)constant(LAYOUT_FILL_X)operator(\))

    comment(# Horizontal divider line)
    constant(FXHorizontalSeparator)operator(.)ident(new)operator(()ident(buttonFrame)operator(,) constant(SEPARATOR_RIDGE)operator(|)constant(LAYOUT_FILL_X)operator(\))

    comment(# Spin according to timer)
    ident(spinTimerBtn) operator(=) constant(FXButton)operator(.)ident(new)operator(()ident(buttonFrame)operator(,)
      string<delimiter(")content(Spin &Timer)char(\\t)content(Spin using interval timers)char(\\n)content(Note the app
      blocks until the interal has elapsed...)delimiter(")>operator(,) pre_constant(nil)operator(,)
      pre_constant(nil)operator(,) integer(0)operator(,) constant(FRAME_THICK)operator(|)constant(FRAME_RAISED)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(spinTimerBtn)operator(.)ident(padLeft)operator(,) ident(spinTimerBtn)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(spinTimerBtn)operator(.)ident(padTop)operator(,) ident(spinTimerBtn)operator(.)ident(padBottom) operator(=) integer(5)operator(,) integer(5)
    ident(spinTimerBtn)operator(.)ident(connect)operator(()constant(SEL_COMMAND)operator(\)) operator({)
      instance_variable(@spinning) operator(=) pre_constant(true)
      instance_variable(@timer) operator(=) ident(getApp)operator(()operator(\))operator(.)ident(addTimeout)operator(()constant(TIMER_INTERVAL)operator(,) ident(method)operator(()symbol(:onTimeout)operator(\))operator(\))
    operator(})
    ident(spinTimerBtn)operator(.)ident(connect)operator(()constant(SEL_UPDATE)operator(\)) operator({) operator(|)ident(sender)operator(,) ident(sel)operator(,) ident(ptr)operator(|)
      instance_variable(@spinning) operator(?) ident(sender)operator(.)ident(disable) operator(:) ident(sender)operator(.)ident(enable)
    operator(})

    comment(# Spin according to chore)
    ident(spinChoreBtn) operator(=) constant(FXButton)operator(.)ident(new)operator(()ident(buttonFrame)operator(,)
      string<delimiter(")content(Spin &Chore)char(\\t)content(Spin as fast as possible using chores)char(\\n)content(Note even though the
      app is very responsive, it never blocks;)char(\\n)content(there is always something to
      do...)delimiter(")>operator(,) pre_constant(nil)operator(,)
      pre_constant(nil)operator(,) integer(0)operator(,) constant(FRAME_THICK)operator(|)constant(FRAME_RAISED)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(spinChoreBtn)operator(.)ident(padLeft)operator(,) ident(spinChoreBtn)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(spinChoreBtn)operator(.)ident(padTop)operator(,) ident(spinChoreBtn)operator(.)ident(padBottom) operator(=) integer(5)operator(,) integer(5)
    ident(spinChoreBtn)operator(.)ident(connect)operator(()constant(SEL_COMMAND)operator(\)) operator({)
      instance_variable(@spinning) operator(=) pre_constant(true)
      instance_variable(@chore) operator(=) ident(getApp)operator(()operator(\))operator(.)ident(addChore)operator(()ident(method)operator(()symbol(:onChore)operator(\))operator(\))
    operator(})
    ident(spinChoreBtn)operator(.)ident(connect)operator(()constant(SEL_UPDATE)operator(\)) operator({) operator(|)ident(sender)operator(,) ident(sel)operator(,) ident(ptr)operator(|)
      instance_variable(@spinning) operator(?) ident(sender)operator(.)ident(disable) operator(:) ident(sender)operator(.)ident(enable)
    operator(})

    comment(# Stop spinning)
    ident(stopBtn) operator(=) constant(FXButton)operator(.)ident(new)operator(()ident(buttonFrame)operator(,)
      string<delimiter(")content(&Stop Spin)char(\\t)content(Stop this mad spinning, I'm getting dizzy)delimiter(")>operator(,) pre_constant(nil)operator(,)
      pre_constant(nil)operator(,) integer(0)operator(,) constant(FRAME_THICK)operator(|)constant(FRAME_RAISED)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(stopBtn)operator(.)ident(padLeft)operator(,) ident(stopBtn)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(stopBtn)operator(.)ident(padTop)operator(,) ident(stopBtn)operator(.)ident(padBottom) operator(=) integer(5)operator(,) integer(5)
    ident(stopBtn)operator(.)ident(connect)operator(()constant(SEL_COMMAND)operator(\)) operator({)
      instance_variable(@spinning) operator(=) pre_constant(false)
      reserved(if) instance_variable(@timer)
        ident(getApp)operator(()operator(\))operator(.)ident(removeTimeout)operator(()instance_variable(@timer)operator(\))
        instance_variable(@timer) operator(=) pre_constant(nil)
      reserved(end)
      reserved(if) instance_variable(@chore)
        ident(getApp)operator(()operator(\))operator(.)ident(removeChore)operator(()instance_variable(@chore)operator(\))
        instance_variable(@chore) operator(=) pre_constant(nil)
      reserved(end)
    operator(})
    ident(stopBtn)operator(.)ident(connect)operator(()constant(SEL_UPDATE)operator(\)) operator({) operator(|)ident(sender)operator(,) ident(sel)operator(,) ident(ptr)operator(|)
      instance_variable(@spinning) operator(?) ident(sender)operator(.)ident(enable) operator(:) ident(sender)operator(.)ident(disable)
    operator(})

    comment(# Exit button)
    ident(exitBtn) operator(=) constant(FXButton)operator(.)ident(new)operator(()ident(buttonFrame)operator(,) string<delimiter(")content(&Exit)char(\\t)content(Exit the application)delimiter(")>operator(,) pre_constant(nil)operator(,)
      ident(getApp)operator(()operator(\))operator(,) constant(FXApp)operator(::)constant(ID_QUIT)operator(,)
      constant(FRAME_THICK)operator(|)constant(FRAME_RAISED)operator(|)constant(LAYOUT_FILL_X)operator(|)constant(LAYOUT_TOP)operator(|)constant(LAYOUT_LEFT)operator(\))
    ident(exitBtn)operator(.)ident(padLeft)operator(,) ident(exitBtn)operator(.)ident(padRight) operator(=) integer(10)operator(,) integer(10)
    ident(exitBtn)operator(.)ident(padTop)operator(,) ident(exitBtn)operator(.)ident(padBottom) operator(=) integer(5)operator(,) integer(5)

    comment(# Make a tooltip)
    constant(FXTooltip)operator(.)ident(new)operator(()ident(getApp)operator(()operator(\))operator(\))

    comment(# Initialize private variables)
    instance_variable(@spinning) operator(=) pre_constant(false)
    instance_variable(@chore) operator(=) pre_constant(nil)
    instance_variable(@timer) operator(=) pre_constant(nil)
    instance_variable(@angle) operator(=) float(0.0)
    instance_variable(@size) operator(=) float(0.5)
  reserved(end)

  comment(# Create and initialize)
  reserved(def) method(create)
    reserved(super)
    ident(show)operator(()constant(PLACEMENT_SCREEN)operator(\))
  reserved(end)
reserved(end)

reserved(if) pre_constant(__FILE__) operator(==) global_variable($0)
  comment(# Construct the application)
  ident(application) operator(=) constant(FXApp)operator(.)ident(new)operator(()string<delimiter(")content(GLTest)delimiter(")>operator(,) string<delimiter(")content(FoxTest)delimiter(")>operator(\))

  comment(# To ensure that the chores-based spin will run as fast as possible,)
  comment(# we can disable the chore in FXRuby's event loop that tries to schedule)
  comment(# other threads. This is OK for this program because there aren't any)
  comment(# other Ruby threads running.)

  comment(#application.disableThreads)

  comment(# Construct the main window)
  constant(GLTestWindow)operator(.)ident(new)operator(()ident(application)operator(\))

  comment(# Create the app's windows)
  ident(application)operator(.)ident(create)

  comment(# Run the application)
  ident(application)operator(.)ident(run)
reserved(end)

reserved(class) class(Facelet)
  ident(attr_accessor) symbol(:color)
  reserved(def) method(initialize)operator(()ident(color)operator(\))
    instance_variable(@color) operator(=) ident(color)
  reserved(end)

  reserved(def) method(to_s)
    instance_variable(@color)
  reserved(end)
reserved(end)

reserved(class) class(Edge)
  ident(attr_accessor) symbol(:facelets)operator(,) symbol(:colors)

  reserved(def) method(initialize)operator(()ident(facelets)operator(\))
    instance_variable(@facelets) operator(=) ident(facelets)
    instance_variable(@colors) operator(=) instance_variable(@facelets)operator(.)ident(map) operator({) operator(|)ident(fl)operator(|) ident(fl)operator(.)ident(color) operator(})
  reserved(end)

  reserved(def) method(apply)operator(()ident(edge)operator(\))
    instance_variable(@facelets)operator(.)ident(each_with_index) operator({) operator(|)ident(fl)operator(,) ident(i)operator(|)
      ident(fl)operator(.)ident(color) operator(=) ident(edge)operator(.)ident(colors)operator([)ident(i)operator(])
    operator(})
  reserved(end)

  reserved(def) method(inspect)
    string<delimiter(")char(\\n)content(%s %s)char(\\n)content(%s %s %s)delimiter(")> operator(%) ident(facelets)
  reserved(end)
reserved(end)

reserved(class) class(Side)
  ident(attr_reader) symbol(:num)operator(,) symbol(:facelets)
  ident(attr_accessor) symbol(:sides)

  reserved(def) method(initialize)operator(()ident(num)operator(\))
    instance_variable(@num) operator(=) ident(num)
    instance_variable(@sides) operator(=) operator([)operator(])
    instance_variable(@facelets) operator(=) operator([)operator(])
    instance_variable(@fl_by_side) operator(=) operator({)operator(})
  reserved(end)

  comment(# facelets & sides)
  comment(#     0)
  comment(#   0 1 2)
  comment(# 3 3 4 5 1)
  comment(#   6 7 8)
  comment(#     2)

  reserved(def) method(facelets=)operator(()ident(facelets)operator(\))
    instance_variable(@facelets) operator(=) ident(facelets)operator(.)ident(map) operator({) operator(|)ident(c)operator(|) constant(Facelet)operator(.)ident(new)operator(()ident(c)operator(\)) operator(})
    ident(init_facelet) integer(0)operator(,) integer(3)operator(,)integer(0)
    ident(init_facelet) integer(1)operator(,) integer(0)
    ident(init_facelet) integer(2)operator(,) integer(0)operator(,)integer(1)
    ident(init_facelet) integer(3)operator(,) integer(3)
    ident(init_facelet) integer(5)operator(,) integer(1)
    ident(init_facelet) integer(6)operator(,) integer(2)operator(,)integer(3)
    ident(init_facelet) integer(7)operator(,) integer(2)
    ident(init_facelet) integer(8)operator(,) integer(1)operator(,)integer(2)
  reserved(end)

  reserved(def) method(<=>)operator(()ident(side)operator(\))
    pre_constant(self)operator(.)ident(num) operator(<=>) ident(side)operator(.)ident(num)
  reserved(end)

  reserved(def) method(init_facelet)operator(()ident(pos)operator(,) operator(*)ident(side_nums)operator(\))
    ident(sides) operator(=) ident(side_nums)operator(.)ident(map) operator({) operator(|)ident(num)operator(|) instance_variable(@sides)operator([)ident(num)operator(]) operator(})operator(.)ident(sort)
    instance_variable(@fl_by_side)operator([)ident(sides)operator(]) operator(=) ident(pos)
  reserved(end)

  reserved(def) method([]=)operator(()ident(color)operator(,) operator(*)ident(sides)operator(\))
    instance_variable(@facelets)operator([)instance_variable(@fl_by_side)operator([)ident(sides)operator(.)ident(sort)operator(])operator(])operator(.)ident(color) operator(=) ident(color)
  reserved(end)

  reserved(def) method(values_at)operator(()operator(*)ident(sides)operator(\))
    ident(sides)operator(.)ident(map) operator({) operator(|)ident(sides)operator(|) instance_variable(@facelets)operator([)instance_variable(@fl_by_side)operator([)ident(sides)operator(.)ident(sort)operator(])operator(]) operator(})
  reserved(end)

  reserved(def) method(inspect)operator(()ident(range)operator(=)pre_constant(nil)operator(\))
    reserved(if) ident(range)
      instance_variable(@facelets)operator(.)ident(values_at)operator(()operator(*)operator(()ident(range)operator(.)ident(to_a)operator(\))operator(\))operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))
    reserved(else)
      string<delimiter(<<-EOS)>operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\d)delimiter(/)>operator(\)) operator({) operator(|)ident(num)operator(|) instance_variable(@facelets)operator([)ident(num)operator(.)ident(to_i)operator(]) operator(})operator(.)ident(gsub)operator(()regexp<delimiter(/)content([ABCD])delimiter(/)>operator(\)) operator({) operator(|)ident(side)operator(|) instance_variable(@sides)operator([)ident(side)operator([)integer(0)operator(])operator(-)integer(?A)operator(])operator(.)ident(num)operator(.)ident(to_s) operator(})string<content(
           A
         0 1 2
       D 3 4 5 B
         6 7 8
           C)delimiter(
      EOS)>
    reserved(end)
  reserved(end)

  reserved(def) method(get_edge)operator(()ident(side)operator(\))
    ident(trio) operator(=) operator(()integer(-1)operator(..)integer(1)operator(\))operator(.)ident(map) operator({) operator(|)ident(x)operator(|) operator(()ident(side) operator(+) ident(x)operator(\)) operator(%) integer(4) operator(})
    ident(prev_side)operator(,) ident(this_side)operator(,) ident(next_side) operator(=) instance_variable(@sides)operator(.)ident(values_at)operator(()operator(*)ident(trio)operator(\))
    ident(e) operator(=) constant(Edge)operator(.)ident(new)operator(()
      pre_constant(self)     operator(.)ident(values_at)operator(()                    operator([)ident(this_side)operator(])operator(,) operator([)ident(this_side)operator(,) ident(next_side)operator(]) operator(\)) operator(+)
      ident(this_side)operator(.)ident(values_at)operator(() operator([)pre_constant(self)operator(,) ident(prev_side)operator(])operator(,) operator([)pre_constant(self)     operator(])operator(,) operator([)pre_constant(self)operator(,)      ident(next_side)operator(]) operator(\))
    operator(\))
    comment(#puts 'Edge created for side %d: ' % side + e.inspect)
    ident(e)
  reserved(end)

  reserved(def) method(turn)operator(()ident(dir)operator(\))
    comment(#p 'turn side %d in %d' % [num, dir])
    ident(edges) operator(=) operator(()integer(0)operator(..)integer(3)operator(\))operator(.)ident(map) operator({) operator(|)ident(n)operator(|) ident(get_edge) ident(n) operator(})
    reserved(for) ident(i) reserved(in) integer(0)operator(..)integer(3)
      ident(edges)operator([)ident(i)operator(])operator(.)ident(apply) ident(edges)operator([)operator(()ident(i)operator(-)ident(dir)operator(\)) operator(%) integer(4)operator(])
    reserved(end)
  reserved(end)
reserved(end)

reserved(class) class(Cube)
  reserved(def) method(initialize)
    instance_variable(@sides) operator(=) operator([)operator(])
    string<delimiter(%w()content(left front right back top bottom)delimiter(\))>operator(.)ident(each_with_index) operator({) operator(|)ident(side)operator(,) ident(i)operator(|)
      ident(eval)operator(()string<delimiter(")content(@sides[)inline<inline_delimiter(#{)ident(i)inline_delimiter(})>content(] = @)inline<inline_delimiter(#{)ident(side)inline_delimiter(})>content( = Side.new()inline<inline_delimiter(#{)ident(i)inline_delimiter(})>content(\))delimiter(")>operator(\))
    operator(})
    instance_variable(@left)operator(.)ident(sides) operator(=) operator([)instance_variable(@top)operator(,) instance_variable(@front)operator(,) instance_variable(@bottom)operator(,) instance_variable(@back)operator(])
    instance_variable(@front)operator(.)ident(sides) operator(=) operator([)instance_variable(@top)operator(,) instance_variable(@right)operator(,) instance_variable(@bottom)operator(,) instance_variable(@left)operator(])
    instance_variable(@right)operator(.)ident(sides) operator(=) operator([)instance_variable(@top)operator(,) instance_variable(@back)operator(,) instance_variable(@bottom)operator(,) instance_variable(@front)operator(])
    instance_variable(@back)operator(.)ident(sides) operator(=) operator([)instance_variable(@top)operator(,) instance_variable(@left)operator(,) instance_variable(@bottom)operator(,) instance_variable(@right)operator(])
    instance_variable(@top)operator(.)ident(sides) operator(=) operator([)instance_variable(@back)operator(,) instance_variable(@right)operator(,) instance_variable(@front)operator(,) instance_variable(@left)operator(])
    instance_variable(@bottom)operator(.)ident(sides) operator(=) operator([)instance_variable(@front)operator(,) instance_variable(@right)operator(,) instance_variable(@back)operator(,) instance_variable(@left)operator(])
  reserved(end)

  reserved(def) method(read_facelets)operator(()ident(fs)operator(\))
    ident(pattern) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(<<-EOP)>operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\w)delimiter(/)>operator(,) string<delimiter(')content(\\w)delimiter(')>operator(\))operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(,) string<delimiter(')content(\\s)content(*)delimiter(')>operator(\))operator(\))string<content(
        (w w w\)
        (w w w\)
        (w w w\)
(r r r\) (g g g\) (b b b\) (o o o\)
(r r r\) (g g g\) (b b b\) (o o o\)
(r r r\) (g g g\) (b b b\) (o o o\)
        (y y y\)
        (y y y\)
        (y y y\))delimiter(
    EOP)>
    ident(md) operator(=) ident(pattern)operator(.)ident(match)operator(()ident(fs)operator(\))operator(.)ident(to_a)

    instance_variable(@top)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(1)operator(,)integer(2)operator(,)integer(3)operator(\))operator(\))
    instance_variable(@left)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(4)operator(,)integer(8)operator(,)integer(12)operator(\))operator(\))
    instance_variable(@front)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(5)operator(,)integer(9)operator(,)integer(13)operator(\))operator(\))
    instance_variable(@right)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(6)operator(,)integer(10)operator(,)integer(14)operator(\))operator(\))
    instance_variable(@back)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(7)operator(,)integer(11)operator(,)integer(15)operator(\))operator(\))
    instance_variable(@bottom)operator(.)ident(facelets) operator(=) ident(parse_facelets)operator(()ident(md)operator(.)ident(values_at)operator(()integer(16)operator(,)integer(17)operator(,)integer(18)operator(\))operator(\))
  reserved(end)

  reserved(def) method(turn)operator(()ident(side)operator(,) ident(dir)operator(\))
    comment(#p 'turn %d in %d' % [side, dir])
    instance_variable(@sides)operator([)ident(side)operator(])operator(.)ident(turn)operator(()ident(dir)operator(\))
    comment(#puts inspect)
  reserved(end)

  reserved(def) method(inspect)
    string<delimiter(<<-EOF)>operator(.)ident(gsub)operator(()regexp<delimiter(/)content(()char(\\d)content(\):()char(\\d)content(\)-()char(\\d)content(\))delimiter(/)>operator(\)) operator({) instance_variable(@sides)operator([)global_variable($1)operator(.)ident(to_i)operator(])operator(.)ident(inspect)operator(()constant(Range)operator(.)ident(new)operator(()global_variable($2)operator(.)ident(to_i)operator(,) global_variable($3)operator(.)ident(to_i)operator(\))operator(\)) operator(})string<content(
      4:0-2
      4:3-5
      4:6-8
0:0-2 1:0-2 2:0-2 3:0-2
0:3-5 1:3-5 2:3-5 3:3-5
0:6-8 1:6-8 2:6-8 3:6-8
      5:0-2
      5:3-5
      5:6-8)delimiter(
    EOF)>
  reserved(end)

ident(private)
  reserved(def) method(parse_facelets)operator(()ident(rows)operator(\))
    ident(rows)operator(.)ident(join)operator(.)ident(delete)operator(()string<delimiter(')content( )delimiter(')>operator(\))operator(.)ident(split)operator(()regexp<delimiter(/)delimiter(/)>operator(\))
  reserved(end)
reserved(end)

comment(#$stdin = DATA)

ident(gets)operator(.)ident(to_i)operator(.)ident(times) reserved(do) operator(|)ident(i)operator(|)
  ident(puts) string<delimiter(")content(Scenario #)inline<inline_delimiter(#{)ident(i)operator(+)integer(1)inline_delimiter(})>content(:)delimiter(")>
  ident(fs) operator(=) string<delimiter(')delimiter(')>
  integer(9)operator(.)ident(times) operator({) ident(fs) operator(<<) ident(gets) operator(})
  ident(cube) operator(=) constant(Cube)operator(.)ident(new)
  ident(cube)operator(.)ident(read_facelets) ident(fs)
  ident(gets)operator(.)ident(to_i)operator(.)ident(times) reserved(do) operator(|)ident(t)operator(|)
    ident(side)operator(,) ident(dir) operator(=) ident(gets)operator(.)ident(split)operator(.)ident(map) operator({)operator(|)ident(s)operator(|) ident(s)operator(.)ident(to_i)operator(})
    ident(cube)operator(.)ident(turn)operator(()ident(side)operator(,) ident(dir)operator(\))
  reserved(end)
  ident(puts) ident(cube)operator(.)ident(inspect)
  ident(puts)
reserved(end)

comment(# 2004 by murphy <korny@cYcnus.de>)
comment(# GPL)
reserved(class) class(Scenario)
	reserved(class) class(TimePoint)
		ident(attr_reader) symbol(:data)
		reserved(def) method(initialize) operator(*)ident(data)
			instance_variable(@data) operator(=) ident(data)
		reserved(end)

		reserved(def) method([]) ident(i)
			instance_variable(@data)operator([)ident(i)operator(]) reserved(or) integer(0)
		reserved(end)

		ident(include) constant(Comparable)
		reserved(def) method(<=>) ident(tp)
			ident(r) operator(=) integer(0)
			operator([)instance_variable(@data)operator(.)ident(size)operator(,) ident(tp)operator(.)ident(data)operator(.)ident(size)operator(])operator(.)ident(max)operator(.)ident(times) reserved(do) operator(|)ident(i)operator(|)
				ident(r) operator(=) pre_constant(self)operator([)ident(i)operator(]) operator(<=>) ident(tp)operator([)ident(i)operator(])
				reserved(return) ident(r) reserved(if) ident(r)operator(.)ident(nonzero?)
			reserved(end)
			integer(0)
		reserved(end)

		reserved(def) method(-) ident(tp)
			ident(r) operator(=) operator([)operator(])
			operator([)instance_variable(@data)operator(.)ident(size)operator(,) ident(tp)operator(.)ident(data)operator(.)ident(size)operator(])operator(.)ident(max)operator(.)ident(times) reserved(do) operator(|)ident(i)operator(|)
				ident(r) operator(<<) pre_constant(self)operator([)ident(i)operator(]) operator(-) ident(tp)operator([)ident(i)operator(])
			reserved(end)
			ident(r)
		reserved(end)

		reserved(def) method(inspect)
			comment(# 01/01/1800 00:00:00)
			string<delimiter(')content(%02d/%02d/%04d %02d:%02d:%02d)delimiter(')> operator(%) instance_variable(@data)operator(.)ident(values_at)operator(()integer(1)operator(,) integer(2)operator(,) integer(0)operator(,) integer(3)operator(,) integer(4)operator(,) integer(5)operator(\))
		reserved(end)
	reserved(end)

	constant(ONE_HOUR) operator(=) constant(TimePoint)operator(.)ident(new) integer(0)operator(,) integer(0)operator(,) integer(0)operator(,) integer(1)operator(,) integer(0)operator(,) integer(0)

	constant(APPOINTMENT_PATTERN) operator(=) regexp<delimiter(/)content(
		( )char(\\d)content({4} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content(
		( )char(\\d)content({4} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \) )char(\\s)content( ( )char(\\d)content({2} \)
	)delimiter(/)modifier(x)>

	reserved(def) method(initialize) ident(io)
		instance_variable(@team_size) operator(=) ident(io)operator(.)ident(gets)operator(.)ident(to_i)
		instance_variable(@data) operator(=) operator([) operator([)constant(TimePoint)operator(.)ident(new)operator(()integer(1800)operator(,) integer(01)operator(,) integer(01)operator(,) integer(00)operator(,) integer(00)operator(,) integer(00)operator(\))operator(,) instance_variable(@team_size)operator(]) operator(])
		instance_variable(@team_size)operator(.)ident(times) reserved(do)  comment(# each team member)
			ident(io)operator(.)ident(gets)operator(.)ident(to_i)operator(.)ident(times) reserved(do)  comment(# each appointment)
				ident(m) operator(=) constant(APPOINTMENT_PATTERN)operator(.)ident(match) ident(io)operator(.)ident(gets)
				instance_variable(@data) operator(<<) operator([)constant(TimePoint)operator(.)ident(new)operator(()operator(*)ident(m)operator(.)ident(captures)operator([)integer(0)operator(,)integer(6)operator(])operator(.)ident(map) operator({) operator(|)ident(x)operator(|) ident(x)operator(.)ident(to_i) operator(})operator(\))operator(,) integer(-1)operator(])
				instance_variable(@data) operator(<<) operator([)constant(TimePoint)operator(.)ident(new)operator(()operator(*)ident(m)operator(.)ident(captures)operator([)integer(6)operator(,)integer(6)operator(])operator(.)ident(map) operator({) operator(|)ident(x)operator(|) ident(x)operator(.)ident(to_i) operator(})operator(\))operator(,) integer(+1)operator(])
			reserved(end)
		reserved(end)
		instance_variable(@data) operator(<<) operator([)constant(TimePoint)operator(.)ident(new)operator(()integer(2200)operator(,) integer(01)operator(,) integer(01)operator(,) integer(00)operator(,) integer(00)operator(,) integer(00)operator(\))operator(,) operator(-)instance_variable(@team_size)operator(])
	reserved(end)

	reserved(def) method(print_time_plan)
		ident(n) operator(=) integer(0)
		ident(appointment) operator(=) pre_constant(nil)
		ident(no_appointment) operator(=) pre_constant(true)
		instance_variable(@data)operator(.)ident(sort_by) operator({) operator(|)ident(x)operator(|) ident(x)operator([)integer(0)operator(]) operator(})operator(.)ident(each) reserved(do) operator(|)ident(x)operator(|)
			ident(tp)operator(,) ident(action) operator(=) operator(*)ident(x)
			ident(n) operator(+=) ident(action)
			comment(# at any time during the meeting, at least two team members need to be there)
			comment(# and at most one team member is allowed to be absent)
			reserved(if) ident(n) operator(>)operator(=) integer(2) reserved(and) operator(()instance_variable(@team_size) operator(-) ident(n)operator(\)) operator(<=) integer(1)
				ident(appointment) operator(||=) ident(tp)
			reserved(else)
				reserved(if) ident(appointment)
					comment(# the meeting should be at least one hour in length)
					reserved(if) constant(TimePoint)operator(.)ident(new)operator(()operator(*)operator(()ident(tp) operator(-) ident(appointment)operator(\))operator(\)) operator(>)operator(=) constant(ONE_HOUR)
						ident(puts) string<delimiter(')content(appointment possible from %p to %p)delimiter(')> operator(%) operator([)ident(appointment)operator(,) ident(tp)operator(])
						ident(no_appointment) operator(=) pre_constant(false)
					reserved(end)
					ident(appointment) operator(=) pre_constant(false)
				reserved(end)
			reserved(end)
		reserved(end)
		ident(puts) string<delimiter(')content(no appointment possible)delimiter(')> reserved(if) ident(no_appointment)
	reserved(end)
reserved(end)

comment(# read the data)
pre_constant(DATA)operator(.)ident(gets)operator(.)ident(to_i)operator(.)ident(times) reserved(do) operator(|)ident(si)operator(|) comment(# each scenario)
	ident(puts) string<delimiter(')content(Scenario #%d:)delimiter(')> operator(%) operator(()ident(si) operator(+) integer(1)operator(\))
	ident(sc) operator(=) constant(Scenario)operator(.)ident(new) pre_constant(DATA)
	ident(sc)operator(.)ident(print_time_plan)
	ident(puts)
reserved(end)

comment(#__END__)
integer(2)
integer(3)
integer(3)
integer(2002) integer(06) integer(28) integer(15) integer(00) integer(00) integer(2002) integer(06) integer(28) integer(18) integer(00) integer(00) constant(TUD) constant(Contest) constant(Practice) constant(Session)
integer(2002) integer(06) integer(29) integer(10) integer(00) integer(00) integer(2002) integer(06) integer(29) integer(15) integer(00) integer(00) constant(TUD) constant(Contest)
integer(2002) integer(11) integer(15) integer(15) integer(00) integer(00) integer(2002) integer(11) integer(17) integer(23) integer(00) integer(00) constant(NWERC) constant(Delft)
integer(4)
integer(2002) integer(06) integer(25) integer(13) integer(30) integer(00) integer(2002) integer(06) integer(25) integer(15) integer(30) integer(00) constant(FIFA) constant(World) constant(Cup) constant(Semifinal) constant(I)
integer(2002) integer(06) integer(26) integer(13) integer(30) integer(00) integer(2002) integer(06) integer(26) integer(15) integer(30) integer(00) constant(FIFA) constant(World) constant(Cup) constant(Semifinal) constant(II)
integer(2002) integer(06) integer(29) integer(13) integer(00) integer(00) integer(2002) integer(06) integer(29) integer(15) integer(00) integer(00) constant(FIFA) constant(World) constant(Cup) constant(Third) constant(Place)
integer(2002) integer(06) integer(30) integer(13) integer(00) integer(00) integer(2002) integer(06) integer(30) integer(15) integer(00) integer(00) constant(FIFA) constant(World) constant(Cup) constant(Final)
integer(1)
integer(2002) integer(06) integer(01) integer(00) integer(00) integer(00) integer(2002) integer(06) integer(29) integer(18) integer(00) integer(00) constant(Preparation) ident(of) constant(Problem) constant(Set)
integer(2)
integer(1)
integer(1800) integer(01) integer(01) integer(00) integer(00) integer(00) integer(2200) integer(01) integer(01) integer(00) integer(00) integer(00) constant(Solving) constant(Problem) integer(8)
integer(0)

ident(require) string<delimiter(')content(token_consts)delimiter(')>
ident(require) string<delimiter(')content(symbol)delimiter(')>
ident(require) string<delimiter(')content(ctype)delimiter(')>
ident(require) string<delimiter(')content(error)delimiter(')>

reserved(class) class(Fixnum)
	comment(# Treat char as a digit and return it's value as Fixnum.)
	comment(# Returns nonsense for non-digits.)
	comment(# Examples:)
	comment(# <code>)
	comment(# RUBY_VERSION[0].digit == '1.8.2'[0].digit == 1)
	comment(# </code>)
	comment(#)
	comment(# <code>)
	comment(# ?6.digit == 6)
	comment(# </code>)
	comment(#)
	comment(# <code>)
	comment(# ?A.digit == 17)
	comment(# </code>)
	reserved(def) method(digit)
		pre_constant(self) operator(-) integer(?0)
	reserved(end)
reserved(end)

comment(##)
comment(# Stellt einen einfachen Scanner fr die lexikalische Analyse der Sprache Pas-0 dar.)
comment(#)
comment(# @author Andreas Kunert)
comment(# Ruby port by murphy)
reserved(class) class(Scanner)

	ident(include) constant(TokenConsts)

	ident(attr_reader) symbol(:line)operator(,) symbol(:pos)

	comment(# To allow Scanner.new without parameters.)
	constant(DUMMY_INPUT) operator(=) string<delimiter(')content(dummy file)delimiter(')>
	reserved(def) constant(DUMMY_INPUT)operator(.)ident(getc)
		pre_constant(nil)
	reserved(end)

	comment(##)
	comment(# Erzeugt einen Scanner, der als Eingabe das bergebene IO benutzt.)
	reserved(def) method(initialize) ident(input) operator(=) constant(DUMMY_INPUT)
		instance_variable(@line) operator(=) integer(1)
		instance_variable(@pos) operator(=) integer(0)

		reserved(begin)
			instance_variable(@input) operator(=) ident(input)
			instance_variable(@next_char) operator(=) instance_variable(@input)operator(.)ident(getc)
		reserved(rescue) constant(IOError)  comment(# TODO show the reason!)
			constant(Error)operator(.)ident(ioError)
			ident(raise)
		reserved(end)
	reserved(end)

	comment(##)
	comment(# Liest das n chste Zeichen von der Eingabe.)
	reserved(def) method(read_next_char)
		reserved(begin)
			instance_variable(@pos) operator(+=) integer(1)
			instance_variable(@current_char) operator(=) instance_variable(@next_char)
			instance_variable(@next_char) operator(=) instance_variable(@input)operator(.)ident(getc)
		reserved(rescue) constant(IOError)
			constant(Error)operator(.)ident(ioError)
			ident(raise)
		reserved(end)
	reserved(end)

	comment(##)
	comment(# Sucht das nchste Symbol, identifiziert es, instantiiert ein entsprechendes)
	comment(# PascalSymbol-Objekt und gibt es zurck.)
	comment(# @see Symbol)
	comment(# @return das gefundene Symbol als PascalSymbol-Objekt)
	reserved(def) method(get_symbol)
		ident(current_symbol) operator(=) pre_constant(nil)
		reserved(until) ident(current_symbol)
			ident(read_next_char)

			reserved(if) instance_variable(@current_char)operator(.)ident(alpha?)
				ident(identifier) operator(=) instance_variable(@current_char)operator(.)ident(chr)
				reserved(while) instance_variable(@next_char)operator(.)ident(alpha?) reserved(or) instance_variable(@next_char)operator(.)ident(digit?)
					ident(identifier) operator(<<) instance_variable(@next_char)
					ident(read_next_char)
				reserved(end)
				ident(current_symbol) operator(=) ident(handle_identifier)operator(()ident(identifier)operator(.)ident(upcase)operator(\))
			reserved(elsif) instance_variable(@current_char)operator(.)ident(digit?)
				ident(current_symbol) operator(=) ident(number)
			reserved(else)
				reserved(case) instance_variable(@current_char)
				reserved(when) integer(?\\s)
					comment(# ignore)
				reserved(when) integer(?\\n)
					ident(new_line)
				reserved(when) pre_constant(nil)
					ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(EOP)
				reserved(when) integer(?{)
					ident(comment)

				reserved(when) integer(?:)
					reserved(if) instance_variable(@next_char) operator(==) integer(?=)
						ident(read_next_char)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(BECOMES)
					reserved(else)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(COLON)
					reserved(end)

				reserved(when) integer(?<)
					reserved(if) operator(()instance_variable(@next_char) operator(==) integer(?=)operator(\))
						ident(read_next_char)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(LEQSY)
					reserved(elsif) operator(()instance_variable(@next_char) operator(==) integer(?>)operator(\))
						ident(read_next_char)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(NEQSY)
					reserved(else)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(LSSSY)
					reserved(end)

				reserved(when) integer(?>)
					reserved(if) operator(()instance_variable(@next_char) operator(==) integer(?=)operator(\))
						ident(read_next_char)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(GEQSY)
					reserved(else)
						ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(GRTSY)
					reserved(end)

				reserved(when) integer(?.) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(PERIOD)
				reserved(when) integer(?() reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(LPARENT)
				reserved(when) integer(?,) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(COMMA)
				reserved(when) integer(?*) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(TIMES)
				reserved(when) integer(?/) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(SLASH)
				reserved(when) integer(?+) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(PLUS)
				reserved(when) integer(?-) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(MINUS)
				reserved(when) integer(?=) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(EQLSY)
				reserved(when) integer(?\)) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(RPARENT)
				reserved(when) integer(?;) reserved(then) ident(current_symbol) operator(=) constant(PascalSymbol)operator(.)ident(new) constant(SEMICOLON)
				reserved(else)
					constant(Error)operator(.)ident(error)operator(()integer(100)operator(,) instance_variable(@line)operator(,) instance_variable(@pos)operator(\)) reserved(if) instance_variable(@current_char) operator(>) integer(?\\s)
				reserved(end)
			reserved(end)
		reserved(end)
		ident(current_symbol)
	reserved(end)

ident(private)
	comment(##)
	comment(# Versucht, in dem gegebenen String ein Schlsselwort zu erkennen.)
	comment(# Sollte dabei ein Keyword gefunden werden, so gibt er ein PascalSymbol-Objekt zurck, das)
	comment(# das entsprechende Keyword reprsentiert. Ansonsten besteht die Rckgabe aus)
	comment(# einem SymbolIdent-Objekt (abgeleitet von PascalSymbol\), das den String 1:1 enthlt)
	comment(# @see symbol)
	comment(# @return falls Keyword gefunden, zugehriges PascalSymbol, sonst SymbolIdent)
	reserved(def) method(handle_identifier) ident(identifier)
		reserved(if) ident(sym) operator(=) constant(KEYWORD_SYMBOLS)operator([)ident(identifier)operator(])
			constant(PascalSymbol)operator(.)ident(new) ident(sym)
		reserved(else)
			constant(SymbolIdent)operator(.)ident(new) ident(identifier)
		reserved(end)
	reserved(end)

	constant(MAXINT) operator(=) integer(2)operator(**)integer(31) operator(-) integer(1)
	constant(MAXINT_DIV_10)  operator(=) constant(MAXINT) operator(/) integer(10)
	constant(MAXINT_MOD_10)  operator(=) constant(MAXINT) operator(%) integer(10)
	comment(##)
	comment(# Versucht, aus dem gegebenen Zeichen und den folgenden eine Zahl zusammenzusetzen.)
	comment(# Dabei wird der relativ intuitive Algorithmus benutzt, die endgltige Zahl bei)
	comment(# jeder weiteren Ziffer mit 10 zu multiplizieren und diese dann mit der Ziffer zu)
	comment(# addieren. Sonderflle bestehen dann nur noch in der Behandlung von reellen Zahlen.)
	comment(# <BR>)
	comment(# Treten dabei kein Punkt oder ein E auf, so gibt diese Methode ein SymbolIntCon-Objekt)
	comment(# zurck, ansonsten (reelle Zahl\) ein SymbolRealCon-Objekt. Beide Symbole enthalten)
	comment(# jeweils die Zahlwerte.)
	comment(# <BR>)
	comment(# Anmerkung: Diese Funktion ist mit Hilfe der Java/Ruby-API deutlich leichter zu realisieren.)
	comment(# Sie wurde dennoch so implementiert, um den Algorithmus zu demonstrieren)
	comment(# @see symbol)
	comment(# @return SymbolIntcon- oder SymbolRealcon-Objekt, das den Zahlwert enthlt)
	reserved(def) method(number)
		ident(is_integer) operator(=) pre_constant(true)
		ident(integer_too_long) operator(=) pre_constant(false)
		ident(exponent) operator(=) integer(0)
		ident(exp_counter) operator(=) integer(-1)
		ident(exp_sign) operator(=) integer(1)

		ident(integer_mantisse) operator(=) instance_variable(@current_char)operator(.)ident(digit)

		reserved(while) operator(()instance_variable(@next_char)operator(.)ident(digit?) reserved(and) ident(integer_mantisse) operator(<) constant(MAXINT_DIV_10)operator(\)) reserved(or)
		 operator(()ident(integer_mantisse) operator(==) constant(MAXINT_DIV_10) reserved(and) instance_variable(@next_char)operator(.)ident(digit) operator(<=) constant(MAXINT_MOD_10)operator(\))
			ident(integer_mantisse) operator(*=) integer(10)
			ident(integer_mantisse) operator(+=) instance_variable(@next_char)operator(.)ident(digit)
			ident(read_next_char)
		reserved(end)

		ident(real_mantisse) operator(=) ident(integer_mantisse)

		reserved(while) instance_variable(@next_char)operator(.)ident(digit?)
			ident(integer_too_long) operator(=) pre_constant(true)
			ident(real_mantisse) operator(*=) integer(10)
			ident(real_mantisse) operator(+=) instance_variable(@next_char)operator(.)ident(digit)
			ident(read_next_char)
		reserved(end)
		reserved(if) instance_variable(@next_char) operator(==) integer(?.)
			ident(read_next_char)
			ident(is_integer) operator(=) pre_constant(false)
			reserved(unless) instance_variable(@next_char)operator(.)ident(digit?)
				constant(Error)operator(.)ident(error) integer(101)operator(,) instance_variable(@line)operator(,) instance_variable(@pos)
			reserved(end)
			reserved(while) instance_variable(@next_char)operator(.)ident(digit?)
				ident(real_mantisse) operator(+=) instance_variable(@next_char)operator(.)ident(digit) operator(*) operator(()integer(10) operator(**) ident(exp_counter)operator(\))
				ident(read_next_char)
				ident(exp_counter) operator(-=) integer(1)
			reserved(end)
		reserved(end)
		reserved(if) instance_variable(@next_char) operator(==) integer(?E)
			ident(is_integer) operator(=) pre_constant(false)
			ident(read_next_char)
			reserved(if) instance_variable(@next_char) operator(==) integer(?-)
				ident(exp_sign) operator(=) integer(-1)
				ident(read_next_char)
			reserved(end)
			reserved(unless) instance_variable(@next_char)operator(.)ident(digit?)
				constant(Error)operator(.)ident(error) integer(101)operator(,) instance_variable(@line)operator(,) instance_variable(@pos)
			reserved(end)
			reserved(while) instance_variable(@next_char)operator(.)ident(digit?)
				ident(exponent) operator(*=) integer(10)
				ident(exponent) operator(+=) instance_variable(@next_char)operator(.)ident(digit)
				ident(read_next_char)
			reserved(end)
		reserved(end)

		reserved(if) ident(is_integer)
			reserved(if) ident(integer_too_long)
				constant(Error)operator(.)ident(error) integer(102)operator(,) instance_variable(@line)operator(,) instance_variable(@pos)
			reserved(end)
			constant(SymbolIntcon)operator(.)ident(new) ident(integer_mantisse)
		reserved(else)
			constant(SymbolRealcon)operator(.)ident(new) ident(real_mantisse) operator(*) operator(()integer(10) operator(**) operator(()ident(exp_sign) operator(*) ident(exponent)operator(\))operator(\))
		reserved(end)
	reserved(end)

	comment(##)
	comment(# Sorgt fr ein berlesen von Kommentaren.)
	comment(# Es werden einfach alle Zeichen bis zu einer schlieenden Klammer eingelesen)
	comment(# und verworfen.)
	reserved(def) method(comment)
		reserved(while) instance_variable(@current_char) operator(!=) integer(?})
			ident(forbid_eop)
			ident(new_line) reserved(if) instance_variable(@current_char) operator(==) integer(?\\n)
			ident(read_next_char)
		reserved(end)
	reserved(end)

	reserved(def) method(new_line)
		instance_variable(@line) operator(+=) integer(1)
		instance_variable(@pos) operator(=) integer(0)
	reserved(end)

	reserved(def) method(forbid_eop)
		reserved(if) ident(eop?)
			constant(Error)operator(.)ident(error) integer(103)operator(,) instance_variable(@line)operator(,) instance_variable(@pos)
		reserved(end)
		ident(exit)
	reserved(end)

	reserved(def) method(eop?)
		instance_variable(@current_char)operator(.)ident(nil?)
	reserved(end)
reserved(end)

comment(##)
comment(# Lt ein Testprogramm ablaufen.)
comment(# Dieses erzeugt sich ein Scanner-Objekt und ruft an diesem kontinuierlich bis zum Dateiende)
comment(# get_symbol auf.)
reserved(if) global_variable($0) operator(==) pre_constant(__FILE__)
	ident(scan) operator(=) constant(Scanner)operator(.)ident(new)operator(()constant(File)operator(.)ident(new)operator(()pre_constant(ARGV)operator([)integer(0)operator(]) operator(||) string<delimiter(')content(test.pas)delimiter(')>operator(\))operator(\))
	ident(loop) reserved(do)
		ident(c) operator(=) ident(scan)operator(.)ident(get_symbol)
		ident(puts) ident(c)
		reserved(break) reserved(if) ident(c)operator(.)ident(typ) operator(==) constant(TokenConsts)operator(::)constant(EOP)
	reserved(end)
reserved(end)

