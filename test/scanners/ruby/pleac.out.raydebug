comment(# -*- ruby -*-)

comment(# Local variables:)
comment(#  indent-tabs-mode: nil)
comment(#  ruby-indent-level: 4)
comment(# End:)

comment(# @@PLEAC@@_NAME)
comment(# @@SKIP@@ Ruby)

comment(# @@PLEAC@@_WEB)
comment(# @@SKIP@@ http://www.ruby-lang.org)


comment(# @@PLEAC@@_1.0)
ident(string) operator(=) string<delimiter(')content(\\n)delimiter(')>                     comment(# two characters, \\ and an n)
ident(string) operator(=) string<delimiter(')content(Jon )char(\\')content(Maddog)char(\\')content( Orwant)delimiter(')>  comment(# literal single quotes)

ident(string) operator(=) string<delimiter(")char(\\n)delimiter(")>                     comment(# a "newline" character)
ident(string) operator(=) string<delimiter(")content(Jon )char(\\")content(Maddog)char(\\")content( Orwant)delimiter(")>  comment(# literal double quotes)

ident(string) operator(=) string<delimiter(%q/)content(Jon 'Maddog' Orwant)delimiter(/)>  comment(# literal single quotes)

ident(string) operator(=) string<delimiter(%q[)content(Jon 'Maddog' Orwant)delimiter(])>  comment(# literal single quotes)
ident(string) operator(=) string<delimiter(%q{)content(Jon 'Maddog' Orwant)delimiter(})>  comment(# literal single quotes)
ident(string) operator(=) string<delimiter(%q()content(Jon 'Maddog' Orwant)delimiter(\))>  comment(# literal single quotes)
ident(string) operator(=) string<delimiter(%q<)content(Jon 'Maddog' Orwant)delimiter(>)>  comment(# literal single quotes)

ident(a) operator(=) string<delimiter(<<"EOF")>string<content(
This is a multiline here document
terminated by EOF on a line by itself)delimiter(
EOF)>


comment(# @@PLEAC@@_1.1)
ident(value) operator(=) ident(string)operator([)ident(offset)operator(,)ident(count)operator(])
ident(value) operator(=) ident(string)operator([)ident(offset)operator(..)integer(-1)operator(])

ident(string)operator([)ident(offset)operator(,)ident(count)operator(]) operator(=) ident(newstring)
ident(string)operator([)ident(offset)operator(..)integer(-1)operator(])   operator(=) ident(newtail)

comment(# in Ruby we can also specify intervals by their two offsets)
ident(value) operator(=) ident(string)operator([)ident(offset)operator(..)ident(offs2)operator(])
ident(string)operator([)ident(offset)operator(..)ident(offs2)operator(]) operator(=) ident(newstring)

ident(leading)operator(,) ident(s1)operator(,) ident(s2)operator(,) ident(trailing) operator(=) ident(data)operator(.)ident(unpack)operator(()string<delimiter(")content(A5 x3 A8 A8 A*)delimiter(")>operator(\))

ident(fivers) operator(=) ident(string)operator(.)ident(unpack)operator(()string<delimiter(")content(A5)delimiter(")> operator(*) operator(()ident(string)operator(.)ident(length)operator(/)integer(5)operator(\))operator(\))

ident(chars) operator(=) ident(string)operator(.)ident(unpack)operator(()string<delimiter(")content(A1)delimiter(")> operator(*) ident(string)operator(.)ident(length)operator(\))

ident(string) operator(=) string<delimiter(")content(This is what you have)delimiter(")>
comment(#        +012345678901234567890  Indexing forwards  (left to right\))
comment(#         109876543210987654321- Indexing backwards (right to left\))
comment(#          note that 0 means 10 or 20, etc. above)

ident(first)  operator(=) ident(string)operator([)integer(0)operator(,) integer(1)operator(])       comment(# "T")
ident(start)  operator(=) ident(string)operator([)integer(5)operator(,) integer(2)operator(])       comment(# "is")
ident(rest)   operator(=) ident(string)operator([)integer(13)operator(..)integer(-1)operator(])     comment(# "you have")
ident(last)   operator(=) ident(string)operator([)integer(-1)operator(,) integer(1)operator(])      comment(# "e")
ident(end_)   operator(=) ident(string)operator([)integer(-4)operator(..)integer(-1)operator(])     comment(# "have")
ident(piece)  operator(=) ident(string)operator([)integer(-8)operator(,) integer(3)operator(])      comment(# "you")

ident(string)operator([)integer(5)operator(,) integer(2)operator(]) operator(=) string<delimiter(")content(wasn't)delimiter(")>     comment(# change "is" to "wasn't")
ident(string)operator([)integer(-12)operator(..)integer(-1)operator(]) operator(=) string<delimiter(")content(ondrous)delimiter(")> comment(# "This wasn't wondrous")
ident(string)operator([)integer(0)operator(,) integer(1)operator(]) operator(=) string<delimiter(")delimiter(")>           comment(# delete first character)
ident(string)operator([)integer(-10)operator(..)integer(-1)operator(])  operator(=) string<delimiter(")delimiter(")>       comment(# delete last 10 characters)

reserved(if) ident(string)operator([)integer(-10)operator(..)integer(-1)operator(]) operator(=)operator(~) regexp<delimiter(/)content(pattern)delimiter(/)>
    ident(puts) string<delimiter(")content(Pattern matches in last 10 characters)delimiter(")>
reserved(end)

ident(string)operator([)integer(0)operator(,) integer(5)operator(])operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(is)delimiter(/)>operator(,) string<delimiter(')content(at)delimiter(')>operator(\))

ident(a) operator(=) string<delimiter(")content(make a hat)delimiter(")>
ident(a)operator([)integer(0)operator(,) integer(1)operator(])operator(,) ident(a)operator([)integer(-1)operator(,) integer(1)operator(]) operator(=) ident(a)operator([)integer(-1)operator(,) integer(1)operator(])operator(,) ident(a)operator([)integer(0)operator(,) integer(1)operator(])

ident(a) operator(=) string<delimiter(")content(To be or not to be)delimiter(")>
ident(b) operator(=) ident(a)operator(.)ident(unpack)operator(()string<delimiter(")content(x6 A6)delimiter(")>operator(\))

ident(b)operator(,) ident(c) operator(=) ident(a)operator(.)ident(unpack)operator(()string<delimiter(")content(x6 A2 X5 A2)delimiter(")>operator(\))
ident(puts) string<delimiter(")inline<delimiter(#{)ident(b)delimiter(})>char(\\n)inline<delimiter(#{)ident(c)delimiter(})>char(\\n)delimiter(")>

reserved(def) method(cut2fmt)operator(()operator(*)ident(args)operator(\))
    ident(template) operator(=) string<delimiter(')delimiter(')>
    ident(lastpos)  operator(=) integer(1)
    reserved(for) ident(place) reserved(in) ident(args)
        ident(template) operator(+=) string<delimiter(")content(A)delimiter(")> operator(+) operator(()ident(place) operator(-) ident(lastpos)operator(\))operator(.)ident(to_s) operator(+) string<delimiter(")content( )delimiter(")>
        ident(lastpos)   operator(=) ident(place)
    reserved(end)
    ident(template) operator(+=) string<delimiter(")content(A*)delimiter(")>
    reserved(return) ident(template)
reserved(end)

ident(fmt) operator(=) ident(cut2fmt)operator(()integer(8)operator(,) integer(14)operator(,) integer(20)operator(,) integer(26)operator(,) integer(30)operator(\))


comment(# @@PLEAC@@_1.2)
comment(# careful! "b is true" doesn't mean "b != 0" (0 is true in Ruby\))
comment(# thus no problem of "defined" later since only nil is false)
comment(# the following sets to `c' if `b' is nil or false)
ident(a) operator(=) ident(b) operator(||) ident(c)

comment(# if you need Perl's behaviour (setting to `c' if `b' is 0\) the most)
comment(# effective way is to use Numeric#nonzero? (thanks to Dave Thomas!\))
ident(a) operator(=) ident(b)operator(.)ident(nonzero?) operator(||) ident(c)

comment(# you will still want to use defined? in order to test)
comment(# for scope existence of a given object)
ident(a) operator(=) reserved(defined?)operator(()ident(b)operator(\)) operator(?) ident(b) operator(:) ident(c)

ident(dir) operator(=) pre_constant(ARGV)operator(.)ident(shift) operator(||) string<delimiter(")content(/tmp)delimiter(")>


comment(# @@PLEAC@@_1.3)
ident(v1)operator(,) ident(v2) operator(=) ident(v2)operator(,) ident(v1)

ident(alpha)operator(,) ident(beta)operator(,) ident(production) operator(=) string<delimiter(%w()content(January March August)delimiter(\))>
ident(alpha)operator(,) ident(beta)operator(,) ident(production) operator(=) ident(beta)operator(,) ident(production)operator(,) ident(alpha)


comment(# @@PLEAC@@_1.4)
ident(num) operator(=) ident(char)operator([)integer(0)operator(])
ident(char) operator(=) ident(num)operator(.)ident(chr)

comment(# Ruby also supports having a char from character constant)
ident(num) operator(=) integer(?r)

ident(char) operator(=) ident(sprintf)operator(()string<delimiter(")content(%c)delimiter(")>operator(,) ident(num)operator(\))
ident(printf)operator(()string<delimiter(")content(Number %d is character %c)char(\\n)delimiter(")>operator(,) ident(num)operator(,) ident(num)operator(\))

ident(ascii) operator(=) ident(string)operator(.)ident(unpack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))
ident(string) operator(=) ident(ascii)operator(.)ident(pack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))

ident(hal) operator(=) string<delimiter(")content(HAL)delimiter(")>
ident(ascii) operator(=) ident(hal)operator(.)ident(unpack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))
comment(# We can't use Array#each since we can't mutate a Fixnum)
ident(ascii)operator(.)ident(collect!) operator({) operator(|)ident(i)operator(|)
    ident(i) operator(+) integer(1)                         comment(# add one to each ASCII value)
operator(})                
ident(ibm) operator(=) ident(ascii)operator(.)ident(pack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))
ident(puts) ident(ibm)


comment(# @@PLEAC@@_1.5)
ident(array) operator(=) ident(string)operator(.)ident(split)operator(()string<delimiter(')delimiter(')>operator(\))

ident(array) operator(=) ident(string)operator(.)ident(unpack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))

ident(string)operator(.)ident(scan)operator(()regexp<delimiter(/)content(.)delimiter(/)>operator(\)) operator({) operator(|)ident(b)operator(|)
    comment(# do something with b)
operator(})

ident(string) operator(=) string<delimiter(")content(an apple a day)delimiter(")>
ident(print) string<delimiter(")content(unique chars are: )delimiter(")>operator(,) ident(string)operator(.)ident(split)operator(()string<delimiter(')delimiter(')>operator(\))operator(.)ident(uniq)operator(.)ident(sort)operator(,) string<delimiter(")char(\\n)delimiter(")>

ident(sum) operator(=) integer(0)
reserved(for) ident(ascval) reserved(in) ident(string)operator(.)ident(unpack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\)) comment(# or use Array#each for a pure OO style :\))
    ident(sum) operator(+=) ident(ascval)
reserved(end)
ident(puts) string<delimiter(")content(sum is )inline<delimiter(#{)ident(sum) operator(&) integer(0xffffffff)delimiter(})>delimiter(")> comment(# since Ruby will go Bignum if necessary)

comment(# @@INCLUDE@@ include/ruby/slowcat.rb)


comment(# @@PLEAC@@_1.6)
ident(revbytes) operator(=) ident(string)operator(.)ident(reverse)

ident(revwords) operator(=) ident(string)operator(.)ident(split)operator(()string<delimiter(")content( )delimiter(")>operator(\))operator(.)ident(reverse)operator(.)ident(join)operator(()string<delimiter(")content( )delimiter(")>operator(\))

ident(revwords) operator(=) ident(string)operator(.)ident(split)operator(()regexp<delimiter(/)content(()char(\\s)content(+\))delimiter(/)>operator(\))operator(.)ident(reverse)operator(.)ident(join)

comment(# using the fact that IO is Enumerable, you can directly "select" it)
ident(long_palindromes) operator(=) constant(File)operator(.)ident(open)operator(()string<delimiter(")content(/usr/share/dict/words)delimiter(")>operator(\))operator(.)
    ident(select) operator({) operator(|)ident(w)operator(|) ident(w)operator(.)ident(chomp!)operator(;) ident(w)operator(.)ident(reverse) operator(==) ident(w) operator(&&) ident(w)operator(.)ident(length) operator(>) integer(5) operator(})


comment(# @@PLEAC@@_1.7)
reserved(while) ident(string)operator(.)ident(sub!)operator(()string<delimiter(")char(\\t)content(+)delimiter(")>operator(\)) operator({) string<delimiter(')content( )delimiter(')> operator(*) operator(()global_variable($&)operator(.)ident(length) operator(*) integer(8) operator(-) global_variable($`)operator(.)ident(length) operator(%) integer(8)operator(\)) operator(})
reserved(end)


comment(# @@PLEAC@@_1.8)
string<delimiter(')content(You owe #{debt} to me)delimiter(')>operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\#)content({()char(\\w)content(+\)})delimiter(/)>operator(\)) operator({) ident(eval)operator(()global_variable($1)operator(\)) operator(})

ident(rows)operator(,) ident(cols) operator(=) integer(24)operator(,) integer(80)
ident(text) operator(=) string<delimiter(%q()content(I am #{rows} high and #{cols} long)delimiter(\))>
ident(text)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\#)content({()char(\\w)content(+\)})delimiter(/)>operator(\)) operator({) ident(eval)operator(()string<delimiter(")inline<delimiter(#{)global_variable($1)delimiter(})>delimiter(")>operator(\)) operator(})
ident(puts) ident(text)

string<delimiter(')content(I am 17 years old)delimiter(')>operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\d)content(+)delimiter(/)>operator(\)) operator({) integer(2) operator(*) global_variable($&)operator(.)ident(to_i) operator(})


comment(# @@PLEAC@@_1.9)
ident(e) operator(=) string<delimiter(")content(bo peep)delimiter(")>operator(.)ident(upcase)
ident(e)operator(.)ident(downcase!)
ident(e)operator(.)ident(capitalize!)

string<delimiter(")content(thIS is a loNG liNE)delimiter(")>operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\w)content(+)delimiter(/)>operator(\)) operator({) global_variable($&)operator(.)ident(capitalize) operator(})


comment(# @@PLEAC@@_1.10)
string<delimiter(")content(I have )inline<delimiter(#{)ident(n)integer(+1)delimiter(})>content( guanacos.)delimiter(")>
ident(print) string<delimiter(")content(I have )delimiter(")>operator(,) ident(n)integer(+1)operator(,) string<delimiter(")content( guanacos.)delimiter(")>


comment(# @@PLEAC@@_1.11)
ident(var) operator(=) string<delimiter(<<'EOF')>operator(.)ident(gsub)operator(()regexp<delimiter(/)content(^)char(\\s)content(+)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))string<content(
    your text
    goes here)delimiter(
EOF)>


comment(# @@PLEAC@@_1.12)
ident(string) operator(=) string<delimiter(")content(Folding and splicing is the work of an editor,)char(\\n)delimiter(")>operator(+)
    string<delimiter(")content(not a mere collection of silicon)char(\\n)delimiter(")>operator(+) 
    string<delimiter(")content(and)char(\\n)delimiter(")>operator(+)
    string<delimiter(")content(mobile electrons!)delimiter(")>

reserved(def) method(wrap)operator(()ident(str)operator(,) ident(max_size)operator(\))
    ident(all) operator(=) operator([)operator(])
    ident(line) operator(=) string<delimiter(')delimiter(')>
    reserved(for) ident(l) reserved(in) ident(str)operator(.)ident(split)
        reserved(if) operator(()ident(line)operator(+)ident(l)operator(\))operator(.)ident(length) operator(>)operator(=) ident(max_size)
            ident(all)operator(.)ident(push)operator(()ident(line)operator(\))
            ident(line) operator(=) string<delimiter(')delimiter(')>
        reserved(end)
        ident(line) operator(+=) ident(line) operator(==) string<delimiter(')delimiter(')> operator(?) ident(l) operator(:) string<delimiter(')content( )delimiter(')> operator(+) ident(l)
    reserved(end)
    ident(all)operator(.)ident(push)operator(()ident(line)operator(\))operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))
reserved(end)

ident(print) ident(wrap)operator(()ident(string)operator(,) integer(20)operator(\))
comment(#=> Folding and )
comment(#=> splicing is the )
comment(#=> work of an editor, )
comment(#=> not a mere )
comment(#=> collection of )
comment(#=> silicon and mobile )
comment(#=> electrons!)


comment(# @@PLEAC@@_1.13)
ident(string) operator(=) string<delimiter(%q()content(Mom said, "Don't do that.")delimiter(\))>
ident(string)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(['"])delimiter(/)>operator(\)) operator({) string<delimiter(')char(\\\\)delimiter(')>operator(+)global_variable($&) operator(})
ident(string)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(['"])delimiter(/)>operator(,) string<delimiter(')content(\\&)content(\\&)delimiter(')>operator(\))
ident(string)operator(.)ident(gsub)operator(()regexp<delimiter(/)content([^A-Z])delimiter(/)>operator(\)) operator({) string<delimiter(')char(\\\\)delimiter(')>operator(+)global_variable($&) operator(})
string<delimiter(")content(is a test!)delimiter(")>operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\W)delimiter(/)>operator(\)) operator({) string<delimiter(')char(\\\\)delimiter(')>operator(+)global_variable($&) operator(})  comment(# no function like quotemeta?)


comment(# @@PLEAC@@_1.14)
ident(string)operator(.)ident(strip!)


comment(# @@PLEAC@@_1.15)
reserved(def) method(parse_csv)operator(()ident(text)operator(\))
    ident(new) operator(=) ident(text)operator(.)ident(scan)operator(()regexp<delimiter(/)content("([^)char(\\")char(\\\\)content(]*(?:)char(\\\\)content(.[^)char(\\")char(\\\\)content(]*\)*\)",?|([^,]+\),?|,)delimiter(/)>operator(\))
    ident(new) operator(<<) pre_constant(nil) reserved(if) ident(text)operator([)integer(-1)operator(]) operator(==) integer(?,)
    ident(new)operator(.)ident(flatten)operator(.)ident(compact)
reserved(end)  

ident(line) operator(=) string<delimiter(%q<)content(XYZZY,"","O'Reilly, Inc","Wall, Larry","a )content(\\")content(glug)content(\\")content( bit,",5,"Error, Core Dumped")delimiter(>)>
ident(fields) operator(=) ident(parse_csv)operator(()ident(line)operator(\))
ident(fields)operator(.)ident(each_with_index) operator({) operator(|)ident(v)operator(,)ident(i)operator(|)
    ident(print) string<delimiter(")inline<delimiter(#{)ident(i)delimiter(})>content( : )inline<delimiter(#{)ident(v)delimiter(})>char(\\n)delimiter(")>operator(;)
operator(})


comment(# @@PLEAC@@_1.16)
comment(# Use the soundex.rb Library from Michael Neumann.)
comment(# http://www.s-direktnet.de/homepages/neumann/rb_prgs/Soundex.rb)
ident(require) string<delimiter(')content(Soundex)delimiter(')>

ident(code) operator(=) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(string)operator(\))
ident(codes) operator(=) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(array)operator(\))

comment(# substitution function for getpwent(\):)
comment(# returns an array of user entries,)
comment(# each entry contains the username and the full name)
reserved(def) method(login_names)
    ident(result) operator(=) operator([)operator(])
    constant(File)operator(.)ident(open)operator(()string<delimiter(")content(/etc/passwd)delimiter(")>operator(\)) operator({) operator(|)ident(file)operator(|)
        ident(file)operator(.)ident(each_line) operator({) operator(|)ident(line)operator(|)
            reserved(next) reserved(if) ident(line)operator(.)ident(match)operator(()regexp<delimiter(/)content(^#)delimiter(/)>operator(\))
            ident(cols) operator(=) ident(line)operator(.)ident(split)operator(()string<delimiter(")content(:)delimiter(")>operator(\))
            ident(result)operator(.)ident(push)operator(()operator([)ident(cols)operator([)integer(0)operator(])operator(,) ident(cols)operator([)integer(4)operator(])operator(])operator(\))
        operator(})
    operator(})
    ident(result)
reserved(end)

ident(puts) string<delimiter(")content(Lookup user: )delimiter(")>
ident(user) operator(=) constant(STDIN)operator(.)ident(gets)
ident(user)operator(.)ident(chomp!)
ident(exit) reserved(unless) ident(user)
ident(name_code) operator(=) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(user)operator(\))

ident(splitter) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(()content(\\w)content(+\)[^,]*)content(\\b)content(()content(\\w)content(+\))delimiter(')>operator(\))
reserved(for) ident(username)operator(,) ident(fullname) reserved(in) ident(login_names) reserved(do)
    ident(firstname)operator(,) ident(lastname) operator(=) ident(splitter)operator(.)ident(match)operator(()ident(fullname)operator(\))operator([)integer(1)operator(,)integer(2)operator(])
    reserved(if) ident(name_code) operator(==) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(username)operator(\))
        operator(||) ident(name_code) operator(==) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(firstname)operator(\))
        operator(||) ident(name_code) operator(==) constant(Text)operator(::)constant(Soundex)operator(.)ident(soundex)operator(()ident(lastname)operator(\))
    reserved(then)
        ident(puts) string<delimiter(")inline<delimiter(#{)ident(username)delimiter(})>content(: )inline<delimiter(#{)ident(firstname)delimiter(})>content( )inline<delimiter(#{)ident(lastname)delimiter(})>delimiter(")>
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_1.17)
comment(# @@INCLUDE@@ include/ruby/fixstyle.rb)


comment(# @@PLEAC@@_1.18)
comment(# @@INCLUDE@@ include/ruby/psgrep.rb)


comment(# @@PLEAC@@_2.1)
comment(# Matz tells that you can use Integer(\) for strict checked conversion.)
ident(Integer)operator(()string<delimiter(")content(abc)delimiter(")>operator(\))
comment(#=> `Integer': invalid value for Integer: "abc" (ArgumentError\))
ident(Integer)operator(()string<delimiter(")content(567)delimiter(")>operator(\))
comment(#=> 567)

comment(# You may use Float(\) for floating point stuff)
ident(Integer)operator(()string<delimiter(")content(56.7)delimiter(")>operator(\))
comment(#=> `Integer': invalid value for Integer: "56.7" (ArgumentError\))
ident(Float)operator(()string<delimiter(")content(56.7)delimiter(")>operator(\))
comment(#=> 56.7)

comment(# You may also use a regexp for that)
reserved(if) ident(string) operator(=)operator(~) regexp<delimiter(/)content(^[+-]?)char(\\d)content(+$)delimiter(/)>
    ident(p) string<delimiter(')content(is an integer)delimiter(')>
reserved(else)
    ident(p) string<delimiter(')content(is not)delimiter(')>
reserved(end)

reserved(if) ident(string) operator(=)operator(~) regexp<delimiter(/)content(^-?(?:)char(\\d)content(+(?:)char(\\.)char(\\d)content(*\)?|)char(\\.)char(\\d)content(+\)$)delimiter(/)>
    ident(p) string<delimiter(')content(is a decimal number)delimiter(')>
reserved(else)
    ident(p) string<delimiter(')content(is not)delimiter(')>
reserved(end)


comment(# @@PLEAC@@_2.2)
comment(# equal(num1, num2, accuracy\) : returns true if num1 and num2 are)
comment(#   equal to accuracy number of decimal places)
reserved(def) method(equal)operator(()ident(i)operator(,) ident(j)operator(,) ident(a)operator(\))
    ident(sprintf)operator(()string<delimiter(")content(%.)inline<delimiter(#{)ident(a)delimiter(})>content(g)delimiter(")>operator(,) ident(i)operator(\)) operator(==) ident(sprintf)operator(()string<delimiter(")content(%.)inline<delimiter(#{)ident(a)delimiter(})>content(g)delimiter(")>operator(,) ident(j)operator(\))
reserved(end)

ident(wage) operator(=) integer(536)                        comment(# $5.36/hour)
ident(week) operator(=) integer(40) operator(*) ident(wage)                  comment(# $214.40)
ident(printf)operator(()string<delimiter(")content(One week's wage is: )char(\\$)content(%.2f)char(\\n)delimiter(")>operator(,) ident(week)operator(/)float(100.0)operator(\))


comment(# @@PLEAC@@_2.3)
ident(num)operator(.)ident(round)                         comment(# rounds to integer)

ident(a) operator(=) float(0.255)
ident(b) operator(=) ident(sprintf)operator(()string<delimiter(")content(%.2f)delimiter(")>operator(,) ident(a)operator(\))
ident(print)  string<delimiter(")content(Unrounded: )inline<delimiter(#{)ident(a)delimiter(})>char(\\n)content(Rounded: )inline<delimiter(#{)ident(b)delimiter(})>char(\\n)delimiter(")>
ident(printf) string<delimiter(")content(Unrounded: )inline<delimiter(#{)ident(a)delimiter(})>char(\\n)content(Rounded: %.2f)char(\\n)delimiter(")>operator(,) ident(a)

ident(print) string<delimiter(")content(number)char(\\t)content(int)char(\\t)content(floor)char(\\t)content(ceil)char(\\n)delimiter(")>
ident(a) operator(=) operator([) float(3.3) operator(,) float(3.5) operator(,) float(3.7)operator(,) float(-3.3) operator(])
reserved(for) ident(n) reserved(in) ident(a)
    ident(printf)operator(()string<delimiter(")content(% .1f)char(\\t)content(% .1f)char(\\t)content(% .1f)char(\\t)content(% .1f)char(\\n)delimiter(")>operator(,)  comment(# at least I don't fake my output :\))
           ident(n)operator(,) ident(n)operator(.)ident(to_i)operator(,) ident(n)operator(.)ident(floor)operator(,) ident(n)operator(.)ident(ceil)operator(\))
reserved(end)


comment(# @@PLEAC@@_2.4)
reserved(def) method(dec2bin)operator(()ident(n)operator(\))
    operator([)ident(n)operator(])operator(.)ident(pack)operator(()string<delimiter(")content(N)delimiter(")>operator(\))operator(.)ident(unpack)operator(()string<delimiter(")content(B32)delimiter(")>operator(\))operator([)integer(0)operator(])operator(.)ident(sub)operator(()regexp<delimiter(/)content(^0+(?=)char(\\d)content(\))delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))
reserved(end)

reserved(def) method(bin2dec)operator(()ident(n)operator(\))
    operator([)operator(()string<delimiter(")content(0)delimiter(")>operator(*)integer(32)operator(+)ident(n)operator(.)ident(to_s)operator(\))operator([)integer(-32)operator(..)integer(-1)operator(])operator(])operator(.)ident(pack)operator(()string<delimiter(")content(B32)delimiter(")>operator(\))operator(.)ident(unpack)operator(()string<delimiter(")content(N)delimiter(")>operator(\))operator([)integer(0)operator(])
reserved(end)


comment(# @@PLEAC@@_2.5)
reserved(for) ident(i) reserved(in) ident(x) operator(..) ident(y)
    comment(# i is set to every integer from x to y, inclusive)
reserved(end)

ident(x)operator(.)ident(step)operator(()ident(y)operator(,)integer(7)operator(\)) operator({) operator(|)ident(i)operator(|)
    comment(# i is set to every integer from x to y, stepsize = 7)
operator(})

ident(print) string<delimiter(")content(Infancy is: )delimiter(")>
operator(()integer(0)operator(..)integer(2)operator(\))operator(.)ident(each) operator({) operator(|)ident(i)operator(|)
    ident(print) ident(i)operator(,) string<delimiter(")content( )delimiter(")>
operator(})
ident(print) string<delimiter(")char(\\n)delimiter(")>


comment(# @@PLEAC@@_2.6)
comment(# We can add conversion methods to the Integer class,)
comment(# this makes a roman number just a representation for normal numbers.)
reserved(class) class(Integer)
    
    class_variable(@@romanlist) operator(=) operator([)operator([)string<delimiter(")content(M)delimiter(")>operator(,) integer(1000)operator(])operator(,)
                   operator([)string<delimiter(")content(CM)delimiter(")>operator(,) integer(900)operator(])operator(,)
                   operator([)string<delimiter(")content(D)delimiter(")>operator(,)  integer(500)operator(])operator(,)
                   operator([)string<delimiter(")content(CD)delimiter(")>operator(,) integer(400)operator(])operator(,)
                   operator([)string<delimiter(")content(C)delimiter(")>operator(,)  integer(100)operator(])operator(,)
                   operator([)string<delimiter(")content(XC)delimiter(")>operator(,)  integer(90)operator(])operator(,)
                   operator([)string<delimiter(")content(L)delimiter(")>operator(,)   integer(50)operator(])operator(,)
                   operator([)string<delimiter(")content(XL)delimiter(")>operator(,)  integer(40)operator(])operator(,)
                   operator([)string<delimiter(")content(X)delimiter(")>operator(,)   integer(10)operator(])operator(,)
                   operator([)string<delimiter(")content(IX)delimiter(")>operator(,)   integer(9)operator(])operator(,)
                   operator([)string<delimiter(")content(V)delimiter(")>operator(,)    integer(5)operator(])operator(,)
                   operator([)string<delimiter(")content(IV)delimiter(")>operator(,)   integer(4)operator(])operator(,)
                   operator([)string<delimiter(")content(I)delimiter(")>operator(,)    integer(1)operator(])operator(])
    
    reserved(def) method(to_roman)
        ident(remains) operator(=) pre_constant(self)
        ident(roman) operator(=) string<delimiter(")delimiter(")>
        reserved(for) ident(sym)operator(,) ident(num) reserved(in) class_variable(@@romanlist)
            reserved(while) ident(remains) operator(>)operator(=) ident(num)
                ident(remains) operator(-=) ident(num)
                ident(roman) operator(<<) ident(sym)
            reserved(end)
        reserved(end)
        ident(roman)
    reserved(end)
    
    reserved(def) constant(Integer)operator(.)ident(from_roman)operator(()ident(roman)operator(\))
        ident(ustr) operator(=) ident(roman)operator(.)ident(upcase)
        ident(sum) operator(=) integer(0)
        reserved(for) ident(entry) reserved(in) class_variable(@@romanlist)
            ident(sym)operator(,) ident(num) operator(=) ident(entry)operator([)integer(0)operator(])operator(,) ident(entry)operator([)integer(1)operator(])
            reserved(while) ident(sym) operator(==) ident(ustr)operator([)integer(0)operator(,) ident(sym)operator(.)ident(length)operator(])
                ident(sum) operator(+=) ident(num)
                ident(ustr)operator(.)ident(slice!)operator(()integer(0)operator(,) ident(sym)operator(.)ident(length)operator(\))
            reserved(end)
        reserved(end)
        ident(sum)
    reserved(end)
    
reserved(end)


ident(roman_fifteen) operator(=) integer(15)operator(.)ident(to_roman)
ident(puts) string<delimiter(")content(Roman for fifteen is )inline<delimiter(#{)ident(roman_fifteen)delimiter(})>delimiter(")>
ident(i) operator(=) constant(Integer)operator(.)ident(from_roman)operator(()ident(roman_fifteen)operator(\))
ident(puts) string<delimiter(")content(Converted back, )inline<delimiter(#{)ident(roman_fifteen)delimiter(})>content( is )inline<delimiter(#{)ident(i)delimiter(})>delimiter(")>

comment(# check)
reserved(for) ident(i) reserved(in) operator(()integer(1)operator(..)integer(3900)operator(\))
    ident(r) operator(=) ident(i)operator(.)ident(to_roman)
    ident(j) operator(=) constant(Integer)operator(.)ident(from_roman)operator(()ident(r)operator(\))
    reserved(if) ident(i) operator(!=) ident(j)
        ident(puts) string<delimiter(")content(error: )inline<delimiter(#{)ident(i)delimiter(})>content( : )inline<delimiter(#{)ident(r)delimiter(})>content( - )inline<delimiter(#{)ident(j)delimiter(})>delimiter(")>
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_2.7)
ident(random) operator(=) ident(rand)operator(()ident(y)operator(-)ident(x)integer(+1)operator(\))operator(+)ident(x)

ident(chars) operator(=) operator([)string<delimiter(")content(A)delimiter(")>operator(..)string<delimiter(")content(Z)delimiter(")>operator(,)string<delimiter(")content(a)delimiter(")>operator(..)string<delimiter(")content(z)delimiter(")>operator(,)string<delimiter(")content(0)delimiter(")>operator(..)string<delimiter(")content(9)delimiter(")>operator(])operator(.)ident(collect) operator({) operator(|)ident(r)operator(|) ident(r)operator(.)ident(to_a) operator(})operator(.)ident(join) operator(+) string<delimiter(%q()content(!@$%^&*)delimiter(\))>
ident(password) operator(=) operator(()integer(1)operator(..)integer(8)operator(\))operator(.)ident(collect) operator({) ident(chars)operator([)ident(rand)operator(()ident(chars)operator(.)ident(size)operator(\))operator(]) operator(})operator(.)ident(pack)operator(()string<delimiter(")content(C*)delimiter(")>operator(\))


comment(# @@PLEAC@@_2.8)
ident(srand)        comment(# uses a combination of the time, the process id, and a sequence number)
ident(srand)operator(()ident(val)operator(\))   comment(# for repeatable behaviour)


comment(# @@PLEAC@@_2.9)
comment(# from the randomr lib: )
comment(# http://raa.ruby-lang.org/project/randomr/)
operator(-)operator(-)operator(-)operator(-)operator(>) ident(http)symbol(:/)operator(/)ident(raa)operator(.)ident(ruby)operator(-)ident(lang)operator(.)ident(org)operator(/)ident(project)operator(/)ident(randomr)operator(/)

ident(require) string<delimiter(')content(random/mersenne_twister)delimiter(')>
ident(mers) operator(=) constant(Random)operator(::)constant(MersenneTwister)operator(.)ident(new) integer(123456789)
ident(puts) ident(mers)operator(.)ident(rand)operator(()integer(0)operator(\))    comment(# 0.550321932544541)
ident(puts) ident(mers)operator(.)ident(rand)operator(()integer(10)operator(\))   comment(# 2)

comment(# using online sources of random data via the realrand package:)
comment(# http://raa.ruby-lang.org/project/realrand/)
comment(# **Note**)
comment(# The following online services are used in this package:)
comment(#   http://www.random.org - source: atmospheric noise )
comment(#   http://www.fourmilab.ch/hotbits - source: radioactive decay timings)
comment(#   http://random.hd.org - source: entropy from local and network noise)
comment(# Please visit the sites and respect the rules of each service.)

ident(require) string<delimiter(')content(random/online)delimiter(')>

ident(generator1) operator(=) constant(Random)operator(::)constant(RandomOrg)operator(.)ident(new)
ident(puts) ident(generator1)operator(.)ident(randbyte)operator(()integer(5)operator(\))operator(.)ident(join)operator(()string<delimiter(")content(,)delimiter(")>operator(\))
ident(puts) ident(generator1)operator(.)ident(randnum)operator(()integer(10)operator(,) integer(1)operator(,) integer(6)operator(\))operator(.)ident(join)operator(()string<delimiter(")content(,)delimiter(")>operator(\))  comment(# Roll dice 10 times.)

ident(generator2) operator(=) constant(Random)operator(::)constant(FourmiLab)operator(.)ident(new)
ident(puts) ident(generator2)operator(.)ident(randbyte)operator(()integer(5)operator(\))operator(.)ident(join)operator(()string<delimiter(")content(,)delimiter(")>operator(\))
comment(# randnum is not supported.)

ident(generator3) operator(=) constant(Random)operator(::)constant(EntropyPool)operator(.)ident(new)
ident(puts) ident(generator3)operator(.)ident(randbyte)operator(()integer(5)operator(\))operator(.)ident(join)operator(()string<delimiter(")content(,)delimiter(")>operator(\))
comment(# randnum is not supported.)


comment(# @@PLEAC@@_2.10)
reserved(def) method(gaussian_rand)
    reserved(begin)
        ident(u1) operator(=) integer(2) operator(*) ident(rand)operator(()operator(\)) operator(-) integer(1)
        ident(u2) operator(=) integer(2) operator(*) ident(rand)operator(()operator(\)) operator(-) integer(1)
        ident(w) operator(=) ident(u1)operator(*)ident(u1) operator(+) ident(u2)operator(*)ident(u2)
    reserved(end) reserved(while) operator(()ident(w) operator(>)operator(=) integer(1)operator(\))
    ident(w) operator(=) constant(Math)operator(.)ident(sqrt)operator(()operator(()integer(-2)operator(*)constant(Math)operator(.)ident(log)operator(()ident(w)operator(\))operator(\))operator(/)ident(w)operator(\))
    operator([) ident(u2)operator(*)ident(w)operator(,) ident(u1)operator(*)ident(w) operator(])
reserved(end)

ident(mean) operator(=) integer(25)
ident(sdev) operator(=) integer(2)
ident(salary) operator(=) ident(gaussian_rand)operator([)integer(0)operator(]) operator(*) ident(sdev) operator(+) ident(mean)
ident(printf)operator(()string<delimiter(")content(You have been hired at )char(\\$)content(%.2f)char(\\n)delimiter(")>operator(,) ident(salary)operator(\))


comment(# @@PLEAC@@_2.11)
reserved(def) method(deg2rad)operator(()ident(d)operator(\))
    operator(()ident(d)operator(/)float(180.0)operator(\))operator(*)constant(Math)operator(::)constant(PI)
reserved(end)

reserved(def) method(rad2deg)operator(()ident(r)operator(\))
    operator(()ident(r)operator(/)constant(Math)operator(::)constant(PI)operator(\))operator(*)integer(180)
reserved(end)


comment(# @@PLEAC@@_2.12)
ident(sin_val) operator(=) constant(Math)operator(.)ident(sin)operator(()ident(angle)operator(\))
ident(cos_val) operator(=) constant(Math)operator(.)ident(cos)operator(()ident(angle)operator(\))
ident(tan_val) operator(=) constant(Math)operator(.)ident(tan)operator(()ident(angle)operator(\))

comment(# AFAIK Ruby's Math module doesn't provide acos/asin)
comment(# While we're at it, let's also define missing hyperbolic functions)
reserved(module) class(Math)
    reserved(def) constant(Math)operator(.)ident(asin)operator(()ident(x)operator(\))
        ident(atan2)operator(()ident(x)operator(,) ident(sqrt)operator(()integer(1) operator(-) ident(x)operator(**)integer(2)operator(\))operator(\))
    reserved(end)
    reserved(def) constant(Math)operator(.)ident(acos)operator(()ident(x)operator(\))
        ident(atan2)operator(()ident(sqrt)operator(()integer(1) operator(-) ident(x)operator(**)integer(2)operator(\))operator(,) ident(x)operator(\))
    reserved(end)
    reserved(def) constant(Math)operator(.)ident(atan)operator(()ident(x)operator(\))
        ident(atan2)operator(()ident(x)operator(,) integer(1)operator(\))
    reserved(end)
    reserved(def) constant(Math)operator(.)ident(sinh)operator(()ident(x)operator(\))
        operator(()ident(exp)operator(()ident(x)operator(\)) operator(-) ident(exp)operator(()operator(-)ident(x)operator(\))operator(\)) operator(/) integer(2)
    reserved(end)
    reserved(def) constant(Math)operator(.)ident(cosh)operator(()ident(x)operator(\))
        operator(()ident(exp)operator(()ident(x)operator(\)) operator(+) ident(exp)operator(()operator(-)ident(x)operator(\))operator(\)) operator(/) integer(2)
    reserved(end)
    reserved(def) constant(Math)operator(.)ident(tanh)operator(()ident(x)operator(\))
        ident(sinh)operator(()ident(x)operator(\)) operator(/) ident(cosh)operator(()ident(x)operator(\))
    reserved(end)
reserved(end)

comment(# The support for Complex numbers is not built-in)
ident(y) operator(=) constant(Math)operator(.)ident(acos)operator(()float(3.7)operator(\))
comment(#=> in `sqrt': square root for negative number (ArgumentError\))

comment(# There is an implementation of Complex numbers in 'complex.rb' in current)
comment(# Ruby distro, but it doesn't support atan2 with complex args, so it doesn't)
comment(# solve this problem.)


comment(# @@PLEAC@@_2.13)
ident(log_e) operator(=) constant(Math)operator(.)ident(log)operator(()ident(val)operator(\))
ident(log_10) operator(=) constant(Math)operator(.)ident(log10)operator(()ident(val)operator(\))

reserved(def) method(log_base)operator(()ident(base)operator(,) ident(val)operator(\))
    constant(Math)operator(.)ident(log)operator(()ident(val)operator(\))operator(/)constant(Math)operator(.)ident(log)operator(()ident(base)operator(\))
reserved(end)

ident(answer) operator(=) ident(log_base)operator(()integer(10)operator(,) integer(10_000)operator(\))
ident(puts) string<delimiter(")content(log10(10,000\) = )inline<delimiter(#{)ident(answer)delimiter(})>delimiter(")>


comment(# @@PLEAC@@_2.14)
ident(require) string<delimiter(')content(matrix.rb)delimiter(')>

ident(a) operator(=) constant(Matrix)operator([)operator([)integer(3)operator(,) integer(2)operator(,) integer(3)operator(])operator(,) operator([)integer(5)operator(,) integer(9)operator(,) integer(8)operator(])operator(])
ident(b) operator(=) constant(Matrix)operator([)operator([)integer(4)operator(,) integer(7)operator(])operator(,) operator([)integer(9)operator(,) integer(3)operator(])operator(,) operator([)integer(8)operator(,) integer(1)operator(])operator(])
ident(c) operator(=) ident(a) operator(*) ident(b)

ident(a)operator(.)ident(row_size)
ident(a)operator(.)ident(column_size)

ident(c)operator(.)ident(det)
ident(a)operator(.)ident(transpose)


comment(# @@PLEAC@@_2.15)
ident(require) string<delimiter(')content(complex.rb)delimiter(')>
ident(require) string<delimiter(')content(rational.rb)delimiter(')>

ident(a) operator(=) ident(Complex)operator(()integer(3)operator(,) integer(5)operator(\))              comment(# 3 + 5i)
ident(b) operator(=) ident(Complex)operator(()integer(2)operator(,) integer(-2)operator(\))             comment(# 2 - 2i)
ident(puts) string<delimiter(")content(c = )inline<delimiter(#{)ident(a)operator(*)ident(b)delimiter(})>delimiter(")>

ident(c) operator(=) ident(a) operator(*) ident(b)
ident(d) operator(=) integer(3) operator(+) integer(4)operator(*)constant(Complex)operator(::)constant(I)

ident(printf) string<delimiter(")content(sqrt()inline<delimiter(#{)ident(d)delimiter(})>content(\) = %s)char(\\n)delimiter(")>operator(,) constant(Math)operator(.)ident(sqrt)operator(()ident(d)operator(\))


comment(# @@PLEAC@@_2.16)
ident(number) operator(=) ident(hexadecimal)operator(.)ident(hex)
ident(number) operator(=) ident(octal)operator(.)ident(oct)

ident(print) string<delimiter(")content(Gimme a number in decimal, octal, or hex: )delimiter(")>
ident(num) operator(=) ident(gets)operator(.)ident(chomp)
ident(exit) reserved(unless) reserved(defined?)operator(()ident(num)operator(\))
ident(num) operator(=) ident(num)operator(.)ident(oct) reserved(if) ident(num) operator(=)operator(~) regexp<delimiter(/)content(^0)delimiter(/)>  comment(# does both oct and hex  )
ident(printf) string<delimiter(")content(%d %x %o)char(\\n)delimiter(")>operator(,) ident(num)operator(,) ident(num)operator(,) ident(num)

ident(print) string<delimiter(")content(Enter file permission in octal: )delimiter(")>
ident(permissions) operator(=) ident(gets)operator(.)ident(chomp)
ident(raise) string<delimiter(")content(Exiting ...)char(\\n)delimiter(")> reserved(unless) reserved(defined?)operator(()ident(permissions)operator(\))
ident(puts) string<delimiter(")content(The decimal value is )inline<delimiter(#{)ident(permissions)operator(.)ident(oct)delimiter(})>delimiter(")>


comment(# @@PLEAC@@_2.17)
reserved(def) method(commify)operator(()ident(n)operator(\))
    ident(n)operator(.)ident(to_s) operator(=)operator(~) regexp<delimiter(/)content(([^)char(\\.)content(]*\)()char(\\.)content(.*\)?)delimiter(/)>
    ident(int)operator(,) ident(dec) operator(=) global_variable($1)operator(.)ident(reverse)operator(,) global_variable($2) operator(?) global_variable($2) operator(:) string<delimiter(")delimiter(")>
    reserved(while) ident(int)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content((,|)char(\\.)content(|^\)()char(\\d)content({3}\)()char(\\d)content(\))delimiter(/)>operator(,) string<delimiter(')content(\\1)content(\\2)content(,)content(\\3)delimiter(')>operator(\))
    reserved(end)
    ident(int)operator(.)ident(reverse) operator(+) ident(dec)
reserved(end)


comment(# @@PLEAC@@_2.18)
ident(printf) string<delimiter(")content(It took %d hour%s)char(\\n)delimiter(")>operator(,) ident(time)operator(,) ident(time) operator(==) integer(1) operator(?) string<delimiter(")delimiter(")> operator(:) string<delimiter(")content(s)delimiter(")>

comment(# dunno if an equivalent to Lingua::EN::Inflect exists...)


comment(# @@PLEAC@@_2.19)
comment(#-----------------------------)
comment(#!/usr/bin/ruby)
comment(# bigfact - calculating prime factors)
reserved(def) method(factorize)operator(()ident(orig)operator(\))
    ident(factors) operator(=) operator({)operator(})
    ident(factors)operator(.)ident(default) operator(=) integer(0)     comment(# return 0 instead nil if key not found in hash)
    ident(n) operator(=) ident(orig)
    ident(i) operator(=) integer(2)
    ident(sqi) operator(=) integer(4)                 comment(# square of i)
    reserved(while) ident(sqi) operator(<=) ident(n) reserved(do)
        reserved(while) ident(n)operator(.)ident(modulo)operator(()ident(i)operator(\)) operator(==) integer(0) reserved(do)
            ident(n) regexp<delimiter(/)content(= i
            factors[i] += 1
            # puts "Found factor )inline<delimiter(#{)ident(i)delimiter(})>content("
        end
        # we take advantage of the fact that (i +1\)**2 = i**2 + 2*i +1
        sqi += 2 * i + 1
        i += 1
    end
    
    if (n != 1\) && (n != orig\)
        factors[n] += 1
    end
    factors
end

def printfactorhash(orig, factorcount\)
    print format("%-10d ", orig\)
    if factorcount.length == 0
        print "PRIME"
    else
        # sorts after number, because the hash keys are numbers
        factorcount.sort.each { |factor,exponent|
            print factor
            if exponent > 1
                print "**", exponent
            end
            print " "
        }
    end
    puts
end

for arg in ARGV
    n = arg.to_i
    mfactors = factorize(n\)
    printfactorhash(n, mfactors\)
end
#-----------------------------


# @@PLEAC@@_3.0
puts Time.now

print "Today is day ", Time.now.yday, " of the current year.)char(\\n)content("
print "Today is day ", Time.now.day, " of the current month.)char(\\n)content("


# @@PLEAC@@_3.1
day, month, year = Time.now.day, Time.now.month, Time.now.year
# or
day, month, year = Time.now.to_a[3..5]

tl = Time.now.localtime
printf("The current date is %04d %02d %02d)char(\\n)content(", tl.year, tl.month, tl.day\)

Time.now.localtime.strftime("%Y-%m-%d"\)


# @@PLEAC@@_3.2
Time.local(year, month, day, hour, minute, second\).tv_sec
Time.gm(year, month, day, hour, minute, second\).tv_sec


# @@PLEAC@@_3.3
sec, min, hour, day, month, year, wday, yday, isdst, zone = Time.at(epoch_secs\).to_a


# @@PLEAC@@_3.4
when_ = now + difference         # now -> Time ; difference -> Numeric (delta in seconds\)
then_ = now - difference


# @@PLEAC@@_3.5
bree = 361535725
nat  =  96201950

difference = bree - nat
puts "There were )inline<delimiter(#{)ident(difference)delimiter(})>content( seconds between Nat and Bree"

seconds    =  difference % 60
difference = (difference - seconds\) )delimiter(/)> integer(60)
ident(minutes)    operator(=)  ident(difference) operator(%) integer(60)
ident(difference) operator(=) operator(()ident(difference) operator(-) ident(minutes)operator(\)) operator(/) integer(60)
ident(hours)      operator(=)  ident(difference) operator(%) integer(24)
ident(difference) operator(=) operator(()ident(difference) operator(-) ident(hours)operator(\))   operator(/) integer(24)
ident(days)       operator(=)  ident(difference) operator(%) integer(7)
ident(weeks)      operator(=) operator(()ident(difference) operator(-) ident(days)operator(\))    operator(/)  integer(7)

ident(puts) string<delimiter(")content(()inline<delimiter(#{)ident(weeks)delimiter(})>content( weeks, )inline<delimiter(#{)ident(days)delimiter(})>content( days, )inline<delimiter(#{)ident(hours)delimiter(})>content(:)inline<delimiter(#{)ident(minutes)delimiter(})>content(:)inline<delimiter(#{)ident(seconds)delimiter(})>content(\))delimiter(")>


comment(# @@PLEAC@@_3.6)
ident(monthday)operator(,) ident(weekday)operator(,) ident(yearday) operator(=) ident(date)operator(.)ident(mday)operator(,) ident(date)operator(.)ident(wday)operator(,) ident(date)operator(.)ident(yday)

comment(# AFAIK the week number is not just a division since week boundaries are on sundays)
ident(weeknum) operator(=) ident(d)operator(.)ident(strftime)operator(()string<delimiter(")content(%U)delimiter(")>operator(\))operator(.)ident(to_i) operator(+) integer(1)

ident(year)  operator(=) integer(1981)
ident(month) operator(=) string<delimiter(")content(jun)delimiter(")>                     comment(# or `6' if you want to emulate a broken language)
ident(day)   operator(=) integer(16)
ident(t) operator(=) constant(Time)operator(.)ident(mktime)operator(()ident(year)operator(,) ident(month)operator(,) ident(day)operator(\))
ident(print) string<delimiter(")inline<delimiter(#{)ident(month)delimiter(})>content(/)inline<delimiter(#{)ident(day)delimiter(})>content(/)inline<delimiter(#{)ident(year)delimiter(})>content( was a )delimiter(")>operator(,) ident(t)operator(.)ident(strftime)operator(()string<delimiter(")content(%A)delimiter(")>operator(\))operator(,) string<delimiter(")char(\\n)delimiter(")>


comment(# @@PLEAC@@_3.7)
ident(yyyy)operator(,) ident(mm)operator(,) ident(dd) operator(=) global_variable($1)operator(,) global_variable($2)operator(,) global_variable($3) reserved(if) string<delimiter(")content(1998-06-25)delimiter(")> operator(=)operator(~) regexp<delimiter(/)content(()char(\\d)content(+\)-()char(\\d)content(+\)-()char(\\d)content(+\))delimiter(/)>

ident(epoch_seconds) operator(=) constant(Time)operator(.)ident(mktime)operator(()ident(yyyy)operator(,) ident(mm)operator(,) ident(dd)operator(\))operator(.)ident(tv_sec)

comment(# dunno an equivalent to Date::Manip#ParseDate)


comment(# @@PLEAC@@_3.8)
ident(string) operator(=) constant(Time)operator(.)ident(at)operator(()ident(epoch_secs)operator(\))
constant(Time)operator(.)ident(at)operator(()integer(1234567890)operator(\))operator(.)ident(gmtime)        comment(# gives: Fri Feb 13 23:31:30 UTC 2009)

ident(time) operator(=) constant(Time)operator(.)ident(mktime)operator(()integer(1973)operator(,) string<delimiter(")content(jan)delimiter(")>operator(,) integer(18)operator(,) integer(3)operator(,) integer(45)operator(,) integer(50)operator(\))
ident(print) string<delimiter(")content(In localtime it gives: )delimiter(")>operator(,) ident(time)operator(.)ident(localtime)operator(,) string<delimiter(")char(\\n)delimiter(")>


comment(# @@PLEAC@@_3.9)
comment(# Ruby provides micro-seconds in Time object)
constant(Time)operator(.)ident(now)operator(.)ident(usec)

comment(# Ruby gives the seconds in floating format when substracting two Time objects)
ident(before) operator(=) constant(Time)operator(.)ident(now)
ident(line) operator(=) ident(gets)
ident(elapsed) operator(=) constant(Time)operator(.)ident(now) operator(-) ident(before)
ident(puts) string<delimiter(")content(You took )inline<delimiter(#{)ident(elapsed)delimiter(})>content( seconds.)delimiter(")>

comment(# On my Celeron-400 with Linux-2.2.19-14mdk, average for three execs are:)
comment(#   This Ruby version:       average 0.00321 sec)
comment(#   Cookbook's Perl version: average 0.00981 sec)
ident(size) operator(=) integer(500)
ident(number_of_times) operator(=) integer(100)
ident(total_time) operator(=) integer(0)
ident(number_of_times)operator(.)ident(times) operator({)
    comment(# populate array)
    ident(array) operator(=) operator([)operator(])
    ident(size)operator(.)ident(times) operator({) ident(array) operator(<<) ident(rand) operator(})
    comment(# sort it)
    ident(begin_) operator(=) constant(Time)operator(.)ident(now)
    ident(array)operator(.)ident(sort!)
    ident(time) operator(=) constant(Time)operator(.)ident(now) operator(-) ident(begin_)
    ident(total_time) operator(+=) ident(time)
operator(})
ident(printf) string<delimiter(")content(On average, sorting %d random numbers takes %.5f seconds)char(\\n)delimiter(")>operator(,)
    ident(size)operator(,) operator(()ident(total_time)operator(/)ident(Float)operator(()ident(number_of_times)operator(\))operator(\))


comment(# @@PLEAC@@_3.10)
ident(sleep)operator(()float(0.005)operator(\))                      comment(# Ruby is definitely not as broken as Perl :\))
comment(# (may be interrupted by sending the process a SIGALRM\))


comment(# @@PLEAC@@_3.11)
comment(#!/usr/bin/ruby -w)
comment(# hopdelta - feed mail header, produce lines)
comment(#            showing delay at each hop.)
ident(require) string<delimiter(')content(time)delimiter(')>
reserved(class) class(MailHopDelta)

    reserved(def) method(initialize)operator(()ident(mail)operator(\))
        instance_variable(@head) operator(=) ident(mail)operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\n)char(\\s)content(+)delimiter(/)>operator(,)string<delimiter(')content( )delimiter(')>operator(\))
        instance_variable(@topline) operator(=) string<delimiter(%w-)content(Sender Recipient Time Delta)delimiter(-)>
        instance_variable(@start_from) operator(=) ident(mail)operator(.)ident(match)operator(()regexp<delimiter(/)content(^From.*)char(\\@)content(([^)char(\\s)content(>]*\))delimiter(/)>operator(\))operator([)integer(1)operator(])
        instance_variable(@date) operator(=) constant(Time)operator(.)ident(parse)operator(()ident(mail)operator(.)ident(match)operator(()regexp<delimiter(/)content(^Date:)char(\\s)content(+(.*\))delimiter(/)>operator(\))operator([)integer(1)operator(])operator(\))
    reserved(end)

    reserved(def) method(out)operator(()ident(line)operator(\))
         string<delimiter(")content(%-20.20s %-20.20s %-20.20s  %s)delimiter(")> operator(%) ident(line)
    reserved(end)

    reserved(def) method(hop_date)operator(()ident(day)operator(\))
        ident(day)operator(.)ident(strftime)operator(()string<delimiter(")content(%I:%M:%S %Y/%m/%d)delimiter(")>operator(\))
    reserved(end)

    reserved(def) method(puts_hops)
        ident(puts) ident(out)operator(()instance_variable(@topline)operator(\)) 
        ident(puts) ident(out)operator(()operator([)string<delimiter(')content(Start)delimiter(')>operator(,) instance_variable(@start_from)operator(,) ident(hop_date)operator(()instance_variable(@date)operator(\))operator(,)string<delimiter(')delimiter(')>operator(])operator(\))
        instance_variable(@head)operator(.)ident(split)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))operator(.)ident(reverse)operator(.)ident(grep)operator(()regexp<delimiter(/)content(^Received:)delimiter(/)>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(hop)operator(|)
            ident(hop)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\b)content(on (.*?\) (id.*\))delimiter(/)>operator(,)string<delimiter(')content(; )content(\\1)delimiter(')>operator(\))
            ident(whence) operator(=) ident(hop)operator(.)ident(match)operator(()regexp<delimiter(/)content(;)char(\\s)content(+(.*\)$)delimiter(/)>operator(\))operator([)integer(1)operator(])
            reserved(unless) ident(whence)
                ident(warn) string<delimiter(")content(Bad received line: )inline<delimiter(#{)ident(hop)delimiter(})>delimiter(")>
                reserved(next)
            reserved(end)
            ident(from) operator(=) global_variable($+) reserved(if) ident(hop) operator(=)operator(~) regexp<delimiter(/)content(from)char(\\s)content(+()char(\\S)content(+\)|)char(\\()content((.*?\))char(\\\))delimiter(/)>
            ident(by)   operator(=) global_variable($1) reserved(if) ident(hop) operator(=)operator(~) regexp<delimiter(/)content(by)char(\\s)content(+()char(\\S)content(+)char(\\.)char(\\S)content(+\))delimiter(/)>
            reserved(next) reserved(unless) ident(now) operator(=) constant(Time)operator(.)ident(parse)operator(()ident(whence)operator(\))operator(.)ident(localtime)
            ident(delta) operator(=) ident(now) operator(-) instance_variable(@date)
            ident(puts) ident(out)operator(()operator([)ident(from)operator(,) ident(by)operator(,) ident(hop_date)operator(()ident(now)operator(\))operator(,) ident(hop_time)operator(()ident(delta)operator(\))operator(])operator(\))
            instance_variable(@date) operator(=) ident(now)
        reserved(end)
    reserved(end)

    reserved(def) method(hop_time)operator(()ident(secs)operator(\))
        ident(sign) operator(=) ident(secs) operator(<) integer(0) operator(?) integer(-1) operator(:) integer(1)
        ident(days)operator(,) ident(secs) operator(=) ident(secs)operator(.)ident(abs)operator(.)ident(divmod)operator(()integer(60) operator(*) integer(60) operator(*) integer(24)operator(\))
        ident(hours)operator(,)ident(secs) operator(=) ident(secs)operator(.)ident(abs)operator(.)ident(divmod)operator(()integer(60) operator(*) integer(60)operator(\))
        ident(mins)operator(,) ident(secs) operator(=) ident(secs)operator(.)ident(abs)operator(.)ident(divmod)operator(()integer(60)operator(\))
        ident(rtn) operator(=)  string<delimiter(")content(%3ds)delimiter(")> operator(%) operator([)ident(secs)  operator(*) ident(sign)operator(])
        ident(rtn) operator(<<) string<delimiter(")content(%3dm)delimiter(")> operator(%) operator([)ident(mins)  operator(*) ident(sign)operator(]) reserved(if) ident(mins)  operator(!=) integer(0)
        ident(rtn) operator(<<) string<delimiter(")content(%3dh)delimiter(")> operator(%) operator([)ident(hours) operator(*) ident(sign)operator(]) reserved(if) ident(hours) operator(!=) integer(0)
        ident(rtn) operator(<<) string<delimiter(")content(%3dd)delimiter(")> operator(%) operator([)ident(days)  operator(*) ident(sign)operator(]) reserved(if) ident(days)  operator(!=) integer(0) 
        ident(rtn)
    reserved(end)
reserved(end)

global_variable($/) operator(=) string<delimiter(")delimiter(")>
ident(mail) operator(=) constant(MailHopDelta)operator(.)ident(new)operator(()pre_constant(ARGF)operator(.)ident(gets)operator(\))operator(.)ident(puts_hops)


comment(# @@PLEAC@@_4.0)
ident(single_level) operator(=) operator([) string<delimiter(")content(this)delimiter(")>operator(,) string<delimiter(")content(that)delimiter(")>operator(,) string<delimiter(")content(the)delimiter(")>operator(,) string<delimiter(")content(other)delimiter(")> operator(])

comment(# Ruby directly supports nested arrays)
ident(double_level) operator(=) operator([) string<delimiter(")content(this)delimiter(")>operator(,) string<delimiter(")content(that)delimiter(")>operator(,) operator([) string<delimiter(")content(the)delimiter(")>operator(,) string<delimiter(")content(other)delimiter(")> operator(]) operator(])
ident(still_single_level) operator(=) operator([) string<delimiter(")content(this)delimiter(")>operator(,) string<delimiter(")content(that)delimiter(")>operator(,) operator([) string<delimiter(")content(the)delimiter(")>operator(,) string<delimiter(")content(other)delimiter(")> operator(]) operator(])operator(.)ident(flatten)


comment(# @@PLEAC@@_4.1)
ident(a) operator(=) operator([) string<delimiter(")content(quick)delimiter(")>operator(,) string<delimiter(")content(brown)delimiter(")>operator(,) string<delimiter(")content(fox)delimiter(")> operator(])
ident(a) operator(=) string<delimiter(%w()content(Why are you teasing me?)delimiter(\))>

ident(lines) operator(=) string<delimiter(<<"END_OF_HERE_DOC")>operator(.)ident(gsub)operator(()regexp<delimiter(/)content(^)char(\\s)content(*(.+\))delimiter(/)>operator(,) string<delimiter(')content(\\1)delimiter(')>operator(\))string<content(
    The boy stood on the burning deck,
    It was as hot as glass.)delimiter(
END_OF_HERE_DOC)>

ident(bigarray) operator(=) constant(IO)operator(.)ident(readlines)operator(()string<delimiter(")content(mydatafile)delimiter(")>operator(\))operator(.)ident(collect) operator({) operator(|)ident(l)operator(|) ident(l)operator(.)ident(chomp) operator(})

ident(name) operator(=) string<delimiter(")content(Gandalf)delimiter(")>
ident(banner) operator(=) string<delimiter(%Q()content(Speak, )inline<delimiter(#{)ident(name)delimiter(})>content(, and welcome!)delimiter(\))>

ident(host_info)  operator(=) shell<delimiter(`)content(host )inline<delimiter(#{)ident(his_host)delimiter(})>delimiter(`)>

shell<delimiter(%x()content(ps )inline<delimiter(#{)global_variable($$)delimiter(})>delimiter(\))>

ident(banner) operator(=) string<delimiter(')content(Costs only $4.95)delimiter(')>operator(.)ident(split)operator(()string<delimiter(')content( )delimiter(')>operator(\))

ident(rax) operator(=) string<delimiter(%w!)content( ( \) < > { } [ ] )delimiter(!)>


comment(# @@PLEAC@@_4.2)
reserved(def) method(commify_series)operator(()ident(arr)operator(\))
    reserved(return) string<delimiter(')delimiter(')> reserved(if) reserved(not) ident(arr)
    reserved(case) ident(arr)operator(.)ident(size)
        reserved(when) integer(0) reserved(then) string<delimiter(')delimiter(')>
        reserved(when) integer(1) reserved(then) ident(arr)operator([)integer(0)operator(])
        reserved(when) integer(2) reserved(then) ident(arr)operator(.)ident(join)operator(()string<delimiter(')content( and )delimiter(')>operator(\))
        reserved(else) ident(arr)operator([)integer(0)operator(..)integer(-2)operator(])operator(.)ident(join)operator(()string<delimiter(')content(, )delimiter(')>operator(\)) operator(+) string<delimiter(')content(, and )delimiter(')> operator(+) ident(arr)operator([)integer(-1)operator(])
    reserved(end)
reserved(end)

ident(array) operator(=) operator([) string<delimiter(")content(red)delimiter(")>operator(,) string<delimiter(")content(yellow)delimiter(")>operator(,) string<delimiter(")content(green)delimiter(")> operator(])

ident(print) string<delimiter(")content(I have )delimiter(")>operator(,) ident(array)operator(,) string<delimiter(")content( marbles)char(\\n)delimiter(")>
comment(# -> I have redyellowgreen marbles)

comment(# But unlike Perl:)
ident(print) string<delimiter(")content(I have )inline<delimiter(#{)ident(array)delimiter(})>content( marbles)char(\\n)delimiter(")>
comment(# -> I have redyellowgreen marbles)
comment(# So, needs:)
ident(print) string<delimiter(")content(I have )inline<delimiter(#{)ident(array)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>content( marbles)char(\\n)delimiter(")>
comment(# -> I have red yellow green marbles)

comment(#!/usr/bin/ruby)
comment(# communify_series - show proper comma insertion in list output)

reserved(def) method(commify_series)operator(()ident(arr)operator(\))
    reserved(return) string<delimiter(')delimiter(')> reserved(if) reserved(not) ident(arr)
    ident(sepchar) operator(=) ident(arr)operator(.)ident(find) operator({) operator(|)ident(p)operator(|) ident(p) operator(=)operator(~) regexp<delimiter(/)content(,)delimiter(/)> operator(}) operator(?) string<delimiter(')content(; )delimiter(')> operator(:) string<delimiter(')content(, )delimiter(')>
    reserved(case) ident(arr)operator(.)ident(size)
        reserved(when) integer(0) reserved(then) string<delimiter(')delimiter(')>
        reserved(when) integer(1) reserved(then) ident(arr)operator([)integer(0)operator(])
        reserved(when) integer(2) reserved(then) ident(arr)operator(.)ident(join)operator(()string<delimiter(')content( and )delimiter(')>operator(\))
        reserved(else) ident(arr)operator([)integer(0)operator(..)integer(-2)operator(])operator(.)ident(join)operator(()ident(sepchar)operator(\)) operator(+) ident(sepchar) operator(+) string<delimiter(')content(and )delimiter(')> operator(+) ident(arr)operator([)integer(-1)operator(])
    reserved(end)
reserved(end)

ident(lists) operator(=) operator([)
    operator([) string<delimiter(')content(just one thing)delimiter(')> operator(])operator(,)
    string<delimiter(%w()content(Mutt Jeff)delimiter(\))>operator(,)
    string<delimiter(%w()content(Peter Paul Mary)delimiter(\))>operator(,)
    operator([) string<delimiter(')content(To our parents)delimiter(')>operator(,) string<delimiter(')content(Mother Theresa)delimiter(')>operator(,) string<delimiter(')content(God)delimiter(')> operator(])operator(,)
    operator([) string<delimiter(')content(pastrami)delimiter(')>operator(,) string<delimiter(')content(ham and cheese)delimiter(')>operator(,) string<delimiter(')content(peanut butter and jelly)delimiter(')>operator(,) string<delimiter(')content(tuna)delimiter(')> operator(])operator(,)
    operator([) string<delimiter(')content(recycle tired, old phrases)delimiter(')>operator(,) string<delimiter(')content(ponder big, happy thoughts)delimiter(')> operator(])operator(,)
    operator([) string<delimiter(')content(recycle tired, old phrases)delimiter(')>operator(,)
      string<delimiter(')content(ponder big, happy thoughts)delimiter(')>operator(,)
      string<delimiter(')content(sleep and dream peacefully)delimiter(')> operator(])operator(,)
operator(])

reserved(for) ident(list) reserved(in) ident(lists) reserved(do)
    ident(puts) string<delimiter(")content(The list is: )inline<delimiter(#{)ident(commify_series)operator(()ident(list)operator(\))delimiter(})>content(.)delimiter(")>
reserved(end)


comment(# @@PLEAC@@_4.3)
comment(#   (note: AFAIK Ruby doesn't allow gory change of Array length\))
comment(# grow the array by assigning nil to past the end of array)
ident(ary)operator([)ident(new_size)integer(-1)operator(]) operator(=) pre_constant(nil)
comment(# shrink the array by slicing it down)
ident(ary)operator(.)ident(slice!)operator(()ident(new_size)operator(..)integer(-1)operator(\))
comment(# init the array with given size)
constant(Array)operator(.)ident(new)operator(()ident(number_of_elems)operator(\))
comment(# assign to an element past the original end enlarges the array)
ident(ary)operator([)ident(index_new_last_elem)operator(]) operator(=) ident(value)

reserved(def) method(what_about_that_array)operator(()ident(a)operator(\))
    ident(print) string<delimiter(")content(The array now has )delimiter(")>operator(,) ident(a)operator(.)ident(size)operator(,) string<delimiter(")content( elements.)char(\\n)delimiter(")>
    comment(# Index of last element is not really interesting in Ruby)
    ident(print) string<delimiter(")content(Element #3 is `)inline<delimiter(#{)ident(a)operator([)integer(3)operator(])delimiter(})>content('.)char(\\n)delimiter(")>
reserved(end)
ident(people) operator(=) string<delimiter(%w()content(Crosby Stills Nash Young)delimiter(\))>
ident(what_about_that_array)operator(()ident(people)operator(\))


comment(# @@PLEAC@@_4.4)
comment(# OO style)
ident(bad_users)operator(.)ident(each) operator({) operator(|)ident(user)operator(|)
    ident(complain)operator(()ident(user)operator(\))
operator(})
comment(# or, functional style)
reserved(for) ident(user) reserved(in) ident(bad_users)
    ident(complain)operator(()ident(user)operator(\))
reserved(end)

reserved(for) ident(var) reserved(in) constant(ENV)operator(.)ident(keys)operator(.)ident(sort)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(var)delimiter(})>content(=)inline<delimiter(#{)constant(ENV)operator([)ident(var)operator(])delimiter(})>delimiter(")>
reserved(end)

reserved(for) ident(user) reserved(in) ident(all_users)
    ident(disk_space) operator(=) ident(get_usage)operator(()ident(user)operator(\))
    reserved(if) operator(()ident(disk_space) operator(>) constant(MAX_QUOTA)operator(\))
        ident(complain)operator(()ident(user)operator(\))
    reserved(end)
reserved(end)

reserved(for) ident(l) reserved(in) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(who)delimiter(")>operator(\))operator(.)ident(readlines)
    ident(print) ident(l) reserved(if) ident(l) operator(=)operator(~) regexp<delimiter(/)content(^gc)delimiter(/)> 
reserved(end)

comment(# we can mimic the obfuscated Perl way)
reserved(while) ident(fh)operator(.)ident(gets)               comment(# $_ is set to the line just read)
    ident(chomp)                   comment(# $_ has a trailing \\n removed, if it had one)
    ident(split)operator(.)ident(each) operator({) operator(|)ident(w)operator(|)        comment(# $_ is split on whitespace)
                            comment(# but $_ is not set to each chunk as in Perl)
        ident(print) ident(w)operator(.)ident(reverse)
    operator(})
reserved(end)
comment(# ...or use a cleaner way)
reserved(for) ident(l) reserved(in) ident(fh)operator(.)ident(readlines)
    ident(l)operator(.)ident(chomp)operator(.)ident(split)operator(.)ident(each) operator({) operator(|)ident(w)operator(|) ident(print) ident(w)operator(.)ident(reverse) operator(})
reserved(end)

comment(# same drawback as in problem 1.4, we can't mutate a Numeric...)
ident(array)operator(.)ident(collect!) operator({) operator(|)ident(v)operator(|) ident(v) operator(-) integer(1) operator(})

ident(a) operator(=) operator([) operator(.)integer(5)operator(,) integer(3) operator(])operator(;) ident(b) operator(=) operator([) integer(0)operator(,) integer(1) operator(])
reserved(for) ident(ary) reserved(in) operator([) ident(a)operator(,) ident(b) operator(])
    ident(ary)operator(.)ident(collect!) operator({) operator(|)ident(v)operator(|) ident(v) operator(*) integer(7) operator(})
reserved(end)
ident(puts) string<delimiter(")inline<delimiter(#{)ident(a)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>content( )inline<delimiter(#{)ident(b)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>delimiter(")>

comment(# we can mutate Strings, cool; we need a trick for the scalar)
reserved(for) ident(ary) reserved(in) operator([) operator([) ident(scalar) operator(])operator(,) ident(array)operator(,) ident(hash)operator(.)ident(values) operator(])
    ident(ary)operator(.)ident(each) operator({) operator(|)ident(v)operator(|) ident(v)operator(.)ident(strip!) operator(})     comment(# String#strip rules :\))
reserved(end)


comment(# @@PLEAC@@_4.5)
comment(# not relevant in Ruby since we have always references)
reserved(for) ident(item) reserved(in) ident(array)
    comment(# do somethingh with item)
reserved(end)


comment(# @@PLEAC@@_4.6)
ident(unique) operator(=) ident(list)operator(.)ident(uniq)

comment(# generate a list of users logged in, removing duplicates)
ident(users) operator(=) shell<delimiter(`)content(who)delimiter(`)>operator(.)ident(collect) operator({) operator(|)ident(l)operator(|) ident(l) operator(=)operator(~) regexp<delimiter(/)content(()char(\\w)content(+\))delimiter(/)>operator(;) global_variable($1) operator(})operator(.)ident(sort)operator(.)ident(uniq)
ident(puts)operator(()string<delimiter(")content(users logged in: )inline<delimiter(#{)ident(commify_series)operator(()ident(users)operator(\))delimiter(})>delimiter(")>operator(\))  comment(# see 4.2 for commify_series)


comment(# @@PLEAC@@_4.7)
ident(a) operator(-) ident(b)
comment(# [ 1, 1, 2, 2, 3, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  ->  [3, 5])


comment(# @@PLEAC@@_4.8)
ident(union) operator(=) ident(a) operator(|) ident(b)
ident(intersection) operator(=) ident(a) operator(&) ident(b)
ident(difference) operator(=) ident(a) operator(-) ident(b)


comment(# @@PLEAC@@_4.9)
ident(array1)operator(.)ident(concat)operator(()ident(array2)operator(\))
comment(# if you will assign to another object, better use:)
ident(new_ary) operator(=) ident(array1) operator(+) ident(array2)

ident(members) operator(=) operator([) string<delimiter(")content(Time)delimiter(")>operator(,) string<delimiter(")content(Flies)delimiter(")> operator(])
ident(initiates) operator(=)  operator([) string<delimiter(")content(An)delimiter(")>operator(,) string<delimiter(")content(Arrow)delimiter(")> operator(])
ident(members) operator(+=) ident(initiates)

ident(members) operator(=) operator([) string<delimiter(")content(Time)delimiter(")>operator(,) string<delimiter(")content(Flies)delimiter(")> operator(])
ident(initiates) operator(=) operator([) string<delimiter(")content(An)delimiter(")>operator(,) string<delimiter(")content(Arrow)delimiter(")> operator(])
ident(members)operator([)integer(2)operator(,)integer(0)operator(]) operator(=) operator([) string<delimiter(")content(Like)delimiter(")>operator(,) ident(initiates) operator(])operator(.)ident(flatten)

ident(members)operator([)integer(0)operator(]) operator(=) string<delimiter(")content(Fruit)delimiter(")>
ident(members)operator([)integer(3)operator(,)integer(2)operator(]) operator(=) string<delimiter(")content(A)delimiter(")>operator(,) string<delimiter(")content(Banana)delimiter(")>


comment(# @@PLEAC@@_4.10)
ident(reversed) operator(=) ident(ary)operator(.)ident(reverse)

ident(ary)operator(.)ident(reverse_each) operator({) operator(|)ident(e)operator(|)
    comment(# do something with e)
operator(})

ident(descending) operator(=) ident(ary)operator(.)ident(sort)operator(.)ident(reverse)
ident(descending) operator(=) ident(ary)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(b) operator(<=>) ident(a) operator(})


comment(# @@PLEAC@@_4.11)
comment(# remove n elements from front of ary (shift n\))
ident(front) operator(=) ident(ary)operator(.)ident(slice!)operator(()integer(0)operator(,) ident(n)operator(\))

comment(# remove n elements from the end of ary (pop n\))
ident(end_) operator(=) ident(ary)operator(.)ident(slice!)operator(()operator(-)ident(n) operator(..) integer(-1)operator(\))

comment(# let's extend the Array class, to make that useful)
reserved(class) class(Array)
    reserved(def) method(shift2)operator(()operator(\))
        ident(slice!)operator(()integer(0) operator(..) integer(1)operator(\))     comment(# more symetric with pop2...)
    reserved(end)
    reserved(def) method(pop2)operator(()operator(\))
        ident(slice!)operator(()integer(-2) operator(..) integer(-1)operator(\))
    reserved(end)
reserved(end)

ident(friends) operator(=) string<delimiter(%w()content(Peter Paul Mary Jim Tim)delimiter(\))>
ident(this)operator(,) ident(that) operator(=) ident(friends)operator(.)ident(shift2)

ident(beverages) operator(=) string<delimiter(%w()content(Dew Jolt Cola Sprite Fresca)delimiter(\))>
ident(pair) operator(=) ident(beverages)operator(.)ident(pop2)


comment(# @@PLEAC@@_4.12)
comment(# use Enumerable#detect (or the synonym Enumerable#find\))
ident(highest_eng) operator(=) ident(employees)operator(.)ident(detect) operator({) operator(|)ident(emp)operator(|) ident(emp)operator(.)ident(category) operator(==) string<delimiter(')content(engineer)delimiter(')> operator(})


comment(# @@PLEAC@@_4.13)
comment(# use Enumerable#select (or the synonym Enumerable#find_all\))
ident(bigs) operator(=) ident(nums)operator(.)ident(select) operator({) operator(|)ident(i)operator(|) ident(i) operator(>) integer(1_000_000) operator(})
ident(pigs) operator(=) ident(users)operator(.)ident(keys)operator(.)ident(select) operator({) operator(|)ident(k)operator(|) ident(users)operator([)ident(k)operator(]) operator(>) float(1e7) operator(})

ident(matching) operator(=) shell<delimiter(`)content(who)delimiter(`)>operator(.)ident(select) operator({) operator(|)ident(u)operator(|) ident(u) operator(=)operator(~) regexp<delimiter(/)content(^gnat )delimiter(/)> operator(})

ident(engineers) operator(=) ident(employees)operator(.)ident(select) operator({) operator(|)ident(e)operator(|) ident(e)operator(.)ident(position) operator(==) string<delimiter(')content(Engineer)delimiter(')> operator(})

ident(secondary_assistance) operator(=) ident(applicants)operator(.)ident(select) operator({) operator(|)ident(a)operator(|)
    ident(a)operator(.)ident(income) operator(>)operator(=) integer(26_000) operator(&&) ident(a)operator(.)ident(income) operator(<) integer(30_000)
operator(})


comment(# @@PLEAC@@_4.14)
comment(# normally you would have an array of Numeric (Float or)
comment(# Fixnum or Bignum\), so you would use:)
ident(sorted) operator(=) ident(unsorted)operator(.)ident(sort)
comment(# if you have strings representing Integers or Floats)
comment(# you may specify another sort method:)
ident(sorted) operator(=) ident(unsorted)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator(.)ident(to_f) operator(<=>) ident(b)operator(.)ident(to_f) operator(})

comment(# let's use the list of my own PID's)
shell<delimiter(`)content(ps ux)delimiter(`)>operator(.)ident(split)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))operator([)integer(1)operator(..)integer(-1)operator(])operator(.)
    ident(select) operator({) operator(|)ident(i)operator(|) ident(i) operator(=)operator(~) regexp<delimiter(/)content(^)inline<delimiter(#{)constant(ENV)operator([)string<delimiter(')content(USER)delimiter(')>operator(])delimiter(})>delimiter(/)> operator(})operator(.)
    ident(collect) operator({) operator(|)ident(i)operator(|) ident(i)operator(.)ident(split)operator([)integer(1)operator(]) operator(})operator(.)
    ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator(.)ident(to_i) operator(<=>) ident(b)operator(.)ident(to_i) operator(})operator(.)ident(each) operator({) operator(|)ident(i)operator(|) ident(puts) ident(i) operator(})
ident(puts) string<delimiter(")content(Select a process ID to kill:)delimiter(")>
ident(pid) operator(=) ident(gets)operator(.)ident(chomp)
ident(raise) string<delimiter(")content(Exiting ... )char(\\n)delimiter(")> reserved(unless) ident(pid) operator(&&) ident(pid) operator(=)operator(~) regexp<delimiter(/)content(^)char(\\d)content(+$)delimiter(/)>
constant(Process)operator(.)ident(kill)operator(()string<delimiter(')content(TERM)delimiter(')>operator(,) ident(pid)operator(.)ident(to_i)operator(\))
ident(sleep) integer(2)
constant(Process)operator(.)ident(kill)operator(()string<delimiter(')content(KILL)delimiter(')>operator(,) ident(pid)operator(.)ident(to_i)operator(\))

ident(descending) operator(=) ident(unsorted)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(b)operator(.)ident(to_f) operator(<=>) ident(a)operator(.)ident(to_f) operator(})


comment(# @@PLEAC@@_4.15)
ident(ordered) operator(=) ident(unordered)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(compare)operator(()ident(a)operator(,)ident(b)operator(\)) operator(})

ident(precomputed) operator(=) ident(unordered)operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) operator([)ident(compute)operator(,) ident(e)operator(]) operator(})
ident(ordered_precomputed) operator(=) ident(precomputed)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})
ident(ordered) operator(=) ident(ordered_precomputed)operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) ident(e)operator([)integer(1)operator(]) operator(})

ident(ordered) operator(=) ident(unordered)operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) operator([)ident(compute)operator(,) ident(e)operator(]) operator(})operator(.)
    ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})operator(.)
    ident(collect) operator({) operator(|)ident(e)operator(|) ident(e)operator([)integer(1)operator(]) operator(})

reserved(for) ident(employee) reserved(in) ident(employees)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator(.)ident(name) operator(<=>) ident(b)operator(.)ident(name) operator(})
    ident(print) ident(employee)operator(.)ident(name)operator(,) string<delimiter(")content( earns )char(\\$)content( )delimiter(")>operator(,) ident(employee)operator(.)ident(salary)operator(,) string<delimiter(")char(\\n)delimiter(")>
reserved(end)

comment(# Beware! `0' is true in Ruby.)
comment(# For chaining comparisons, you may use Numeric#nonzero?, which)
comment(# returns num if num is not zero, nil otherwise)
ident(sorted) operator(=) ident(employees)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) operator(()ident(a)operator(.)ident(name) operator(<=>) ident(b)operator(.)ident(name)operator(\))operator(.)ident(nonzero?) operator(||) ident(b)operator(.)ident(age) operator(<=>) ident(a)operator(.)ident(age) operator(})

ident(users) operator(=) operator([)operator(])
comment(# getpwent is not wrapped in Ruby... let's fallback)
constant(IO)operator(.)ident(readlines)operator(()string<delimiter(')content(/etc/passwd)delimiter(')>operator(\))operator(.)ident(each) operator({) operator(|)ident(u)operator(|) ident(users) operator(<<) ident(u)operator(.)ident(split)operator(()string<delimiter(')content(:)delimiter(')>operator(\)) operator(})
ident(users)operator(.)ident(sort!) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})
reserved(for) ident(user) reserved(in) ident(users)
    ident(puts) ident(user)operator([)integer(0)operator(])
reserved(end)

ident(sorted) operator(=) ident(names)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(1)operator(,) integer(1)operator(]) operator(<=>) ident(b)operator([)integer(1)operator(,) integer(1)operator(]) operator(})
ident(sorted) operator(=) ident(strings)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator(.)ident(length) operator(<=>) ident(b)operator(.)ident(length) operator(})

comment(# let's show only the compact version)
ident(ordered) operator(=) ident(strings)operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) operator([)ident(e)operator(.)ident(length)operator(,) ident(e)operator(]) operator(})operator(.)
    ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})operator(.)
    ident(collect) operator({) operator(|)ident(e)operator(|) ident(e)operator([)integer(1)operator(]) operator(})

ident(ordered) operator(=) ident(strings)operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) operator([)regexp<delimiter(/)char(\\d)content(+)delimiter(/)>operator(.)ident(match)operator(()ident(e)operator(\))operator([)integer(0)operator(])operator(.)ident(to_i)operator(,) ident(e)operator(]) operator(})operator(.)
    ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})operator(.)
    ident(collect) operator({) operator(|)ident(e)operator(|) ident(e)operator([)integer(1)operator(]) operator(})

ident(print) shell<delimiter(`)content(cat /etc/passwd)delimiter(`)>operator(.)ident(collect) operator({) operator(|)ident(e)operator(|) operator([)ident(e)operator(,) ident(e)operator(.)ident(split)operator(()string<delimiter(')content(:)delimiter(')>operator(\))operator(.)ident(indexes)operator(()integer(3)operator(,)integer(2)operator(,)integer(0)operator(\))operator(])operator(.)ident(flatten) operator(})operator(.)
    ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) operator(()ident(a)operator([)integer(1)operator(]) operator(<=>) ident(b)operator([)integer(1)operator(])operator(\))operator(.)ident(nonzero?) operator(||) operator(()ident(a)operator([)integer(2)operator(]) operator(<=>) ident(b)operator([)integer(2)operator(])operator(\))operator(.)ident(nonzero?) operator(||) ident(a)operator([)integer(3)operator(]) operator(<=>) ident(b)operator([)integer(3)operator(]) operator(})operator(.)
    ident(collect) operator({) operator(|)ident(e)operator(|) ident(e)operator([)integer(0)operator(]) operator(})


comment(# @@PLEAC@@_4.16)
ident(circular)operator(.)ident(unshift)operator(()ident(circular)operator(.)ident(pop)operator(\))        comment(# the last shall be first)
ident(circular)operator(.)ident(push)operator(()ident(circular)operator(.)ident(shift)operator(\))         comment(# and vice versa)

reserved(def) method(grab_and_rotate)operator(()ident(l)operator(\))
    ident(l)operator(.)ident(push)operator(()ident(ret) operator(=) ident(l)operator(.)ident(shift)operator(\))
    ident(ret)
reserved(end)

ident(processes) operator(=) operator([)integer(1)operator(,) integer(2)operator(,) integer(3)operator(,) integer(4)operator(,) integer(5)operator(])
reserved(while) operator(()integer(1)operator(\))
    ident(process) operator(=) ident(grab_and_rotate)operator(()ident(processes)operator(\))
    ident(puts) string<delimiter(")content(Handling process )inline<delimiter(#{)ident(process)delimiter(})>delimiter(")>
    ident(sleep) integer(1)
reserved(end)


comment(# @@PLEAC@@_4.17)
reserved(def) method(fisher_yates_shuffle)operator(()ident(a)operator(\))
    operator(()ident(a)operator(.)ident(size)integer(-1)operator(\))operator(.)ident(downto)operator(()integer(1)operator(\)) operator({) operator(|)ident(i)operator(|)
        ident(j) operator(=) ident(rand)operator(()ident(i)integer(+1)operator(\))
        ident(a)operator([)ident(i)operator(])operator(,) ident(a)operator([)ident(j)operator(]) operator(=) ident(a)operator([)ident(j)operator(])operator(,) ident(a)operator([)ident(i)operator(]) reserved(if) ident(i) operator(!=) ident(j)
    operator(})
reserved(end)

reserved(def) method(naive_shuffle)operator(()ident(a)operator(\))
    reserved(for) ident(i) reserved(in) integer(0)operator(...)ident(a)operator(.)ident(size)
        ident(j) operator(=) ident(rand)operator(()ident(a)operator(.)ident(size)operator(\))
        ident(a)operator([)ident(i)operator(])operator(,) ident(a)operator([)ident(j)operator(]) operator(=) ident(a)operator([)ident(j)operator(])operator(,) ident(a)operator([)ident(i)operator(])
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_4.18)
comment(#!/usr/bin/env ruby)
comment(# example 4-2 words)
comment(# words - gather lines, present in colums)

comment(# class to encapsulate the word formatting from the input)
reserved(class) class(WordFormatter)
    reserved(def) method(initialize)operator(()ident(cols)operator(\))
        instance_variable(@cols) operator(=) ident(cols)
    reserved(end)

    comment(# helper to return the length of the longest word in the wordlist)
    reserved(def) method(maxlen)operator(()ident(wordlist)operator(\))
        ident(max) operator(=) integer(1)
        reserved(for) ident(word) reserved(in) ident(wordlist)
            reserved(if) ident(word)operator(.)ident(length) operator(>) ident(max)
                ident(max) operator(=) ident(word)operator(.)ident(length)
            reserved(end)
        reserved(end)
        ident(max)
    reserved(end)

    comment(# process the wordlist and print it formmated into columns)
    reserved(def) method(output)operator(()ident(wordlist)operator(\))
        ident(collen) operator(=) ident(maxlen)operator(()ident(wordlist)operator(\)) operator(+) integer(1)
        ident(columns) operator(=) instance_variable(@cols) operator(/) ident(collen)
        ident(columns) operator(=) integer(1) reserved(if) ident(columns) operator(==) integer(0)
        ident(rows) operator(=) operator(()ident(wordlist)operator(.)ident(length) operator(+) ident(columns) operator(-) integer(1)operator(\)) operator(/) ident(columns)
        comment(# now process each item, picking out proper piece for this position)
        integer(0)operator(.)ident(upto)operator(()ident(rows) operator(*) ident(columns) operator(-) integer(1)operator(\)) operator({) operator(|)ident(item)operator(|)
            ident(target) operator(=) operator(()ident(item) operator(%) ident(columns)operator(\)) operator(*) ident(rows) operator(+) operator(()ident(item) operator(/) ident(columns)operator(\))
            ident(eol) operator(=) operator(()operator(()ident(item)integer(+1)operator(\)) operator(%) ident(columns) operator(==) integer(0)operator(\))
            ident(piece) operator(=) ident(wordlist)operator([)ident(target)operator(]) operator(||) string<delimiter(")delimiter(")>
            ident(piece) operator(=) ident(piece)operator(.)ident(ljust)operator(()ident(collen)operator(\)) reserved(unless) ident(eol)
            ident(print) ident(piece)
            ident(puts) reserved(if) ident(eol)
        operator(})
        comment(# no need to finish it up, because eol is always true for the last element)
    reserved(end)
reserved(end)

comment(# get nr of chars that fit in window or console, see PLEAC 15.4)
comment(# not portable -- linux only (?\))
reserved(def) method(getWinCharWidth)operator(()operator(\))
    ident(buf) operator(=) string<delimiter(")char(\\0)delimiter(")> operator(*) integer(8)
    global_variable($stdout)operator(.)ident(ioctl)operator(()integer(0x5413)operator(,) ident(buf)operator(\))
    ident(ws_row)operator(,) ident(ws_col)operator(,) ident(ws_xpixel)operator(,) ident(ws_ypixel) operator(=) ident(buf)operator(.)ident(unpack)operator(()string<delimiter(")content($4)delimiter(")>operator(\))
    ident(ws_col) operator(||) integer(80)
reserved(rescue)
    integer(80)
reserved(end)

comment(# main program)
ident(cols) operator(=) ident(getWinCharWidth)operator(()operator(\))
ident(formatter) operator(=) constant(WordFormatter)operator(.)ident(new)operator(()ident(cols)operator(\))
ident(words) operator(=) ident(readlines)operator(()operator(\))
ident(words)operator(.)ident(collect!) operator({) operator(|)ident(line)operator(|)
    ident(line)operator(.)ident(chomp)
operator(})
ident(formatter)operator(.)ident(output)operator(()ident(words)operator(\))


comment(# @@PLEAC@@_4.19)
comment(# In ruby, Fixnum's are automatically converted to Bignum's when)
comment(# needed, so there is no need for an extra module)
reserved(def) method(factorial)operator(()ident(n)operator(\))
    ident(s) operator(=) integer(1)
    reserved(while) ident(n) operator(>) integer(0)
        ident(s) operator(*=) ident(n)
        ident(n) operator(-=) integer(1)
    reserved(end)
    ident(s)
reserved(end)

ident(puts) ident(factorial)operator(()integer(500)operator(\))

comment(#---------------------------------------------------------)
comment(# Example 4-3. tsc-permute)
comment(# tsc_permute: permute each word of input)
reserved(def) method(permute)operator(()ident(items)operator(,) ident(perms)operator(\))
    reserved(unless) ident(items)operator(.)ident(length) operator(>) integer(0)
        ident(puts) ident(perms)operator(.)ident(join)operator(()string<delimiter(")content( )delimiter(")>operator(\))
    reserved(else)
        reserved(for) ident(i) reserved(in) ident(items)
            ident(newitems) operator(=) ident(items)operator(.)ident(dup)
            ident(newperms) operator(=) ident(perms)operator(.)ident(dup)
            ident(newperms)operator(.)ident(unshift)operator(()ident(newitems)operator(.)ident(delete)operator(()ident(i)operator(\))operator(\))
            ident(permute)operator(()ident(newitems)operator(,) ident(newperms)operator(\))
        reserved(end)
    reserved(end)
reserved(end)
comment(# In ruby the main program must be after all definitions it is using)
ident(permute)operator(()pre_constant(ARGV)operator(,) operator([)operator(])operator(\))

comment(#---------------------------------------------------------)
comment(# mjd_permute: permute each word of input)

reserved(def) method(factorial)operator(()ident(n)operator(\))
    ident(s) operator(=) integer(1)
    reserved(while) ident(n) operator(>) integer(0)
        ident(s) operator(*=) ident(n)
        ident(n) operator(-=) integer(1)
    reserved(end)
    ident(s)
reserved(end)

comment(# we use a class with a class variable store the private cache)
comment(# for the results of the factorial function.)
reserved(class) class(Factorial)
    class_variable(@@fact) operator(=) operator([) integer(1) operator(])
    reserved(def) constant(Factorial)operator(.)ident(compute)operator(()ident(n)operator(\))
        reserved(if) class_variable(@@fact)operator([)ident(n)operator(])
            class_variable(@@fact)operator([)ident(n)operator(])
        reserved(else)
            class_variable(@@fact)operator([)ident(n)operator(]) operator(=) ident(n) operator(*) constant(Factorial)operator(.)ident(compute)operator(()ident(n) operator(-) integer(1)operator(\))
        reserved(end)
    reserved(end)
reserved(end)

comment(#---------------------------------------------------------)
comment(# Example 4-4- mjd-permute)
comment(# n2pat(n, len\): produce the N-th pattern of length len)

comment(# We must use a lower case letter as parameter N, otherwise it is)
comment(# handled as constant Length is the length of the resulting)
comment(# array, not the index of the last element (length -1\) like in)
comment(# the perl example.)
reserved(def) method(n2pat)operator(()ident(n)operator(,) ident(length)operator(\))
    ident(pat) operator(=) operator([)operator(])
    ident(i) operator(=) integer(1)
    reserved(while) ident(i) operator(<=) ident(length)
        ident(pat)operator(.)ident(push)operator(()ident(n) operator(%) ident(i)operator(\))
        ident(n) regexp<delimiter(/)content(= i
        i += 1
    end
    pat
end

# pat2perm(pat\): turn pattern returned by n2pat(\) into
# permutation of integers.
def pat2perm(pat\)
    source = (0 .. pat.length - 1\).to_a
    perm = []
    perm.push(source.slice!(pat.pop\)\) while pat.length > 0
    perm
end

def n2perm(n, len\)
    pat2perm(n2pat(n,len\)\)
end

# In ruby the main program must be after all definitions
while gets
    data = split
    # the perl solution has used $#data, which is length-1
    num_permutations = Factorial.compute(data.length(\)\)
    0.upto(num_permutations - 1\) do |i|
        # in ruby we can not use an array as selector for an array
        # but by exchanging the two arrays, we can use the collect method
        # which returns an array with the result of all block invocations
        permutation = n2perm(i, data.length\).collect {
            |j| data[j]
        }
        puts permutation.join(" "\)
    end
end


# @@PLEAC@@_5.0
age = { "Nat",   24,
        "Jules", 25,
        "Josh",  17  }

age["Nat"]   = 24
age["Jules"] = 25
age["Josh"]  = 17

food_color = {
    "Apple"  => "red",
    "Banana" => "yellow",
    "Lemon"  => "yellow",
    "Carrot" => "orange"
             }

# In Ruby, you cannot avoid the double or simple quoting
# while manipulatin hashes


# @@PLEAC@@_5.1
hash[key] = value

food_color["Raspberry"] = "pink"
puts "Known foods:", food_color.keys


# @@PLEAC@@_5.2
# does hash have a value for key ?
if (hash.has_key?(key\)\)
    # it exists
else
    # it doesn't
end

[ "Banana", "Martini" ].each { |name|
    print name, " is a ", food_color.has_key?(name\) ? "food" : "drink", ")char(\\n)content("
}

age = {}
age['Toddler'] = 3
age['Unborn'] = 0
age['Phantasm'] = nil

for thing in ['Toddler', 'Unborn', 'Phantasm', 'Relic']
    print ")inline<delimiter(#{)ident(thing)delimiter(})>content(: "
    print "Has-key " if age.has_key?(thing\)
    print "True " if age[thing]
    print "Nonzero " if age[thing] && age[thing].nonzero?
    print ")char(\\n)content("
end

#=>
# Toddler: Has-key True Nonzero 
# Unborn: Has-key True 
# Phantasm: Has-key 
# Relic: 

# You use Hash#has_key? when you use Perl's exists -> it checks
# for existence of a key in a hash.
# All Numeric are "True" in ruby, so the test doesn't have the
# same semantics as in Perl; you would use Numeric#nonzero? to
# achieve the same semantics (false if 0, true otherwise\).


# @@PLEAC@@_5.3
food_color.delete("Banana"\)


# @@PLEAC@@_5.4
hash.each { |key, value|
    # do something with key and value
}

hash.each_key { |key|
    # do something with key
}

food_color.each { |food, color|
    puts ")inline<delimiter(#{)ident(food)delimiter(})>content( is )inline<delimiter(#{)ident(color)delimiter(})>content("
}

food_color.each_key { |food|
    puts ")inline<delimiter(#{)ident(food)delimiter(})>content( is )inline<delimiter(#{)ident(food_color)operator([)ident(food)operator(])delimiter(})>content("
}

# IMO this demonstrates that OO style is by far more readable
food_color.keys.sort.each { |food|
    puts ")inline<delimiter(#{)ident(food)delimiter(})>content( is )inline<delimiter(#{)ident(food_color)operator([)ident(food)operator(])delimiter(})>content(."
}

#-----------------------------
#!)delimiter(/)modifier(us)>ident(r)operator(/)ident(bin)operator(/)ident(ruby)
comment(# countfrom - count number of messages from each sender)

comment(# Default value is 0)
ident(from) operator(=) constant(Hash)operator(.)ident(new)operator(()integer(0)operator(\))
reserved(while) ident(gets)
    regexp<delimiter(/)content(^From: (.*\))delimiter(/)> reserved(and) ident(from)operator([)global_variable($1)operator(]) operator(+=) integer(1)
reserved(end)

comment(# More useful to sort by number of received mail by person)
ident(from)operator(.)ident(sort) operator({)operator(|)ident(a)operator(,)ident(b)operator(|) ident(b)operator([)integer(1)operator(])operator(<=>)ident(a)operator([)integer(1)operator(])operator(})operator(.)ident(each) operator({) operator(|)ident(v)operator(|)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(v)operator([)integer(1)operator(])delimiter(})>content(: )inline<delimiter(#{)ident(v)operator([)integer(0)operator(])delimiter(})>delimiter(")>
operator(})
comment(#-----------------------------)


comment(# @@PLEAC@@_5.5)
comment(# You may use the built-in 'inspect' method this way:)
ident(p) ident(hash)

comment(# Or do it the Cookbook way:)
ident(hash)operator(.)ident(each) operator({) operator(|)ident(k)operator(,)ident(v)operator(|) ident(puts) string<delimiter(")inline<delimiter(#{)ident(k)delimiter(})>content( => )inline<delimiter(#{)ident(v)delimiter(})>delimiter(")> operator(})

comment(# Sorted by keys)
ident(hash)operator(.)ident(sort)operator(.)ident(each) operator({) operator(|)ident(e)operator(|) ident(puts) string<delimiter(")inline<delimiter(#{)ident(e)operator([)integer(0)operator(])delimiter(})>content( => )inline<delimiter(#{)ident(e)operator([)integer(1)operator(])delimiter(})>delimiter(")> operator(})
comment(# Sorted by values)
ident(hash)operator(.)ident(sort)operator({)operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(1)operator(])operator(<=>)ident(b)operator([)integer(1)operator(])operator(})operator(.)ident(each) operator({) operator(|)ident(e)operator(|) ident(puts) string<delimiter(")inline<delimiter(#{)ident(e)operator([)integer(0)operator(])delimiter(})>content( => )inline<delimiter(#{)ident(e)operator([)integer(1)operator(])delimiter(})>delimiter(")> operator(})


comment(# @@PLEAC@@_5.7)
ident(ttys) operator(=) constant(Hash)operator(.)ident(new)
reserved(for) ident(i) reserved(in) shell<delimiter(`)content(who)delimiter(`)>
    ident(user)operator(,) ident(tty) operator(=) ident(i)operator(.)ident(split)
    operator(()ident(ttys)operator([)ident(user)operator(]) operator(||=) operator([)operator(])operator(\)) operator(<<) ident(tty)               comment(# see problems_ruby for more infos)
reserved(end)
ident(ttys)operator(.)ident(keys)operator(.)ident(sort)operator(.)ident(each) operator({) operator(|)ident(k)operator(|)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(k)delimiter(})>content(: )inline<delimiter(#{)ident(commify_series)operator(()ident(ttys)operator([)ident(k)operator(])operator(\))delimiter(})>delimiter(")>  comment(# from 4.2)
operator(})


comment(# @@PLEAC@@_5.8)
ident(surname) operator(=) operator({) string<delimiter(")content(Mickey)delimiter(")> operator(=)operator(>) string<delimiter(")content(Mantle)delimiter(")>operator(,) string<delimiter(")content(Babe)delimiter(")> operator(=)operator(>) string<delimiter(")content(Ruth)delimiter(")> operator(})
ident(puts) ident(surname)operator(.)ident(index)operator(()string<delimiter(")content(Mantle)delimiter(")>operator(\))

comment(# If you really needed to 'invert' the whole hash, use Hash#invert)

comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# foodfind - find match for food or color)

ident(given) operator(=) pre_constant(ARGV)operator(.)ident(shift) reserved(or) ident(raise) string<delimiter(")content(usage: foodfind food_or_color)delimiter(")>

ident(color) operator(=) operator({)
    string<delimiter(")content(Apple)delimiter(")>  operator(=)operator(>) string<delimiter(")content(red)delimiter(")>operator(,)
    string<delimiter(")content(Banana)delimiter(")> operator(=)operator(>) string<delimiter(")content(yellow)delimiter(")>operator(,)
    string<delimiter(")content(Lemon)delimiter(")>  operator(=)operator(>) string<delimiter(")content(yellow)delimiter(")>operator(,)
    string<delimiter(")content(Carrot)delimiter(")> operator(=)operator(>) string<delimiter(")content(orange)delimiter(")>operator(,)
operator(})

reserved(if) operator(()ident(color)operator(.)ident(has_key?)operator(()ident(given)operator(\))operator(\))
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(given)delimiter(})>content( is a food with color )inline<delimiter(#{)ident(color)operator([)ident(given)operator(])delimiter(})>content(.)delimiter(")>
reserved(end)
reserved(if) operator(()ident(color)operator(.)ident(has_value?)operator(()ident(given)operator(\))operator(\))
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(color)operator(.)ident(index)operator(()ident(given)operator(\))delimiter(})>content( is a food with color )inline<delimiter(#{)ident(given)delimiter(})>content(.)delimiter(")>
reserved(end)
comment(#-----------------------------)


comment(# @@PLEAC@@_5.9)
comment(# Sorted by keys (Hash#sort gives an Array of pairs made of each key,value\))
ident(food_color)operator(.)ident(sort)operator(.)ident(each) operator({) operator(|)ident(f)operator(|)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(f)operator([)integer(0)operator(])delimiter(})>content( is )inline<delimiter(#{)ident(f)operator([)integer(1)operator(])delimiter(})>content(.)delimiter(")>
operator(})

comment(# Sorted by values)
ident(food_color)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(1)operator(]) operator(<=>) ident(b)operator([)integer(1)operator(]) operator(})operator(.)ident(each) operator({) operator(|)ident(f)operator(|)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(f)operator([)integer(0)operator(])delimiter(})>content( is )inline<delimiter(#{)ident(f)operator([)integer(1)operator(])delimiter(})>content(.)delimiter(")>
operator(})

comment(# Sorted by length of values)
ident(food_color)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(a)operator([)integer(1)operator(])operator(.)ident(length) operator(<=>) ident(b)operator([)integer(1)operator(])operator(.)ident(length) operator(})operator(.)ident(each) operator({) operator(|)ident(f)operator(|)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(f)operator([)integer(0)operator(])delimiter(})>content( is )inline<delimiter(#{)ident(f)operator([)integer(1)operator(])delimiter(})>content(.)delimiter(")>
operator(})


comment(# @@PLEAC@@_5.10)
ident(merged) operator(=) ident(a)operator(.)ident(clone)operator(.)ident(update)operator(()ident(b)operator(\))        comment(# because Hash#update changes object in place)

ident(drink_color) operator(=) operator({) string<delimiter(")content(Galliano)delimiter(")>  operator(=)operator(>) string<delimiter(")content(yellow)delimiter(")>operator(,) string<delimiter(")content(Mai Tai)delimiter(")> operator(=)operator(>) string<delimiter(")content(blue)delimiter(")> operator(})
ident(ingested_color) operator(=) ident(drink_color)operator(.)ident(clone)operator(.)ident(update)operator(()ident(food_color)operator(\))

ident(substance_color) operator(=) operator({)operator(})
reserved(for) ident(i) reserved(in) operator([) ident(food_color)operator(,) ident(drink_color) operator(])
    ident(i)operator(.)ident(each_key) operator({) operator(|)ident(k)operator(|)
        reserved(if) ident(substance_color)operator(.)ident(has_key?)operator(()ident(k)operator(\))
            ident(puts) string<delimiter(")content(Warning: )inline<delimiter(#{)ident(k)delimiter(})>content( seen twice.  Using the first definition.)delimiter(")>
            reserved(next)
        reserved(end)
        ident(substance_color)operator([)ident(k)operator(]) operator(=) integer(1)
    operator(})
reserved(end)


comment(# @@PLEAC@@_5.11)
ident(common) operator(=) ident(hash1)operator(.)ident(keys) operator(&) ident(hash2)operator(.)ident(keys)

ident(this_not_that) operator(=) ident(hash1)operator(.)ident(keys) operator(-) ident(hash2)operator(.)ident(keys)


comment(# @@PLEAC@@_5.12)
comment(# no problem here, Ruby handles any kind of object for key-ing)
comment(# (it takes Object#hash, which defaults to Object#id\))


comment(# @@PLEAC@@_5.13)
comment(# AFAIK, not possible in Ruby)


comment(# @@PLEAC@@_5.14)
comment(# Be careful, the following is possible only because Fixnum objects are)
comment(# special (documentation says: there is effectively only one Fixnum object)
comment(# instance for any given integer value\).)
ident(count) operator(=) constant(Hash)operator(.)ident(new)operator(()integer(0)operator(\))
ident(array)operator(.)ident(each) operator({) operator(|)ident(e)operator(|)
    ident(count)operator([)ident(e)operator(]) operator(+=) integer(1)
operator(})


comment(# @@PLEAC@@_5.15)
ident(father) operator(=) operator({)
    string<delimiter(")content(Cain)delimiter(")>      operator(,) string<delimiter(")content(Adam)delimiter(")>operator(,)
    string<delimiter(")content(Abel)delimiter(")>      operator(,) string<delimiter(")content(Adam)delimiter(")>operator(,)
    string<delimiter(")content(Seth)delimiter(")>      operator(,) string<delimiter(")content(Adam)delimiter(")>operator(,)
    string<delimiter(")content(Enoch)delimiter(")>     operator(,) string<delimiter(")content(Cain)delimiter(")>operator(,)
    string<delimiter(")content(Irad)delimiter(")>      operator(,) string<delimiter(")content(Enoch)delimiter(")>operator(,)
    string<delimiter(")content(Mehujael)delimiter(")>  operator(,) string<delimiter(")content(Irad)delimiter(")>operator(,)
    string<delimiter(")content(Methusael)delimiter(")> operator(,) string<delimiter(")content(Mehujael)delimiter(")>operator(,)
    string<delimiter(")content(Lamech)delimiter(")>    operator(,) string<delimiter(")content(Methusael)delimiter(")>operator(,)
    string<delimiter(")content(Jabal)delimiter(")>     operator(,) string<delimiter(")content(Lamech)delimiter(")>operator(,)
    string<delimiter(")content(Jubal)delimiter(")>     operator(,) string<delimiter(")content(Lamech)delimiter(")>operator(,)
    string<delimiter(")content(Tubalcain)delimiter(")> operator(,) string<delimiter(")content(Lamech)delimiter(")>operator(,)
    string<delimiter(")content(Enos)delimiter(")>      operator(,) string<delimiter(")content(Seth)delimiter(")>operator(,)
operator(})

reserved(while) ident(gets)
    ident(chomp)
    reserved(begin)
        ident(print) global_variable($_)operator(,) string<delimiter(")content( )delimiter(")>
    reserved(end) reserved(while) global_variable($_) operator(=) ident(father)operator([)global_variable($_)operator(])
    ident(puts)
reserved(end)

ident(children) operator(=) operator({)operator(})
ident(father)operator(.)ident(each) operator({) operator(|)ident(k)operator(,)ident(v)operator(|)
    operator(()ident(children)operator([)ident(v)operator(]) operator(||=) operator([)operator(])operator(\)) operator(<<) ident(k)
operator(})
reserved(while) ident(gets)
    ident(chomp)
    ident(puts) string<delimiter(")inline<delimiter(#{)global_variable($_)delimiter(})>content( begat )inline<delimiter(#{)operator(()ident(children)operator([)global_variable($_)operator(]) operator(||) operator([)string<delimiter(')content(Nobody)delimiter(')>operator(])operator(\))operator(.)ident(join)operator(()string<delimiter(')content(, )delimiter(')>operator(\))delimiter(})>content(.)char(\\n)delimiter(")>
reserved(end)

ident(includes) operator(=) operator({)operator(})
ident(files)operator(.)ident(each) operator({) operator(|)ident(f)operator(|)
    reserved(begin)
        reserved(for) ident(l) reserved(in) constant(IO)operator(.)ident(readlines)operator(()ident(f)operator(\))
            reserved(next) reserved(unless) ident(l) operator(=)operator(~) regexp<delimiter(/)content(^)char(\\s)content(*#)char(\\s)content(*include)char(\\s)content(*<([^>]+\)>)delimiter(/)>
            operator(()ident(includes)operator([)global_variable($1)operator(]) operator(||=) operator([)operator(])operator(\)) operator(<<) ident(f)
        reserved(end)
    reserved(rescue) constant(SystemCallError)
        global_variable($stderr)operator(.)ident(puts) string<delimiter(")escape(#)global_variable($!)content( (skipping\))delimiter(")>
    reserved(end)
operator(})

ident(include_free) operator(=) ident(includes)operator(.)ident(values)operator(.)ident(flatten)operator(.)ident(uniq) operator(-) ident(includes)operator(.)ident(keys)


comment(# @@PLEAC@@_5.16)
comment(# dutree - print sorted intented rendition of du output)
comment(#% dutree)
comment(#% dutree /usr)
comment(#% dutree -a)
comment(#% dutree -a /bin)

comment(# The DuNode class collects all information about a directory,)
comment(# and provides some convenience methods)
reserved(class) class(DuNode)

    ident(attr_reader) symbol(:name)
    ident(attr_accessor) symbol(:size)
    ident(attr_accessor) symbol(:kids)

    reserved(def) method(initialize)operator(()ident(name)operator(\))
        instance_variable(@name) operator(=) ident(name)
        instance_variable(@kids) operator(=) operator([)operator(])
        instance_variable(@size) operator(=) integer(0)
    reserved(end)

    comment(# support for sorting nodes with side)
    reserved(def) method(size_compare)operator(()ident(node2)operator(\))
        instance_variable(@size) operator(<=>) ident(node2)operator(.)ident(size)
    reserved(end)

    reserved(def) method(basename)
        instance_variable(@name)operator(.)ident(sub)operator(()regexp<delimiter(/)content(.*)char(\\/)delimiter(/)>operator(,) string<delimiter(")delimiter(")>operator(\))
    reserved(end)

    comment(#returns substring before last "/", nil if not there)
    reserved(def) method(parent)
        ident(p) operator(=) instance_variable(@name)operator(.)ident(sub)operator(()regexp<delimiter(/)char(\\/)content([^)char(\\/)content(]+$)delimiter(/)>operator(,)string<delimiter(")delimiter(")>operator(\))
        reserved(if) ident(p) operator(==) instance_variable(@name)
            pre_constant(nil)
        reserved(else)
            ident(p)
        reserved(end)
    reserved(end)

reserved(end)

comment(# The DuTree does the acdtual work of)
comment(# getting the input, parsing it, builging up a tree)
comment(# and format it for output)
reserved(class) class(Dutree)

    ident(attr_reader) symbol(:topdir)

    reserved(def) method(initialize)
        instance_variable(@nodes) operator(=) constant(Hash)operator(.)ident(new)
        instance_variable(@dirsizes) operator(=) constant(Hash)operator(.)ident(new)operator(()integer(0)operator(\))
        instance_variable(@kids) operator(=) constant(Hash)operator(.)ident(new)operator(()operator([)operator(])operator(\))
    reserved(end)

    comment(# get a node by name, create it if it does not exist yet)
    reserved(def) method(get_create_node)operator(()ident(name)operator(\))
        reserved(if) instance_variable(@nodes)operator(.)ident(has_key?)operator(()ident(name)operator(\))
            instance_variable(@nodes)operator([)ident(name)operator(])
        reserved(else)
            ident(node) operator(=) constant(DuNode)operator(.)ident(new)operator(()ident(name)operator(\))
            instance_variable(@nodes)operator([)ident(name)operator(]) operator(=) ident(node)
            ident(node)
        reserved(end)
    reserved(end)

    comment(# run du, read in input, save sizes and kids)
    comment(# stores last directory read in instance variable topdir)
    reserved(def) method(input)operator(()ident(arguments)operator(\))
        ident(name) operator(=) string<delimiter(")delimiter(")>
        ident(cmd) operator(=) string<delimiter(")content(du )delimiter(")> operator(+) ident(arguments)operator(.)ident(join)operator(()string<delimiter(")content( )delimiter(")>operator(\))
        constant(IO)operator(.)ident(popen)operator(()ident(cmd)operator(\)) operator({) operator(|)ident(pipe)operator(|)
            ident(pipe)operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
                ident(size)operator(,) ident(name) operator(=) ident(line)operator(.)ident(chomp)operator(.)ident(split)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(,) integer(2)operator(\))
                ident(node) operator(=) ident(get_create_node)operator(()ident(name)operator(\))
                ident(node)operator(.)ident(size) operator(=) ident(size)operator(.)ident(to_i)
                instance_variable(@nodes)operator([)ident(name)operator(]) operator(=) ident(node)
                ident(parent) operator(=) ident(node)operator(.)ident(parent)
                reserved(if) ident(parent)
                    ident(get_create_node)operator(()ident(parent)operator(\))operator(.)ident(kids)operator(.)ident(push)operator(()ident(node)operator(\))
                reserved(end)
            operator(})
        operator(})
        instance_variable(@topdir) operator(=) instance_variable(@nodes)operator([)ident(name)operator(])
    reserved(end)

    comment(# figure out how much is taken in each directory)
    comment(# that isn't stored in the subdirectories. Add a new)
    comment(# fake kid called "." containing that much.)
    reserved(def) method(get_dots)operator(()ident(node)operator(\))
        ident(cursize) operator(=) ident(node)operator(.)ident(size)
        reserved(for) ident(kid) reserved(in) ident(node)operator(.)ident(kids)
            ident(cursize) operator(-=)  ident(kid)operator(.)ident(size)
            ident(get_dots)operator(()ident(kid)operator(\))
        reserved(end)
        reserved(if) ident(node)operator(.)ident(size) operator(!=) ident(cursize)
            ident(newnode) operator(=) ident(get_create_node)operator(()ident(node)operator(.)ident(name) operator(+) string<delimiter(")content(/.)delimiter(")>operator(\))
            ident(newnode)operator(.)ident(size) operator(=) ident(cursize)
            ident(node)operator(.)ident(kids)operator(.)ident(push)operator(()ident(newnode)operator(\))
        reserved(end)
    reserved(end)

    comment(# recursively output everything)
    comment(# passing padding and number width as well)
    comment(# on recursive calls)
    reserved(def) method(output)operator(()ident(node)operator(,) ident(prefix)operator(=)string<delimiter(")delimiter(")>operator(,) ident(width)operator(=)integer(0)operator(\))
        ident(line) operator(=) ident(sprintf)operator(()string<delimiter(")content(%)inline<delimiter(#{)ident(width)delimiter(})>content(d %s)delimiter(")>operator(,) ident(node)operator(.)ident(size)operator(,) ident(node)operator(.)ident(basename)operator(\))
        ident(puts)operator(()ident(prefix) operator(+) ident(line)operator(\))
        ident(prefix) operator(+=) ident(line)operator(.)ident(sub)operator(()regexp<delimiter(/)char(\\d)content( )delimiter(/)>operator(,) string<delimiter(")content(| )delimiter(")>operator(\))
        ident(prefix)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content([^|])delimiter(/)>operator(,) string<delimiter(")content( )delimiter(")>operator(\))
        reserved(if) ident(node)operator(.)ident(kids)operator(.)ident(length) operator(>) integer(0)     comment(# not a bachelor node)
            ident(kids) operator(=) ident(node)operator(.)ident(kids)
            ident(kids)operator(.)ident(sort!) operator({) operator(|)ident(a)operator(,)ident(b)operator(|)
                ident(b)operator(.)ident(size_compare)operator(()ident(a)operator(\))
            operator(})
            ident(width) operator(=) ident(kids)operator([)integer(0)operator(])operator(.)ident(size)operator(.)ident(to_s)operator(.)ident(length)
            reserved(for) ident(kid) reserved(in) ident(kids)
                ident(output)operator(()ident(kid)operator(,) ident(prefix)operator(,) ident(width)operator(\))
            reserved(end)
        reserved(end)
    reserved(end)

reserved(end)

ident(tree) operator(=) constant(Dutree)operator(.)ident(new)
ident(tree)operator(.)ident(input)operator(()pre_constant(ARGV)operator(\))
ident(tree)operator(.)ident(get_dots)operator(()ident(tree)operator(.)ident(topdir)operator(\))
ident(tree)operator(.)ident(output)operator(()ident(tree)operator(.)ident(topdir)operator(\))


comment(# @@PLEAC@@_6.0)
comment(# The verbose version are match, sub, gsub, sub! and gsub!;)
comment(# pattern needs to be a Regexp object; it yields a MatchData)
comment(# object.)
ident(pattern)operator(.)ident(match)operator(()ident(string)operator(\))
ident(string)operator(.)ident(sub)operator(()ident(pattern)operator(,) ident(replacement)operator(\))
ident(string)operator(.)ident(gsub)operator(()ident(pattern)operator(,) ident(replacement)operator(\))
comment(# As usual in Ruby, sub! does the same as sub but also modifies)
comment(# the object, the same for gsub!/gsub.)

comment(# Sugared syntax yields the position of the match (or nil if no)
comment(# match\). Note that the object at the right of the operator needs)
comment(# not to be a Regexp object (it can be a String\). The "dont)
comment(# match" operator yields true or false.)
ident(meadow) operator(=)operator(~) regexp<delimiter(/)content(sheep)delimiter(/)>   comment(# position of the match, nil if no match)
ident(meadow) operator(!)operator(~) regexp<delimiter(/)content(sheep)delimiter(/)>   comment(# true if doesn't match, false if it does)
comment(# There is no sugared version for the substitution)

ident(meadow) operator(=)operator(~) regexp<delimiter(/)char(\\b)content(ovines?)char(\\b)delimiter(/)modifier(i)> reserved(and) ident(print) string<delimiter(")content(Here be sheep!)delimiter(")>

ident(string) operator(=) string<delimiter(")content(good food)delimiter(")>
ident(string)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(o*)delimiter(/)>operator(,) string<delimiter(')content(e)delimiter(')>operator(\))

comment(# % echo ababacaca | ruby -ne 'puts $& if /(a|ba|b\)+(a|ac\)+/')
comment(# ababa)

comment(# The "global" (or "multiple"\) match is handled by String#scan)
ident(scan) operator(()regexp<delimiter(/)content(()char(\\d)content(+\))delimiter(/)>operator(\)) operator({)
    ident(puts) string<delimiter(")content(Found number )inline<delimiter(#{)global_variable($1)delimiter(})>delimiter(")>
operator(})

comment(# String#scan yields an Array if not used with a block)
ident(numbers) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\d)content(+)delimiter(/)>operator(\))

ident(digits) operator(=) string<delimiter(")content(123456789)delimiter(")>
ident(nonlap) operator(=) ident(digits)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\d)char(\\d)char(\\d)content(\))delimiter(/)>operator(\))
ident(yeslap) operator(=) ident(digits)operator(.)ident(scan)operator(()regexp<delimiter(/)content((?=()char(\\d)char(\\d)char(\\d)content(\)\))delimiter(/)>operator(\))
ident(puts) string<delimiter(")content(Non-overlapping:  )inline<delimiter(#{)ident(nonlap)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>delimiter(")>
ident(puts) string<delimiter(")content(Overlapping:      )inline<delimiter(#{)ident(yeslap)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>delimiter(")>operator(;)
comment(# Non-overlapping:  123 456 789)
comment(# Overlapping:      123 234 345 456 567 678 789)

ident(string) operator(=) string<delimiter(")content(And little lambs eat ivy)delimiter(")>
ident(string) operator(=)operator(~) regexp<delimiter(/)content(l[^s]*s)delimiter(/)>
ident(puts) string<delimiter(")content(()escape(#)global_variable($`)content(\) ()escape(#)global_variable($&)content(\) ()escape(#)global_variable($')content(\))delimiter(")>
comment(# (And \) (little lambs\) ( eat ivy\))


comment(# @@PLEAC@@_6.1)
comment(# Ruby doesn't have the same problem:)
ident(dst) operator(=) ident(src)operator(.)ident(sub)operator(()string<delimiter(')content(this)delimiter(')>operator(,) string<delimiter(')content(that)delimiter(')>operator(\))

ident(progname) operator(=) global_variable($0)operator(.)ident(sub)operator(()string<delimiter(')content(^.*/)delimiter(')>operator(,) string<delimiter(')delimiter(')>operator(\))

ident(bindirs) operator(=) string<delimiter(%w()content(/usr/bin /bin /usr/local/bin)delimiter(\))>
ident(libdirs) operator(=) ident(bindirs)operator(.)ident(map) operator({) operator(|)ident(l)operator(|) ident(l)operator(.)ident(sub)operator(()string<delimiter(')content(bin)delimiter(')>operator(,) string<delimiter(')content(lib)delimiter(')>operator(\)) operator(})


comment(# @@PLEAC@@_6.3)
regexp<delimiter(/)char(\\S)content(+)delimiter(/)>               comment(# as many non-whitespace bytes as possible)
regexp<delimiter(/)content([A-Za-z'-]+)delimiter(/)>       comment(# as many letters, apostrophes, and hyphens)

regexp<delimiter(/)char(\\b)content(([A-Za-z]+\))char(\\b)delimiter(/)>   comment(# usually best)
regexp<delimiter(/)char(\\s)content(([A-Za-z]+\))char(\\s)delimiter(/)>   comment(# fails at ends or w/ punctuation)


comment(# @@PLEAC@@_6.4)
ident(require) string<delimiter(')content(socket)delimiter(')>
ident(str) operator(=) string<delimiter(')content(www.ruby-lang.org and www.rubygarden.org)delimiter(')>
ident(re) operator(=) regexp<delimiter(/)content(
      (               # capture the hostname in $1
        (?:           # these parens for grouping only
          (?! [-_] \)  # lookahead for neither underscore nor dash
          [)char(\\w)content(-] +     # hostname component
          )char(\\.)content(          # and the domain dot
        \) +           # now repeat that whole thing a bunch of times
        [A-Za-z]      # next must be a letter
        [)char(\\w)content(-] +       # now trailing domain part
      \)               # end of $1 capture
     )delimiter(/)modifier(x)>               comment(# /x for nice formatting)

ident(str)operator(.)ident(gsub!) ident(re) reserved(do)       comment(# pass a block to execute replacement)
    ident(host) operator(=) constant(TCPsocket)operator(.)ident(gethostbyname)operator(()global_variable($1)operator(\))
    string<delimiter(")inline<delimiter(#{)global_variable($1)delimiter(})>content( [)inline<delimiter(#{)ident(host)operator([)integer(3)operator(])delimiter(})>content(])delimiter(")>
reserved(end)

ident(puts) ident(str)
comment(#-----------------------------)
comment(# to match whitespace or #-characters in an extended re you need to escape)
comment(# them.)

ident(foo) operator(=) integer(42)
ident(str) operator(=) string<delimiter(')content(blah #foo# blah)delimiter(')>
ident(str)operator(.)ident(gsub!) regexp<delimiter(%r/)content(       # replace
              )char(\\#)content(    #   a pound sign
              ()char(\\w)content(+\) #   the variable name
              )char(\\#)content(    #   another pound sign
          )delimiter(/)modifier(x)> reserved(do)
              ident(eval) global_variable($1)           comment(# with the value of a local variable)
          reserved(end)
ident(puts) ident(str)  comment(# => blah 42 blah)


comment(# @@PLEAC@@_6.5)
comment(# The 'g' modifier doesn't exist in Ruby, a regexp can't be used)
comment(# directly in a while loop; instead, use String#scan { |match| .. } )
ident(fish) operator(=) string<delimiter(')content(One fish two fish red fish blue fish)delimiter(')>
constant(WANT) operator(=) integer(3)
ident(count) operator(=) integer(0)
ident(fish)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\w)content(+\))char(\\s)content(+fish)char(\\b)delimiter(/)modifier(i)>operator(\)) operator({)
    reserved(if) operator(()ident(count) operator(+=) integer(1)operator(\)) operator(==) constant(WANT)
        ident(puts) string<delimiter(")content(The third fish is a )inline<delimiter(#{)global_variable($1)delimiter(})>content( one.)delimiter(")>
    reserved(end)
operator(})

reserved(if) ident(fish) operator(=)operator(~) regexp<delimiter(/)content((?:)char(\\w)content(+)char(\\s)content(+fish)char(\\s)content(+\){2}()char(\\w)content(+\))char(\\s)content(+fish)delimiter(/)modifier(i)>
    ident(puts) string<delimiter(")content(The third fish is a )inline<delimiter(#{)global_variable($1)delimiter(})>content( one.)delimiter(")>
reserved(end)

ident(pond) operator(=) string<delimiter(')content(One fish two fish red fish blue fish)delimiter(')>
comment(# String#scan without a block gives an array of matches, each match)
comment(# being an array of all the specified groups)
ident(colors) operator(=) ident(pond)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\w)content(+\))char(\\s)content(+fish)char(\\b)delimiter(/)modifier(i)>operator(\))operator(.)ident(flatten)  comment(# get all matches)
ident(color)  operator(=) ident(colors)operator([)integer(2)operator(])                          comment(# then the one we want)
comment(# or without a temporary array)
ident(color) operator(=) ident(pond)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\w)content(+\))char(\\s)content(+fish)char(\\b)delimiter(/)modifier(i)>operator(\))operator(.)ident(flatten)operator([)integer(2)operator(])  comment(# just grab element 3)
ident(puts) string<delimiter(")content(The third fish in the pond is )inline<delimiter(#{)ident(color)delimiter(})>content(.)delimiter(")>

ident(count) operator(=) integer(0)
ident(fishes) operator(=) string<delimiter(')content(One fish two fish red fish blue fish)delimiter(')>
ident(evens) operator(=) ident(fishes)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\w)content(+\))char(\\s)content(+fish)char(\\b)delimiter(/)modifier(i)>operator(\))operator(.)ident(select) operator({) operator(()ident(count)operator(+=)integer(1)operator(\)) operator(%) integer(2) operator(==) integer(0) operator(})
ident(print) string<delimiter(")content(Even numbered fish are )inline<delimiter(#{)ident(evens)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>content(.)delimiter(")>

ident(count) operator(=) integer(0)
ident(fishes)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(
   )char(\\b)content(               # makes next )char(\\w)content( more efficient
   ( )char(\\w)content(+ \)          # this is what we)char(\\')content(ll be changing
   (
     )char(\\s)content(+ fish )char(\\b)content(
   \)
            )delimiter(/)modifier(x)>operator(\)) operator({)
    reserved(if) operator(()ident(count) operator(+=) integer(1)operator(\)) operator(==) integer(4)
        string<delimiter(')content(sushi)delimiter(')> operator(+) global_variable($2)
    reserved(else)
        global_variable($1) operator(+) global_variable($2)
    reserved(end)
operator(})

ident(pond) operator(=) string<delimiter(')content(One fish two fish red fish blue fish swim here.)delimiter(')>
ident(puts) string<delimiter(")content(Last fish is )inline<delimiter(#{)ident(pond)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\b)content(()char(\\w)content(+\))char(\\s)content(+fish)char(\\b)delimiter(/)modifier(i)>operator(\))operator(.)ident(flatten)operator([)integer(-1)operator(])delimiter(})>delimiter(")>

regexp<delimiter(/)content(
    A               # find some pattern A
    (?!             # mustn)char(\\')content(t be able to find
        .*          # something
        A           # and A
    \)
    $               # through the end of the string
)delimiter(/)modifier(x)>

comment(# The "s" perl modifier is "m" in Ruby (not very nice since there is)
comment(# also an "m" in perl..\))
ident(pond) operator(=) string<delimiter(")content(One fish two fish red fish blue fish swim here.)delimiter(")>
reserved(if) operator(()ident(pond) operator(=)operator(~) regexp<delimiter(/)content(
                    )char(\\b)content(  (  )char(\\w)content(+\) )char(\\s)content(+ fish )char(\\b)content(
                (?! .* )char(\\b)content( fish )char(\\b)content( \)
            )delimiter(/)modifier(mix)>operator(\))
    ident(puts) string<delimiter(")content(Last fish is )inline<delimiter(#{)global_variable($1)delimiter(})>content(.)delimiter(")>
reserved(else)
    ident(puts) string<delimiter(")content(Failed!)delimiter(")>
reserved(end)


comment(# @@PLEAC@@_6.6)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# killtags - very bad html killer)
global_variable($/) operator(=) pre_constant(nil)operator(;)                              comment(# each read is whole file)
reserved(while) ident(file) operator(=) ident(gets)operator(()operator(\)) reserved(do)
    ident(file)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(<.*?>)delimiter(/)modifier(m)>operator(,)string<delimiter(')delimiter(')>operator(\))operator(;)           comment(# strip tags (terribly\))
    ident(puts) ident(file)                          comment(# print file to STDOUT)
reserved(end)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(#headerfy - change certain chapter headers to html)
global_variable($/) operator(=) string<delimiter(')delimiter(')>
reserved(while) ident(file) operator(=) ident(gets)operator(()operator(\)) reserved(do)
    ident(pattern) operator(=) regexp<delimiter(/)content(
                  )char(\\A)content(                   # start of record
                  (                    # capture in $1
                      Chapter          # text string
                      )char(\\s)content(+              # mandatory whitespace
                      )char(\\d)content(+              # decimal number
                      )char(\\s)content(*              # optional whitespace
                      :                # a real colon
                      . *              # anything not a newline till end of line
                  \)
               )delimiter(/)modifier(x)>
    ident(puts) ident(file)operator(.)ident(gsub)operator(()ident(pattern)operator(,)string<delimiter(')content(<H1>)content(\\1)content(</H1>)delimiter(')>operator(\))
reserved(end)
comment(#-----------------------------)
comment(#% ruby -00pe "gsub!(/\\A(Chapter\\s+\\d+\\s*:.*\)/,'<H1>\\1</H1>'\)" datafile)

comment(#!/usr/bin/ruby -w)
comment(#-----------------------------)
reserved(for) ident(file) reserved(in) pre_constant(ARGV)
    ident(file) operator(=) constant(File)operator(.)ident(open)operator(()pre_constant(ARGV)operator(.)ident(shift)operator(\))
    reserved(while) ident(file)operator(.)ident(gets)operator(()string<delimiter(')delimiter(')>operator(\)) reserved(do)             comment(# each read is a paragraph)
        ident(print) string<delimiter(")content(chunk )inline<delimiter(#{)global_variable($.)delimiter(})>content( in $ARGV has <<)inline<delimiter(#{)global_variable($1)delimiter(})>content(>>)char(\\n)delimiter(")> reserved(while) regexp<delimiter(/)content(^START(.*?\)^END)delimiter(/)modifier(m)>
    reserved(end)                                comment(# /m activates the multiline mode)
reserved(end)
comment(#-----------------------------)

comment(# @@PLEAC@@_6.7)
comment(#-----------------------------)
global_variable($/) operator(=) pre_constant(nil)operator(;)
ident(file) operator(=) constant(File)operator(.)ident(open)operator(()string<delimiter(")content(datafile)delimiter(")>operator(\))
ident(chunks) operator(=) ident(file)operator(.)ident(gets)operator(.)ident(split)operator(()regexp<delimiter(/)content(pattern)delimiter(/)>operator(\))
comment(#-----------------------------)
comment(# .Ch, .Se and .Ss divide chunks of STDIN)
ident(chunks) operator(=) ident(gets)operator(()pre_constant(nil)operator(\))operator(.)ident(split)operator(()regexp<delimiter(/)content(^)char(\\.)content((Ch|Se|Ss\)$)delimiter(/)>operator(\))
ident(print) string<delimiter(")content(I read )inline<delimiter(#{)ident(chunks)operator(.)ident(size)delimiter(})>content( chunks.)char(\\n)delimiter(")>
comment(#-----------------------------)


comment(# @@PLEAC@@_6.8)
reserved(while) ident(gets)
    reserved(if) operator(~)regexp<delimiter(/)content(BEGIN)delimiter(/)> operator(..) operator(~)regexp<delimiter(/)content(END)delimiter(/)>
        comment(# line falls between BEGIN and END inclusive)
    reserved(end)
reserved(end)

reserved(while) ident(gets)
    reserved(if) operator(()global_variable($.) operator(==) ident(firstnum)operator(\)) operator(..) operator(()global_variable($.) operator(==) ident(lastnum)operator(\))
        comment(# operate between firstnum and lastnum line number)
    reserved(end)
reserved(end)

comment(# in ruby versions prior to 1.8, the above two conditional)
comment(# expressions could be shortened to:)
comment(#     if /BEGIN/ .. /END/)
comment(# and)
comment(#     if firstnum .. lastnum)
comment(# but these now only work this way from the command line  )

comment(#-----------------------------)

reserved(while) ident(gets)
    reserved(if) operator(~)regexp<delimiter(/)content(BEGIN)delimiter(/)> operator(...) operator(~)regexp<delimiter(/)content(END)delimiter(/)>
        comment(# line falls between BEGIN and END on different lines)
    reserved(end)
reserved(end)

reserved(while) ident(gets)
    reserved(if) operator(()global_variable($.) operator(==) ident(first)operator(\)) operator(...) operator(()global_variable($.) operator(==) ident(last)operator(\))
        comment(# operate between first and last line number on different lines)
    reserved(end)
reserved(end)

comment(#-----------------------------)
comment(# command-line to print lines 15 through 17 inclusive (see below\))
ident(ruby) operator(-)ident(ne) string<delimiter(')content(print if 15 .. 17)delimiter(')> ident(datafile)

comment(# print out all <XMP> .. </XMP> displays from HTML doc)
reserved(while) ident(gets)
    ident(print) reserved(if) operator(~)regexp<delimiter(%r#)content(<XMP>)delimiter(#)modifier(i)> operator(..) operator(~)regexp<delimiter(%r#)content(</XMP>)delimiter(#)modifier(i)>operator(;)
reserved(end)
    
comment(# same, but as shell command)
comment(# ruby -ne 'print if %r#<XMP>#i .. %r#</XMP>#i' document.html)
comment(#-----------------------------)
comment(# ruby -ne 'BEGIN { $top=3; $bottom=5 }; \\)
comment(#     print if $top .. $bottom' /etc/passwd                 #  FAILS)
comment(# ruby -ne 'BEGIN { $top=3; $bottom=5 }; \\)
comment(#     print if $. == $top .. $. ==  $bottom' /etc/passwd    # works)
comment(# ruby -ne 'print if 3 .. 5' /etc/passwd                    # also works)
comment(#-----------------------------)
ident(print) reserved(if) operator(~)regexp<delimiter(/)content(begin)delimiter(/)> operator(..) operator(~)regexp<delimiter(/)content(end)delimiter(/)>operator(;)
ident(print) reserved(if) operator(~)regexp<delimiter(/)content(begin)delimiter(/)> operator(...) operator(~)regexp<delimiter(/)content(end)delimiter(/)>operator(;)
comment(#-----------------------------)
reserved(while) ident(gets)
    global_variable($in_header) operator(=) global_variable($.) operator(==) integer(1)  operator(..) operator(~)regexp<delimiter(/)content(^$)delimiter(/)> operator(?) pre_constant(true) operator(:) pre_constant(false)
    global_variable($in_body)   operator(=) operator(~)regexp<delimiter(/)content(^$)delimiter(/)> operator(..) pre_constant(ARGF)operator(.)ident(eof) operator(?) pre_constant(true) operator(:) pre_constant(false)
reserved(end)
comment(#-----------------------------)
ident(seen) operator(=) operator({)operator(})
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    reserved(next) reserved(unless) ident(line) operator(=)operator(~) regexp<delimiter(/)content(^From:?)char(\\s)delimiter(/)modifier(i)> operator(..) ident(line) operator(=)operator(~) regexp<delimiter(/)content(^$)delimiter(/)>operator(;)
    ident(line)operator(.)ident(scan)operator(()regexp<delimiter(%r/)content(([^<>(\),;)char(\\s)content(]+)char(\\@)content([^<>(\),;)char(\\s)content(]+\))delimiter(/)>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(addr)operator(|)
        ident(puts) ident(addr) reserved(unless) ident(seen)operator([)ident(addr)operator(])
        ident(seen)operator([)ident(addr)operator(]) operator(||=) integer(1) 
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_6.9)
reserved(def) method(glob2pat)operator(()ident(globstr)operator(\))
    ident(patmap) operator(=) operator({)
        string<delimiter(')content(*)delimiter(')> operator(=)operator(>) string<delimiter(')content(.*)delimiter(')>operator(,)
        string<delimiter(')content(?)delimiter(')> operator(=)operator(>) string<delimiter(')content(.)delimiter(')>operator(,)
        string<delimiter(')content([)delimiter(')> operator(=)operator(>) string<delimiter(')content([)delimiter(')>operator(,)
        string<delimiter(')content(])delimiter(')> operator(=)operator(>) string<delimiter(')content(])delimiter(')>operator(,)
    operator(})
    ident(globstr)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content((.\))delimiter(/)>operator(\)) operator({) operator(|)ident(c)operator(|) ident(patmap)operator([)ident(c)operator(]) operator(||) constant(Regexp)operator(::)ident(escape)operator(()ident(c)operator(\)) operator(})
    string<delimiter(')content(^)delimiter(')> operator(+) ident(globstr) operator(+) string<delimiter(')content($)delimiter(')>
reserved(end)


comment(# @@PLEAC@@_6.10)
comment(# avoid interpolating patterns like this if the pattern)
comment(# isn't going to change:)
ident(pattern) operator(=) pre_constant(ARGV)operator(.)ident(shift)
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)inline<delimiter(#{)ident(pattern)delimiter(})>delimiter(/)>
reserved(end)

comment(# the above creates a new regex each iteration. Instead,)
comment(# use the /o modifier so the regex is compiled only once)

ident(pattern) operator(=) pre_constant(ARGV)operator(.)ident(shift)
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)inline<delimiter(#{)ident(pattern)delimiter(})>delimiter(/)modifier(o)>
reserved(end)

comment(#-----------------------------)

comment(#!/usr/bin/ruby)
comment(# popgrep1 - grep for abbreviations of places that say "pop")
comment(# version 1: slow but obvious way)
ident(popstates) operator(=) string<delimiter(%w()content(CO ON MI WI MN)delimiter(\))>
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(popstates)operator(.)ident(each) reserved(do) operator(|)ident(state)operator(|)
        reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)char(\\b)inline<delimiter(#{)ident(state)delimiter(})>char(\\b)delimiter(/)>
            ident(print) ident(line)
            ident(last)
        reserved(end)
    reserved(end)
reserved(end)

comment(#-----------------------------)
comment(#!/usr/bin/ruby)
comment(# popgrep2 - grep for abbreviations of places that say "pop")
comment(# version 2: eval strings; fast but hard to quote)
ident(popstates) operator(=) string<delimiter(%w()content(CO ON MI WI MN)delimiter(\))>
ident(code) operator(=) string<delimiter(")content(ARGF.each do |line|)char(\\n)delimiter(")>
ident(popstates)operator(.)ident(each) reserved(do) operator(|)ident(state)operator(|)
    ident(code) operator(+=) string<delimiter(")char(\\t)content(if line =~ /)char(\\\\)content(b)inline<delimiter(#{)ident(state)delimiter(})>char(\\\\)content(b/; print(line\); next; end)char(\\n)delimiter(")>
reserved(end)
ident(code) operator(+=) string<delimiter(")content(end)char(\\n)delimiter(")>
ident(print) string<delimiter(")content(CODE IS)char(\\n)content(---)char(\\n)inline<delimiter(#{)ident(code)delimiter(})>char(\\n)content(---)char(\\n)delimiter(")> reserved(if) pre_constant(false) comment(# turn on for debugging)
ident(eval) ident(code)

comment(# CODE IS)
comment(# ---)
comment(# ARGF.each do |line|)
comment(#         if line =~ /\\bCO\\b/; print(line\); next; end)
comment(#         if line =~ /\\bON\\b/; print(line\); next; end)
comment(#         if line =~ /\\bMI\\b/; print(line\); next; end)
comment(#         if line =~ /\\bWI\\b/; print(line\); next; end)
comment(#         if line =~ /\\bMN\\b/; print(line\); next; end)
comment(# end)
comment(# )
comment(# ---)

comment(## alternatively, the same idea as above but compiling )
comment(## to a case statement: (not in perlcookbook\))
comment(#!/usr/bin/ruby -w)
comment(# popgrep2.5 - grep for abbreviations of places that say "pop")
comment(# version 2.5: eval strings; fast but hard to quote)
ident(popstates) operator(=) string<delimiter(%w()content(CO ON MI WI MN)delimiter(\))>
ident(code) operator(=) string<delimiter(")content(ARGF.each do |line|)char(\\n)content(    case line)char(\\n)delimiter(")>
ident(popstates)operator(.)ident(each) reserved(do) operator(|)ident(state)operator(|)
    ident(code) operator(+=) string<delimiter(")content(        when /)char(\\\\)content(b)inline<delimiter(#{)ident(state)delimiter(})>char(\\\\)content(b/ : print line)char(\\n)delimiter(")>
reserved(end)
ident(code) operator(+=) string<delimiter(")content(    end)char(\\n)content(end)char(\\n)delimiter(")>
ident(print) string<delimiter(")content(CODE IS)char(\\n)content(---)char(\\n)inline<delimiter(#{)ident(code)delimiter(})>char(\\n)content(---)char(\\n)delimiter(")> reserved(if) pre_constant(false) comment(# turn on for debugging)
ident(eval) ident(code)

comment(# CODE IS)
comment(# ---)
comment(# ARGF.each do |line|)
comment(#     case line)
comment(#         when /\\bCO\\b/ : print line)
comment(#         when /\\bON\\b/ : print line)
comment(#         when /\\bMI\\b/ : print line)
comment(#         when /\\bWI\\b/ : print line)
comment(#         when /\\bMN\\b/ : print line)
comment(#     end)
comment(# end)
comment(# )
comment(# ---)

comment(# Note: (above\) Ruby 1.8+ allows the 'when EXP : EXPR' on one line)
comment(# with the colon separator.)

comment(#-----------------------------)
comment(#!/usr/bin/ruby)
comment(# popgrep3 - grep for abbreviations of places that say "pop")
comment(# version3: build a match_any function)
ident(popstates) operator(=) string<delimiter(%w()content(CO ON MI WI MN)delimiter(\))>
ident(expr) operator(=) ident(popstates)operator(.)ident(map)operator({)operator(|)ident(e)operator(|)string<delimiter(")content(line =~ /)char(\\\\)content(b)inline<delimiter(#{)ident(e)delimiter(})>char(\\\\)content(b/)delimiter(")>operator(})operator(.)ident(join)operator(()string<delimiter(')content(||)delimiter(')>operator(\))
ident(eval) string<delimiter(")content(def match_any(line\); )inline<delimiter(#{)ident(expr)delimiter(})>content(;end)delimiter(")>
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(match_any)operator(()ident(line)operator(\))
reserved(end)
comment(#-----------------------------)

comment(##  building a match_all function is a trivial)
comment(##  substitution of && for ||)
comment(##  here is a generalized example:)
comment(#!/usr/bin/ruby -w)
comment(## grepauth - print lines that mention both foo and bar)
reserved(class) class(MultiMatch) 
    reserved(def) method(initialize)operator(()operator(*)ident(patterns)operator(\))
        ident(_any) operator(=) ident(build_match)operator(()string<delimiter(')content(||)delimiter(')>operator(,)ident(patterns)operator(\))
        ident(_all) operator(=) ident(build_match)operator(()string<delimiter(')content(&&)delimiter(')>operator(,)ident(patterns)operator(\))
        ident(eval) string<delimiter(")content(def match_any(line\);)inline<delimiter(#{)ident(_any)delimiter(})>content(;end)char(\\n)delimiter(")>
        ident(eval) string<delimiter(")content(def match_all(line\);)inline<delimiter(#{)ident(_all)delimiter(})>content(;end)char(\\n)delimiter(")>
      reserved(end)
    reserved(def) method(build_match)operator(()ident(sym)operator(,)ident(args)operator(\))
        ident(args)operator(.)ident(map)operator({)operator(|)ident(e)operator(|)string<delimiter(")content(line =~ /)inline<delimiter(#{)ident(e)delimiter(})>content(/)delimiter(")>operator(})operator(.)ident(join)operator(()ident(sym)operator(\))
    reserved(end)
reserved(end)

ident(mm) operator(=) constant(MultiMatch)operator(.)ident(new)operator(()string<delimiter(')content(foo)delimiter(')>operator(,)string<delimiter(')content(bar)delimiter(')>operator(\))
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(mm)operator(.)ident(match_all)operator(()ident(line)operator(\))
reserved(end)
comment(#-----------------------------)

comment(#!/usr/bin/ruby)
comment(# popgrep4 - grep for abbreviations of places that say "pop")
comment(# version4: pretty fast, but simple: compile all re's first:)
ident(popstates) operator(=) string<delimiter(%w()content(CO ON MI WI MN)delimiter(\))>
ident(popstates) operator(=) ident(popstates)operator(.)ident(map)operator({)operator(|)ident(re)operator(|) regexp<delimiter(%r/)char(\\b)inline<delimiter(#{)ident(re)delimiter(})>char(\\b)delimiter(/)>operator(})
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(popstates)operator(.)ident(each) reserved(do) operator(|)ident(state_re)operator(|)
        reserved(if) ident(line) operator(=)operator(~) ident(state_re)
            ident(print) ident(line)
            reserved(break)
        reserved(end)
    reserved(end)
reserved(end)

comment(## speeds trials on the jargon file(412\): 26006 lines, 1.3MB)
comment(## popgrep1   => 7.040s)
comment(## popgrep2   => 0.656s)
comment(## popgrep2.5 => 0.633s)
comment(## popgrep3   => 0.675s)
comment(## popgrep4   => 1.027s)

comment(# unless speed is criticial, the technique in popgrep4 is a)
comment(# reasonable balance between speed and logical simplicity.)


comment(# @@PLEAC@@_6.11)
reserved(begin)
    ident(print) string<delimiter(")content(Pattern? )delimiter(")>
    ident(pat) operator(=) global_variable($stdin)operator(.)ident(gets)operator(.)ident(chomp)
    constant(Regexp)operator(.)ident(new)operator(()ident(pat)operator(\))
reserved(rescue) 
    ident(warn) string<delimiter(")content(Invalid Pattern)delimiter(")>
    reserved(retry)
reserved(end)


comment(# @@PLEAC@@_6.13)
comment(# uses the 'amatch' extension found on:)
comment(# http://raa.ruby-lang.org/project/amatch/)
ident(require) string<delimiter(')content(amatch)delimiter(')>
ident(matcher) operator(=) constant(Amatch)operator(.)ident(new)operator(()string<delimiter(')content(balast)delimiter(')>operator(\))
comment(#$relative, $distance = 0, 1)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(/usr/share/dict/words)delimiter(')>operator(\))operator(.)ident(each_line) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(matcher)operator(.)ident(search)operator(()ident(line)operator(\)) operator(<=) integer(1)
reserved(end)
comment(__END__
)comment(#CODE)
ident(ballast)
ident(ballasts)
ident(balustrade)
ident(balustrades)
ident(blast)
ident(blasted)
ident(blaster)
ident(blasters)
ident(blasting)
ident(blasts)


comment(# @@PLEAC@@_6.14)
ident(str)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\G)content(()char(\\d)content(\))delimiter(/)>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(token)operator(|)
    ident(puts) string<delimiter(")content(found )inline<delimiter(#{)ident(token)delimiter(})>delimiter(")>
reserved(end)
comment(#-----------------------------)
ident(n) operator(=) string<delimiter(")content(   49 here)delimiter(")>
ident(n)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\G)content( )delimiter(/)>operator(,)string<delimiter(')content(0)delimiter(')>operator(\))
ident(puts) ident(n)
comment(#-----------------------------)
ident(str) operator(=) string<delimiter(")content(3,4,5,9,120)delimiter(")>
ident(str)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\G)content(,?()char(\\d)content(+\))delimiter(/)>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(num)operator(|)
    ident(puts) string<delimiter(")content(Found number: )inline<delimiter(#{)ident(num)delimiter(})>delimiter(")>
reserved(end)
comment(#-----------------------------)
comment(# Ruby doesn't have the String.pos or a /c re modifier like Perl )
comment(# But it does have StringScanner in the standard library (strscn\))
comment(# which allows similar functionality:)

ident(require) string<delimiter(')content(strscan)delimiter(')>
ident(text) operator(=) string<delimiter(')content(the year 1752 lost 10 days on the 3rd of September)delimiter(')>
ident(sc) operator(=) constant(StringScanner)operator(.)ident(new)operator(()ident(text)operator(\))
reserved(while) ident(sc)operator(.)ident(scan)operator(()regexp<delimiter(/)content(.*?()char(\\d)content(+\))delimiter(/)>operator(\))
    ident(print) string<delimiter(")content(found: )inline<delimiter(#{)ident(sc)operator([)integer(1)operator(])delimiter(})>char(\\n)delimiter(")>   
reserved(end)
reserved(if) ident(sc)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\S)content(+)delimiter(/)>operator(\))
    ident(puts) string<delimiter(")content(Found )inline<delimiter(#{)ident(sc)operator([)integer(0)operator(])delimiter(})>content( after last number)delimiter(")>
reserved(end)
comment(#-----------------------------)
comment(# assuming continuing from above:)
ident(puts) string<delimiter(")content(The position in 'text' is: )inline<delimiter(#{)ident(sc)operator(.)ident(pos)delimiter(})>delimiter(")>
ident(sc)operator(.)ident(pos) operator(=) integer(30)
ident(puts) string<delimiter(")content(The position in 'text' is: )inline<delimiter(#{)ident(sc)operator(.)ident(pos)delimiter(})>delimiter(")>


comment(# @@PLEAC@@_6.15)
comment(#-----------------------------)
comment(# greedy pattern)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(<.*>)delimiter(/)modifier(m)>operator(,)string<delimiter(')delimiter(')>operator(\))   comment(# not good)

comment(# non-greedy (minimal\) pattern)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(<.*?>)delimiter(/)modifier(m)>operator(,)string<delimiter(')delimiter(')>operator(\))   comment(# not great)


comment(#-----------------------------)
comment(#<b><i>this</i> and <i>that</i> are important</b> Oh, <b><i>me too!</i></b>)
comment(#-----------------------------)
regexp<delimiter(%r{)content( <b><i>(.*?\)</i></b> )delimiter(})modifier(mx)>
comment(#-----------------------------)
regexp<delimiter(%r/)content(BEGIN((?:(?!BEGIN\).\)*\)END)delimiter(/)>
comment(#-----------------------------)
regexp<delimiter(%r{)content( <b><i>(  (?: (?!</b>|</i>\). \)*  \) </i></b> )delimiter(})modifier(mx)>
comment(#-----------------------------)
regexp<delimiter(%r{)content( <b><i>(  (?: (?!</[ib]>\). \)*  \) </i></b> )delimiter(})modifier(mx)>
comment(#-----------------------------)
regexp<delimiter(%r{)content(
    <b><i> 
    [^<]*  # stuff not possibly bad, and not possibly the end.
    (?:
 # at this point, we can have '<' if not part of something bad
     (?!  </?[ib]>  \)   # what we can't have
     <                  # okay, so match the '<'
     [^<]*              # and continue with more safe stuff
    \) *
    </i></b>
 )delimiter(})modifier(mx)>


comment(# @@PLEAC@@_6.16)
comment(#-----------------------------)
global_variable($/) operator(=) string<delimiter(")delimiter(")>
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(para)operator(|)
    ident(para)operator(.)ident(scan) regexp<delimiter(%r/)content(
                  )char(\\b)content(     # start at word boundary
                  ()char(\\S)content(+\)  # find chunk of non-whitespace
                  )char(\\b)content(     # until a word boundary
                  (      
                    )char(\\s)content(+  # followed by whitespace
                    )char(\\1)content(   # and that same chunk again
                    )char(\\b)content(   # and a word boundary
                  \) +    # one or more times
                )delimiter(/)modifier(xi)> reserved(do)
        ident(puts) string<delimiter(")content(dup word ')inline<delimiter(#{)global_variable($1)delimiter(})>content(' at paragraph )inline<delimiter(#{)global_variable($.)delimiter(})>delimiter(")> 
    reserved(end)
reserved(end)
comment(#-----------------------------)
ident(astr) operator(=) string<delimiter(')content(nobody)delimiter(')>
ident(bstr) operator(=) string<delimiter(')content(bodysnatcher)delimiter(')>
reserved(if) string<delimiter(")inline<delimiter(#{)ident(astr)delimiter(})>content( )inline<delimiter(#{)ident(bstr)delimiter(})>delimiter(")> operator(=)operator(~) regexp<delimiter(/)content(^()char(\\w)content(+\)()char(\\w)content(+\) )char(\\2)content(()char(\\w)content(+\)$)delimiter(/)>
    ident(print) string<delimiter(")inline<delimiter(#{)global_variable($2)delimiter(})>content( overlaps in )inline<delimiter(#{)global_variable($1)delimiter(})>content(-)inline<delimiter(#{)global_variable($2)delimiter(})>content(-)inline<delimiter(#{)global_variable($3)delimiter(})>delimiter(")>
reserved(end)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# prime_pattern -- find prime factors of argument using patterns)
pre_constant(ARGV) operator(<<) integer(180)
ident(cap) operator(=) string<delimiter(')content(o)delimiter(')> operator(*) pre_constant(ARGV)operator(.)ident(shift)
reserved(while) ident(cap) operator(=)operator(~) regexp<delimiter(/)content(^(oo+?\))char(\\1)content(+$)delimiter(/)>
    ident(print) global_variable($1)operator(.)ident(size)operator(,) string<delimiter(")content( )delimiter(")>
    ident(cap)operator(.)ident(gsub!)operator(()regexp<delimiter(/)inline<delimiter(#{)global_variable($1)delimiter(})>delimiter(/)>operator(,)string<delimiter(')content(o)delimiter(')>operator(\))
reserved(end)
ident(puts) ident(cap)operator(.)ident(size)
comment(#-----------------------------)
comment(#diophantine)
comment(# solve for 12x + 15y + 16z = 281, maximizing x)
reserved(if) operator(()string<delimiter(')content(o)delimiter(')> operator(*) integer(281)operator(\))operator(.)ident(match)operator(()regexp<delimiter(/)content(^(o*\))char(\\1)content({11}(o*\))char(\\2)content({14}(o*\))char(\\3)content({15}$)delimiter(/)>operator(\))
    ident(x)operator(,) ident(y)operator(,) ident(z) operator(=) global_variable($1)operator(.)ident(size)operator(,) global_variable($2)operator(.)ident(size)operator(,) global_variable($3)operator(.)ident(size)
    ident(puts) string<delimiter(")content(One solution is: x=)inline<delimiter(#{)ident(x)delimiter(})>content(; y=)inline<delimiter(#{)ident(y)delimiter(})>content(; z=)inline<delimiter(#{)ident(z)delimiter(})>delimiter(")>
reserved(else) 
    ident(puts) string<delimiter(")content(No solution.)delimiter(")>
reserved(end)
comment(#    => One solution is: x=17; y=3; z=2)

comment(#-----------------------------)
comment(# using different quantifiers:)
operator(()string<delimiter(')content(o)delimiter(')> operator(*) integer(281)operator(\))operator(.)ident(match)operator(()regexp<delimiter(/)content(^(o+\))char(\\1)content({11}(o+\))char(\\2)content({14}(o+\))char(\\3)content({15}$)delimiter(/)>operator(\))
comment(#    => One solution is: x=17; y=3; z=2)

operator(()string<delimiter(')content(o)delimiter(')> operator(*) integer(281)operator(\))operator(.)ident(match)operator(()regexp<delimiter(/)content(^(o*?\))char(\\1)content({11}(o*\))char(\\2)content({14}(o*\))char(\\3)content({15}$)delimiter(/)>operator(\))
comment(#    => One solution is: x=0; y=7; z=11)

operator(()string<delimiter(')content(o)delimiter(')> operator(*) integer(281)operator(\))operator(.)ident(match)operator(()regexp<delimiter(/)content(^(o+?\))char(\\1)content({11}(o*\))char(\\2)content({14}(o*\))char(\\3)content({15}$)delimiter(/)>operator(\))
comment(#    => One solution is: x=1; y=3; z=14)


comment(# @@PLEAC@@_6.17)
comment(# alpha OR beta)
regexp<delimiter(%r/)content(alpha|beta)delimiter(/)>

comment(# alpha AND beta)
regexp<delimiter(%r/)content((?=.*alpha\)(?=.*beta\))delimiter(/)modifier(m)>

comment(# alpha AND beta,  no overlap)
regexp<delimiter(%r/)content(alpha.*beta|beta.*alpha)delimiter(/)modifier(m)>

comment(# NOT beta)
regexp<delimiter(%r/)content(^(?:(?!beta\).\)*$)delimiter(/)modifier(m)>

comment(# NOT bad BUT good)
regexp<delimiter(%r/)content((?=(?:(?!BAD\).\)*$\)GOOD)delimiter(/)modifier(m)>
comment(#-----------------------------)

reserved(if) operator(!)operator(()ident(string) operator(=)operator(~) regexp<delimiter(/)content(pattern)delimiter(/)>operator(\))   comment(# ugly)
    ident(something)operator(()operator(\))
reserved(end)

reserved(if) ident(string) operator(!)operator(~) regexp<delimiter(/)content(pattern)delimiter(/)>   comment(# preferred)
    ident(something)operator(()operator(\))
reserved(end)


comment(#-----------------------------)
reserved(if) ident(string) operator(=)operator(~) regexp<delimiter(/)content(pat1)delimiter(/)>  operator(&&) ident(string) operator(=)operator(~) regexp<delimiter(/)content(pat2)delimiter(/)>
    ident(something)operator(()operator(\))
reserved(end)
comment(#-----------------------------)
reserved(if) ident(string) operator(=)operator(~) regexp<delimiter(/)content(pat1)delimiter(/)> operator(||) ident(string) operator(=)operator(~) regexp<delimiter(/)content(pat2)delimiter(/)>
    ident(something)operator(()operator(\))
reserved(end)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# minigrep - trivial grep)
ident(pat) operator(=) pre_constant(ARGV)operator(.)ident(shift)
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(print) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)inline<delimiter(#{)ident(pat)delimiter(})>delimiter(/)modifier(o)>
reserved(end)
comment(#-----------------------------)
 string<delimiter(")content(labelled)delimiter(")> operator(=)operator(~) regexp<delimiter(/)content(^(?=.*bell\)(?=.*lab\))delimiter(/)modifier(m)>
comment(#-----------------------------)
global_variable($string) operator(=)operator(~) regexp<delimiter(/)content(bell)delimiter(/)> operator(&&) global_variable($string) operator(=)operator(~) regexp<delimiter(/)content(lab)delimiter(/)>
comment(#-----------------------------)
global_variable($murray_hill) operator(=) string<delimiter(")content(blah bell blah )delimiter(")>
reserved(if) global_variable($murray_hill) operator(=)operator(~) regexp<delimiter(%r{)content(
                         ^              # start of string
                        (?=             # zero-width lookahead
                            .*          # any amount of intervening stuff
                            bell        # the desired bell string
                        \)               # rewind, since we were only looking
                        (?=             # and do the same thing
                            .*          # any amount of intervening stuff
                            lab         # and the lab part
                        \)
                     )delimiter(})modifier(mx)>                comment(# /m means . can match newline)

    ident(print) string<delimiter(")content(Looks like Bell Labs might be in Murray Hill!)char(\\n)delimiter(")>operator(;)
reserved(end)
comment(#-----------------------------)
string<delimiter(")content(labelled)delimiter(")> operator(=)operator(~) regexp<delimiter(/)content((?:^.*bell.*lab\)|(?:^.*lab.*bell\))delimiter(/)>
comment(#-----------------------------)
global_variable($brand) operator(=) string<delimiter(")content(labelled)delimiter(")>operator(;)
reserved(if) global_variable($brand) operator(=)operator(~) regexp<delimiter(%r{)content(
                (?:                 # non-capturing grouper
                    ^ .*?           # any amount of stuff at the front
                      bell          # look for a bell
                      .*?           # followed by any amount of anything
                      lab           # look for a lab
                  \)                 # end grouper
            |                       # otherwise, try the other direction
                (?:                 # non-capturing grouper
                    ^ .*?           # any amount of stuff at the front
                      lab           # look for a lab
                      .*?           # followed by any amount of anything
                      bell          # followed by a bell
                  \)                 # end grouper
            )delimiter(})modifier(mx)>                     comment(# /m means . can match newline)
    ident(print) string<delimiter(")content(Our brand has bell and lab separate.)char(\\n)delimiter(")>operator(;)
reserved(end)
comment(#-----------------------------)
global_variable($map) operator(=)operator(~) regexp<delimiter(/)content(^(?:(?!waldo\).\)*$)delimiter(/)modifier(s)>
comment(#-----------------------------)
global_variable($map) operator(=) string<delimiter(")content(the great baldo)delimiter(")>
reserved(if) global_variable($map) operator(=)operator(~) regexp<delimiter(%r{)content(
                ^                   # start of string
                (?:                 # non-capturing grouper
                    (?!             # look ahead negation
                        waldo       # is he ahead of us now?
                    \)               # is so, the negation failed
                    .               # any character (cuzza /s\)
                \) *                 # repeat that grouping 0 or more
                $                   # through the end of the string
             )delimiter(})modifier(mx)>                    comment(# /m means . can match newline)
    ident(print) string<delimiter(")content(There's no waldo here!)char(\\n)delimiter(")>operator(;)
reserved(end)
comment(=begin
 7:15am  up 206 days, 13:30,  4 users,  load average: 1.04, 1.07, 1.04

USER     TTY      FROM              LOGIN@  IDLE   JCPU   PCPU  WHAT

tchrist  tty1                       5:16pm 36days 24:43   0.03s  xinit

tchrist  tty2                       5:19pm  6days  0.43s  0.43s  -tcsh

tchrist  ttyp0    chthon            7:58am  3days 23.44s  0.44s  -tcsh

gnat     ttyS4    coprolith         2:01pm 13:36m  0.30s  0.30s  -tcsh
=end)
comment(#% w | minigrep '^(?!.*ttyp\).*tchrist')
comment(#-----------------------------)
regexp<delimiter(%r{)content(
    ^                       # anchored to the start
    (?!                     # zero-width look-ahead assertion
        .*                  # any amount of anything (faster than .*?\)
        ttyp                # the string you don't want to find
    \)                       # end look-ahead negation; rewind to start
    .*                      # any amount of anything (faster than .*?\)
    tchrist                 # now try to find Tom
)delimiter(})modifier(x)>
comment(#-----------------------------)
comment(#% w | grep tchrist | grep -v ttyp)
comment(#-----------------------------)
comment(#% grep -i 'pattern' files)
comment(#% minigrep '(?i\)pattern' files)
comment(#-----------------------------)


comment(# @@PLEAC@@_6.20)
ident(ans) operator(=) global_variable($stdin)operator(.)ident(gets)operator(.)ident(chomp)
ident(re) operator(=) regexp<delimiter(%r/)content(^)inline<delimiter(#{)constant(Regexp)operator(.)ident(quote)operator(()ident(ans)operator(\))delimiter(})>delimiter(/)>
reserved(case) 
    reserved(when) string<delimiter(")content(SEND)delimiter(")>  operator(=)operator(~) ident(re) operator(:) ident(puts) string<delimiter(")content(Action is send)delimiter(")>
    reserved(when) string<delimiter(")content(STOP)delimiter(")>  operator(=)operator(~) ident(re) operator(:) ident(puts) string<delimiter(")content(Action is stop)delimiter(")>
    reserved(when) string<delimiter(")content(ABORT)delimiter(")> operator(=)operator(~) ident(re) operator(:) ident(puts) string<delimiter(")content(Action is abort)delimiter(")>
    reserved(when) string<delimiter(")content(EDIT)delimiter(")>  operator(=)operator(~) ident(re) operator(:) ident(puts) string<delimiter(")content(Action is edit)delimiter(")>
reserved(end)
comment(#-----------------------------)
ident(require) string<delimiter(')content(abbrev)delimiter(')>
ident(table) operator(=) constant(Abbrev)operator(.)ident(abbrev) string<delimiter(%w-)content(send stop abort edit)delimiter(-)>
ident(loop) reserved(do)
    ident(print) string<delimiter(")content(Action: )delimiter(")>
    ident(ans) operator(=) global_variable($stdin)operator(.)ident(gets)operator(.)ident(chomp)
    ident(puts) string<delimiter(")content(Action for )inline<delimiter(#{)ident(ans)delimiter(})>content( is )inline<delimiter(#{)ident(table)operator([)ident(ans)operator(.)ident(downcase)operator(])delimiter(})>delimiter(")>
reserved(end)


comment(#-----------------------------)
comment(# dummy values are defined for 'file', 'PAGER', and)
comment(# the 'invoke_editor' and 'deliver_message' methods)
comment(# do not do anything interesting in this example.)
comment(#!/usr/bin/ruby -w)
ident(require) string<delimiter(')content(abbrev)delimiter(')>

ident(file) operator(=) string<delimiter(')content(pleac_ruby.data)delimiter(')>
constant(PAGER) operator(=) string<delimiter(')content(less)delimiter(')>

reserved(def) method(invoke_editor)
    ident(puts) string<delimiter(")content(invoking editor)delimiter(")>
reserved(end)

reserved(def) method(deliver_message)
    ident(puts) string<delimiter(")content(delivering message)delimiter(")>
reserved(end)

ident(actions) operator(=) operator({)
    string<delimiter(')content(edit)delimiter(')>  operator(=)operator(>) pre_constant(self)operator(.)ident(method)operator(()symbol(:invoke_editor)operator(\))operator(,)
    string<delimiter(')content(send)delimiter(')>  operator(=)operator(>) pre_constant(self)operator(.)ident(method)operator(()symbol(:deliver_message)operator(\))operator(,)
    string<delimiter(')content(list)delimiter(')>  operator(=)operator(>) ident(proc) operator({)ident(system)operator(()constant(PAGER)operator(,) ident(file)operator(\))operator(})operator(,)
    string<delimiter(')content(abort)delimiter(')> operator(=)operator(>) ident(proc) operator({)ident(puts) string<delimiter(")content(See ya!)delimiter(")>operator(;) ident(exit)operator(})operator(,)
    string<delimiter(")delimiter(")>      operator(=)operator(>) ident(proc) operator({)ident(puts) string<delimiter(")content(Unknown Command)delimiter(")>operator(})
operator(})

ident(dtable) operator(=) constant(Abbrev)operator(.)ident(abbrev)operator(()ident(actions)operator(.)ident(keys)operator(\))
ident(loop) reserved(do)
    ident(print) string<delimiter(")content(Action: )delimiter(")>
    ident(ans) operator(=) global_variable($stdin)operator(.)ident(gets)operator(.)ident(chomp)operator(.)ident(delete)operator(()string<delimiter(")content( )char(\\t)delimiter(")>operator(\))
    ident(actions)operator([) ident(dtable)operator([)ident(ans)operator(.)ident(downcase)operator(]) operator(||) string<delimiter(")delimiter(")> operator(])operator(.)ident(call)
reserved(end)


comment(# @@PLEAC@@_6.19)
comment(#-----------------------------)
comment(# basically, the Perl Cookbook categorizes this as an)
comment(# unsolvable problem ...)
comment(#-----------------------------)
integer(1) reserved(while) ident(addr)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\()content([^(\)]*)char(\\\))delimiter(/)>operator(,)string<delimiter(')delimiter(')>operator(\))
comment(#-----------------------------)
constant(Dear) ident(someuser)instance_variable(@host)operator(.)ident(com)operator(,)

constant(Please) ident(confirm) ident(the) ident(mail) ident(address) ident(you) ident(gave) ident(us) constant(Wed) constant(May)  integer(6) integer(09)operator(:)integer(38)operator(:)integer(41)
constant(MDT) integer(1998) ident(by) ident(replying) ident(to) ident(this) ident(message)operator(.)  constant(Include) ident(the) ident(string)
string<delimiter(")content(Rumpelstiltskin)delimiter(")> reserved(in) ident(that) ident(reply)operator(,) ident(but) ident(spelled) reserved(in) ident(reverse)operator(;) ident(that) ident(is)operator(,)
ident(start) ident(with) string<delimiter(")content(Nik...)delimiter(")>operator(.)  constant(Once) ident(this) ident(is) ident(done)operator(,) ident(your) ident(confirmed) ident(address) ident(will)
ident(be) ident(entered) ident(into) ident(our) ident(records)operator(.)


comment(# @@PLEAC@@_6.21)
comment(#-----------------------------)
comment(#% gunzip -c ~/mail/archive.gz | urlify > archive.urlified)
comment(#-----------------------------)
comment(#% urlify ~/mail/*.inbox > ~/allmail.urlified)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# urlify - wrap HTML links around URL-like constructs)

ident(urls) operator(=) string<delimiter(')content((https?|telnet|gopher|file|wais|ftp\))delimiter(')>operator(;)
ident(ltrs) operator(=) string<delimiter(')content(\\w)delimiter(')>operator(;)
ident(gunk) operator(=) string<delimiter(')content(/#~:.?+=&%@!)content(\\-)delimiter(')>operator(;)
ident(punc) operator(=) string<delimiter(')content(.:?)content(\\-)delimiter(')>operator(;)
ident(any)  operator(=) string<delimiter(")inline<delimiter(#{)ident(ltrs)delimiter(})>inline<delimiter(#{)ident(gunk)delimiter(})>inline<delimiter(#{)ident(punc)delimiter(})>delimiter(")>operator(;)

pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(line)operator(.)ident(gsub!) regexp<delimiter(%r/)content(
        )char(\\b)content(                    # start at word boundary
        (                     # begin $1  {
         )inline<delimiter(#{)ident(urls)delimiter(})>content(     :        # need resource and a colon
         [)inline<delimiter(#{)ident(any)delimiter(})>content(] +?          # followed by on or more
                              #  of any valid character, but
                              #  be conservative and take only
                              #  what you need to....
        \)                     # end   $1  }
        (?=                   # look-ahead non-consumptive assertion
         [)inline<delimiter(#{)ident(punc)delimiter(})>content(]*           # either 0 or more punctuation
         [^)inline<delimiter(#{)ident(any)delimiter(})>content(]            #   followed by a non-url char
         |                    # or else
         $                    #   then end of the string
        \)
    )delimiter(/)modifier(iox)> reserved(do) 
        string<delimiter(%Q|)content(<A HREF=")inline<delimiter(#{)global_variable($1)delimiter(})>content(">)inline<delimiter(#{)global_variable($1)delimiter(})>content(</A>)delimiter(|)>
    reserved(end)
    ident(print) ident(line)
reserved(end)


comment(# @@PLEAC@@_6.23)
regexp<delimiter(%r/)content(^m*(d?c{0,3}|c[dm]\)(l?x{0,3}|x[lc]\)(v?i{0,3}|i[vx]\)$)delimiter(/)modifier(i)>
comment(#-----------------------------)
ident(str)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(()char(\\S)content(+\)()char(\\s)content(+\)()char(\\S)content(+\))delimiter(/)>operator(,) string<delimiter(')content(\\3)content(\\2)content(\\1)delimiter(')>operator(\))
comment(#-----------------------------)
regexp<delimiter(%r/)content(()char(\\w)content(+\))char(\\s)content(*=)char(\\s)content(*(.*\))char(\\s)content(*$)delimiter(/)>             comment(# keyword is $1, value is $2)
comment(#-----------------------------)
regexp<delimiter(%r/)content(.{80,})delimiter(/)>
comment(#-----------------------------)
regexp<delimiter(%r|)content(()char(\\d)content(+\)/()char(\\d)content(+\)/()char(\\d)content(+\) ()char(\\d)content(+\):()char(\\d)content(+\):()char(\\d)content(+\))delimiter(|)>
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(%r|)content(/usr/bin)delimiter(|)>operator(,)string<delimiter(')content(/usr/local/bin)delimiter(')>operator(\))
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(%([0-9A-Fa-f][0-9A-Fa-f]\))delimiter(/)>operator(\))operator({) global_variable($1)operator(.)ident(hex)operator(.)ident(chr) operator(})
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(%r{)content(
    /)char(\\*)content(                    # Match the opening delimiter
    .*?                    # Match a minimal number of characters
    )char(\\*)content(/                    # Match the closing delimiter
)delimiter(})modifier(xm)>operator(,)string<delimiter(')delimiter(')>operator(\))
comment(#-----------------------------)
ident(str)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(^)char(\\s)content(+)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))
ident(str)operator(.)ident(sub!)operator(()regexp<delimiter(/)char(\\s)content(+$)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))

comment(# but really, in Ruby we'd just do:)
ident(str)operator(.)ident(strip!)
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\\\)content(n)delimiter(/)>operator(,)string<delimiter(")char(\\n)delimiter(")>operator(\))
comment(#-----------------------------)
ident(str)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(^.*::)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))
comment(#-----------------------------)
regexp<delimiter(%r/)content(^([01]?)char(\\d)char(\\d)content(|2[0-4])char(\\d)content(|25[0-5]\))char(\\.)content(([01]?)char(\\d)char(\\d)content(|2[0-4])char(\\d)content(|25[0-5]\))char(\\.)content(
    ([01]?)char(\\d)char(\\d)content(|2[0-4])char(\\d)content(|25[0-5]\))char(\\.)content(([01]?)char(\\d)char(\\d)content(|2[0-4])char(\\d)content(|25[0-5]\)$)delimiter(/)modifier(x)>
comment(#-----------------------------)
ident(str)operator(.)ident(sub!)operator(()regexp<delimiter(%r|)content(^.*/)delimiter(|)>operator(,) string<delimiter(')delimiter(')>operator(\))
comment(#-----------------------------)
ident(cols) operator(=) operator(() operator(()constant(ENV)operator([)string<delimiter(')content(TERMCAP)delimiter(')>operator(]) operator(||) string<delimiter(")content( )delimiter(")>operator(\)) operator(=)operator(~) regexp<delimiter(/)content(:co#()char(\\d)content(+\):)delimiter(/)> operator(\)) operator(?) global_variable($1) operator(:) integer(80)operator(;)
comment(#-----------------------------)
ident(name) operator(=) string<delimiter(")content( )inline<delimiter(#{)global_variable($0)delimiter(})>content( )inline<delimiter(#{)pre_constant(ARGV)delimiter(})>delimiter(")>operator(.)ident(gsub)operator(()regexp<delimiter(%r|)content( /)char(\\S)content(+/)delimiter(|)>operator(,) string<delimiter(')content( )delimiter(')>operator(\))
comment(#-----------------------------)
ident(require) string<delimiter(')content(rbconfig)delimiter(')>
ident(include) constant(Config)
ident(raise) string<delimiter(")content(This isn't Linux)delimiter(")> reserved(unless) constant(CONFIG)operator([)string<delimiter(')content(target_os)delimiter(')>operator(]) operator(=)operator(~) regexp<delimiter(/)content(linux)delimiter(/)modifier(i)>operator(;)
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(%r/)char(\\n)char(\\s)content(+)delimiter(/)>operator(,) string<delimiter(')content( )delimiter(')>operator(\))
comment(#-----------------------------)
ident(nums) operator(=) ident(str)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\d)content(+)char(\\.)content(?)char(\\d)content(*|)char(\\.)char(\\d)content(+\))delimiter(/)>operator(\))
comment(#-----------------------------)
ident(capwords) operator(=) ident(str)operator(.)ident(scan)operator(()regexp<delimiter(%r/)content(()char(\\b)content([^)char(\\W)content(a-z0-9_]+)char(\\b)content(\))delimiter(/)>operator(\))
comment(#-----------------------------)
ident(lowords) operator(=) ident(str)operator(.)ident(scan)operator(()regexp<delimiter(%r/)content(()char(\\b)content([^)char(\\W)content(A-Z0-9_]+)char(\\b)content(\))delimiter(/)>operator(\))
comment(#-----------------------------)
ident(icwords) operator(=) ident(str)operator(.)ident(scan)operator(()regexp<delimiter(%r/)content(()char(\\b)content([^)char(\\W)content(a-z0-9_][^)char(\\W)content(A-Z0-9_]*)char(\\b)content(\))delimiter(/)>operator(\))
comment(#-----------------------------)
ident(links) operator(=) ident(str)operator(.)ident(scan)operator(()regexp<delimiter(%r/)content(<A[^>]+?HREF)char(\\s)content(*=)char(\\s)content(*["']?([^'" >]+?\)[ '"]?>)delimiter(/)modifier(mi)>operator(\))
comment(#-----------------------------)
ident(initial) operator(=) ident(str) operator(=)operator(~) regexp<delimiter(/)content(^)char(\\S)content(+)char(\\s)content(+()char(\\S)content(\))char(\\S)content(*)char(\\s)content(+)char(\\S)delimiter(/)> operator(?) global_variable($1) operator(:) string<delimiter(")delimiter(")>
comment(#-----------------------------)
ident(str)operator(.)ident(gsub!)operator(()regexp<delimiter(%r/)content("([^"]*\)")delimiter(/)>operator(,) string<delimiter(%q-)content(``)content(\\1)content('')delimiter(-)>operator(\))
comment(#-----------------------------)

global_variable($/) operator(=) string<delimiter(")delimiter(")>
ident(sentences) operator(=) operator([)operator(])
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(para)operator(|)
    ident(para)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(,) string<delimiter(')content( )delimiter(')>operator(\))
    ident(para)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content( {3,})delimiter(/)>operator(,)string<delimiter(')content(  )delimiter(')>operator(\))
    ident(sentences) operator(<<) ident(para)operator(.)ident(scan)operator(()regexp<delimiter(/)content(()char(\\S)content(.*?[!?.]\)(?=  |)char(\\Z)content(\))delimiter(/)>operator(\))
reserved(end)

comment(#-----------------------------)
regexp<delimiter(%r/)content(()char(\\d)content({4}\)-()char(\\d)char(\\d)content(\)-()char(\\d)char(\\d)content(\))delimiter(/)>            comment(# YYYY in $1, MM in $2, DD in $3)
comment(#-----------------------------)
regexp<delimiter(%r/)content( ^
      (?:
       1 )char(\\s)content( (?: )char(\\d)char(\\d)char(\\d)content( )char(\\s)content(\)?            # 1, or 1 and area code
       |                               # ... or ...
       )char(\\()char(\\d)char(\\d)char(\\d)char(\\\))content( )char(\\s)content(                   # area code with parens
       |                               # ... or ...
       (?: )char(\\+)char(\\d)char(\\d)content(?)char(\\d)content(? )char(\\s)content(\)?             # optional +country code
       )char(\\d)char(\\d)char(\\d)content( ([)char(\\s)char(\\-)content(]\)                 # and area code
      \)
      )char(\\d)char(\\d)char(\\d)content( ()char(\\s)content(|)char(\\1)content(\)                   # prefix (and area code separator\)
      )char(\\d)char(\\d)char(\\d)char(\\d)content(                         # exchange
        $
 )delimiter(/)modifier(x)>
comment(#-----------------------------)
regexp<delimiter(%r/)char(\\b)content(oh)char(\\s)content(+my)char(\\s)content(+gh?o(d(dess(es\)?|s?\)|odness|sh\))char(\\b)delimiter(/)modifier(i)>
comment(#-----------------------------)
ident(lines) operator(=) operator([)operator(])
ident(lines) operator(<<) global_variable($1) reserved(while) ident(input)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(^([^)char(\\012)char(\\015)content(]*\)()char(\\012)char(\\015)content(?|)char(\\015)char(\\012)content(?\))delimiter(/)>operator(,)string<delimiter(')delimiter(')>operator(\))


comment(# @@PLEAC@@_7.0)
comment(# An IO object being Enumerable, we can use 'each' directly on it)
constant(File)operator(.)ident(open)operator(()string<delimiter(")content(/usr/local/widgets/data)delimiter(")>operator(\))operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
    ident(puts) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)content(blue)delimiter(/)>
operator(})

ident(logfile) operator(=) constant(File)operator(.)ident(new)operator(()string<delimiter(")content(/var/log/rubylog.txt)delimiter(")>operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
ident(mysub)operator(()global_variable($stdin)operator(,) ident(logfile)operator(\))

comment(# The method IO#readline is similar  to IO#gets)
comment(# but throws an exception when it reaches EOF)
ident(f) operator(=) constant(File)operator(.)ident(new)operator(()string<delimiter(")content(bla.txt)delimiter(")>operator(\))
reserved(begin)
    reserved(while) operator(()ident(line) operator(=) ident(f)operator(.)ident(readline)operator(\))
        ident(line)operator(.)ident(chomp)
        global_variable($stdout)operator(.)ident(print) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)content(blue)delimiter(/)>
    reserved(end)
reserved(rescue) constant(EOFError)
    ident(f)operator(.)ident(close)
reserved(end)

reserved(while) global_variable($stdin)operator(.)ident(gets)                        comment(# reads from STDIN)
    reserved(unless) operator(()regexp<delimiter(/)char(\\d)delimiter(/)>operator(\)) 
        global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(No digit found.)delimiter(")>   comment(# writes to STDERR)
    reserved(end)
    ident(puts) string<delimiter(")content(Read: )inline<delimiter(#{)global_variable($_)delimiter(})>delimiter(")>                   comment(# writes to STDOUT)
reserved(end)

ident(logfile) operator(=) constant(File)operator(.)ident(new)operator(()string<delimiter(")content(/tmp/log)delimiter(")>operator(,) string<delimiter(")content(w)delimiter(")>operator(\))

ident(logfile)operator(.)ident(close)

comment(# $defout (or its synonym '$>'\) is the destination of output)
comment(# for Kernel#print, Kernel#puts, and family functions)
ident(logfile) operator(=) constant(File)operator(.)ident(new)operator(()string<delimiter(")content(log.txt)delimiter(")>operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
ident(old) operator(=) global_variable($defout)
global_variable($defout) operator(=) ident(logfile)                 comment(# switch to logfile for output)
ident(puts) string<delimiter(")content(Countdown initiated ...)delimiter(")>
global_variable($defout) operator(=) ident(old)                     comment(# return to original output)
ident(puts) string<delimiter(")content(You have 30 seconds to reach minimum safety distance.)delimiter(")>


comment(# @@PLEAC@@_7.1)
ident(source) operator(=) constant(File)operator(.)ident(new)operator(()ident(path)operator(,) string<delimiter(")content(r)delimiter(")>operator(\))  comment(# open file "path" for reading only)
ident(sink)   operator(=) constant(File)operator(.)ident(new)operator(()ident(path)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))  comment(# open file "path" for writing only)

ident(source) operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDONLY)operator(\))  comment(# open file "path" for reading only)
ident(sink)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(\))  comment(# open file "path" for writing only)

ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) string<delimiter(")content(r+)delimiter(")>operator(\))  comment(# open "path" for reading and writing)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) ident(flags)operator(\)) comment(# open "path" with the flags "flags" (see examples below for flags\))

comment(# open file "path" read only)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) string<delimiter(")content(r)delimiter(")>operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDONLY)operator(\))

comment(# open file "path" write only, create it if it does not exist)
comment(# truncate it to zero length if it exists)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(TRUNC)operator(|)constant(File)operator(::)constant(CREAT)operator(\)) 
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(TRUNC)operator(|)constant(File)operator(::)constant(CREAT)operator(,) integer(0666)operator(\))  comment(# with permission 0666)

comment(# open file "path" write only, fails if file exists)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(EXCL)operator(|)constant(File)operator(::)constant(CREAT)operator(\)) 
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(EXCL)operator(|)constant(File)operator(::)constant(CREAT)operator(,) integer(0666)operator(\)) 

comment(# open file "path" for appending)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) string<delimiter(")content(a)delimiter(")>operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(APPEND)operator(|)constant(File)operator(::)constant(CREAT)operator(\)) 
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(APPEND)operator(|)constant(File)operator(::)constant(CREAT)operator(,) integer(0666)operator(\)) 

comment(# open file "path" for appending only when file exists)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(WRONLY)operator(|)constant(File)operator(::)constant(APPEND)operator(\)) 

comment(# open file "path" for reading and writing)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) string<delimiter(")content(r+)delimiter(")>operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDWR)operator(\))

comment(# open file for reading and writing, create a new file if it does not exist)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(CREAT)operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(CREAT)operator(,) integer(0600)operator(\))

comment(# open file "path" reading and writing, fails if file exists)
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(EXCL)operator(|)constant(File)operator(::)constant(CREAT)operator(\))
ident(file)   operator(=) constant(File)operator(.)ident(open)operator(()ident(path)operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(EXCL)operator(|)constant(File)operator(::)constant(CREAT)operator(,) integer(0600)operator(\))


comment(# @@PLEAC@@_7.2)
comment(# No problem with Ruby since the filename doesn't contain characters with)
comment(# special meaning; like Perl's sysopen)
constant(File)operator(.)ident(open)operator(()ident(filename)operator(,) string<delimiter(')content(r)delimiter(')>operator(\))


comment(# @@PLEAC@@_7.3)
constant(File)operator(.)ident(expand_path)operator(()string<delimiter(')content(~root/tmp)delimiter(')>operator(\))
comment(#=> "/root/tmp")
constant(File)operator(.)ident(expand_path)operator(()string<delimiter(')content(~rpcuser)delimiter(')>operator(\))
comment(#=> "/var/lib/nfs")

comment(# To expand ~/.. it explicitely needs the environment variable HOME)
constant(File)operator(.)ident(expand_path)operator(()string<delimiter(')content(~/tmp)delimiter(')>operator(\))
comment(#=> "/home/gc/tmp")


comment(# @@PLEAC@@_7.4)
comment(# The exception raised in Ruby reports the filename)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(afile)delimiter(')>operator(\))


comment(# @@PLEAC@@_7.5)
comment(# Standard Ruby distribution provides the following useful extension)
ident(require) string<delimiter(')content(tempfile)delimiter(')>
comment(# With the Tempfile class, the file is automatically deleted on garbage)
comment(# collection, so you won't need to remove it, later on.)
ident(tf) operator(=) constant(Tempfile)operator(.)ident(new)operator(()string<delimiter(')content(tmp)delimiter(')>operator(\))   comment(# a name is required to create the filename)

comment(# If you need to pass the filename to an external program you can use)
comment(# File#path, but don't forget to File#flush in order to flush anything)
comment(# living in some buffer somewhere.)
ident(tf)operator(.)ident(flush)
ident(system)operator(()string<delimiter(")content(/usr/bin/dowhatever )inline<delimiter(#{)ident(tf)operator(.)ident(path)delimiter(})>delimiter(")>operator(\))

ident(fh) operator(=) constant(Tempfile)operator(.)ident(new)operator(()string<delimiter(')content(tmp)delimiter(')>operator(\))
ident(fh)operator(.)ident(sync) operator(=) pre_constant(true)                comment(# autoflushes)
integer(10)operator(.)ident(times) operator({) operator(|)ident(i)operator(|) ident(fh)operator(.)ident(puts) ident(i) operator(})
ident(fh)operator(.)ident(rewind)
ident(puts) string<delimiter(')content(Tmp file has: )delimiter(')>operator(,) ident(fh)operator(.)ident(readlines)


comment(# @@PLEAC@@_7.6)
reserved(while) operator(()pre_constant(DATA)operator(.)ident(gets)operator(\)) reserved(do)
    comment(# process the line  )
reserved(end)
comment(__END__
# your data goes here
# __DATA__ doesn't exist in Ruby

)comment(#CODE)
comment(# get info about the script (size, date of last modification\))
ident(kilosize) operator(=) pre_constant(DATA)operator(.)ident(stat)operator(.)ident(size) operator(/) integer(1024)
ident(last_modif) operator(=) pre_constant(DATA)operator(.)ident(stat)operator(.)ident(mtime)
ident(puts) string<delimiter(")content(<P>Script size is )inline<delimiter(#{)ident(kilosize)delimiter(})>delimiter(")>
ident(puts) string<delimiter(")content(<P>Last script update: )inline<delimiter(#{)ident(last_modif)delimiter(})>delimiter(")>
comment(__END__
# DO NOT REMOVE THE PRECEEDING LINE.
# Everything else in this file will be ignored.
)comment(#CODE)


comment(# @@PLEAC@@_7.7)
reserved(while) ident(line) operator(=) ident(gets) reserved(do)
    comment(# do something with line.)
reserved(end)

comment(#  or )
reserved(while) ident(gets) reserved(do)
    comment(# do something with $_)
reserved(end)

comment(# or more rubyish)
global_variable($stdin)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    comment(# do stuff with line)
reserved(end)


comment(# ARGF may makes this more easy)
comment(# this is skipped if ARGV.size==0)
pre_constant(ARGV)operator(.)ident(each) reserved(do) operator(|)ident(filename)operator(|) 
    comment(# closing and exception handling are done by the block)
    ident(open)operator(()ident(filename)operator(\)) reserved(do) operator(|)ident(fd)operator(|) 
        ident(fd)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
            comment(# do stuff with line)
        reserved(end)   
    reserved(end) reserved(rescue) ident(abort)operator(()string<delimiter(")content(can't open %s)delimiter(")> operator(%) ident(filename)operator(\))
reserved(end)

comment(# globbing is done in the Dir module)
pre_constant(ARGV) operator(=) constant(Dir)operator([)string<delimiter(")content(*.[Cch])delimiter(")>operator(]) reserved(if) pre_constant(ARGV)operator(.)ident(empty?)

comment(# note: optparse is the preferred way to handle this)
reserved(if) operator(()pre_constant(ARGV)operator([)integer(0)operator(]) operator(==) string<delimiter(')content(-c)delimiter(')>operator(\))  
    ident(chop_first) operator(+=) integer(1)
    pre_constant(ARGV)operator(.)ident(shift)
reserved(end)


comment(# processing numerical options)
reserved(if) pre_constant(ARGV)operator([)integer(0)operator(]) operator(=)operator(~) regexp<delimiter(/)content(^-()char(\\d)content(+\)$)delimiter(/)>
    ident(columns) operator(=) global_variable($1)
    pre_constant(ARGV)operator(.)ident(shift)
reserved(end)

comment(# again, better to use optparse:)
ident(require) string<delimiter(')content(optparse)delimiter(')>
ident(nostdout) operator(=) integer(0)
ident(append) operator(=) integer(0)
ident(unbuffer) operator(=) integer(0)
ident(ignore_ints) operator(=) integer(0)
pre_constant(ARGV)operator(.)ident(options) reserved(do) operator(|)ident(opt)operator(|)
    ident(opt)operator(.)ident(on)operator(()string<delimiter(')content(-n)delimiter(')>operator(\)) operator({) ident(nostdout) operator(+=)integer(1) operator(})
    ident(opt)operator(.)ident(on)operator(()string<delimiter(')content(-a)delimiter(')>operator(\)) operator({) ident(append)   operator(+=)integer(1) operator(})
    ident(opt)operator(.)ident(on)operator(()string<delimiter(')content(-u)delimiter(')>operator(\)) operator({) ident(unbuffer) operator(+=)integer(1) operator(})
    ident(opt)operator(.)ident(on)operator(()string<delimiter(')content(-i)delimiter(')>operator(\)) operator({) ident(ignore_ints) operator(+=)integer(1) operator(})
    ident(opt)operator(.)ident(parse!)
reserved(end) reserved(or) ident(abort)operator(()string<delimiter(")content(usage: )delimiter(")> operator(+) pre_constant(__FILE__) operator(+) string<delimiter(")content( [-ainu] [filenames])delimiter(")>operator(\))

comment(# no need to do undef $/, we have File.read)
ident(str) operator(=) constant(File)operator(.)ident(read)operator(()pre_constant(ARGV)operator([)integer(0)operator(])operator(\))

comment(# again we have File.read)
ident(str) operator(=) constant(File)operator(.)ident(read)operator(()pre_constant(ARGV)operator([)integer(0)operator(])operator(\))

comment(# not sure what this should do:)
comment(# I believe open the file, print filename, lineno and line:)
pre_constant(ARGF)operator(.)ident(each_with_index) reserved(do) operator(|)ident(line)operator(,) ident(idx)operator(|)
    ident(print) pre_constant(ARGF)operator(.)ident(filename)operator(,) string<delimiter(")content(:)delimiter(")>operator(,) ident(idx)operator(,) string<delimiter(")content(;)delimiter(")>operator(,) ident(line)
reserved(end)

comment(# print all the lines in every file passed via command line that contains login)
pre_constant(ARGF)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(puts) ident(line) reserved(if) ident(line) operator(=)operator(~) regexp<delimiter(/)content(login)delimiter(/)>
reserved(end)
comment(#)
comment(# even this would fit)
comment(#%ruby -ne "print if /f/" 2.log)
comment(#)

pre_constant(ARGF)operator(.)ident(each) operator({) operator(|)ident(l)operator(|) ident(puts) ident(l)operator(.)ident(downcase!) operator(})

comment(#------------------)
comment(#!/usr/bin/ruby -p)
comment(# just like perl's -p)
global_variable($_)operator(.)ident(downcase!)
comment(#)

comment(# I don't know who should I trust. )
comment(# perl's version splits on \\w+ while python's on \\w.)

ident(chunks) operator(=) integer(0)

constant(File)operator(.)ident(read)operator(()pre_constant(ARGV)operator([)integer(0)operator(])operator(\))operator(.)ident(split)operator(.)ident(each) reserved(do) operator(|)ident(word)operator(|)
    reserved(next) reserved(if) ident(word) operator(=)operator(~) regexp<delimiter(/)content(^#)delimiter(/)>
    reserved(break) reserved(if) operator([)string<delimiter(")content(__DATA__)delimiter(")>operator(,) string<delimiter(")content(__END__)delimiter(")>operator(])operator(.)ident(member?) ident(word)
    ident(chunks) operator(+=) integer(1) 
reserved(end)

ident(print) string<delimiter(")content(Found )delimiter(")>operator(,) ident(chunks)operator(,) string<delimiter(")content( chunks)char(\\n)delimiter(")>


comment(# @@PLEAC@@_7.8)
ident(old) operator(=) constant(File)operator(.)ident(open)operator(()ident(old_file)operator(\))
ident(new) operator(=) constant(File)operator(.)ident(open)operator(()ident(new_file)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
reserved(while) ident(old)operator(.)ident(gets) reserved(do)
    comment(# change $_, then...)
    ident(new)operator(.)ident(print) global_variable($_)
reserved(end)
ident(old)operator(.)ident(close)
ident(new)operator(.)ident(close)
constant(File)operator(.)ident(rename)operator(()ident(old_file)operator(,) string<delimiter(")content(old.orig)delimiter(")>operator(\))
constant(File)operator(.)ident(rename)operator(()ident(new_file)operator(,) ident(old_file)operator(\))

reserved(while) ident(old)operator(.)ident(gets) reserved(do)
    reserved(if) global_variable($.) operator(==) integer(20) reserved(then) comment(# we are at the 20th line)
        ident(new)operator(.)ident(puts) string<delimiter(")content(Extra line 1)delimiter(")>
        ident(new)operator(.)ident(puts) string<delimiter(")content(Extra line 2)delimiter(")>
    reserved(end)
    ident(new)operator(.)ident(print) global_variable($_)
reserved(end)

reserved(while) ident(old)operator(.)ident(gets) reserved(do)
    reserved(next) reserved(if) integer(20)operator(..)integer(30) comment(# skip the 20th line to the 30th)
                   comment(# Ruby (and Perl\) permit to write if 20..30 )
                   comment(# instead of if (20 <= $.\) and ($. <= 30\))
    ident(new)operator(.)ident(print) global_variable($_)
reserved(end)


comment(# @@PLEAC@@_7.9)
comment(#% ruby -i.orig -pe 'FILTER COMMAND' file1 file2 file3 ...)
comment(#)
comment(#-----------------------------)
comment(##!/usr/bin/ruby -i.orig -p)
comment(# filter commands go here)
comment(#-----------------------------)

comment(#% ruby -pi.orig -e 'gsub!(/DATE/\){Time.now\)')

comment(# effectively becomes:)
pre_constant(ARGV) operator(<<) string<delimiter(')content(I)delimiter(')>
ident(oldfile) operator(=) string<delimiter(")delimiter(")>
reserved(while) ident(gets)
    reserved(if) pre_constant(ARGF)operator(.)ident(filename) operator(!=) ident(oldfile)
        ident(newfile) operator(=) pre_constant(ARGF)operator(.)ident(filename)
        constant(File)operator(.)ident(rename)operator(()ident(newfile)operator(,) ident(newfile) operator(+) string<delimiter(")content(.orig)delimiter(")>operator(\))
        global_variable($stdout) operator(=) constant(File)operator(.)ident(open)operator(()ident(newfile)operator(,)string<delimiter(')content(w)delimiter(')>operator(\))
        ident(oldfile) operator(=) ident(newfile)
    reserved(end)
    ident(gsub!)operator(()regexp<delimiter(/)content(DATE)delimiter(/)>operator(\))operator({)constant(Time)operator(.)ident(now)operator(})
    ident(print) 
reserved(end)
global_variable($stdout) operator(=) constant(STDOUT)
comment(#-----------------------------)
comment(#% ruby -i.old -pe 'gsub!(%r{\\bhisvar\\b}, 'hervar'\)' *.[Cchy])

comment(#-----------------------------)
comment(# set up to iterate over the *.c files in the current directory,)
comment(# editing in place and saving the old file with a .orig extension)
global_variable($-i) operator(=) string<delimiter(')content(.orig)delimiter(')>                       comment(# set up -i mode)
pre_constant(ARGV)operator(.)ident(replace)operator(()constant(Dir)operator([)string<delimiter(')content(*.[Cchy])delimiter(')>operator(])operator(\))
reserved(while) ident(gets)
    reserved(if) global_variable($.) operator(==) integer(1)
        ident(print) string<delimiter(")content(This line should appear at the top of each file)char(\\n)delimiter(")>
    reserved(end)
    ident(gsub!)operator(()regexp<delimiter(/)char(\\b)content((p\)earl)char(\\b)delimiter(/)modifier(i)>operator(,) string<delimiter(')content(\\1)content(erl)delimiter(')>operator(\))    comment(# Correct typos, preserving case)
    ident(print)
    pre_constant(ARGF)operator(.)ident(close) reserved(if) pre_constant(ARGF)operator(.)ident(eof)
reserved(end)


comment(# @@PLEAC@@_7.10)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(itest)delimiter(')>operator(,) string<delimiter(')content(r+)delimiter(')>operator(\)) reserved(do) operator(|)ident(f)operator(|)   comment(# open file for update)
    ident(lines) operator(=) ident(f)operator(.)ident(readlines)           comment(# read into array of lines)
    ident(lines)operator(.)ident(each) reserved(do) operator(|)ident(it)operator(|)            comment(# modify lines)
        ident(it)operator(.)ident(gsub!)operator(()regexp<delimiter(/)content(foo)delimiter(/)>operator(,) string<delimiter(')content(QQQ)delimiter(')>operator(\))
    reserved(end)
    ident(f)operator(.)ident(pos) operator(=) integer(0)                     comment(# back to start)
    ident(f)operator(.)ident(print) ident(lines)                 comment(# write out modified lines)
    ident(f)operator(.)ident(truncate)operator(()ident(f)operator(.)ident(pos)operator(\))             comment(# truncate to new length)
reserved(end)                               comment(# file is automatically closed)
comment(#-----------------------------)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(itest)delimiter(')>operator(,) string<delimiter(')content(r+)delimiter(')>operator(\)) reserved(do) operator(|)ident(f)operator(|)   
    ident(out) operator(=) string<delimiter(")delimiter(")>
    ident(f)operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
        ident(out) operator(<<) ident(line)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(DATE)delimiter(/)>operator(\)) operator({)constant(Time)operator(.)ident(now)operator(})
    reserved(end)
    ident(f)operator(.)ident(pos) operator(=) integer(0)                     
    ident(f)operator(.)ident(print) ident(out)
    ident(f)operator(.)ident(truncate)operator(()ident(f)operator(.)ident(pos)operator(\))             
reserved(end)

comment(# @@PLEAC@@_7.11)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(infile)delimiter(')>operator(,) string<delimiter(')content(r+)delimiter(')>operator(\)) reserved(do) operator(|)ident(f)operator(|)
    ident(f)operator(.)ident(flock) constant(File)operator(::)constant(LOCK_EX)
    comment(# update file)
reserved(end)
comment(#-----------------------------)
constant(File)operator(::)constant(LOCK_SH)     comment(# shared lock (for reading\))
constant(File)operator(::)constant(LOCK_EX)     comment(# exclusive lock (for writing\))
constant(File)operator(::)constant(LOCK_NB)     comment(# non-blocking request)
constant(File)operator(::)constant(LOCK_UN)     comment(# free lock)
comment(#-----------------------------)
reserved(unless) ident(f)operator(.)ident(flock) constant(File)operator(::)constant(LOCK_EX) operator(|) constant(File)operator(::)constant(LOCK_NB)
    ident(warn) string<delimiter(")content(can't get immediate lock: blocking ...)delimiter(")>
    ident(f)operator(.)ident(flock) constant(File)operator(::)constant(LOCK_EX) 
reserved(end)
comment(#-----------------------------)
constant(File)operator(.)ident(open)operator(()string<delimiter(')content(numfile)delimiter(')>operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(CREAT)operator(\)) reserved(do) operator(|)ident(f)operator(|)
    ident(f)operator(.)ident(flock)operator(()constant(File)operator(::)constant(LOCK_EX)operator(\))
    ident(num) operator(=) ident(f)operator(.)ident(gets)operator(.)ident(to_i) operator(||) integer(0)
    ident(f)operator(.)ident(pos) operator(=) integer(0)
    ident(f)operator(.)ident(truncate) integer(0)
    ident(f)operator(.)ident(puts) ident(num) operator(+) integer(1)ident(q)
reserved(end)


comment(# @@PLEAC@@_7.12)
ident(output_handle)operator(.)ident(sync) operator(=) pre_constant(true)
comment(# Please note that like in Perl, $stderr is already unbuffered)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# seeme - demo stdio output buffering)
global_variable($stdout)operator(.)ident(sync) operator(=) pre_constant(ARGV)operator(.)ident(size) operator(>) integer(0)
ident(print) string<delimiter(")content(Now you don't see it...)delimiter(")>
ident(sleep) integer(2)
ident(puts) string<delimiter(")content(now you do)delimiter(")>
comment(#-----------------------------)
global_variable($stderr)operator(.)ident(sync) operator(=) pre_constant(true)
ident(afile)operator(.)ident(sync) operator(=) pre_constant(false)
comment(#-----------------------------)
comment(# assume 'remote_con' is an interactive socket handle,)
comment(# but 'disk_file' is a handle to a regular file.)
ident(remote_con)operator(.)ident(sync) operator(=) pre_constant(true)       comment(# unbuffer for clarity)
ident(disk_file)operator(.)ident(sync) operator(=) pre_constant(false)       comment(# buffered for speed)
comment(#-----------------------------)
ident(require) string<delimiter(')content(socket)delimiter(')>
ident(sock) operator(=) constant(TCPSocket)operator(.)ident(new)operator(()string<delimiter(')content(www.ruby-lang.org)delimiter(')>operator(,) integer(80)operator(\))
ident(sock)operator(.)ident(sync) operator(=) pre_constant(true)
ident(sock)operator(.)ident(puts) string<delimiter(")content(GET /en/ HTTP/1.0 )char(\\n)char(\\n)delimiter(")>
ident(resp) operator(=) ident(sock)operator(.)ident(read)
ident(print) string<delimiter(")content(DOC IS: )inline<delimiter(#{)ident(resp)delimiter(})>char(\\n)delimiter(")>


comment(# @@PLEAC@@_7.13)
comment(#-----------------------------)
comment(# assumes fh1, fh2, fh2 are oen IO objects)
ident(nfound) operator(=) ident(select)operator(()operator([)global_variable($stdin)operator(,) ident(fh1)operator(,) ident(fh2)operator(,) ident(fh3)operator(])operator(,) pre_constant(nil)operator(,) pre_constant(nil)operator(,) integer(0)operator(\))
ident(nfound)operator([)integer(0)operator(])operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
    reserved(case) ident(file)
        reserved(when) ident(fh1)
            comment(# do something with fh1)
        reserved(when) ident(fh2)
            comment(# do something with fh2)
        reserved(when) ident(fh3)
            comment(# do something with fh3)
    reserved(end)
reserved(end)
comment(#-----------------------------)
ident(input_files) operator(=) operator([)operator(])
comment(# repeat next line for all in-files to poll)
ident(input_files) operator(<<) ident(fh1)
reserved(if) ident(nfound) operator(=) ident(select)operator(()ident(input_files)operator(,) pre_constant(nil)operator(,) pre_constant(nil)operator(,) integer(0)operator(\))
    comment(# input ready on files in nfound[0])
reserved(end)


comment(# @@PLEAC@@_8.0)
comment(#-----------------------------)
comment(# datafile is a file or IO object)
ident(datafile)operator(.)ident(readlines)operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
    ident(line)operator(.)ident(chomp!)
    ident(size) operator(=) ident(line)operator(.)ident(length)
    ident(puts) ident(size)
operator(})
comment(#-----------------------------)
ident(datafile)operator(.)ident(readlines)operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
    ident(puts) ident(line)operator(.)ident(chomp!)operator(.)ident(length)
operator(})
comment(#-----------------------------)
ident(lines) operator(=) ident(datafile)operator(.)ident(readlines)
comment(#-----------------------------)
ident(whole_file) operator(=) ident(file)operator(.)ident(read)
comment(#-----------------------------)
comment(# ruby -040 -e 'word = gets; puts "First word is #{word}"')
comment(#-----------------------------)
comment(# ruby -ne 'BEGIN { $/="%%\\n" }; $_.chomp; puts $_ if( $_=~/Unix/i\)' fortune.dat)
comment(#-----------------------------)
ident(handle)operator(.)ident(print) string<delimiter(")content(one)delimiter(")>operator(,) string<delimiter(")content(two)delimiter(")>operator(,) string<delimiter(")content(three)delimiter(")> comment(# "onetwothree")
ident(puts) string<delimiter(")content(Baa baa black sheep.)delimiter(")>        comment(# sent to $stdout)
comment(#-----------------------------)
ident(buffer) operator(=) ident(handle)operator(.)ident(read)operator(()integer(4096)operator(\))
ident(rv)     operator(=) ident(buffer)operator(.)ident(length)
comment(#-----------------------------)
ident(handle)operator(.)ident(truncate)operator(()ident(length)operator(\))
ident(open)operator(()string<delimiter(")content(/tmp)inline<delimiter(#{)global_variable($$)delimiter(})>content(.pid)delimiter(")>operator(,) string<delimiter(')content(w)delimiter(')>operator(\)) operator({) operator(|)ident(handle)operator(|) ident(handle)operator(.)ident(truncate)operator(()ident(length)operator(\)) operator(})
comment(#-----------------------------)
ident(pos) operator(=) ident(datafile)operator(.)ident(pos)  comment(# tell is an alias of pos)
ident(puts) string<delimiter(")content(I'm )inline<delimiter(#{)ident(pos)delimiter(})>content( bytes from the start of datafile)delimiter(")>
comment(#-----------------------------)
ident(logfile)operator(.)ident(seek)operator(()integer(0)operator(,) constant(IO)operator(::)constant(SEEK_END)operator(\))
ident(datafile)operator(.)ident(seek)operator(()ident(pos)operator(\))  comment(#  IO::SEEK_SET is the default)
ident(out)operator(.)ident(seek)operator(()integer(-20)operator(,) constant(IO)operator(::)constant(SEEK_CUR)operator(\))
comment(#-----------------------------)
ident(written) operator(=) ident(datafile)operator(.)ident(syswrite)operator(()ident(mystring)operator(\))
ident(raise) constant(RunTimeError) reserved(unless) ident(written) operator(==) ident(mystring)operator(.)ident(length)
ident(block) operator(=) ident(infile)operator(.)ident(sysread)operator(()integer(256)operator(\))   comment(# no equivalent to perl offset parameter in sysread)
ident(puts) string<delimiter(")content(only read )inline<delimiter(#{)ident(block)operator(.)ident(length)delimiter(})>content( bytes)delimiter(")> reserved(if) integer(256) operator(!=) ident(block)operator(.)ident(length)
comment(#-----------------------------)
ident(pos) operator(=) ident(handle)operator(.)ident(sysseek)operator(()integer(0)operator(,) constant(IO)operator(::)constant(SEEK_CUR)operator(\))  comment(# don't change position)


comment(# @@PLEAC@@_8.1)
reserved(while) operator(()ident(line) operator(=) ident(fh)operator(.)ident(gets)operator(\))
    ident(line)operator(.)ident(chomp!)
    ident(nextline) operator(=) pre_constant(nil)
    ident(line)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\\\)content($)delimiter(/)>operator(\)) operator({) operator(|)ident(match)operator(|) ident(nextline) operator(=) ident(fh)operator(.)ident(gets)operator(;) string<delimiter(')delimiter(')> operator(})
    reserved(if) operator(()ident(nextline) operator(!=) pre_constant(nil)operator(\))
        ident(line) operator(+=) ident(nextline) 
        reserved(redo)
    reserved(end)
    comment(# process full record in line here)
reserved(end)
comment(#-----------------------------)
comment(# DISTFILES = $(DIST_COMMON\) $(SOURCES\) $(HEADERS\) \\)
comment(#         $(TEXINFOS\) $(INFOS\) $(MANS\) $(DATA\))
comment(# DEP_DISTFILES = $(DIST_COMMON\) $(SOURCES\) $(HEADERS\) \\)
comment(#         $(TEXINFOS\) $(INFO_DEPS\) $(MANS\) $(DATA\) \\)
comment(#         $(EXTRA_DIST\))
comment(#-----------------------------)
ident(line)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\\\)char(\\s)content(*$)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\)) operator({)
    comment(# as before)
operator(})


comment(# @@PLEAC@@_8.2)
comment(#-----------------------------)
ident(count) operator(=) shell<delimiter(`)content(wc -l < )inline<delimiter(#{)ident(filename)delimiter(})>delimiter(`)>
ident(fail) string<delimiter(")content(wc failed: )inline<delimiter(#{)global_variable($?)delimiter(})>delimiter(")> reserved(if) global_variable($?) operator(!=) integer(0)
ident(count)operator(.)ident(chomp!)
comment(#-----------------------------)
ident(count) operator(=) integer(0)
constant(File)operator(.)ident(open)operator(()ident(file)operator(,) string<delimiter(')content(r)delimiter(')>operator(\)) operator({) operator(|)ident(fh)operator(|)
    ident(count) operator(+=) integer(1) reserved(while) ident(fh)operator(.)ident(gets)
operator(})
comment(# count now holds the number of lines read)
comment(#-----------------------------)
ident(count) operator(=) integer(0)
reserved(while) operator(()ident(chunk) operator(=) ident(file)operator(.)ident(sysread)operator(()integer(2)operator(**)integer(16)operator(\))operator(\)) 
    ident(count) operator(+=) ident(chunk)operator(.)ident(count)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))
reserved(end) reserved(rescue) constant(EOFError)
comment(#-----------------------------)
constant(File)operator(.)ident(open)operator(()ident(filename)operator(,)string<delimiter(')content(r)delimiter(')>operator(\)) operator({) operator(|)ident(fh)operator(|)
    ident(count) operator(+=) integer(1) reserved(while) ident(fh)operator(.)ident(gets)
operator(})
comment(# count now holds the number of lines read)
comment(#-----------------------------)
comment(# As ruby doesn't quite have an equivalent to using a for)
comment(# statement as in perl, I threw this in)
ident(count) operator(=) constant(File)operator(.)ident(readlines)operator(()ident(filename)operator(\))operator(.)ident(size)
comment(#-----------------------------)
integer(1) reserved(while) ident(file)operator(.)ident(gets)
ident(count) operator(=) global_variable($.)
comment(#-----------------------------)
global_variable($/) operator(=) string<delimiter(')delimiter(')>
ident(open)operator(()ident(filename)operator(,) string<delimiter(')content(r)delimiter(')>operator(\)) operator({) operator(|)ident(fh)operator(|)
    integer(1) reserved(while) ident(fh)operator(.)ident(gets)
    ident(para_count) operator(=) global_variable($.)
operator(}) reserved(rescue) ident(fail)operator(()string<delimiter(")content(can't open )inline<delimiter(#{)ident(filename)delimiter(})>content(: $!)delimiter(")>operator(\)) 
comment(#-----------------------------)


comment(# ^^PLEAC^^_8.3)
comment(#-----------------------------)
reserved(while) operator(()ident(gets)operator(\))
    ident(split)operator(.)ident(each) operator({) operator(|)ident(chunk)operator(|)
        comment(# do something with chunk)
    operator(})
reserved(end)
comment(#-----------------------------)
reserved(while) operator(()ident(gets)operator(\))
    ident(gsub)operator(()regexp<delimiter(/)content(()char(\\w)content([)char(\\w)content('-]*\))delimiter(/)>operator(\)) operator({) operator(|)ident(word)operator(|)
        comment(# do something with word)
    operator(})
reserved(end)
comment(#-----------------------------)
comment(# Make a word frequency count)
comment(# normally hashes can be created using {} or just Hash.new)
comment(# but we want the default value of an entry to be 0 instead )
comment(# of nil. (nil can't be incremented\))
ident(seen) operator(=) constant(Hash)operator(.)ident(new)operator(()integer(0)operator(\))
reserved(while) operator(()ident(gets)operator(\))
    ident(gsub)operator(()regexp<delimiter(/)content(()char(\\w)content([)char(\\w)content('-]*\))delimiter(/)>operator(\)) operator({) operator(|)ident(word)operator(|)
        ident(seen)operator([)ident(word)operator(.)ident(downcase)operator(]) operator(+=) integer(1)
    operator(})
reserved(end)
comment(# output hash in a descending numeric sort of its values)
ident(seen)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(b)operator([)integer(1)operator(]) operator(<=>) ident(a)operator([)integer(1)operator(]) operator(})operator(.)ident(each) reserved(do) operator(|)ident(k)operator(,)ident(v)operator(|)
    ident(printf)operator(()string<delimiter(")content(%5d %s)char(\\n)delimiter(")>operator(,) ident(v)operator(,) ident(k) operator(\))
reserved(end)

comment(#-----------------------------)
comment(# Line frequency count)
ident(seen) operator(=) constant(Hash)operator(.)ident(new)operator(()integer(0)operator(\))
reserved(while) operator(()ident(gets)operator(\))
    ident(seen)operator([)global_variable($_)operator(.)ident(downcase)operator(]) operator(+=) integer(1)
reserved(end)
ident(seen)operator(.)ident(sort) operator({) operator(|)ident(a)operator(,)ident(b)operator(|) ident(b)operator([)integer(1)operator(]) operator(<=>) ident(a)operator([)integer(1)operator(]) operator(})operator(.)ident(each) reserved(do) operator(|)ident(k)operator(,)ident(v)operator(|)
    ident(printf)operator(()string<delimiter(")content(%5d %s)char(\\n)delimiter(")>operator(,) ident(v)operator(,) ident(k) operator(\))
reserved(end)
comment(#-----------------------------)


comment(# @@PLEAC@@_8.4)
comment(#-----------------------------)
comment(# instead of file handle FILE, we can just)
comment(# use a string containing the filename)
constant(File)operator(.)ident(readlines)operator(()ident(file)operator(\))operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
    comment(# do something with line)
operator(})
comment(#-----------------------------)
constant(File)operator(.)ident(readlines)operator(()ident(file)operator(\))operator(.)ident(reverse_each) operator({) operator(|)ident(line)operator(|)
    comment(# do something with line)
operator(})
comment(#-----------------------------)
comment(# the variable lines might have been created)
comment(# this way)
comment(# lines = File.readlines(file\))
comment(#)
comment(# normally one would use the reverse_each, but)
comment(# if you insist on using a numerical index to)
comment(# iterate over the lines array...)
operator(()ident(lines)operator(.)ident(size) operator(-) integer(1)operator(\))operator(.)ident(downto)operator(()integer(0)operator(\)) operator({) operator(|)ident(i)operator(|)
    ident(line) operator(=) ident(lines)operator([)ident(i)operator(])
operator(})
comment(#-----------------------------)
comment(# the second readlines argument is a the )
comment(# record separator $/, just like perl, a blank)
comment(# separator splits the records into paragraphs)
constant(File)operator(.)ident(readlines)operator(()ident(file)operator(,) string<delimiter(')delimiter(')>operator(\))operator(.)ident(each) operator({) operator(|)ident(paragraph)operator(|)
    comment(# do something with paragraph)
    ident(puts) string<delimiter(")content(->Paragraph )inline<delimiter(#{)ident(paragraph)delimiter(})>delimiter(")>
operator(})
comment(#-----------------------------)


comment(# @@PLEAC@@_8.6)

global_variable($/) operator(=) string<delimiter(")content(%)char(\\n)delimiter(")>operator(;)
ident(srand)operator(;)

constant(File)operator(.)ident(open)operator(()string<delimiter(')content(/usr/share/fortune/humorists)delimiter(')>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(line)operator(|)
    ident(adage) operator(=) ident(line) reserved(if) ident(rand)operator(()global_variable($.)operator(\)) operator(<) integer(1)
reserved(end)

ident(puts) ident(adage)operator(;)


comment(# @@PLEAC@@_8.10)
reserved(begin)
    ident(fh) operator(=) constant(File)operator(.)ident(open)operator(()ident(file)operator(,) string<delimiter(")content(r+)delimiter(")>operator(\))
    ident(addr) operator(=) ident(fh)operator(.)ident(tell) reserved(unless) ident(fh)operator(.)ident(eof) reserved(while) ident(fh)operator(.)ident(gets)
    ident(fh)operator(.)ident(truncate)operator(()ident(addr)operator(\))
reserved(rescue) constant(SystemCallError)
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")escape(#)global_variable($!)delimiter(")>
reserved(end)


comment(# @@PLEAC@@_9.0)
ident(entry) operator(=) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(/usr/bin/vi)delimiter(")>operator(\))
ident(entry) operator(=) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(/usr/bin)delimiter(")>operator(\))
ident(entry) operator(=) constant(File)operator(.)ident(stat)operator(()constant(INFILE)operator(\))

ident(entry) operator(=) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(/usr/bin/vi)delimiter(")>operator(\))
ident(ctime) operator(=) ident(entry)operator(.)ident(ctime)
ident(size)  operator(=) ident(entry)operator(.)ident(size)

ident(f) operator(=) constant(File)operator(.)ident(open)operator(()ident(filename)operator(,) string<delimiter(")content(r)delimiter(")>operator(\))

comment(## There is no -T equivalent in Ruby, but we can still test emptiness)
reserved(if) ident(test)operator(()integer(?s)operator(,) ident(filename)operator(\))
  ident(puts) string<delimiter(")inline<delimiter(#{)ident(filename)delimiter(})>content( doesn't have text in it.)delimiter(")>
  ident(exit)
reserved(end)

constant(Dir)operator(.)ident(new)operator(()string<delimiter(")content(/usr/bin)delimiter(")>operator(\))operator(.)ident(each) reserved(do) operator(|)ident(filename)operator(|)
  ident(puts) string<delimiter(")content(Inside /usr/bin is something called )inline<delimiter(#{)ident(filename)delimiter(})>delimiter(")>
reserved(end)


comment(# @@PLEAC@@_9.1)
ident(file) operator(=) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(filename)delimiter(")>operator(\))
ident(readtime)operator(,) ident(writetime) operator(=) ident(file)operator(.)ident(atime)operator(,) ident(file)operator(.)ident(mtime)
ident(file)operator(.)ident(utime)operator(()ident(readtime)operator(,) ident(writetime)operator(\))  

constant(SECONDS_PER_DAY) operator(=) integer(60) operator(*) integer(60) operator(*) integer(24)
ident(file) operator(=) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(filename)delimiter(")>operator(\))
ident(atime)operator(,) ident(mtime) operator(=) ident(file)operator(.)ident(atime)operator(,) ident(file)operator(.)ident(mtime)

ident(atime) operator(-=) integer(7) operator(*) constant(SECONDS_PER_DAY)
ident(mtime) operator(-=) integer(7) operator(*) constant(SECONDS_PER_DAY)

constant(File)operator(.)ident(utime)operator(()ident(atime)operator(,) ident(mtime)operator(,) ident(file)operator(\))
ident(mtime) operator(=) constant(File)operator(.)ident(stat)operator(()ident(file)operator(\))operator(.)ident(mtime)
constant(File)operator(.)ident(utime)operator(()constant(Time)operator(.)ident(new)operator(,) ident(mtime)operator(,) ident(file)operator(\))
constant(File)operator(.)ident(utime)operator(()constant(Time)operator(.)ident(new)operator(,) constant(File)operator(.)ident(stat)operator(()string<delimiter(")content(testfile)delimiter(")>operator(\))operator(.)ident(mtime)operator(,) ident(file)operator(\))

comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(## uvi - vi a file without changing it's access times)

reserved(if) pre_constant(ARGV)operator(.)ident(length) operator(!=) integer(1)
  ident(puts) string<delimiter(")content(usage: uvi filename)delimiter(")>
  ident(exit)
reserved(end)
ident(file) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
ident(atime)operator(,) ident(mtime) operator(=) constant(File)operator(.)ident(stat)operator(()ident(file)operator(\))operator(.)ident(atime)operator(,) constant(File)operator(.)ident(stat)operator(()ident(file)operator(\))operator(.)ident(mtime)
ident(system)operator(()constant(ENV)operator([)string<delimiter(")content(EDITOR)delimiter(")>operator(]) operator(||) string<delimiter(")content(vi)delimiter(")>operator(,) ident(file)operator(\))
constant(File)operator(.)ident(utime)operator(()ident(atime)operator(,) ident(mtime)operator(,) ident(file)operator(\))
comment(#-----------------------------)


comment(# @@PLEAC@@_9.2)
constant(File)operator(.)ident(unlink)operator(()constant(FILENAME)operator(\))

ident(err_flg) operator(=) pre_constant(false)
ident(filenames)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
  reserved(begin)
    constant(File)operator(.)ident(unlink)operator(()ident(file)operator(\))
  reserved(rescue)
    ident(err_flg) operator(=) global_variable($!)
  reserved(end)
reserved(end)
ident(err_flg) reserved(and) ident(raise) string<delimiter(")content(Couldn't unlink all of )inline<delimiter(#{)ident(filenames)operator(.)ident(join)operator(()string<delimiter(")content( )delimiter(")>operator(\))delimiter(})>content(: )inline<delimiter(#{)ident(err_flg)delimiter(})>delimiter(")>

constant(File)operator(.)ident(unlink)operator(()ident(file)operator(\))

ident(count) operator(=) ident(filenames)operator(.)ident(length)
ident(filenames)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
  reserved(begin)
    constant(File)operator(.)ident(unlink)operator(()ident(file)operator(\))
  reserved(rescue)
    ident(count) operator(-=) integer(1)
  reserved(end)
reserved(end)
reserved(if) ident(count) operator(!=) ident(filenames)operator(.)ident(length)
  constant(STDERR)operator(.)ident(puts) string<delimiter(")content(could only delete )inline<delimiter(#{)ident(count)delimiter(})>content( of )inline<delimiter(#{)ident(filenames)operator(.)ident(length)delimiter(})>content( files)delimiter(")>
reserved(end)


comment(# @@PLEAC@@_9.3)
ident(require) string<delimiter(")content(ftools)delimiter(")>
constant(File)operator(.)ident(copy)operator(()ident(oldfile)operator(,) ident(newfile)operator(\))

ident(infile)  operator(=) constant(File)operator(.)ident(open)operator(()ident(oldfile)operator(,) string<delimiter(")content(r)delimiter(")>operator(\))
ident(outfile) operator(=) constant(File)operator(.)ident(open)operator(()ident(newfile)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))

ident(blksize) operator(=) ident(infile)operator(.)ident(stat)operator(.)ident(blksize)
comment(# This doesn't handle partial writes or ^Z)
comment(# like the Perl version does.)
reserved(while) operator(()ident(line) operator(=) ident(infile)operator(.)ident(read)operator(()ident(blksize)operator(\))operator(\))
  ident(outfile)operator(.)ident(write)operator(()ident(line)operator(\))
reserved(end)

ident(infile)operator(.)ident(close)
ident(outfile)operator(.)ident(close)

ident(system)operator(()string<delimiter(")content(cp )inline<delimiter(#{)ident(oldfile)delimiter(})>content( )inline<delimiter(#{)ident(newfile)delimiter(})>delimiter(")>operator(\))    comment(# unix)
ident(system)operator(()string<delimiter(")content(copy )inline<delimiter(#{)ident(oldfile)delimiter(})>content( )inline<delimiter(#{)ident(newfile)delimiter(})>delimiter(")>operator(\))  comment(# dos, vms)

ident(require) string<delimiter(")content(ftools)delimiter(")>
constant(File)operator(.)ident(copy)operator(()string<delimiter(")content(datafile.dat)delimiter(")>operator(,) string<delimiter(")content(datafile.bak)delimiter(")>operator(\))
constant(File)operator(.)ident(move)operator(()string<delimiter(")content(datafile.new)delimiter(")>operator(,) string<delimiter(")content(datafile.dat)delimiter(")>operator(\))


comment(# @@PLEAC@@_9.4)
global_variable($seen) operator(=) operator({)operator(}) comment(# must use global var to be seen inside of method below)

reserved(def) method(do_my_thing)operator(()ident(filename)operator(\))
    ident(dev)operator(,) ident(ino) operator(=) constant(File)operator(.)ident(stat)operator(()ident(filename)operator(\))operator(.)ident(dev)operator(,) constant(File)operator(.)ident(stat)operator(()ident(filename)operator(\))operator(.)ident(ino)
    reserved(unless) global_variable($seen)operator([)operator([)ident(dev)operator(,) ident(ino)operator(])operator(])
        comment(# do something with $filename because we haven't)
        comment(# seen it before)
    reserved(end)
    global_variable($seen)operator([)operator([)ident(dev)operator(,) ident(ino)operator(])operator(]) operator(=) global_variable($seen)operator([)operator([)ident(dev)operator(,) ident(ino)operator(])operator(])operator(.)ident(to_i) operator(+) integer(1)
reserved(end)

ident(files)operator(.)ident(each) reserved(do) operator(|)ident(filename)operator(|)
    ident(dev)operator(,) ident(ino) operator(=) constant(File)operator(.)ident(stat)operator(()ident(filename)operator(\))operator(.)ident(dev)operator(,) constant(File)operator(.)ident(stat)operator(()ident(filename)operator(\))operator(.)ident(ino)
    reserved(if) operator(!)global_variable($seen)operator(.)ident(has_key?)operator(()operator([)ident(dev)operator(,) ident(ino)operator(])operator(\))
        global_variable($seen)operator([)operator([)ident(dev)operator(,) ident(ino)operator(])operator(]) operator(=) operator([)operator(])
    reserved(end)
    global_variable($seen)operator([)operator([)ident(dev)operator(,) ident(ino)operator(])operator(])operator(.)ident(push)operator(()ident(filename)operator(\))
reserved(end)

global_variable($seen)operator(.)ident(keys)operator(.)ident(sort)operator(.)ident(each) reserved(do) operator(|)ident(devino)operator(|)
    ident(ino)operator(,) ident(dev) operator(=) ident(devino)
    reserved(if) global_variable($seen)operator([)ident(devino)operator(])operator(.)ident(length) operator(>) integer(1)
        comment(# $seen[devino] is a list of filenames for the same file)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_9.5)
constant(Dir)operator(.)ident(open)operator(()ident(dirname)operator(\)) reserved(do) operator(|)ident(dir)operator(|)
    ident(dir)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
        comment(# do something with dirname/file)
        ident(puts) ident(file)
    reserved(end)
reserved(end)
comment(# Dir.close is automatic)

comment(# No -T equivalent in Ruby)

ident(dir)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
    reserved(next) reserved(if) ident(file) operator(=)operator(~) regexp<delimiter(/)content(^)char(\\.)char(\\.)content(?$)delimiter(/)>
    comment(# ...)
reserved(end)

reserved(def) method(plainfiles)operator(()ident(dir)operator(\))
    ident(dh) operator(=) constant(Dir)operator(.)ident(open)operator(()ident(dir)operator(\))
    ident(dh)operator(.)ident(entries)operator(.)ident(grep)operator(()regexp<delimiter(/)content(^[^.])delimiter(/)>operator(\))operator(.)
        ident(map)      operator({)operator(|)ident(file)operator(|) string<delimiter(")inline<delimiter(#{)ident(dir)delimiter(})>content(/)inline<delimiter(#{)ident(file)delimiter(})>delimiter(")>operator(})operator(.)
        ident(find_all) operator({)operator(|)ident(file)operator(|) ident(test)operator(()integer(?f)operator(,) ident(file)operator(\))operator(})operator(.)
        ident(sort)
reserved(end)


comment(# @@PLEAC@@_9.6)
ident(list) operator(=) constant(Dir)operator(.)ident(glob)operator(()string<delimiter(")content(*.c)delimiter(")>operator(\))

ident(dir) operator(=) constant(Dir)operator(.)ident(open)operator(()ident(path)operator(\))
ident(files) operator(=) ident(dir)operator(.)ident(entries)operator(.)ident(grep)operator(()regexp<delimiter(/)char(\\.)content(c$)delimiter(/)>operator(\))
ident(dir)operator(.)ident(close)

ident(files) operator(=) constant(Dir)operator(.)ident(glob)operator(()string<delimiter(")content(*.c)delimiter(")>operator(\))
ident(files) operator(=) constant(Dir)operator(.)ident(open)operator(()ident(path)operator(\))operator(.)ident(entries)operator(.)ident(grep)operator(()regexp<delimiter(/)char(\\.)content([ch]$)delimiter(/)modifier(i)>operator(\))

ident(dir) operator(=) constant(Dir)operator(.)ident(new)operator(()ident(path)operator(\))
ident(files) operator(=) ident(dir)operator(.)ident(entries)operator(.)ident(grep)operator(()regexp<delimiter(/)char(\\.)content([ch]$)delimiter(/)modifier(i)>operator(\))

reserved(begin)
  ident(d) operator(=) constant(Dir)operator(.)ident(open)operator(()ident(dir)operator(\))
reserved(rescue) constant(Errno)operator(::)constant(ENOENT)
  ident(raise) string<delimiter(")content(Couldn't open )inline<delimiter(#{)ident(dir)delimiter(})>content( for reading: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(end)

ident(files) operator(=) operator([)operator(])
ident(d)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
  ident(puts) ident(file)
  reserved(next) reserved(unless) ident(file) operator(=)operator(~) regexp<delimiter(/)char(\\.)content([ch]$)delimiter(/)modifier(i)>

  ident(filename) operator(=) string<delimiter(")inline<delimiter(#{)ident(dir)delimiter(})>content(/)inline<delimiter(#{)ident(file)delimiter(})>delimiter(")>
  comment(# There is no -T equivalent in Ruby, but we can still test emptiness)
  ident(files)operator(.)ident(push)operator(()ident(filename)operator(\)) reserved(if) ident(test)operator(()integer(?s)operator(,) ident(filename)operator(\))
reserved(end)

ident(dirs)operator(.)ident(entries)operator(.)ident(grep)operator(()regexp<delimiter(/)content(^)char(\\d)content(+$)delimiter(/)>operator(\))operator(.)
             ident(map)    operator({) operator(|)ident(file)operator(|) operator([)ident(file)operator(,) string<delimiter(")inline<delimiter(#{)ident(path)delimiter(})>content(/)inline<delimiter(#{)ident(file)delimiter(})>delimiter(")>operator(])operator(}) operator(.)
             ident(select) operator({) operator(|)ident(file)operator(|) ident(test)operator(()integer(?d)operator(,) ident(file)operator([)integer(1)operator(])operator(\)) operator(})operator(.)
             ident(sort)   operator({) operator(|)ident(a)operator(,)ident(b)operator(|)  ident(a)operator([)integer(0)operator(]) operator(<=>) ident(b)operator([)integer(0)operator(]) operator(})operator(.)
             ident(map)    operator({) operator(|)ident(file)operator(|) ident(file)operator([)integer(1)operator(]) operator(})


comment(# @@PLEAC@@_9.7)
ident(require) string<delimiter(')content(find)delimiter(')>
constant(Find)operator(.)ident(find)operator(()ident(dirlist)operator(\)) reserved(do) operator(|)ident(file)operator(|)
  comment(# do whatever)
reserved(end)

ident(require) string<delimiter(')content(find)delimiter(')>
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) string<delimiter(%w{)content(.)delimiter(})> operator(:) pre_constant(ARGV)
constant(Find)operator(.)ident(find)operator(()operator(*)ident(argv)operator(\)) reserved(do) operator(|)ident(file)operator(|)
  ident(print) ident(file)operator(,) operator(()ident(test)operator(()integer(?d)operator(,) ident(file)operator(\)) operator(?) string<delimiter(")content(/)char(\\n)delimiter(")> operator(:) string<delimiter(")char(\\n)delimiter(")>operator(\))
reserved(end)

ident(require) string<delimiter(')content(find)delimiter(')>
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) string<delimiter(%w{)content(.)delimiter(})> operator(:) pre_constant(ARGV)
ident(sum) operator(=) integer(0)
constant(Find)operator(.)ident(find)operator(()operator(*)ident(argv)operator(\)) reserved(do) operator(|)ident(file)operator(|)
  ident(size) operator(=) ident(test)operator(()integer(?s)operator(,) ident(file)operator(\)) operator(||) integer(0)
  ident(sum) operator(+=) ident(size)
reserved(end)
ident(puts) string<delimiter(")inline<delimiter(#{)ident(argv)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>content( contains )inline<delimiter(#{)ident(sum)delimiter(})>content( bytes)delimiter(")>

ident(require) string<delimiter(')content(find)delimiter(')>
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) string<delimiter(%w{)content(.)delimiter(})> operator(:) pre_constant(ARGV)
ident(saved_size)operator(,) ident(saved_name) operator(=) integer(-1)operator(,) string<delimiter(")delimiter(")>
constant(Find)operator(.)ident(find)operator(()operator(*)ident(argv)operator(\)) reserved(do) operator(|)ident(file)operator(|)
  ident(size) operator(=) ident(test)operator(()integer(?s)operator(,) ident(file)operator(\)) operator(||) integer(0)
  reserved(next) reserved(unless) ident(test)operator(()integer(?f)operator(,) ident(file)operator(\)) operator(&&) ident(size) operator(>) ident(saved_size)
  ident(saved_size) operator(=) ident(size)
  ident(saved_name) operator(=) ident(file)
reserved(end)
ident(puts) string<delimiter(")content(Biggest file )inline<delimiter(#{)ident(saved_name)delimiter(})>content( in )inline<delimiter(#{)ident(argv)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\))delimiter(})>content( is )inline<delimiter(#{)ident(saved_size)delimiter(})>delimiter(")>

ident(require) string<delimiter(')content(find)delimiter(')>
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) string<delimiter(%w{)content(.)delimiter(})> operator(:) pre_constant(ARGV)
ident(age)operator(,) ident(name) operator(=) pre_constant(nil)
constant(Find)operator(.)ident(find)operator(()operator(*)ident(argv)operator(\)) reserved(do) operator(|)ident(file)operator(|)
  ident(mtime) operator(=) constant(File)operator(.)ident(stat)operator(()ident(file)operator(\))operator(.)ident(mtime)
  reserved(next) reserved(if) ident(age) operator(&&) ident(age) operator(>) ident(mtime)
  ident(age) operator(=) ident(mtime)
  ident(name) operator(=) ident(file)
reserved(end)
ident(puts) string<delimiter(")inline<delimiter(#{)ident(name)delimiter(})>content( )inline<delimiter(#{)ident(age)delimiter(})>delimiter(")>

comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# fdirs - find all directories)
ident(require) string<delimiter(')content(find)delimiter(')>
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) string<delimiter(%w{)content(.)delimiter(})> operator(:) pre_constant(ARGV)
constant(File)operator(.)ident(find)operator(()operator(*)ident(argv)operator(\)) operator({) operator(|)ident(file)operator(|) ident(puts) ident(file) reserved(if) ident(test)operator(()integer(?d)operator(,) ident(file)operator(\)) operator(})
comment(#-----------------------------)


comment(# @@PLEAC@@_9.8)
ident(require) string<delimiter(')content(fileutils)delimiter(')>

ident(puts) string<delimiter(")content(Usage )inline<delimiter(#{)global_variable($0)delimiter(})>content( dir ...)delimiter(")> reserved(if) pre_constant(ARGV)operator(.)ident(empty?)
pre_constant(ARGV)operator(.)ident(each) reserved(do) operator(|)ident(dir)operator(|)
  constant(FileUtils)operator(.)ident(rmtree)operator(()ident(dir)operator(\))
reserved(end)


comment(# @@PLEAC@@_9.9)
ident(require) string<delimiter(')content(ftools)delimiter(')>
ident(names)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
  ident(newname) operator(=) ident(file)
  reserved(begin)
    constant(File)operator(.)ident(move)operator(()ident(file)operator(,) ident(newname)operator(\))
  reserved(rescue) constant(Errno)operator(::)constant(EPERM)
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(Couldn't rename )inline<delimiter(#{)ident(file)delimiter(})>content( to )inline<delimiter(#{)ident(newname)delimiter(})>content(: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
  reserved(end)
reserved(end)

ident(require) string<delimiter(')content(ftools)delimiter(')>
ident(op) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) operator(()ident(raise) string<delimiter(")content(Usage: rename expr [files])char(\\n)delimiter(")>operator(\)) operator(:) pre_constant(ARGV)operator(.)ident(shift)
ident(argv) operator(=) pre_constant(ARGV)operator(.)ident(empty?) operator(?) global_variable($stdin)operator(.)ident(readlines)operator(.)ident(map) operator({) operator(|)ident(f)operator(|) ident(f)operator(.)ident(chomp) operator(}) operator(:) pre_constant(ARGV)
ident(argv)operator(.)ident(each) reserved(do) operator(|)ident(file)operator(|)
  ident(was) operator(=) ident(file)
  ident(file) operator(=) ident(eval)operator(()string<delimiter(")content(file.)inline<delimiter(#{)ident(op)delimiter(})>delimiter(")>operator(\))
  constant(File)operator(.)ident(move)operator(()ident(was)operator(,) ident(file)operator(\)) reserved(unless) ident(was) operator(==) ident(file)
reserved(end)


comment(# @@PLEAC@@_9.10)
ident(base) operator(=) constant(File)operator(.)ident(basename)operator(()ident(path)operator(\))
ident(dir)  operator(=) constant(File)operator(.)ident(dirname)operator(()ident(path)operator(\))
comment(# ruby has no fileparse equivalent)
ident(dir)operator(,) ident(base) operator(=) constant(File)operator(.)ident(split)operator(()ident(path)operator(\))
ident(ext) operator(=) ident(base)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\.)content(.*$)delimiter(/)>operator(\))operator(.)ident(to_s)

ident(path) operator(=) string<delimiter(')content(/usr/lib/libc.a)delimiter(')>
ident(file) operator(=) constant(File)operator(.)ident(basename)operator(()ident(path)operator(\))
ident(dir)  operator(=) constant(File)operator(.)ident(dirname)operator(()ident(path)operator(\))

ident(puts) string<delimiter(")content(dir is )inline<delimiter(#{)ident(dir)delimiter(})>content(, file is )inline<delimiter(#{)ident(file)delimiter(})>delimiter(")>
comment(# dir is /usr/lib, file is libc.a)

ident(path) operator(=) string<delimiter(')content(/usr/lib/libc.a)delimiter(')>
ident(dir)operator(,) ident(filename) operator(=) constant(File)operator(.)ident(split)operator(()ident(path)operator(\))
ident(name)operator(,) ident(ext) operator(=) ident(filename)operator(.)ident(split)operator(()regexp<delimiter(/)content((?=)char(\\.)content(\))delimiter(/)>operator(\))
ident(puts) string<delimiter(")content(dir is )inline<delimiter(#{)ident(dir)delimiter(})>content(, name is )inline<delimiter(#{)ident(name)delimiter(})>content(, ext is )inline<delimiter(#{)ident(ext)delimiter(})>delimiter(")>
comment(#   NOTE: The Ruby code prints)
comment(#   dir is /usr/lib, name is libc, extension is .a)
comment(#     while the Perl code prints a '/' after the directory name)
comment(#   dir is /usr/lib/, name is libc, extension is .a)

comment(# No fileparse_set_fstype(\) equivalent in ruby)

reserved(def) method(extension)operator(()ident(path)operator(\))
    ident(ext) operator(=) ident(path)operator(.)ident(scan)operator(()regexp<delimiter(/)char(\\.)content(.*$)delimiter(/)>operator(\))operator(.)ident(to_s)
    ident(ext)operator(.)ident(sub)operator(()regexp<delimiter(/)content(^)char(\\.)delimiter(/)>operator(,) string<delimiter(")delimiter(")>operator(\))
reserved(end)


comment(# @@PLEAC@@_9.11)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# symirror - build spectral forest of symlinks)

ident(require) string<delimiter(')content(find)delimiter(')>
ident(require) string<delimiter(')content(fileutils)delimiter(')>

ident(raise) string<delimiter(")content(usage: )inline<delimiter(#{)global_variable($0)delimiter(})>content( realdir mirrordir)delimiter(")> reserved(unless) pre_constant(ARGV)operator(.)ident(size) operator(==) integer(2)

ident(srcdir)operator(,)ident(dstdir) operator(=) pre_constant(ARGV)
ident(srcmode) operator(=) constant(File)operator(::)ident(stat)operator(()ident(srcdir)operator(\))operator(.)ident(mode)
constant(Dir)operator(.)ident(mkdir)operator(()ident(dstdir)operator(,) ident(srcmode) operator(&) integer(07777)operator(\)) reserved(unless) ident(test)operator(()integer(?d)operator(,) ident(dstdir)operator(\))

comment(# fix relative paths)
constant(Dir)operator(.)ident(chdir)operator(()ident(srcdir)operator(\)) operator({)ident(srcdir) operator(=) constant(Dir)operator(.)ident(pwd)operator(})
constant(Dir)operator(.)ident(chdir)operator(()ident(dstdir)operator(\)) operator({)ident(dstdir) operator(=) constant(Dir)operator(.)ident(pwd)operator(})

constant(Find)operator(.)ident(find)operator(()ident(srcdir)operator(\)) reserved(do) operator(|)ident(srcfile)operator(|) 
    reserved(if) ident(test)operator(()integer(?d)operator(,) ident(srcfile)operator(\))
        ident(dest) operator(=) ident(srcfile)operator(.)ident(sub)operator(()regexp<delimiter(/)content(^)inline<delimiter(#{)ident(srcdir)delimiter(})>delimiter(/)>operator(,) ident(dstdir)operator(\))
        ident(dmode) operator(=) constant(File)operator(::)ident(stat)operator(()ident(srcfile)operator(\))operator(.)ident(mode) operator(&) integer(07777)
        constant(Dir)operator(.)ident(mkdir)operator(()ident(dest)operator(,) ident(dmode)operator(\)) reserved(unless) ident(test)operator(()integer(?d)operator(,) ident(dest)operator(\))
        ident(a) operator(=) constant(Dir)operator([)string<delimiter(")inline<delimiter(#{)ident(srcfile)delimiter(})>content(/*)delimiter(")>operator(])operator(.)ident(reject)operator({)operator(|)ident(f)operator(|) ident(test)operator(()integer(?d)operator(,) ident(f)operator(\))operator(})
        constant(FileUtils)operator(.)ident(ln_s)operator(()ident(a)operator(,) ident(dest)operator(\))
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_9.12)
comment(# we use the Getopt/Declare library here for convenience:)
comment(#   http://raa.ruby-lang.org/project/getoptdeclare/)
comment(#-----------------------------)
comment(#!/usr/bin/ruby -w)
comment(# lst - list sorted directory contents (depth first\))

ident(require) string<delimiter(')content(find)delimiter(')>
ident(require) string<delimiter(')content(etc)delimiter(')>
ident(require) string<delimiter(")content(Getopt/Declare)delimiter(")>

comment(# Note: in the option-spec below there must by at least one hard)
comment(# tab in between each -option and its description. For example)
comment(#    -i <tab> read from stdin)

ident(opts) operator(=) constant(Getopt)operator(::)constant(Declare)operator(.)ident(new)operator(()string<delimiter(<<'EOPARAM')>operator(\))string<content(
    ============
    Input Format:
        -i	read from stdin
    ============
    Output Format:
        -l	long listing
        -r	reverse listing
    ============
    Sort on: (one of\)
        -m	mtime (modify time - default\)
                {$sort_criteria = :mtime}
        -u	atime (access time\)
                {$sort_criteria = :atime}
        -c	ctime (inode change time\)
                {$sort_criteria = :ctime}
        -s	size
                {$sort_criteria = :size}
        [mutex: -m -u -c -s]
)delimiter(
EOPARAM)>

global_variable($sort_criteria) operator(||=) symbol(:mtime)
ident(files) operator(=) operator({)operator(})
constant(DIRS) operator(=) ident(opts)operator([)string<delimiter(')content(-i)delimiter(')>operator(]) operator(?) global_variable($stdin)operator(.)ident(readlines)operator(.)ident(map)operator({)operator(|)ident(f)operator(|)ident(f)operator(.)ident(chomp!)operator(}) operator(:) pre_constant(ARGV)
constant(DIRS)operator(.)ident(each) reserved(do) operator(|)ident(dir)operator(|)
    constant(Find)operator(.)ident(find)operator(()ident(dir)operator(\)) reserved(do) operator(|)ident(ent)operator(|)
        ident(files)operator([)ident(ent)operator(]) operator(=) constant(File)operator(::)ident(stat)operator(()ident(ent)operator(\))
    reserved(end)
reserved(end)
ident(entries) operator(=) ident(files)operator(.)ident(keys)operator(.)ident(sort_by)operator({)operator(|)ident(f)operator(|) ident(files)operator([)ident(f)operator(])operator(.)ident(send)operator(()global_variable($sort_criteria)operator(\))operator(})
ident(entries) operator(=) ident(entries)operator(.)ident(reverse) reserved(unless) ident(opts)operator([)string<delimiter(')content(-r)delimiter(')>operator(])

ident(entries)operator(.)ident(each) reserved(do) operator(|)ident(ent)operator(|)
    reserved(unless) ident(opts)operator([)string<delimiter(')content(-l)delimiter(')>operator(])
        ident(puts) ident(ent)
        reserved(next)
    reserved(end)
    ident(stats) operator(=) ident(files)operator([)ident(ent)operator(])
    ident(ftime) operator(=) ident(stats)operator(.)ident(send)operator(()global_variable($sort_criteria) operator(==) symbol(:size) operator(?) symbol(:mtime) operator(:) global_variable($sort_criteria)operator(\))
    ident(printf) string<delimiter(")content(%6d %04o %6d %8s %8s %8d %s %s)char(\\n)delimiter(")>operator(,)
        ident(stats)operator(.)ident(ino)operator(,)
        ident(stats)operator(.)ident(mode) operator(&) integer(07777)operator(,)
        ident(stats)operator(.)ident(nlink)operator(,)
        constant(ETC)operator(::)constant(PASSWD)operator([)ident(stats)operator(.)ident(uid)operator(])operator(.)ident(name)operator(,)
        constant(ETC)operator(::)constant(GROUP)operator([)ident(stats)operator(.)ident(gid)operator(])operator(.)ident(name)operator(,)
        ident(stats)operator(.)ident(size)operator(,)
        ident(ftime)operator(.)ident(strftime)operator(()string<delimiter(")content(%a %b %d %H:%M:%S %Y)delimiter(")>operator(\))operator(,)
        ident(ent)
reserved(end)


comment(# @@PLEAC@@_10.0)
reserved(def) method(hello)
    global_variable($greeted) operator(+=) integer(1)      comment(# in Ruby, a variable beginning with $ is global (can be any type of course\))
    ident(puts) string<delimiter(")content(hi there!)delimiter(")>
reserved(end)

comment(# We need to initialize $greeted before it can be used, because "+=" is waiting a Numeric object)
global_variable($greeted) operator(=) integer(0)
ident(hello)                  comment(# note that appending (\) is optional to function calls with no parameters)


comment(# @@PLEAC@@_10.1)
comment(# In Ruby, parameters are named anyway)
reserved(def) method(hypotenuse)operator(()ident(side1)operator(,) ident(side2)operator(\))
    constant(Math)operator(.)ident(sqrt)operator(()ident(side1)operator(**)integer(2) operator(+) ident(side2)operator(**)integer(2)operator(\))    comment(# the sqrt function comes from the Math module)
reserved(end)
ident(diag) operator(=) ident(hypotenuse)operator(()integer(3)operator(,) integer(4)operator(\))

ident(puts) ident(hypotenuse)operator(()integer(3)operator(,) integer(4)operator(\))

ident(a) operator(=) operator([)integer(3)operator(,) integer(4)operator(])
ident(print) ident(hypotenuse)operator(()operator(*)ident(a)operator(\))                  comment(# the star operator will magically convert an Array into a "tuple")

ident(both) operator(=) ident(men) operator(+) ident(women)

comment(# In Ruby, all objects are references, so the same problem arises; we then return a new object)
ident(nums) operator(=) operator([)float(1.4)operator(,) float(3.5)operator(,) float(6.7)operator(])
reserved(def) method(int_all)operator(()ident(n)operator(\))
    ident(n)operator(.)ident(collect) operator({) operator(|)ident(v)operator(|) ident(v)operator(.)ident(to_i) operator(})
reserved(end)
ident(ints) operator(=) ident(int_all)operator(()ident(nums)operator(\))

ident(nums) operator(=) operator([)float(1.4)operator(,) float(3.5)operator(,) float(6.7)operator(])
reserved(def) method(trunc_em)operator(()ident(n)operator(\))
    ident(n)operator(.)ident(collect!) operator({) operator(|)ident(v)operator(|) ident(v)operator(.)ident(to_i) operator(})         comment(# the bang-version of collect modifies the object)
reserved(end)
ident(trunc_em)operator(()ident(nums)operator(\))

comment(# Ruby has two chomp version:)
comment(# ``chomp'' chomps the record separator and returns what's expected)
comment(# ``chomp!'' does the same but also modifies the parameter object)


comment(# @@PLEAC@@_10.2)
reserved(def) method(somefunc)
    ident(variable) operator(=) ident(something)  comment(# variable is local by default)
reserved(end)

ident(name)operator(,) ident(age) operator(=) pre_constant(ARGV)
ident(start)     operator(=) ident(fetch_time)

ident(a)operator(,) ident(b) operator(=) ident(pair)               comment(# will succeed if pair is an Array object (like ARGV is\))
ident(c) operator(=) ident(fetch_time)

comment(# In ruby, run_check can't access a, b, or c until they are)
comment(# explicitely defined global (using leading $\), even if they are)
comment(# both defined in the same scope)

reserved(def) method(check_x)operator(()ident(x)operator(\))
    ident(y) operator(=) string<delimiter(")content(whatever)delimiter(")>
    ident(run_check)
    reserved(if) global_variable($condition)
        ident(puts) string<delimiter(")content(got $x)delimiter(")>
    reserved(end)
reserved(end)

comment(# The following will keep a reference to the array, though the)
comment(# results will be slightly different from perl: the last element)
comment(# of $global_array will be itself an array)
reserved(def) method(save_array)operator(()ident(ary)operator(\))
    global_variable($global_array) operator(<<) ident(ary)
reserved(end)

comment(# The following gives the same results as in Perl for $global_array,)
comment(# though it doesn't illustrate anymore the way to keep a reference)
comment(# to an object: $global_array is extended with the elements of ary)
reserved(def) method(save_array)operator(()ident(ary)operator(\))
    global_variable($global_array) operator(+=) ident(ary)
reserved(end)


comment(# @@PLEAC@@_10.3)
comment(# In Ruby, AFAIK a method cannot access "local variables" defined)
comment(# upper scope; mostly because everything is an object, so you'll)
comment(# do the same by defining an attribute or a static attribute)

comment(# In Ruby the BEGIN also exists:)
reserved(BEGIN) operator({) ident(puts) string<delimiter(")content(hello from BEGIN)delimiter(")> operator(})
ident(puts) string<delimiter(")content(hello from main)delimiter(")>
reserved(BEGIN) operator({) ident(puts) string<delimiter(")content(hello from 2nd BEGIN)delimiter(")> operator(})
comment(# gives:)
comment(#   hello from BEGIN)
comment(#   hello from 2nd BEGIN)
comment(#   hello from main)

comment(# In Ruby, it can be written as a static method and a static)
comment(# variable)
reserved(class) class(Counter)
    class_variable(@@counter) operator(=) integer(0)
    reserved(def) constant(Counter)operator(.)ident(next_counter)operator(;) class_variable(@@counter) operator(+=) integer(1)operator(;) reserved(end)
reserved(end)

comment(# There is no need of BEGIN since the variable will get)
comment(# initialized when parsing)
reserved(class) class(Counter)
    class_variable(@@counter) operator(=) integer(42)
    reserved(def) constant(Counter)operator(.)ident(next_counter)operator(;) class_variable(@@counter) operator(+=) integer(1)operator(;) reserved(end)
    reserved(def) constant(Counter)operator(.)ident(prev_counter)operator(;) class_variable(@@counter) operator(-=) integer(1)operator(;) reserved(end)
reserved(end)


comment(# @@PLEAC@@_10.4)
comment(# You can either get the whole trace as an array of strings, each)
comment(# string telling which file, line and method is calling:)
ident(caller)

comment(# ...or only the last caller)
ident(caller)operator([)integer(0)operator(])

comment(# We need to extract just the method name of the backtrace:)
reserved(def) method(whoami)operator(;)  ident(caller)operator(()operator(\))operator([)integer(0)operator(]) operator(=)operator(~) regexp<delimiter(/)content(in `([^']+\)')delimiter(/)> operator(?) global_variable($1) operator(:) string<delimiter(')content((anonymous\))delimiter(')>operator(;) reserved(end)
reserved(def) method(whowasi)operator(;) ident(caller)operator(()operator(\))operator([)integer(1)operator(]) operator(=)operator(~) regexp<delimiter(/)content(in `([^']+\)')delimiter(/)> operator(?) global_variable($1) operator(:) string<delimiter(')content((anonymous\))delimiter(')>operator(;) reserved(end)


comment(# @@PLEAC@@_10.5)
comment(# In Ruby, every value is a reference on an object, thus there is)
comment(# no such problem)
ident(array_diff)operator(()ident(array1)operator(,) ident(array2)operator(\))

reserved(def) method(add_vecpair)operator(()ident(a1)operator(,) ident(a2)operator(\))
    ident(results) operator(=) operator([)operator(])
    ident(a1)operator(.)ident(each_index) operator({) operator(|)ident(i)operator(|) ident(results) operator(<<) operator(()ident(a1)operator([)ident(i)operator(]) operator(+) ident(a2)operator([)ident(i)operator(])operator(\)) operator(})
    ident(results)
reserved(end)
ident(a) operator(=) operator([)integer(1)operator(,) integer(2)operator(])
ident(b) operator(=) operator([)integer(5)operator(,) integer(8)operator(])
ident(c) operator(=) ident(add_vecpair)operator(()ident(a)operator(,) ident(b)operator(\))
ident(p) ident(c)

comment(# Add this to the beginning of the function to check if we were)
comment(# given two arrays)
ident(a1)operator(.)ident(type) operator(==) constant(Array) operator(&&) ident(a2)operator(.)ident(type) operator(==) constant(Array) reserved(or)
    ident(raise) string<delimiter(")content(usage: add_vecpair array1 array2 (was used with: )inline<delimiter(#{)ident(a1)operator(.)ident(type)delimiter(})>content( )inline<delimiter(#{)ident(a2)operator(.)ident(type)delimiter(})>content(\))delimiter(")>


comment(# @@PLEAC@@_10.6)
comment(# There is no return context in Ruby)


comment(# @@PLEAC@@_10.7)
comment(# Like in Perl, we need to fake with a hash, but it's dirty :-()
reserved(def) method(thefunc)operator(()ident(param_args)operator(\))
    ident(args) operator(=) operator({) string<delimiter(')content(INCREMENT)delimiter(')> operator(=)operator(>) string<delimiter(')content(10s)delimiter(')>operator(,) string<delimiter(')content(FINISH)delimiter(')> operator(=)operator(>) string<delimiter(')content(0)delimiter(')>operator(,) string<delimiter(')content(START)delimiter(')> operator(=)operator(>) integer(0) operator(})
    ident(args)operator(.)ident(update)operator(()ident(param_args)operator(\))
    reserved(if) operator(()ident(args)operator([)string<delimiter(')content(INCREMENT)delimiter(')>operator(])  operator(=)operator(~) regexp<delimiter(/)content(m$)delimiter(/)> operator(\))
        comment(# .....)
    reserved(end)
reserved(end)

ident(thefunc)operator(()operator({) string<delimiter(')content(INCREMENT)delimiter(')> operator(=)operator(>) string<delimiter(')content(20s)delimiter(')>operator(,) string<delimiter(')content(START)delimiter(')> operator(=)operator(>) string<delimiter(')content(+5m)delimiter(')>operator(,) string<delimiter(')content(FINISH)delimiter(')> operator(=)operator(>) string<delimiter(')content(+30m)delimiter(')> operator(})operator(\))
ident(thefunc)operator(()operator({)operator(})operator(\))


comment(# @@PLEAC@@_10.8)
comment(# there is no "undef" direct equivalent but there is the slice equiv:)
ident(a)operator(,) ident(c) operator(=) ident(func)operator(.)ident(indexes)operator(()integer(0)operator(,) integer(2)operator(\))


comment(# @@PLEAC@@_10.9)
comment(# Ruby has no such limitation:)
reserved(def) method(somefunc)
    ident(ary) operator(=) operator([)operator(])
    ident(hash) operator(=) operator({)operator(})
    comment(# ...)
    reserved(return) ident(ary)operator(,) ident(hash)
reserved(end)
ident(arr)operator(,) ident(dict) operator(=) ident(somefunc)

ident(array_of_hashes) operator(=) ident(fn)
ident(h1)operator(,) ident(h2)operator(,) ident(h3)      operator(=) ident(fn)


comment(# @@PLEAC@@_10.10)
reserved(return)
comment(# or (equivalent\))
reserved(return) pre_constant(nil)


comment(# @@PLEAC@@_10.11)
comment(# You can't prototype in Ruby regarding types :-()
comment(# Though, you can force the number of arguments:)
reserved(def) method(func_with_no_arg)operator(;) reserved(end)
reserved(def) method(func_with_no_arg)operator(()operator(\))operator(;) reserved(end)
reserved(def) method(func_with_one_arg)operator(()ident(a1)operator(\))operator(;) reserved(end)
reserved(def) method(func_with_two_args)operator(()ident(a1)operator(,) ident(a2)operator(\))operator(;) reserved(end)
reserved(def) method(func_with_any_number_of_args)operator(()operator(*)ident(args)operator(\))operator(;) reserved(end)


comment(# @@PLEAC@@_10.12)
ident(raise) string<delimiter(")content(some message)delimiter(")>        comment(# raise exception)

reserved(begin)
    ident(val) operator(=) ident(func)
reserved(rescue) constant(Exception) operator(=)operator(>) ident(msg)
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(func raised an exception: )inline<delimiter(#{)ident(msg)delimiter(})>delimiter(")>
reserved(end)

comment(# In Ruby the rescue statement uses an exception class, every)
comment(# exception which is not matched is still continuing)
reserved(begin)
    ident(val) operator(=) ident(func)
reserved(rescue) constant(FullMoonError)
    operator(...)
reserved(end)


comment(# @@PLEAC@@_10.13)
comment(# Saving Global Values)
comment(# Of course we can just save the value and restore it later:)
reserved(def) method(print_age)
    ident(puts) string<delimiter(")content(Age is )inline<delimiter(#{)global_variable($age)delimiter(})>delimiter(")>
reserved(end)

global_variable($age) operator(=) integer(18)         comment(# global variable)
ident(print_age)operator(()operator(\))
reserved(if) ident(condition)
    ident(safeage) operator(=) global_variable($age)
    global_variable($age) operator(=) integer(23)
    ident(print_age)operator(()operator(\))
    global_variable($age) operator(=) ident(safeage)
reserved(end)

comment(# We can also use a method that saves the global variable and)
comment(# restores it automatically when the block is left:)

reserved(def) method(local)operator(()ident(var)operator(\))
    ident(eval)operator(()string<delimiter(")content(save = )inline<delimiter(#{)ident(var)operator(.)ident(id2name)delimiter(})>delimiter(")>operator(\))
    reserved(begin)
        ident(result) operator(=) reserved(yield)
    reserved(ensure)
        comment(# we want to call this even if we got an exception)
        ident(eval)operator(()string<delimiter(")inline<delimiter(#{)ident(var)operator(.)ident(id2name)delimiter(})>content( = save)delimiter(")>operator(\))
    reserved(end)
    ident(result)
reserved(end)

ident(condition) operator(=) pre_constant(true)
global_variable($age) operator(=) integer(18)
ident(print_age)operator(()operator(\))
reserved(if) ident(condition)
    ident(local)operator(()symbol(:$age)operator(\)) operator({)
        global_variable($age) operator(=) integer(23)
        ident(print_age)operator(()operator(\))
    operator(})
reserved(end)
ident(print_age)operator(()operator(\))

comment(# There is no need to use local(\) for filehandles or directory)
comment(# handles in ruby because filehandles are normal objects.)


comment(# @@PLEAC@@_10.14)
comment(# In Ruby you may redefine a method [but not overload it :-(])
comment(# just by defining again with the same name.)
reserved(def) method(foo)operator(;) ident(puts) string<delimiter(')content(foo)delimiter(')>operator(;) reserved(end)
reserved(def) method(foo)operator(;) ident(puts) string<delimiter(')content(bar)delimiter(')>operator(;) reserved(end)
ident(foo)
comment(#=> bar)

comment(# You can also take a reference to an existing method before)
comment(# redefining a new one, using the `alias' keyword)
reserved(def) method(foo)operator(;) ident(puts) string<delimiter(')content(foo)delimiter(')>operator(;) reserved(end)
reserved(alias) ident(foo_orig) ident(foo)
reserved(def) method(foo)operator(;) ident(puts) string<delimiter(')content(bar)delimiter(')>operator(;) reserved(end)
ident(foo_orig)
ident(foo)
comment(#=> foo)
comment(#=> bar)

comment(# AFAIK, there is no direct way to create a new method whose name)
comment(# comes from a variable, so use "eval")
ident(colors) operator(=) string<delimiter(%w()content(red blue green yellow orange purple violet)delimiter(\))>
ident(colors)operator(.)ident(each) operator({) operator(|)ident(c)operator(|)
    ident(eval) string<delimiter(<<-EOS)>string<content(
    def )inline<delimiter(#{)ident(c)delimiter(})>content((*a\)
        "<FONT COLOR=')inline<delimiter(#{)ident(c)delimiter(})>content('>" + a.to_s + "</FONT>"
    end)delimiter(
    EOS)>
operator(}) 


comment(# @@PLEAC@@_10.15)
reserved(def) method(method_missing)operator(()ident(name)operator(,) operator(*)ident(args)operator(\))
    string<delimiter(")content(<FONT COLOR=')inline<delimiter(#{)ident(name)delimiter(})>content('>)delimiter(")> operator(+) ident(args)operator(.)ident(join)operator(()string<delimiter(')content( )delimiter(')>operator(\)) operator(+) string<delimiter(")content(</FONT>)delimiter(")>
reserved(end)
ident(puts) ident(chartreuse)operator(()string<delimiter(")content(stuff)delimiter(")>operator(\))


comment(# @@PLEAC@@_10.16)
reserved(def) method(outer)operator(()ident(arg)operator(\))
    ident(x) operator(=) ident(arg) operator(+) integer(35)
    ident(inner) operator(=) ident(proc) operator({) ident(x) operator(*) integer(19) operator(})
    ident(x) operator(+) ident(inner)operator(.)ident(call)operator(()operator(\))
reserved(end)


comment(# @@PLEAC@@_10.17)
comment(#!/usr/bin/ruby -w)
comment(# mailsort - sort mbox by different criteria)
ident(require) string<delimiter(')content(English)delimiter(')>
ident(require) string<delimiter(')content(Date)delimiter(')>

comment(# Objects of class Mail represent a single mail.)
reserved(class) class(Mail)
    ident(attr_accessor) symbol(:no)
    ident(attr_accessor) symbol(:subject)
    ident(attr_accessor) symbol(:fulltext)
    ident(attr_accessor) symbol(:date)

    reserved(def) method(initialize)
        instance_variable(@fulltext) operator(=) string<delimiter(")delimiter(")>
        instance_variable(@subject) operator(=) string<delimiter(")delimiter(")>
    reserved(end)

    reserved(def) method(append)operator(()ident(para)operator(\))
        instance_variable(@fulltext) operator(<<) ident(para)
    reserved(end)

    comment(# this is called if you call puts(mail\))
    reserved(def) method(to_s)
        instance_variable(@fulltext)
    reserved(end)
reserved(end)

comment(# represents a list of mails.)
reserved(class) class(Mailbox) operator(<) constant(Array)

    constant(Subjectpattern) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(Subject:)content(\\s)content(*(?:Re:)content(\\s)content(*\)*(.*\))content(\\n)delimiter(')>operator(\))
    constant(Datepattern) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(Date:)content(\\s)content(*(.*\))content(\\n)delimiter(')>operator(\))

    comment(# reads mails from open file and stores them)
    reserved(def) method(read)operator(()ident(file)operator(\))
        global_variable($INPUT_RECORD_SEPARATOR) operator(=) string<delimiter(')delimiter(')>  comment(# paragraph reads)
        ident(msgno) operator(=) integer(-1)
        ident(file)operator(.)ident(each) operator({) operator(|)ident(para)operator(|)
            reserved(if) ident(para) operator(=)operator(~) regexp<delimiter(/)content(^From)delimiter(/)>
                ident(mail) operator(=) constant(Mail)operator(.)ident(new)
                ident(mail)operator(.)ident(no) operator(=) operator(()ident(msgno) operator(+=) integer(1)operator(\))
                ident(md) operator(=) constant(Subjectpattern)operator(.)ident(match)operator(()ident(para)operator(\))
                reserved(if) ident(md)
                    ident(mail)operator(.)ident(subject) operator(=) ident(md)operator([)integer(1)operator(])
                reserved(end)
                ident(md) operator(=) constant(Datepattern)operator(.)ident(match)operator(()ident(para)operator(\))
                reserved(if) ident(md)
                    ident(mail)operator(.)ident(date) operator(=) constant(DateTime)operator(.)ident(parse)operator(()ident(md)operator([)integer(1)operator(])operator(\))
                reserved(else)
                    ident(mail)operator(.)ident(date) operator(=) constant(DateTime)operator(.)ident(now)
                reserved(end)
                pre_constant(self)operator(.)ident(push)operator(()ident(mail)operator(\))
            reserved(end)
            ident(mail)operator(.)ident(append)operator(()ident(para)operator(\)) reserved(if) ident(mail)
        operator(})
    reserved(end)

    reserved(def) method(sort_by_subject_and_no)
        pre_constant(self)operator(.)ident(sort_by) operator({) operator(|)ident(m)operator(|)
            operator([)ident(m)operator(.)ident(subject)operator(,) ident(m)operator(.)ident(no)operator(])
        operator(})
    reserved(end)

    comment(# sorts by a list of attributs of mail, given as symbols)
    reserved(def) method(sort_by_attributs)operator(()operator(*)ident(attrs)operator(\))
        comment(# you can sort an Enumerable by an array of)
        comment(# values, they would be compared)
        comment(# from ary[0] to ary[n]t, say:)
        comment(# ['b',1] > ['a',10] > ['a',9])
        pre_constant(self)operator(.)ident(sort_by) operator({) operator(|)ident(elem)operator(|)
            ident(attrs)operator(.)ident(map) operator({) operator(|)ident(attr)operator(|)
                ident(elem)operator(.)ident(send)operator(()ident(attr)operator(\))
            operator(})
        operator(})
    reserved(end)

reserved(end)

ident(mailbox) operator(=) constant(Mailbox)operator(.)ident(new)
ident(mailbox)operator(.)ident(read)operator(()pre_constant(ARGF)operator(\))

comment(# print only subjects sorted by subject and number)
reserved(for) ident(m) reserved(in) ident(mailbox)operator(.)ident(sort_by_subject_and_no)
    ident(puts)operator(()ident(m)operator(.)ident(subject)operator(\))
reserved(end)

comment(# print complete mails sorted by date, then subject, then number)
reserved(for) ident(m) reserved(in) ident(mailbox)operator(.)ident(sort_by_attributs)operator(()symbol(:date)operator(,) symbol(:subject)operator(\))
    ident(puts)operator(()ident(m)operator(\))
reserved(end)


comment(# @@PLEAC@@_11.7)
reserved(def) method(mkcounter)operator(()ident(count)operator(\))
    ident(start)  operator(=) ident(count) 
    ident(bundle) operator(=) operator({) 
        string<delimiter(")content(NEXT)delimiter(")>   operator(=)operator(>) ident(proc) operator({) ident(count) operator(+=) integer(1) operator(})operator(,)
        string<delimiter(")content(PREV)delimiter(")>   operator(=)operator(>) ident(proc) operator({) ident(count) operator(-=) integer(1) operator(})operator(,)
        string<delimiter(")content(RESET)delimiter(")>  operator(=)operator(>) ident(proc) operator({) ident(count) operator(=) ident(start) operator(})
    operator(})
    ident(bundle)operator([)string<delimiter(")content(LAST)delimiter(")>operator(]) operator(=) ident(bundle)operator([)string<delimiter(")content(PREV)delimiter(")>operator(])
    reserved(return) ident(bundle)
reserved(end)

ident(c1) operator(=) ident(mkcounter)operator(()integer(20)operator(\))
ident(c2) operator(=) ident(mkcounter)operator(()integer(77)operator(\))

ident(puts) string<delimiter(")content(next c1: )inline<delimiter(#{)ident(c1)operator([)string<delimiter(")content(NEXT)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")>  comment(# 21 )
ident(puts) string<delimiter(")content(next c2: )inline<delimiter(#{)ident(c2)operator([)string<delimiter(")content(NEXT)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")>  comment(# 78 )
ident(puts) string<delimiter(")content(next c1: )inline<delimiter(#{)ident(c1)operator([)string<delimiter(")content(NEXT)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")>  comment(# 22 )
ident(puts) string<delimiter(")content(last c1: )inline<delimiter(#{)ident(c1)operator([)string<delimiter(")content(PREV)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")>  comment(# 21 )
ident(puts) string<delimiter(")content(last c1: )inline<delimiter(#{)ident(c1)operator([)string<delimiter(")content(LAST)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")>  comment(# 20 )
ident(puts) string<delimiter(")content(old  c2: )inline<delimiter(#{)ident(c2)operator([)string<delimiter(")content(RESET)delimiter(")>operator(])operator(.)ident(call)delimiter(})>delimiter(")> comment(# 77 )


comment(# @@PLEAC@@_11.15)
reserved(class) class(Binary_tree)
    reserved(def) method(initialize)operator(()ident(val)operator(\))
        instance_variable(@value) operator(=) ident(val)
        instance_variable(@left) operator(=) pre_constant(nil)
        instance_variable(@right) operator(=) pre_constant(nil)
    reserved(end)
    
    comment(# insert given value into proper point of)
    comment(# provided tree.  If no tree provided, )
    comment(# use implicit pass by reference aspect of @_)
    comment(# to fill one in for our caller.)
    reserved(def) method(insert)operator(()ident(val)operator(\))
        reserved(if) ident(val) operator(<) instance_variable(@value) reserved(then)
            reserved(if) instance_variable(@left) reserved(then)
                instance_variable(@left)operator(.)ident(insert)operator(()ident(val)operator(\))
            reserved(else)
                instance_variable(@left) operator(=) constant(Binary_tree)operator(.)ident(new)operator(()ident(val)operator(\))
            reserved(end)
        reserved(elsif) ident(val) operator(>) instance_variable(@value) reserved(then)
            reserved(if) instance_variable(@right) reserved(then)
                instance_variable(@right)operator(.)ident(insert)operator(()ident(val)operator(\))
            reserved(else)
                instance_variable(@right) operator(=) constant(Binary_tree)operator(.)ident(new)operator(()ident(val)operator(\))
            reserved(end)
        reserved(else)
            ident(puts) string<delimiter(")content(double)delimiter(")>
            comment(# do nothing, no double values)
        reserved(end)
    reserved(end)

    comment(# recurse on left child, )
    comment(# then show current value, )
    comment(# then recurse on right child.  )
    reserved(def) method(in_order)
        instance_variable(@left)operator(.)ident(in_order) reserved(if) instance_variable(@left)
        ident(print) instance_variable(@value)operator(,) string<delimiter(")content( )delimiter(")>
        instance_variable(@right)operator(.)ident(in_order) reserved(if) instance_variable(@right)
    reserved(end)
    
    comment(# show current value, )
    comment(# then recurse on left child, )
    comment(# then recurse on right child.)
    reserved(def) method(pre_order)
        ident(print) instance_variable(@value)operator(,) string<delimiter(")content( )delimiter(")>
        instance_variable(@left)operator(.)ident(pre_order) reserved(if) instance_variable(@left)
        instance_variable(@right)operator(.)ident(pre_order) reserved(if) instance_variable(@right)
    reserved(end)

    comment(# recurse on left child, )
    comment(# then recurse on right child,)
    comment(# then show current value.)
    reserved(def) method(post_order)
        instance_variable(@left)operator(.)ident(post_order) reserved(if) instance_variable(@left)
        instance_variable(@right)operator(.)ident(post_order) reserved(if) instance_variable(@right)
        ident(print) instance_variable(@value)operator(,) string<delimiter(")content( )delimiter(")>
    reserved(end)

    comment(# find out whether provided value is in the tree.)
    comment(# if so, return the node at which the value was found.)
    comment(# cut down search time by only looking in the correct)
    comment(# branch, based on current value.)
    reserved(def) method(search)operator(()ident(val)operator(\))
        reserved(if) ident(val) operator(==) instance_variable(@value) reserved(then)
            reserved(return) pre_constant(self)
        reserved(elsif) ident(val) operator(<) instance_variable(@value) reserved(then)
            reserved(return) instance_variable(@left)operator(.)ident(search)operator(()ident(val)operator(\)) reserved(if) instance_variable(@left)
            reserved(return) pre_constant(nil)
        reserved(else)
            reserved(return) instance_variable(@right)operator(.)ident(search)operator(()ident(val)operator(\)) reserved(if) instance_variable(@right)
            reserved(return) pre_constant(nil)
        reserved(end)
    reserved(end)
reserved(end)

comment(# first generate 20 random inserts)
ident(test) operator(=) constant(Binary_tree)operator(.)ident(new)operator(()integer(0)operator(\))
reserved(for) ident(a) reserved(in) integer(0)operator(..)integer(20)
    ident(test)operator(.)ident(insert)operator(()ident(rand)operator(()integer(1000)operator(\))operator(\)) 
reserved(end)

comment(# now dump out the tree all three ways)
ident(print) string<delimiter(")content(Pre order:  )delimiter(")>operator(;)  ident(test)operator(.)ident(pre_order)operator(;)  ident(puts) string<delimiter(")delimiter(")>
ident(print) string<delimiter(")content(In order:  )delimiter(")>operator(;)  ident(test)operator(.)ident(in_order)operator(;)  ident(puts) string<delimiter(")delimiter(")>
ident(print) string<delimiter(")content(Post order:  )delimiter(")>operator(;)  ident(test)operator(.)ident(post_order)operator(;)  ident(puts) string<delimiter(")delimiter(")>

ident(print) string<delimiter(")content(search?)delimiter(")>
reserved(while) ident(gets)
    ident(print) ident(test)operator(.)ident(search)operator(()global_variable($_)operator(.)ident(to_i)operator(\))
    ident(print) string<delimiter(")char(\\n)content(search?)delimiter(")>
reserved(end)


comment(# @@PLEAC@@_12.0)
comment(# class and module names need to have the first letter capitalized)
reserved(module) class(Alpha)
    constant(NAME) operator(=) string<delimiter(')content(first)delimiter(')>
reserved(end)
reserved(module) class(Omega)
    constant(NAME) operator(=) string<delimiter(')content(last)delimiter(')>
reserved(end)
ident(puts) string<delimiter(")content(Alpha is )inline<delimiter(#{)constant(Alpha)operator(::)constant(NAME)delimiter(})>content(, Omega is )inline<delimiter(#{)constant(Omega)operator(::)constant(NAME)delimiter(})>delimiter(")>

comment(# ruby doesn't differentiate beteen compile-time and run-time)
ident(require) string<delimiter(')content(getoptlong.rb)delimiter(')>
ident(require) string<delimiter(')content(getoptlong)delimiter(')>     comment(# assumes the .rb)
ident(require) string<delimiter(')content(cards/poker.rb)delimiter(')>
ident(require) string<delimiter(')content(cards/poker)delimiter(')>    comment(# assumes the .rb)
ident(load)    string<delimiter(')content(cards/poker)delimiter(')>    comment(# require only loads the file once)

reserved(module) class(Cards)
    reserved(module) class(Poker)
        instance_variable(@card_deck) operator(=) constant(Array)operator(.)ident(new) comment(# or @card_deck = [])
        reserved(def) method(shuffle)
        reserved(end)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_12.1)
comment(# a module exports all of its functions)
reserved(module) class(Your_Module)
    reserved(def) pre_constant(self)operator(.)ident(function)
        comment(# this would be called as Your_Module.function)
    reserved(end)
    
    reserved(def) constant(Your_Module)operator(.)ident(another)
        comment(# this is the same as above, but more specific)
    reserved(end)
reserved(end)

comment(# @@PLEAC@@_12.2)
reserved(begin)
    ident(require) string<delimiter(')content(nonexistent)delimiter(')>
reserved(rescue) constant(LoadError)
    ident(puts) string<delimiter(")content(Couldn't load )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>  comment(# $! contains the last error string)
reserved(end)

comment(# @@PLEAC@@_12.4)
comment(# module variables are private unless access functions are defined)
reserved(module) class(Alpha)
    instance_variable(@aa) operator(=) integer(10)
    instance_variable(@bb) operator(=) integer(11)
    
    reserved(def) pre_constant(self)operator(.)ident(put_aa)
        ident(puts) instance_variable(@aa)
    reserved(end)
    
    reserved(def) pre_constant(self)operator(.)ident(bb)operator(=)operator(()ident(val)operator(\))
        instance_variable(@bb) operator(=) ident(val)
    reserved(end)
reserved(end)

constant(Alpha)operator(.)ident(bb) operator(=) integer(12)
comment(# Alpha.aa = 10 # error, no aa=method)


comment(# @@PLEAC@@_12.5)
comment(# caller provides a backtrace of the call stack)
reserved(module) class(MyModule)
    reserved(def) method(find_caller)
        ident(caller)
    reserved(end)

    reserved(def) method(find_caller2)operator(()ident(i)operator(\))
        ident(caller)operator(()ident(i)operator(\)) comment(# an argument limits the size of the stack returned)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_12.6)
reserved(BEGIN) operator({)
    global_variable($logfile) operator(=) string<delimiter(')content(/tmp/mylog)delimiter(')> reserved(unless) reserved(defined?) global_variable($logfile)
    global_variable($LF) operator(=) constant(File)operator(.)ident(open)operator(()global_variable($logfile)operator(,) string<delimiter(')content(a)delimiter(')>operator(\))
operator(})

reserved(module) class(Logger)
    reserved(def) pre_constant(self)operator(.)ident(logmsg)operator(()ident(msg)operator(\))
        global_variable($LF)operator(.)ident(puts) ident(msg)
    reserved(end)

    ident(logmsg)operator(()string<delimiter(')content(startup)delimiter(')>operator(\))
reserved(end)

reserved(END) operator({)
    constant(Logger)operator(::)ident(logmsg)operator(()string<delimiter(')content(shutdown)delimiter(')>operator(\))
    global_variable($LF)operator(.)ident(close)
operator(})


comment(# @@PLEAC@@_12.7)
comment(#-----------------------------)
comment(# results may be different on your system)
comment(# % ruby -e "$LOAD_PATH.each_index { |i| printf("%d %s\\n", i, $LOAD_PATH[i] })
comment(#0 /usr/local/lib/site_ruby/1.6)
comment(#1 /usr/local/lib/site_ruby/1.6/i386-linux)
comment(#2 /usr/local/lib/site_ruby/)
comment(#3 /usr/lib/ruby/1.6)
comment(#4 /usr/lib/ruby/1.6/i136-linux)
comment(#5 .)
comment(#-----------------------------)
comment(# syntax for sh, bash, ksh, or zsh)
comment(#$ export RUBYLIB=$HOME/rubylib)

comment(# syntax for csh or tcsh)
comment(# % setenv RUBYLIB ~/rubylib)
comment(#-----------------------------)
global_variable($LOAD_PATH)operator(.)ident(unshift) string<delimiter(")content(/projects/spectre/lib)delimiter(")>operator(;)


comment(# @@PLEAC@@_12.8)
comment(# equivalents in ruby are mkmf, SWIG, or Ruby/DL depending on usage)


comment(# @@PLEAC@@_12.9)
comment(# no equivalent in ruby)


comment(# @@PLEAC@@_12.10)
comment(# no equivalent in ruby)


comment(# @@PLEAC@@_12.11)
reserved(module) class(FineTime)
    reserved(def) pre_constant(self)operator(.)ident(time)
        comment(# to be defined later)
    reserved(end)
reserved(end)


reserved(module) class(FineTime)
    reserved(def) pre_constant(self)operator(.)ident(time)
        string<delimiter(")content(its a fine time)delimiter(")>
    reserved(end)
reserved(end)

ident(puts) constant(FineTime)operator(.)ident(time) comment(#=> "its a fine time")


comment(# @@PLEAC@@_12.12)
reserved(def) method(even_only)operator(()ident(n)operator(\))
    ident(raise) string<delimiter(")inline<delimiter(#{)ident(n)delimiter(})>content( is not even)delimiter(")> reserved(if) operator(()ident(n) operator(&) integer(1)operator(\)) operator(!=) integer(0)  comment(# one way to test)
    comment(# ...)
reserved(end)
reserved(def) method(even_only)operator(()ident(n)operator(\))
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")inline<delimiter(#{)ident(n)delimiter(})>content( is not even)delimiter(")> reserved(if) operator(()ident(n) operator(&) integer(1)operator(\)) operator(!=) integer(0)
    comment(# ...)
reserved(end)


comment(# @@PLEAC@@_12.17)
comment(# The library archive for ruby is called Ruby Application archive,)
comment(# or shorter RAA, and can be found at http://raa.ruby-lang.org.)
comment(# A typical library is installed like this:)
comment(# % gunzip some-module-4.54.tar.gz)
comment(# % tar xf some-module-4.54.tar)
comment(# % cd some-module-4.54.tar)
comment(# % ruby install.rb config)
comment(# % ruby install.rb setup)
comment(# get superuser previleges here if needed for next step)
comment(# % ruby install.rb install)

comment(# Some modules use a different process,)
comment(# you should find details in the documentation)
comment(# Here is an example of such a different process)
comment(# % ruby extconf.rb)
comment(# % make)
comment(# % make install)

comment(# If you want the module installed in your own directory:)
comment(# For ruby version specific libraries)
comment(# % ruby install.rb config --site-ruby=~/lib)
comment(# For version independent libraries)
comment(# % ruby install.rb config --site-ruby-common=~/lib)

comment(# Information about possible options for config)
comment(# % ruby install.rb --help)

comment(# If you have your own complete distribution)
comment(# % ruby install.rb --prefix=path=~/ruby-private)


comment(# @@PLEAC@@_13.0)
comment(# Classes and objects in Ruby are rather straigthforward)
reserved(class) class(Person)
    comment(# Class variables (also called static attributes\) are prefixed by @@)
    class_variable(@@person_counter)operator(=)integer(0)
    
    comment(# object constructor)
    reserved(def) method(initialize)operator(()ident(age)operator(,) ident(name)operator(,) ident(alive) operator(=) pre_constant(true)operator(\))     comment(# Default arg like in C++)
        instance_variable(@age)operator(,) instance_variable(@name)operator(,) instance_variable(@alive) operator(=) ident(age)operator(,) ident(name)operator(,) ident(alive)  comment(# Object attributes are prefixed by '@')
        class_variable(@@person_counter) operator(+=) integer(1)
          comment(# There is no '++' operator in Ruby. The '++'/'--'  operators are in fact )
          comment(# hidden assignments which affect variables, not objects. You cannot accomplish)
          comment(# assignment via method. Since everything in Ruby is object, '++' and '--' )
          comment(# contradict Ruby OO ideology. Instead '-=' and '+=' are used.)
    reserved(end)
    
    ident(attr_accessor) symbol(:name)operator(,) symbol(:age)   comment(# This creates setter and getter methods for @name)
                                comment(# and @age. See 13.3 for detailes.)
    
    comment(# methods modifying the receiver object usually have the '!' suffix)
    reserved(def) method(die!)
        instance_variable(@alive) operator(=) pre_constant(false)
        ident(puts) string<delimiter(")inline<delimiter(#{)instance_variable(@name)delimiter(})>content( has died at the age of )inline<delimiter(#{)instance_variable(@age)delimiter(})>content(.)delimiter(")>
        instance_variable(@alive)
    reserved(end)
    
    reserved(def) method(kill)operator(()ident(anotherPerson)operator(\))
        ident(print) instance_variable(@name)operator(,) string<delimiter(')content( is killing )delimiter(')>operator(,) ident(anotherPerson)operator(.)ident(name)operator(,) string<delimiter(")content(.)char(\\n)delimiter(")>
        ident(anotherPerson)operator(.)ident(die!)
    reserved(end)

    comment(# methods used as queries)
    comment(# usually have the '?' suffix    )
    reserved(def) method(alive?)
        instance_variable(@alive) operator(&&) pre_constant(true)
    reserved(end)
    
    reserved(def) method(year_of_birth)
        constant(Time)operator(.)ident(now)operator(.)ident(year) operator(-) instance_variable(@age)
    reserved(end)
    
    comment(# Class method (also called static method\))
    reserved(def) constant(Person)operator(.)ident(number_of_people)
        class_variable(@@person_counter)
    reserved(end)
reserved(end)

comment(# Using the class:)
comment(# Create objects of class Person)
ident(lecter) operator(=) constant(Person)operator(.)ident(new)operator(()integer(47)operator(,) string<delimiter(')content(Hannibal)delimiter(')>operator(\))
ident(starling) operator(=) constant(Person)operator(.)ident(new)operator(()integer(29)operator(,) string<delimiter(')content(Clarice)delimiter(')>operator(,) pre_constant(true)operator(\))
ident(pazzi) operator(=) constant(Person)operator(.)ident(new)operator(()integer(40)operator(,) string<delimiter(')content(Rinaldo)delimiter(')>operator(,) pre_constant(true)operator(\))

comment(# Calling a class method)
ident(print) string<delimiter(")content(There are )delimiter(")>operator(,) constant(Person)operator(.)ident(number_of_people)operator(,) string<delimiter(")content( Person objects)char(\\n)delimiter(")>

ident(print) ident(pazzi)operator(.)ident(name)operator(,) string<delimiter(')content( is )delimiter(')>operator(,) operator(()ident(pazzi)operator(.)ident(alive?)operator(\)) operator(?) string<delimiter(')content(alive)delimiter(')> operator(:) string<delimiter(')content(dead)delimiter(')>operator(,) string<delimiter(")content(.)char(\\n)delimiter(")>
ident(lecter)operator(.)ident(kill)operator(()ident(pazzi)operator(\))
ident(print) ident(pazzi)operator(.)ident(name)operator(,) string<delimiter(')content( is )delimiter(')>operator(,) operator(()ident(pazzi)operator(.)ident(alive?)operator(\)) operator(?) string<delimiter(')content(alive)delimiter(')> operator(:) string<delimiter(')content(dead)delimiter(')>operator(,) string<delimiter(")content(.)char(\\n)delimiter(")>

ident(print) ident(starling)operator(.)ident(name) operator(,) string<delimiter(')content( was born in )delimiter(')>operator(,) ident(starling)operator(.)ident(year_of_birth)operator(,) string<delimiter(")char(\\n)delimiter(")>


comment(# @@PLEAC@@_13.1)
comment(# If you don't need any initialisation in the constructor,)
comment(# you don't need to write a constructor.)
reserved(class) class(MyClass)
reserved(end)

reserved(class) class(MyClass)
    reserved(def) method(initialize)
        instance_variable(@start) operator(=) constant(Time)operator(.)ident(new)
        instance_variable(@age) operator(=) integer(0)
    reserved(end)
reserved(end)

reserved(class) class(MyClass)
    reserved(def) method(initialize)operator(()ident(inithash)operator(\))
        instance_variable(@start) operator(=) constant(Time)operator(.)ident(new)
        instance_variable(@age) operator(=) integer(0)
        reserved(for) ident(key)operator(,) ident(value) reserved(in) ident(inithash)
            ident(instance_variable_set)operator(()string<delimiter(")content(@)inline<delimiter(#{)ident(key)delimiter(})>delimiter(")>operator(,) ident(value)operator(\))
        reserved(end)
    reserved(end)
reserved(end)

comment(# @@PLEAC@@_13.2)
comment(# Objects are destroyed by the garbage collector.)
comment(# The time of destroying is not predictable.)
comment(# The ruby garbage collector can handle circular references,)
comment(# so there is no need to write destructor for that.)

comment(# There is no direct support for destructor.)
comment(# You can call a custom function, or more specific a proc object, when the)
comment(# garbage collector is about to destruct the object, but it is unpredictable)
comment(# when this occurs.)
comment(# Also if such a finalizer object has a reference to the orignal object,)
comment(# this may prevent the original object to get garbage collected.)
comment(# Because of this problem the finalize method below is)
comment(# a class method and not a instance method.)
comment(# So if you need to free resources for an object, like)
comment(# closing a socket or kill a spawned subprocess,)
comment(# you should do it explicitly.)

reserved(class) class(MyClass)
    reserved(def) method(initialize)
        constant(ObjectSpace)operator(.)ident(define_finalizer)operator(()pre_constant(self)operator(,)
                                     pre_constant(self)operator(.)ident(class)operator(.)ident(method)operator(()symbol(:finalize)operator(\))operator(.)ident(to_proc)operator(\))
    reserved(end)
    reserved(def) constant(MyClass)operator(.)ident(finalize)operator(()ident(id)operator(\))
        ident(puts) string<delimiter(")content(Object )inline<delimiter(#{)ident(id)delimiter(})>content( dying at )inline<delimiter(#{)constant(Time)operator(.)ident(new)delimiter(})>delimiter(")>
    reserved(end)
reserved(end)

comment(# test code)
integer(3)operator(.)ident(times) operator({)
    constant(MyClass)operator(.)ident(new)
operator(})
constant(ObjectSpace)operator(.)ident(garbage_collect)


comment(# @@PLEAC@@_13.3)
comment(# You can write getter and setter methods in a natural way:)
reserved(class) class(Person)
    reserved(def) method(name)
        instance_variable(@name)
    reserved(end)
    reserved(def) method(name=)operator(()ident(name)operator(\))
        instance_variable(@name) operator(=) ident(name)
    reserved(end)
reserved(end)

comment(# But there is a better and shorter way)
reserved(class) class(Person)
    ident(attr_reader) symbol(:age)
    ident(attr_writer) symbol(:name)  
    comment(# attr_reader and attr_writer are actually methods in class Class)
    comment(# which set getter and setter methods for you.)
reserved(end)

comment(# There is also attr_accessor to create both setters and getters)
reserved(class) class(Person)
    ident(attr_accessor) symbol(:age)operator(,) symbol(:name)
reserved(end)


comment(# @@PLEAC@@_13.4)
reserved(class) class(Person)
    comment(# Class variables (also called static attributes\) are prefixed by @@)
    class_variable(@@person_counter) operator(=) integer(0)
    
    reserved(def) constant(Person)operator(.)ident(population)
        class_variable(@@person_counter)
    reserved(end)
    reserved(def) method(initialize)
        class_variable(@@person_counter) operator(+=) integer(1)
        constant(ObjectSpace)operator(.)ident(define_finalizer)operator(()pre_constant(self)operator(,)
                                     pre_constant(self)operator(.)ident(class)operator(.)ident(method)operator(()symbol(:finalize)operator(\))operator(.)ident(to_proc)operator(\))
    reserved(end)
    reserved(def) constant(Person)operator(.)ident(finalize)operator(()ident(id)operator(\))
        class_variable(@@person_counter) operator(-=) integer(1)
    reserved(end)
reserved(end)
ident(people) operator(=) operator([)operator(])
integer(10)operator(.)ident(times) operator({)
    ident(people)operator(.)ident(push)operator(()constant(Person)operator(.)ident(new)operator(\))
operator(})
ident(printf)operator(()string<delimiter(")content(There are %d people alive)delimiter(")>operator(,) constant(Person)operator(.)ident(population)operator(\))


constant(FixedArray)operator(.)ident(class_max_bounds) operator(=) integer(100)
ident(alpha) operator(=) constant(FixedArray)operator(.)ident(new)
ident(puts) string<delimiter(")content(Bound on alpha is )inline<delimiter(#{)ident(alpha)operator(.)ident(max_bounds)delimiter(})>delimiter(")>

ident(beta) operator(=) constant(FixedArray)operator(.)ident(new)
ident(beta)operator(.)ident(max_bounds) operator(=) integer(50)                    comment(# calls the instance method)
ident(beta)operator(.)ident(class)operator(.)ident(class_max_bounds) operator(=) integer(50)        comment(# alternative, calls the class method)
ident(puts) string<delimiter(")content(Bound on alpha is )inline<delimiter(#{)ident(alpha)operator(.)ident(max_bounds)delimiter(})>delimiter(")>
    
reserved(class) class(FixedArray)
    class_variable(@@bounds) operator(=) integer(7)
    
    reserved(def) method(max_bounds)
        class_variable(@@max_bounds)
    reserved(end)
    comment(# instance method, which sets the class variable)
    reserved(def) method(max_bounds=)operator(()ident(value)operator(\))
        class_variable(@@max_bounds) operator(=) ident(value)
    reserved(end)
    comment(# class method. This can only be called on a class,)
    comment(# but not on the instances)
    reserved(def) constant(FixedArray)operator(.)ident(class_max_bounds)operator(=)operator(()ident(value)operator(\))
        class_variable(@@max_bounds) operator(=) ident(value)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_13.5)
constant(PersonStruct) operator(=) constant(Struct)operator(.)ident(new)operator(()string<delimiter(")content(Person)delimiter(")>operator(,) symbol(:name)operator(,) symbol(:age)operator(,) symbol(:peers)operator(\))
comment(# creates a class "Person::Struct", which is accessiable with the)
comment(# constant "PersonStruct")
ident(p) operator(=) constant(PersonStruct)operator(.)ident(new)
ident(p) operator(=) constant(Struct)operator(::)constant(Person)operator(.)ident(new)                      comment(# alternative using the classname)
ident(p)operator(.)ident(name) operator(=) string<delimiter(")content(Jason Smythe)delimiter(")>
ident(p)operator(.)ident(age) operator(=) integer(13)
ident(p)operator(.)ident(peers) operator(=) operator([)string<delimiter(")content(Wilbur)delimiter(")>operator(,) string<delimiter(")content(Ralph)delimiter(")>operator(,) string<delimiter(")content(Fred)delimiter(")>operator(])
ident(p)operator([)symbol(:peers)operator(]) operator(=) operator([)string<delimiter(")content(Wilbur)delimiter(")>operator(,) string<delimiter(")content(Ralph)delimiter(")>operator(,) string<delimiter(")content(Fred)delimiter(")>operator(])     comment(# alternative access using symbol)
ident(p)operator([)string<delimiter(")content(peers)delimiter(")>operator(]) operator(=) operator([)string<delimiter(")content(Wilbur)delimiter(")>operator(,) string<delimiter(")content(Ralph)delimiter(")>operator(,) string<delimiter(")content(Fred)delimiter(")>operator(])    comment(# alternative access using name of field)
ident(p)operator([)integer(2)operator(]) operator(=) operator([)string<delimiter(")content(Wilbur)delimiter(")>operator(,) string<delimiter(")content(Ralph)delimiter(")>operator(,) string<delimiter(")content(Fred)delimiter(")>operator(])          comment(# alternative access using index of field)
ident(puts) string<delimiter(")content(At age )inline<delimiter(#{)ident(p)operator(.)ident(age)delimiter(})>content(, )inline<delimiter(#{)ident(p)operator(.)ident(name)delimiter(})>content('s first friend is )inline<delimiter(#{)ident(p)operator(.)ident(peers)operator([)integer(0)operator(])delimiter(})>delimiter(")>

comment(# The fields of a struct have no special type, like other ruby variables)
comment(# you can put any objects in. Therefore the discussions how to specify)
comment(# the types of the fields do not apply to ruby.)

constant(FamilyStruct) operator(=) constant(Struct)operator(.)ident(new)operator(()string<delimiter(")content(Family)delimiter(")>operator(,) symbol(:head)operator(,) symbol(:address)operator(,) symbol(:members)operator(\))
ident(folks) operator(=) constant(FamilyStruct)operator(.)ident(new)
ident(folks)operator(.)ident(head) operator(=) constant(PersonStruct)operator(.)ident(new)
ident(dad) operator(=) ident(folks)operator(.)ident(head)
ident(dad)operator(.)ident(name) operator(=) string<delimiter(")content(John)delimiter(")>
ident(dad)operator(.)ident(age) operator(=) integer(34)

comment(# supply of own accessor method for the struct for error checking)
reserved(class) class(PersonStruct)
    reserved(def) method(age=)operator(()ident(value)operator(\))
        reserved(if) operator(!)ident(value)operator(.)ident(kind_of?)operator(()constant(Integer)operator(\))
            ident(raise)operator(()constant(ArgumentError)operator(,) string<delimiter(")content(Age )inline<delimiter(#{)ident(value)delimiter(})>content( isn't an Integer)delimiter(")>operator(\))
        reserved(elsif) ident(value) operator(>) integer(150)
            ident(raise)operator(()constant(ArgumentError)operator(,) string<delimiter(")content(Age )inline<delimiter(#{)ident(value)delimiter(})>content( is unreasonable)delimiter(")>operator(\))
        reserved(end)
        instance_variable(@age) operator(=) ident(value)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_13.6)
comment(# The ruby Object class defines a dup and a clone method.)
comment(# The dup method is recommended for prototype object creation.)
comment(# The default implementation makes a shallow copy,)
comment(# but each class can override it, for example to make a deep copy.)

comment(# If you want to call 'new' directly on the instances,)
comment(# you can create a instance method "new", which returns a new duplicate.)
comment(# This method is distinct from the class method new.)
comment(#)
reserved(class) class(A)
    reserved(def) method(new)
        ident(dup)
    reserved(end)
reserved(end)

ident(ob1) operator(=) constant(A)operator(.)ident(new)
comment(# later on)
ident(ob2) operator(=) ident(ob1)operator(.)ident(new)


comment(# @@PLEAC@@_13.7)
ident(methname) operator(=) string<delimiter(')content(flicker)delimiter(')>
ident(obj)operator(.)ident(send)operator(()ident(methname)operator(,) integer(10)operator(\))      comment(# calls obj.flicker(10\))

comment(# call three methods on the object, by name)
operator([)string<delimiter(')content(start)delimiter(')>operator(,) string<delimiter(')content(run)delimiter(')>operator(,) string<delimiter(')content(stop)delimiter(')>operator(])operator(.)ident(each) reserved(do) operator(|)ident(method_string)operator(|)
    ident(obj)operator(.)ident(send)operator(()ident(method_string)operator(\))
reserved(end)

comment(# Another way is to create a Method object)
ident(method_obj) operator(=) ident(obj)operator(.)ident(method)operator(()string<delimiter(')content(flicker)delimiter(')>operator(\))
comment(# And then call it)
ident(method_obj)operator(.)ident(call)operator(()integer(10)operator(\))


comment(# @@PLEAC@@_13.8)
comment(# All classes in Ruby inherit from class Object)
comment(# and thus all objects share methods defined in this class)

comment(# the class of the object)
ident(puts) ident(any_object)operator(.)ident(type)

comment(# Ruby classes are actually objects of class Class and they)
comment(# respond to methods defined in Object class as well)

comment(# the superclass of this class)
ident(puts) ident(any_object)operator(.)ident(class)operator(.)ident(superclass)

comment(# ask an object whether it is an instance of particular class)
ident(n) operator(=) float(4.7)
ident(puts) ident(n)operator(.)ident(instance_of?)operator(()constant(Float)operator(\))    comment(# true)
ident(puts) ident(n)operator(.)ident(instance_of?)operator(()constant(Numeric)operator(\))  comment(# false)

comment(# ask an object whether it is an instance of class, one of the)
comment(# superclasses of the object, or modules included in it)
ident(puts) ident(n)operator(.)ident(kind_of?)operator(()constant(Float)operator(\))       comment(# true (the class\))
ident(puts) ident(n)operator(.)ident(kind_of?)operator(()constant(Numeric)operator(\))     comment(# true (an ancestor class\))
ident(puts) ident(n)operator(.)ident(kind_of?)operator(()constant(Comparable)operator(\))  comment(# true (a mixin module\))
ident(puts) ident(n)operator(.)ident(kind_of?)operator(()constant(String)operator(\))      comment(# false)

comment(# ask an object whether it can respond to a particular method)
ident(puts) ident(n)operator(.)ident(respond_to?)operator(()string<delimiter(')content(+)delimiter(')>operator(\))      comment(# true)
ident(puts) ident(n)operator(.)ident(respond_to?)operator(()string<delimiter(')content(length)delimiter(')>operator(\)) comment(# false)

comment(# all methods an object can respond to)
string<delimiter(')content(just a string)delimiter(')>operator(.)ident(methods)operator(.)ident(each) operator({) operator(|)ident(m)operator(|) ident(puts) ident(m) operator(})


comment(# @@PLEAC@@_13.9)
comment(# Actually any class in Ruby is inheritable)
reserved(class) class(Person)        
    ident(attr_accessor) symbol(:age)operator(,) symbol(:name)
    reserved(def) method(initialize)
        instance_variable(@name)
        instance_variable(@age)
    reserved(end)
reserved(end)
comment(#-----------------------------)
ident(dude) operator(=) constant(Person)operator(.)ident(new)
ident(dude)operator(.)ident(name) operator(=) string<delimiter(')content(Jason)delimiter(')>
ident(dude)operator(.)ident(age) operator(=) integer(23)
ident(printf) string<delimiter(")content(%s is age %d.)char(\\n)delimiter(")>operator(,) ident(dude)operator(.)ident(name)operator(,) ident(dude)operator(.)ident(age)
comment(#-----------------------------)
comment(# Inheriting from Person)
reserved(class) class(Employee) operator(<) constant(Person)
    ident(attr_accessor) symbol(:salary)
reserved(end)
comment(#-----------------------------)
ident(empl) operator(=) constant(Employee)operator(.)ident(new)
ident(empl)operator(.)ident(name) operator(=) string<delimiter(')content(Jason)delimiter(')>
ident(empl)operator(.)ident(age) operator(=) integer(23)
ident(empl)operator(.)ident(salary) operator(=) integer(200)
ident(printf) string<delimiter(")content(%s is age %d, the salary is %d.)char(\\n)delimiter(")>operator(,) ident(empl)operator(.)ident(name)operator(,) ident(empl)operator(.)ident(age)operator(,) ident(empl)operator(.)ident(salary)
comment(#-----------------------------)
comment(# Any built-in class can be inherited the same way)
reserved(class) class(WeirdString) operator(<) constant(String)  
    reserved(def) method(initialize)operator(()ident(obj)operator(\))
        reserved(super) ident(obj)
    reserved(end)
    reserved(def) method(+)operator(()ident(anotherObj)operator(\))   comment(# + method in this class is overridden)
        comment(# to return the sum of string lengths)
        pre_constant(self)operator(.)ident(length) operator(+) ident(anotherObj)operator(.)ident(length)  comment(# 'self' can be omitted)
    reserved(end)  
reserved(end)
comment(#-----------------------------)
ident(a) operator(=) constant(WeirdString)operator(.)ident(new)operator(()string<delimiter(')content(hello)delimiter(')>operator(\))
ident(b) operator(=) constant(WeirdString)operator(.)ident(new)operator(()string<delimiter(')content(bye)delimiter(')>operator(\))

ident(puts) ident(a) operator(+) ident(b)    comment(# the overridden +)
comment(#=> 8)
ident(puts) ident(a)operator(.)ident(length) comment(# method from the superclass, String)
comment(#=> 5)


comment(# @@PLEAC@@_13.11)
comment(# In ruby you can override the method_missing method)
comment(# to have a solution similar to perls AUTOLOAD.)
reserved(class) class(Person)

    reserved(def) method(initialize)
        instance_variable(@ok_fields) operator(=) string<delimiter(%w()content(name age peers parent)delimiter(\))>
    reserved(end)

    reserved(def) method(valid_attribute?)operator(()ident(name)operator(\))
        instance_variable(@ok_fields)operator(.)ident(include?)operator(()ident(name)operator(\))
    reserved(end)

    reserved(def) method(method_missing)operator(()ident(namesymbol)operator(,) operator(*)ident(params)operator(\))
        ident(name) operator(=) ident(namesymbol)operator(.)ident(to_s)
        reserved(return) reserved(if) ident(name) operator(=)operator(~) regexp<delimiter(/)content(^A-Z)delimiter(/)>
        reserved(if) ident(name)operator(.)ident(to_s)operator([)integer(-1)operator(]) operator(==) operator(()string<delimiter(')content(=)delimiter(')>operator([)integer(0)operator(])operator(\))       comment(# we have a setter)
            ident(isSetter) operator(=) pre_constant(true)
            ident(name)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(=$)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))
        reserved(end)
        reserved(if) ident(valid_attribute?)operator(()ident(name)operator(\))
            reserved(if) ident(isSetter)
                ident(instance_variable_set)operator(()string<delimiter(")content(@)inline<delimiter(#{)ident(name)delimiter(})>delimiter(")>operator(,) operator(*)ident(params)operator(\))
            reserved(else)
                ident(instance_variable_get)operator(()string<delimiter(")content(@)inline<delimiter(#{)ident(name)delimiter(})>delimiter(")>operator(,) operator(*)ident(params)operator(\))
            reserved(end)
        reserved(else)
            comment(# if no annestor is responsible,)
            comment(# the Object class will throw a NoMethodError exception)
            reserved(super)operator(()ident(namesymbol)operator(,) operator(*)ident(params)operator(\))
        reserved(end)
    reserved(end)

    reserved(def) method(new)
        ident(kid) operator(=) constant(Person)operator(.)ident(new)
        ident(kid)operator(.)ident(parent) operator(=) pre_constant(self)
        ident(kid)
    reserved(end)

reserved(end)

ident(dad) operator(=) constant(Person)operator(.)ident(new)
ident(dad)operator(.)ident(name) operator(=) string<delimiter(")content(Jason)delimiter(")>
ident(dad)operator(.)ident(age) operator(=) integer(23)
ident(kid) operator(=) ident(dad)operator(.)ident(new)
ident(kid)operator(.)ident(name) operator(=) string<delimiter(")content(Rachel)delimiter(")>
ident(kid)operator(.)ident(age) operator(=) integer(2)
ident(puts) string<delimiter(")content(Kid's parent is )inline<delimiter(#{)ident(kid)operator(.)ident(parent)operator(.)ident(name)delimiter(})>delimiter(")>
ident(puts) ident(dad)
ident(puts) ident(kid)

reserved(class) class(Employee) operator(<) constant(Person)
    reserved(def) method(initialize)
        reserved(super)
        instance_variable(@ok_fields)operator(.)ident(push)operator(()string<delimiter(")content(salary)delimiter(")>operator(,) string<delimiter(")content(boss)delimiter(")>operator(\))
    reserved(end)
    reserved(def) method(ok_fields)
        instance_variable(@ok_fields)
    reserved(end)
reserved(end)


comment(# @@PLEAC@@_13.13)
comment(# The ruby garbage collector pretends to cope with circular structures.)
comment(# You can test it with this code:)
reserved(class) class(RingNode)
    ident(attr_accessor) symbol(:next)
    ident(attr_accessor) symbol(:prev)
    ident(attr_reader) symbol(:name)

    reserved(def) method(initialize)operator(()ident(aName)operator(\))
        instance_variable(@name) operator(=) ident(aName)
        constant(ObjectSpace)operator(.)ident(define_finalizer)operator(()pre_constant(self)operator(,)
                                     pre_constant(self)operator(.)ident(class)operator(.)ident(method)operator(()symbol(:finalize)operator(\))operator(.)ident(to_proc)operator(\))
    reserved(end)

    reserved(def) constant(RingNode)operator(.)ident(finalize)operator(()ident(id)operator(\))
        ident(puts) string<delimiter(")content(Node )inline<delimiter(#{)ident(id)delimiter(})>content( dying)delimiter(")>
    reserved(end)

    reserved(def) constant(RingNode)operator(.)ident(show_all_objects)
        constant(ObjectSpace)operator(.)ident(each_object) operator({)operator(|)ident(id)operator(|)
            ident(puts) ident(id)operator(.)ident(name) reserved(if) ident(id)operator(.)ident(class) operator(==) constant(RingNode)
        operator(})
    reserved(end)
reserved(end)

reserved(def) method(create_test)
    ident(a) operator(=) constant(RingNode)operator(.)ident(new)operator(()string<delimiter(")content(Node A)delimiter(")>operator(\))
    ident(b) operator(=) constant(RingNode)operator(.)ident(new)operator(()string<delimiter(")content(Node B)delimiter(")>operator(\))
    ident(c) operator(=) constant(RingNode)operator(.)ident(new)operator(()string<delimiter(")content(Node C)delimiter(")>operator(\))
    ident(a)operator(.)ident(next) operator(=) ident(b)
    ident(b)operator(.)ident(next) operator(=) ident(c)
    ident(c)operator(.)ident(next) operator(=) ident(a)
    ident(a)operator(.)ident(prev) operator(=) ident(c)
    ident(c)operator(.)ident(prev) operator(=) ident(b)
    ident(b)operator(.)ident(prev) operator(=) ident(a)

    ident(a) operator(=) pre_constant(nil)
    ident(b) operator(=) pre_constant(nil)
    ident(c) operator(=) pre_constant(nil)
reserved(end)

ident(create_test)
constant(RingNode)operator(.)ident(show_all_objects)
constant(ObjectSpace)operator(.)ident(garbage_collect)
ident(puts) string<delimiter(")content(After garbage collection)delimiter(")>
constant(RingNode)operator(.)ident(show_all_objects)


comment(# @@PLEAC@@_13.14)
reserved(class) class(String)
    reserved(def) method(<=>)operator(()ident(other)operator(\))
        pre_constant(self)operator(.)ident(casecmp) ident(other)
    reserved(end)
reserved(end)

comment(# There is no way to directly overload the '""' (stringify\) )
comment(# operator in Ruby.  However, by convention, classes which )
comment(# can reasonably be converted to a String will define a )
comment(# 'to_s' method as in the TimeNumber class defined below.)
comment(# The 'puts' method will automatcally call an object's)
comment(# 'to_s' method as is demonstrated below.)
comment(# Furthermore, if a class defines a to_str method, an object of that)
comment(# class can be used most any place where the interpreter is looking )
comment(# for a String value.)

comment(#---------------------------------------)
comment(# NOTE: Ruby has a builtin Time class which would usually be used )
comment(# to manipulate time objects, the following is supplied for)
comment(# educational purposes to demonstrate operator overloading.)
comment(#)
reserved(class) class(TimeNumber)
    ident(attr_accessor)  symbol(:hours)operator(,)symbol(:minutes)operator(,)symbol(:seconds)
    reserved(def) method(initialize)operator(() ident(hours)operator(,) ident(minutes)operator(,) ident(seconds)operator(\))
        instance_variable(@hours) operator(=) ident(hours)
        instance_variable(@minutes) operator(=) ident(minutes)
        instance_variable(@seconds) operator(=) ident(seconds)
    reserved(end)
    
    reserved(def) method(to_s)
        reserved(return) ident(sprintf)operator(() string<delimiter(")content(%d:%02d:%02d)delimiter(")>operator(,) instance_variable(@hours)operator(,) instance_variable(@minutes)operator(,) instance_variable(@seconds)operator(\))
    reserved(end)

    reserved(def) method(to_str)
        ident(to_s)
    reserved(end)

    reserved(def) method(+)operator(() ident(other)operator(\))
        ident(seconds) operator(=) instance_variable(@seconds) operator(+) ident(other)operator(.)ident(seconds)
        ident(minutes) operator(=) instance_variable(@minutes) operator(+) ident(other)operator(.)ident(minutes)
        ident(hours) operator(=) instance_variable(@hours) operator(+) ident(other)operator(.)ident(hours)
        reserved(if) ident(seconds) operator(>)operator(=) integer(60)
            ident(seconds) operator(%=) integer(60)
            ident(minutes) operator(+=) integer(1)
        reserved(end)
        reserved(if) ident(minutes) operator(>)operator(=) integer(60)
            ident(minutes) operator(%=) integer(60)
            ident(hours) operator(+=) integer(1)
        reserved(end)
        reserved(return) constant(TimeNumber)operator(.)ident(new)operator(()ident(hours)operator(,) ident(minutes)operator(,) ident(seconds)operator(\))
    reserved(end)

    reserved(def) method(-)operator(()ident(other)operator(\))
        ident(raise) constant(NotImplementedError)
    reserved(end)

    reserved(def) method(*)operator(()ident(other)operator(\))
        ident(raise) constant(NotImplementedError)
    reserved(end)

    reserved(def) method(/)operator(() ident(other)operator(\))
        ident(raise) constant(NotImplementedError)
    reserved(end)
reserved(end)

ident(t1) operator(=) constant(TimeNumber)operator(.)ident(new)operator(()integer(0)operator(,) integer(58)operator(,) integer(59)operator(\))
ident(sec) operator(=) constant(TimeNumber)operator(.)ident(new)operator(()integer(0)operator(,) integer(0)operator(,) integer(1)operator(\))
ident(min) operator(=) constant(TimeNumber)operator(.)ident(new)operator(()integer(0)operator(,) integer(1)operator(,) integer(0)operator(\))
ident(puts) ident(t1) operator(+) ident(sec) operator(+) ident(min) operator(+) ident(min)

comment(#-----------------------------)
comment(# StrNum class example: Ruby's builtin String class already has the )
comment(# capabilities outlined in StrNum Perl example, however the '*' operator)
comment(# on Ruby's String class acts differently: It creates a string which)
comment(# is the original string repeated N times.)
comment(#)
comment(# Using Ruby's String class as is in this example:)
ident(x) operator(=) string<delimiter(")content(Red)delimiter(")>operator(;) ident(y) operator(=) string<delimiter(")content(Black)delimiter(")>
ident(z) operator(=) ident(x)operator(+)ident(y)
ident(r) operator(=) ident(z)operator(*)integer(3) comment(# r is "RedBlackRedBlackRedBlack")
ident(puts) string<delimiter(")content(values are )inline<delimiter(#{)ident(x)delimiter(})>content(, )inline<delimiter(#{)ident(y)delimiter(})>content(, )inline<delimiter(#{)ident(z)delimiter(})>content(, and )inline<delimiter(#{)ident(r)delimiter(})>delimiter(")>
ident(print) string<delimiter(")inline<delimiter(#{)ident(x)delimiter(})>content( is )delimiter(")>operator(,) ident(x) operator(<) ident(y) operator(?) string<delimiter(")content(LT)delimiter(")> operator(:) string<delimiter(")content(GE)delimiter(")>operator(,) string<delimiter(")content( )inline<delimiter(#{)ident(y)delimiter(})>char(\\n)delimiter(")>
comment(# prints:)
comment(# values are Red, Black, RedBlack, and RedBlackRedBlackRedBlack)
comment(# Red is GE Black)

comment(#-----------------------------)
reserved(class) class(FixNum)
    constant(REGEX) operator(=) regexp<delimiter(/)content(()char(\\.)char(\\d)content(*\))delimiter(/)>
    constant(DEFAULT_PLACES) operator(=) integer(0)
    ident(attr_accessor) symbol(:value)operator(,) symbol(:places)
    reserved(def) method(initialize)operator(()ident(value)operator(,) ident(places) operator(=) pre_constant(nil)operator(\))
        instance_variable(@value) operator(=) ident(value)
        reserved(if) ident(places)
            instance_variable(@places) operator(=) ident(places)
        reserved(else)
            ident(m) operator(=) constant(REGEX)operator(.)ident(match)operator(()ident(value)operator(.)ident(to_s)operator(\)) 
            reserved(if) ident(m)
                instance_variable(@places) operator(=) ident(m)operator([)integer(0)operator(])operator(.)ident(length) operator(-) integer(1)
            reserved(else)
                instance_variable(@places) operator(=) constant(DEFAULT_PLACES)
            reserved(end)
        reserved(end)
    reserved(end)

    reserved(def) method(+)operator(()ident(other)operator(\))
        constant(FixNum)operator(.)ident(new)operator(()instance_variable(@value) operator(+) ident(other)operator(.)ident(value)operator(,) ident(max)operator(()instance_variable(@places)operator(,) ident(other)operator(.)ident(places)operator(\))operator(\))
    reserved(end)

    reserved(def) method(*)operator(()ident(other)operator(\))
        constant(FixNum)operator(.)ident(new)operator(()instance_variable(@value) operator(*) ident(other)operator(.)ident(value)operator(,) ident(max)operator(()instance_variable(@places)operator(,) ident(other)operator(.)ident(places)operator(\))operator(\))
    reserved(end)

    reserved(def) method(/)operator(()ident(other)operator(\))
        ident(puts) string<delimiter(")content(Divide: )inline<delimiter(#{)instance_variable(@value)operator(.)ident(to_f)operator(/)ident(other)operator(.)ident(value)operator(.)ident(to_f)delimiter(})>delimiter(")>
        ident(result) operator(=) constant(FixNum)operator(.)ident(new)operator(()instance_variable(@value)operator(.)ident(to_f)operator(/)ident(other)operator(.)ident(value)operator(.)ident(to_f)operator(\))
        ident(result)operator(.)ident(places) operator(=) ident(max)operator(()ident(result)operator(.)ident(places)operator(,)ident(other)operator(.)ident(places)operator(\)) 
        ident(result)
    reserved(end)

    reserved(def) method(to_s)
        ident(sprintf)operator(()string<delimiter(")content(STR%s: %.*f)delimiter(")>operator(,) pre_constant(self)operator(.)ident(class)operator(.)ident(to_s) operator(,) instance_variable(@places)operator(,) instance_variable(@value)operator(\))   comment(#.)
    reserved(end)  

    reserved(def) method(to_str)
        ident(to_s)
    reserved(end)

    reserved(def) method(to_i) comment(#convert to int)
        instance_variable(@value)operator(.)ident(to_i)
    reserved(end)

    reserved(def) method(to_f) comment(#convert to float`)
        instance_variable(@value)operator(.)ident(to_f)
    reserved(end)

    ident(private)
    reserved(def) method(max)operator(()ident(a)operator(,)ident(b)operator(\))
        ident(a) operator(>) ident(b) operator(?) ident(a) operator(:) ident(b)
    reserved(end)
reserved(end)

reserved(def) method(demo)operator(()operator(\))
    ident(x) operator(=) constant(FixNum)operator(.)ident(new)operator(()integer(40)operator(\))
    ident(y) operator(=) constant(FixNum)operator(.)ident(new)operator(()integer(12)operator(,) integer(0)operator(\))

    ident(puts) string<delimiter(")content(sum of )inline<delimiter(#{)ident(x)delimiter(})>content( and )inline<delimiter(#{)ident(y)delimiter(})>content( is  )inline<delimiter(#{)ident(x)operator(+)ident(y)delimiter(})>delimiter(")>
    ident(puts) string<delimiter(")content(product of )inline<delimiter(#{)ident(x)delimiter(})>content( and )inline<delimiter(#{)ident(y)delimiter(})>content( is )inline<delimiter(#{)ident(x)operator(*)ident(y)delimiter(})>delimiter(")>

    ident(z) operator(=) ident(x)operator(/)ident(y)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(z)delimiter(})>content( has )inline<delimiter(#{)ident(z)operator(.)ident(places)delimiter(})>content( places)delimiter(")>
    reserved(unless) ident(z)operator(.)ident(places)
        ident(z)operator(.)ident(places) operator(=) integer(2)
    reserved(end)

    ident(puts) string<delimiter(")content(div of )inline<delimiter(#{)ident(x)delimiter(})>content( by )inline<delimiter(#{)ident(y)delimiter(})>content( is )inline<delimiter(#{)ident(z)delimiter(})>delimiter(")>
    ident(puts) string<delimiter(")content(square of that is  )inline<delimiter(#{)ident(z)operator(*)ident(z)delimiter(})>delimiter(")>
reserved(end)

reserved(if) pre_constant(__FILE__) operator(==) global_variable($0)
    ident(demo)operator(()operator(\))
reserved(end)


comment(# @@PLEAC@@_14.1)
comment(# There are dbm, sdbm, gdbm modules)
comment(# and the bdb module for accessing the berkeley db)
comment(# sdbm seem to be available on the most systems,)
comment(# so we use it here)
comment(#)
ident(require) string<delimiter(")content(sdbm)delimiter(")>
constant(SDBM)operator(.)ident(open)operator(()string<delimiter(")content(filename)delimiter(")>operator(,) integer(0666)operator(\)) operator({) operator(|)ident(dbobj)operator(|)
    comment(# raises exception if open error)
    
    comment(# the returned sdbm-dbobj has most of the methods of a hash)
    ident(v) operator(=) ident(dbobj)operator([)string<delimiter(")content(key)delimiter(")>operator(])
    ident(dbobj)operator([)string<delimiter(")content(key)delimiter(")>operator(]) operator(=) string<delimiter(")content(newvalue)delimiter(")>
    reserved(if) ident(dbobj)operator(.)ident(has_key?)operator(()string<delimiter(")content(key)delimiter(")>operator(\))
        comment(# ...)
    reserved(end)
    ident(dbobj)operator(.)ident(delete)operator(()string<delimiter(")content(key2)delimiter(")>operator(\))
operator(})
comment(# database is open only inside the block.)

comment(# It is also possible to use a open .. close pair:)
ident(dbobj) operator(=) constant(SDBM)operator(.)ident(open)operator(()string<delimiter(")content(filename)delimiter(")>operator(,) integer(0666)operator(\))
comment(#.. do something with dbobj)
ident(dbobj)operator(.)ident(close)

comment(#!/usr/bin/ruby -w)
comment(# userstats - generate statistics on who is logged in)
comment(# call with usernames as argument to display the totals)
comment(# for the given usernames, call with "ALL" to display all users)

ident(require) string<delimiter(")content(sdbm)delimiter(")>
ident(filename) operator(=) string<delimiter(')content(/tmp/userstats.db)delimiter(')>
constant(SDBM)operator(.)ident(open)operator(()ident(filename)operator(,) integer(0666)operator(\)) operator({) operator(|)ident(dbobj)operator(|)
    reserved(if) pre_constant(ARGV)operator(.)ident(length) operator(>) integer(0)
        reserved(if) pre_constant(ARGV)operator([)integer(0)operator(]) operator(==) string<delimiter(")content(ALL)delimiter(")>
            comment(# ARGV is constant, so we need the variable userlist)
            ident(userlist) operator(=) ident(dbobj)operator(.)ident(keys)operator(()operator(\))operator(.)ident(sort)operator(()operator(\))
        reserved(else)
            ident(userlist) operator(=) pre_constant(ARGV)
        reserved(end)
        ident(userlist)operator(.)ident(each) operator({) operator(|)ident(user)operator(|)
            ident(print) string<delimiter(")inline<delimiter(#{)ident(user)delimiter(})>char(\\t)inline<delimiter(#{)ident(dbobj)operator([)ident(user)operator(])delimiter(})>char(\\n)delimiter(")>
        operator(})
    reserved(else)
        ident(who) operator(=) shell<delimiter(`)content(who)delimiter(`)>
        ident(who)operator(.)ident(split)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))operator(.)ident(each) operator({) operator(|)ident(line)operator(|)
            ident(md) operator(=) regexp<delimiter(/)content(^()char(\\S)content(+\))delimiter(/)>operator(.)ident(match)operator(()ident(line)operator(\))
            ident(raise) string<delimiter(")content(Bad line from who: )inline<delimiter(#{)ident(line)delimiter(})>delimiter(")> reserved(unless) ident(md)
            comment(# sdbm stores only strings, so "+=" doesn't work,)
            comment(# we need to convert them expicitly back to integer.)
            reserved(if) ident(dbobj)operator(.)ident(has_key?)operator(()ident(md)operator([)integer(0)operator(])operator(\))
                ident(dbobj)operator([)ident(md)operator([)integer(0)operator(])operator(]) operator(=) ident(dbobj)operator([)ident(md)operator([)integer(0)operator(])operator(])operator(.)ident(to_i) operator(+) integer(1)
            reserved(else)
                ident(dbobj)operator([)ident(md)operator([)integer(0)operator(])operator(]) operator(=) string<delimiter(")content(1)delimiter(")>
            reserved(end)
        operator(})
    reserved(end)
operator(})


comment(# @@PLEAC@@_14.2)
comment(# using open and clear)
ident(dbobj) operator(=) constant(SDBM)operator(.)ident(open)operator(()string<delimiter(")content(filename)delimiter(")>operator(,) integer(0666)operator(\))
ident(dbobj)operator(.)ident(clear)operator(()operator(\))
ident(dbobj)operator(.)ident(close)operator(()operator(\))
comment(# deleting file and recreating it)
comment(# the filenames depend on the flavor of dbm you use,)
comment(# for example sdbm has two files named filename.pag and filename.dir,)
comment(# so you need to delete both files)
reserved(begin)
    constant(File)operator(.)ident(delete)operator(()string<delimiter(")content(filename)delimiter(")>operator(\))
    comment(# raises Exception if not exist)
    ident(dbobj) operator(=) constant(SDBM)operator(.)ident(open)operator(()string<delimiter(")content(filename)delimiter(")>operator(,) integer(0666)operator(\))
reserved(rescue)
    comment(# add error handling here)
reserved(end)


comment(# @@PLEAC@@_14.3)
comment(# sdbm2gdbm: converts sdbm database to a gdbm database)
ident(require) string<delimiter(")content(sdbm)delimiter(")>
ident(require) string<delimiter(")content(gdbm)delimiter(")>

reserved(unless) pre_constant(ARGV)operator(.)ident(length) operator(==) integer(2)
    ident(fail) string<delimiter(")content(usage: sdbm2gdbm infile outfile)delimiter(")>
reserved(end)
ident(infile) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
ident(outfile) operator(=) pre_constant(ARGV)operator([)integer(1)operator(])

ident(sdb) operator(=) constant(SDBM)operator(.)ident(open)operator(()ident(infile)operator(\))
ident(gdb) operator(=) constant(GDBM)operator(.)ident(open)operator(()ident(outfile)operator(,) integer(0666)operator(\))
ident(sdb)operator(.)ident(each) operator({) operator(|)ident(key)operator(,) ident(val)operator(|)
    ident(gdb)operator([)ident(key)operator(]) operator(=) ident(val)
operator(})
ident(gdb)operator(.)ident(close)
ident(sdb)operator(.)ident(close)


comment(# @@PLEAC@@_14.4)
comment(#!/usr/bin/ruby -w)
comment(# dbmmerge: merges two dbm databases)
ident(require) string<delimiter(")content(sdbm)delimiter(")>

reserved(unless) pre_constant(ARGV)operator(.)ident(length) operator(==) integer(3)
    ident(fail) string<delimiter(")content(usage: dbmmerge indb1 indb2 outdb)delimiter(")>
reserved(end)
ident(infile1) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
ident(infile2) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
ident(outfile) operator(=) pre_constant(ARGV)operator([)integer(2)operator(])

ident(in1) operator(=) constant(SDBM)operator(.)ident(open)operator(()ident(infile1)operator(,) pre_constant(nil)operator(\))
ident(in2) operator(=) constant(SDBM)operator(.)ident(open)operator(()ident(infile2)operator(,) pre_constant(nil)operator(\))
ident(outdb) operator(=) constant(SDBM)operator(.)ident(open)operator(()ident(outfile)operator(,) integer(0666)operator(\))

operator([)ident(in1)operator(,) ident(in2)operator(])operator(.)ident(each) operator({) operator(|)ident(indb)operator(|)
    ident(indb)operator(.)ident(each) operator({) operator(|)ident(key)operator(,) ident(val)operator(|)
        reserved(if) ident(outdb)operator(.)ident(has_key?)operator(()ident(key)operator(\))
            comment(# decide which value to set.)
            comment(# set outdb[key] if necessary)
        reserved(else)
            ident(outdb)operator([)ident(key)operator(]) operator(=) ident(val)
        reserved(end)
    operator(})
operator(})
ident(in1)operator(.)ident(close)
ident(in2)operator(.)ident(close)
ident(outdb)operator(.)ident(close)


comment(# @@PLEAC@@_14.7)
comment(# we write a tie method that extends the Array class.)
comment(# It reads the file into the memory, executes the code block)
comment(# in which you can manipulate the array as needed, and writes)
comment(# the array back to the file after the end of the block execution)
reserved(class) class(Array)
    reserved(def) method(tie)operator(()ident(filename)operator(,) ident(flags)operator(\))
        constant(File)operator(.)ident(open)operator(()ident(filename)operator(,) ident(flags)operator(\)) operator({) operator(|)ident(f)operator(|)
            ident(f)operator(.)ident(each_line) operator({) operator(|)ident(line)operator(|)
                pre_constant(self)operator(.)ident(push)operator(()ident(line)operator(.)ident(chomp)operator(\))
            operator(})
            reserved(yield)
            ident(f)operator(.)ident(rewind)
            ident(each) operator({) operator(|)ident(line)operator(|)
                reserved(if) ident(line)
                    ident(f)operator(.)ident(puts)operator(()ident(line)operator(\))
                reserved(else)
                    ident(f)operator(.)ident(puts) string<delimiter(")delimiter(")>
                reserved(end)
            operator(})
        operator(})
    reserved(end)
reserved(end)

ident(array) operator(=) constant(Array)operator(.)ident(new)
ident(array)operator(.)ident(tie)operator(()string<delimiter(")content(/tmp/textfile.txt)delimiter(")>operator(,) constant(File)operator(::)constant(RDWR)operator(|)constant(File)operator(::)constant(CREAT)operator(\)) operator({)
    ident(array)operator([)integer(4)operator(]) operator(=) string<delimiter(")content(a new line 4)delimiter(")>
operator(})

comment(# The tied array can be manipulated like a normal array,)
comment(# so there is no need for a special API, and the recno_demo program)
comment(# to demonstrate is API is useless)


comment(# tied array demo: show how to use array with a tied file)
ident(filename) operator(=) string<delimiter(")content(db_file.txt)delimiter(")>
ident(lines) operator(=) constant(Array)operator(.)ident(new)
constant(File)operator(.)ident(unlink)operator(()ident(filename)operator(\)) reserved(if) constant(File)operator(.)ident(exists?)operator(()ident(filename)operator(\))
ident(lines)operator(.)ident(tie)operator(()ident(filename)operator(,) constant(File)operator(::)constant(RDWR) operator(|) constant(File)operator(::)constant(CREAT)operator(\)) operator({)
    comment(# first create a textfile to play with)
    ident(lines)operator([)integer(0)operator(]) operator(=) string<delimiter(")content(zero)delimiter(")>
    ident(lines)operator([)integer(1)operator(]) operator(=) string<delimiter(")content(one)delimiter(")>
    ident(lines)operator([)integer(2)operator(]) operator(=) string<delimiter(")content(two)delimiter(")>
    ident(lines)operator([)integer(3)operator(]) operator(=) string<delimiter(")content(three)delimiter(")>
    ident(lines)operator([)integer(4)operator(]) operator(=) string<delimiter(")content(four)delimiter(")>

    comment(# print the records in order.)
    comment(# Opposed to perl, the tied array behaves exactly as a normal array)
    ident(puts) string<delimiter(")char(\\n)content(Original)delimiter(")>
    reserved(for) ident(i) reserved(in) integer(0)operator(..)operator(()ident(lines)operator(.)ident(length)integer(-1)operator(\))
        ident(puts) string<delimiter(")inline<delimiter(#{)ident(i)delimiter(})>content(: )inline<delimiter(#{)ident(lines)operator([)ident(i)operator(])delimiter(})>delimiter(")>
    reserved(end)

    comment(#use push and pop)
    ident(a) operator(=) ident(lines)operator(.)ident(pop)
    ident(lines)operator(.)ident(push)operator(()string<delimiter(")content(last)delimiter(")>operator(\))
    ident(puts)operator(()string<delimiter(")content(The last line was [)inline<delimiter(#{)ident(a)delimiter(})>content(])delimiter(")>operator(\))

    comment(#use shift and unshift)
    ident(a) operator(=) ident(lines)operator(.)ident(shift)
    ident(lines)operator(.)ident(unshift)operator(()string<delimiter(")content(first)delimiter(")>operator(\))
    ident(puts)operator(()string<delimiter(")content(The first line was [)inline<delimiter(#{)ident(a)delimiter(})>content(])delimiter(")>operator(\))

    comment(# add record after record 2)
    ident(i) operator(=) integer(2)
    ident(lines)operator(.)ident(insert)operator(()ident(i) operator(+) integer(1)operator(,) string<delimiter(")content(Newbie)delimiter(")>operator(\))

    comment(# add record before record one)
    ident(i) operator(=) integer(1)
    ident(lines)operator(.)ident(insert)operator(()ident(i)operator(,) string<delimiter(")content(New One)delimiter(")>operator(\))

    comment(# delete record 3)
    ident(lines)operator(.)ident(delete_at)operator(()integer(3)operator(\))

    comment(#now print the records in reverse order)
    ident(puts) string<delimiter(")char(\\n)content(Reverse)delimiter(")>
    operator(()ident(lines)operator(.)ident(length) operator(-) integer(1)operator(\))operator(.)ident(downto)operator(()integer(0)operator(\))operator({) operator(|)ident(i)operator(|)
        ident(puts) string<delimiter(")inline<delimiter(#{)ident(i)delimiter(})>content(: )inline<delimiter(#{)ident(lines)operator([)ident(i)operator(])delimiter(})>delimiter(")>
    operator(})

operator(})


comment(# @@PLEAC@@_14.8)
comment(# example to store complex data in a database)
comment(# uses marshall from the standard library)
ident(require) string<delimiter(")content(sdbm)delimiter(")>
ident(db) operator(=) constant(SDBM)operator(.)ident(open)operator(()string<delimiter(")content(pleac14-8-database)delimiter(")>operator(,) integer(0666)operator(\))

comment(# convert the Objects into strings and back by using the Marshal module.)
comment(# Most normal objects can be converted out of the box,)
comment(# but not special things like procedure objects,)
comment(# IO instance variables, singleton objects)

ident(db)operator([)string<delimiter(")content(Tom Christiansen)delimiter(")>operator(]) operator(=) constant(Marshal)operator(.)ident(dump)operator(()operator([)string<delimiter(")content(book author)delimiter(")>operator(,)  string<delimiter(")content(tchrist@perl.com)delimiter(")>operator(])operator(\))
ident(db)operator([)string<delimiter(")content(Tom Boutell)delimiter(")>operator(]) operator(=) constant(Marshal)operator(.)ident(dump)operator(()operator([)string<delimiter(")content(shareware author)delimiter(")>operator(,)
string<delimiter(")content(boutell@boutell.com)delimiter(")>operator(])operator(\))

ident(name1) operator(=) string<delimiter(")content(Tom Christiansen)delimiter(")>
ident(name2) operator(=) string<delimiter(")content(Tom Boutell)delimiter(")>

ident(tom1) operator(=) constant(Marshal)operator(.)ident(load)operator(()ident(db)operator([)ident(name1)operator(])operator(\))
ident(tom2) operator(=) constant(Marshal)operator(.)ident(load)operator(()ident(db)operator([)ident(name2)operator(])operator(\))

ident(puts) string<delimiter(")content(Two Toming: )inline<delimiter(#{)ident(tom1)delimiter(})>content( )inline<delimiter(#{)ident(tom2)delimiter(})>delimiter(")>

reserved(if) ident(tom1)operator([)integer(0)operator(]) operator(==) ident(tom2)operator([)integer(0)operator(]) operator(&&) ident(tom1)operator([)integer(1)operator(]) operator(==) ident(tom2)operator([)integer(1)operator(])
   ident(puts) string<delimiter(")content(You're having runtime fun with one Tom made two.)delimiter(")>
reserved(else)
   ident(puts) string<delimiter(")content(No two Toms are ever alike)delimiter(")>
reserved(end)

comment(# To change parts of an entry, get the whole entry, change the parts,)
comment(# and save the whole entry back)
ident(entry) operator(=) constant(Marshal)operator(.)ident(load)operator(()ident(db)operator([)string<delimiter(")content(Tom Boutell)delimiter(")>operator(])operator(\))
ident(entry)operator([)integer(0)operator(]) operator(=) string<delimiter(")content(Poet Programmer)delimiter(")>
ident(db)operator([)string<delimiter(")content(Tom Boutell)delimiter(")>operator(]) operator(=) constant(Marshal)operator(.)ident(dump)operator(()ident(entry)operator(\))
ident(db)operator(.)ident(close)


comment(# @@PLEAC@@_14.9)
comment(# example to make data persistent)
comment(# uses Marshal from the standard lib)
comment(# Stores the data in a simple file,)
comment(# see 14.8 on how to store it in a dbm file)

comment(# The BEGIN block is executed before the rest of the script)
comment(# we use global variables here because local variables)
comment(# will go out of scope and are not accessible from the main script)

reserved(BEGIN) operator({)
   global_variable($persistent_store) operator(=) string<delimiter(")content(persitence.dat)delimiter(")>
   reserved(begin)
     constant(File)operator(.)ident(open)operator(()global_variable($persistent_store)operator(\)) reserved(do) operator(|)ident(f)operator(|)
       global_variable($stringvariable1) operator(=) constant(Marshal)operator(.)ident(load)operator(()ident(f)operator(\))
       global_variable($arrayvariable2) operator(=) constant(Marshal)operator(.)ident(load)operator(()ident(f)operator(\))
     reserved(end)
   reserved(rescue)
     ident(puts) string<delimiter(")content(Can not open )inline<delimiter(#{)global_variable($persistent_store)delimiter(})>delimiter(")>
     comment(# Initialisation if this script runs the first time)
     global_variable($stringvariable1) operator(=) string<delimiter(")delimiter(")>
     global_variable($arrayvariable2) operator(=) operator([)operator(])
   reserved(end)
operator(})

reserved(END) operator({)
   constant(File)operator(.)ident(open)operator(()global_variable($persistent_store)operator(,) string<delimiter(")content(w+)delimiter(")>operator(\)) reserved(do) operator(|)ident(f)operator(|)
     constant(Marshal)operator(.)ident(dump)operator(()global_variable($stringvariable1)operator(,) ident(f)operator(\))
     constant(Marshal)operator(.)ident(dump)operator(()global_variable($arrayvariable2)operator(,) ident(f)operator(\))
   reserved(end)
operator(})

comment(# simple test program)
ident(puts) global_variable($stringvariable1)
ident(puts) global_variable($arrayvariable2)
global_variable($stringvariable1) operator(=) string<delimiter(")content(Hello World)delimiter(")>
global_variable($arrayvariable2)operator(.)ident(push)operator(()integer(5)operator(\))
ident(puts) global_variable($stringvariable1)
ident(puts) global_variable($arrayvariable2)


comment(# @@PLEAC@@_14.10)
comment(#!/usr/bin/ruby -w)
comment(# Ruby has a dbi module with an architecture similar)
comment(# to the Perl dbi module: the dbi module provides an unified)
comment(# interface and uses specialized drivers for each dbms vendor)
comment(#)
reserved(begin)
    constant(DBI)operator(.)ident(connect)operator(()string<delimiter(")content(DBI:driver:driverspecific)delimiter(")>operator(,) string<delimiter(")content(username)delimiter(")>operator(,) string<delimiter(")content(auth)delimiter(")>operator(\)) operator({)
        operator(|)ident(dbh)operator(|)

        ident(dbh)operator(.)ident(do)operator(()constant(SQL1)operator(\))

        ident(dbh)operator(.)ident(prepare)operator(()constant(SQL2)operator(\))operator({) operator(|)ident(sth)operator(|)
            ident(sth)operator(.)ident(execute)
            ident(sth)operator(.)ident(fetch) operator({)operator(|)ident(row)operator(|)
                comment(# ...)
            operator(})
        operator(}) comment(# end of block finishes the statement handle)
    operator(}) comment(# end of block closes the database connection)
reserved(rescue) constant(DBI)operator(::)constant(DatabaseError) operator(=)operator(>) ident(e)
    ident(puts) string<delimiter(")content(dbi error occurred)delimiter(")>
    ident(puts) string<delimiter(")content(Error code: )inline<delimiter(#{)ident(e)operator(.)ident(err)delimiter(})>delimiter(")>
    ident(puts) string<delimiter(")content(Error message: )inline<delimiter(#{)ident(e)operator(.)ident(errstr)delimiter(})>delimiter(")>
reserved(end)

comment(#!/usr/bin/ruby -w)
comment(# dbusers - example for mysql which creates a table,)
comment(# fills it with values, retrieves the values back,)
comment(# and finally destroys the table.)

ident(require) string<delimiter(")content(dbi)delimiter(")>

comment(# replacement for the User::pwnt module)
reserved(def) method(getpwent)
    ident(result) operator(=) operator([)operator(])
    constant(File)operator(.)ident(open)operator(()string<delimiter(")content(/etc/passwd)delimiter(")>operator(\)) operator({)operator(|)ident(file)operator(|)
        ident(file)operator(.)ident(each_line) operator({)operator(|)ident(line)operator(|)
            reserved(next) reserved(if) ident(line)operator(.)ident(match)operator(()regexp<delimiter(/)content(^#)delimiter(/)>operator(\))
            ident(cols) operator(=) ident(line)operator(.)ident(split)operator(()string<delimiter(")content(:)delimiter(")>operator(\))
            ident(result)operator(.)ident(push)operator(()operator([)ident(cols)operator([)integer(2)operator(])operator(,) ident(cols)operator([)integer(0)operator(])operator(])operator(\))
        operator(})
    operator(})
    ident(result)
reserved(end)

reserved(begin)
    constant(DBI)operator(.)ident(connect)operator(()string<delimiter(")content(DBI:Mysql:pleacdatabase)delimiter(")>operator(,) string<delimiter(")content(pleac)delimiter(")>operator(,) string<delimiter(")content(pleacpassword)delimiter(")>operator(\)) operator({)
        operator(|)ident(conn)operator(|)

        ident(conn)operator(.)ident(do)operator(()string<delimiter(")content(CREATE TABLE users (uid INT, login CHAR(8\)\))delimiter(")>operator(\))

        ident(users) operator(=) ident(getpwent)

        ident(conn)operator(.)ident(prepare)operator(()string<delimiter(")content(INSERT INTO users VALUES (?,?\))delimiter(")>operator(\)) operator({)operator(|)ident(sth)operator(|)
            ident(users)operator(.)ident(each) operator({)operator(|)ident(entry)operator(|)
                ident(sth)operator(.)ident(execute)operator(()ident(entry)operator([)integer(0)operator(])operator(,) ident(entry)operator([)integer(1)operator(])operator(\))
            operator(})
        operator(})

        ident(conn)operator(.)ident(execute)operator(()string<delimiter(")content(SELECT uid, login FROM users WHERE uid < 50)delimiter(")>operator(\)) operator({)operator(|)ident(sth)operator(|)
            ident(sth)operator(.)ident(fetch) operator({)operator(|)ident(row)operator(|)
                ident(puts) ident(row)operator(.)ident(collect) operator({)operator(|)ident(col)operator(|)
                    reserved(if) ident(col)operator(.)ident(nil?)
                        string<delimiter(")content((null\))delimiter(")>
                    reserved(else)
                        ident(col)
                    reserved(end)
                operator(})operator(.)ident(join)operator(()string<delimiter(")content(, )delimiter(")>operator(\))
            operator(})
        operator(})

        ident(conn)operator(.)ident(do)operator(()string<delimiter(")content(DROP TABLE users)delimiter(")>operator(\))
    operator(})
reserved(rescue) constant(DBI)operator(::)constant(DatabaseError) operator(=)operator(>) ident(e)
    ident(puts) string<delimiter(")content(dbi error occurred)delimiter(")>
    ident(puts) string<delimiter(")content(Error code: )inline<delimiter(#{)ident(e)operator(.)ident(err)delimiter(})>delimiter(")>
    ident(puts) string<delimiter(")content(Error message: )inline<delimiter(#{)ident(e)operator(.)ident(errstr)delimiter(})>delimiter(")>
reserved(end)


comment(# @@PLEAC@@_15.1)
comment(# This test program demonstrates parsing program arguments.)
comment(# It uses the optparse library, which is included with ruby 1.8)
comment(# It handles classic unix style and gnu style options)
ident(require) string<delimiter(')content(optparse)delimiter(')>

instance_variable(@debugmode) operator(=) pre_constant(false)
instance_variable(@verbose) operator(=) pre_constant(false)

pre_constant(ARGV)operator(.)ident(options) reserved(do) operator(|)ident(opts)operator(|)
    ident(opts)operator(.)ident(banner) operator(=) string<delimiter(")content(Usage: ruby )inline<delimiter(#{)global_variable($0)delimiter(})>content( [OPTIONS] INPUTFILES)delimiter(")>

    ident(opts)operator(.)ident(on)operator(()string<delimiter(")content(-h)delimiter(")>operator(,) string<delimiter(")content(--help)delimiter(")>operator(,) string<delimiter(")content(show this message)delimiter(")>operator(\)) operator({)
        ident(puts) ident(opts)
        ident(exit)
    operator(})
    comment(# The OptionParser#on method is called with a specification of short)
    comment(# options, of long options, a data type spezification and user help)
    comment(# messages for this option.)
    comment(# The method analyses the given parameter and decides what it is,)
    comment(# so you can leave out the long option if you don't need it)
    ident(opts)operator(.)ident(on)operator(()string<delimiter(")content(-v)delimiter(")>operator(,) string<delimiter(")content(--[no-]verbose=[FLAG])delimiter(")>operator(,) constant(TrueClass)operator(,) string<delimiter(")content(run verbosly)delimiter(")>operator(\)) operator({)
        operator(|)instance_variable(@verbose)operator(|)   comment(# sets @verbose to true or false)
    operator(})
    ident(opts)operator(.)ident(on)operator(()string<delimiter(")content(-D)delimiter(")>operator(,) string<delimiter(")content(--DEBUG)delimiter(")>operator(,) constant(TrueClass)operator(,) string<delimiter(")content(turns on debug mode)delimiter(")> operator(\))operator({)
        operator(|)instance_variable(@debugmode)operator(|)   comment(# sets @debugmode to true)
    operator(})
    ident(opts)operator(.)ident(on)operator(()string<delimiter(")content(-c)delimiter(")>operator(,) string<delimiter(")content(--count=NUMBER)delimiter(")>operator(,) constant(Integer)operator(,) string<delimiter(")content(how many times we do it)delimiter(")> operator(\))operator({)
        operator(|)instance_variable(@count)operator(|)      comment(# sets @count to given integer)
    operator(})
    ident(opts)operator(.)ident(on)operator(()string<delimiter(")content(-o)delimiter(")>operator(,) string<delimiter(")content(--output=FILE)delimiter(")>operator(,) constant(String)operator(,) string<delimiter(")content(file to write output to)delimiter(")>operator(\))operator({)
        operator(|)instance_variable(@outputfile)operator(|)   comment(# sets @outputfile to given string)
    operator(})
    ident(opts)operator(.)ident(parse!)
reserved(end)

comment(# example to use the options in the main program)
ident(puts) string<delimiter(")content(Verbose is on)delimiter(")> reserved(if) instance_variable(@verbose)
ident(puts) string<delimiter(")content(Debugmode is on)delimiter(")> reserved(if) instance_variable(@debugmode)
ident(puts) string<delimiter(")content(Outfile is )inline<delimiter(#{)instance_variable(@outputfile)delimiter(})>delimiter(")> reserved(if) reserved(defined?) instance_variable(@outputfile)
ident(puts) string<delimiter(")content(Count is )inline<delimiter(#{)instance_variable(@count)delimiter(})>delimiter(")> reserved(if) reserved(defined?) instance_variable(@count)
pre_constant(ARGV)operator(.)ident(each) operator({) operator(|)ident(param)operator(|)
    ident(puts) string<delimiter(")content(Got parameter )inline<delimiter(#{)ident(param)delimiter(})>delimiter(")>
operator(})


comment(# @@PLEAC@@_15.4)
ident(buf) operator(=) string<delimiter(")char(\\0)delimiter(")> operator(*) integer(8)
global_variable($stdout)operator(.)ident(ioctl)operator(()integer(0x5413)operator(,) ident(buf)operator(\))
ident(ws_row)operator(,) ident(ws_col)operator(,) ident(ws_xpixel)operator(,) ident(ws_ypixel) operator(=) ident(buf)operator(.)ident(unpack)operator(()string<delimiter(")content(S4)delimiter(")>operator(\))

ident(raise) string<delimiter(")content(You must have at least 20 characters)delimiter(")> reserved(unless) ident(ws_col) operator(>)operator(=) integer(20)
ident(max) operator(=) integer(0)
ident(values) operator(=) operator(()integer(1)operator(..)integer(5)operator(\))operator(.)ident(collect) operator({) ident(rand)operator(()integer(20)operator(\)) operator(})  comment(# generate an array[5] of rand values)
reserved(for) ident(i) reserved(in) ident(values)
    ident(max) operator(=) ident(i) reserved(if) ident(max) operator(<) ident(i)
reserved(end)
ident(ratio) operator(=) ident(Float)operator(()ident(ws_col)integer(-12)operator(\))operator(/)ident(max)          comment(# chars per unit)
reserved(for) ident(i) reserved(in) ident(values)
    ident(printf) string<delimiter(")content(%8.1f %s)char(\\n)delimiter(")>operator(,) ident(i)operator(,) string<delimiter(")content(*)delimiter(")> operator(*) operator(()ident(ratio)operator(*)ident(i)operator(\))
reserved(end)

comment(# gives, for example:)
comment(#   15.0 *******************************)
comment(#   10.0 *********************)
comment(#    5.0 **********)
comment(#   14.0 *****************************)
comment(#   18.0 **************************************)


comment(# @@PLEAC@@_16.1)
ident(output) operator(=) shell<delimiter(`)content(program args)delimiter(`)>       comment(# collect output into one multiline string)
ident(output) operator(=) shell<delimiter(`)content(program args)delimiter(`)>operator(.)ident(split) comment(# collect output into array, one line per)
ident(element)

ident(readme) operator(=) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(ls)delimiter(")>operator(\))
ident(output) operator(=) string<delimiter(")delimiter(")>
reserved(while) ident(readme)operator(.)ident(gets) reserved(do)
    ident(output) operator(+=) global_variable($_)
reserved(end)
ident(readme)operator(.)ident(close)

shell<delimiter(`)content(fsck -y /dev/rsd1a)delimiter(`)>  comment(# BAD AND SCARY in Perl because it's managed by the shell)
                      comment(# I donna in Ruby ...)

comment(# so the "clean and secure" version)
ident(readme)operator(,) ident(writeme) operator(=) constant(IO)operator(.)ident(pipe)
ident(pid) operator(=) ident(fork) operator({)
    comment(# child)
    global_variable($stdout) operator(=) ident(writeme)
    ident(readme)operator(.)ident(close)
    ident(exec)operator(()string<delimiter(')content(find)delimiter(')>operator(,) string<delimiter(')content(..)delimiter(')>operator(\))
operator(})
comment(# parent)
constant(Process)operator(.)ident(waitpid)operator(()ident(pid)operator(,) integer(0)operator(\))
ident(writeme)operator(.)ident(close)
reserved(while) ident(readme)operator(.)ident(gets) reserved(do)
    comment(# do something with $_)
reserved(end)


comment(# @@PLEAC@@_16.2)
ident(status) operator(=) ident(system)operator(()string<delimiter(")content(xemacs )inline<delimiter(#{)ident(myfile)delimiter(})>delimiter(")>operator(\))

ident(status) operator(=) ident(system)operator(()string<delimiter(")content(xemacs)delimiter(")>operator(,) ident(myfile)operator(\))

ident(system)operator(()string<delimiter(")content(cmd1 args | cmd2 | cmd3 >outfile)delimiter(")>operator(\))
ident(system)operator(()string<delimiter(")content(cmd args <infile >outfile 2>errfile)delimiter(")>operator(\))

comment(# stop if the command fails)
ident(raise) string<delimiter(")content($program exited funny: )inline<delimiter(#{)global_variable($?)delimiter(})>delimiter(")> reserved(unless) ident(system)operator(()string<delimiter(")content(cmd)delimiter(")>operator(,) string<delimiter(")content(args1)delimiter(")>operator(,) string<delimiter(")content(args2)delimiter(")>operator(\))

comment(# get the value of the signal sent to the child)
comment(# even if it is a SIGINT or SIGQUIT)
ident(system)operator(()ident(arglist)operator(\))
ident(raise) string<delimiter(")content(program killed by signal )inline<delimiter(#{)global_variable($?)delimiter(})>delimiter(")> reserved(if) operator(()global_variable($?) operator(&) integer(127)operator(\)) operator(!=) integer(0)

ident(pid) operator(=) ident(fork) operator({)
    ident(trap)operator(()string<delimiter(")content(SIGINT)delimiter(")>operator(,) string<delimiter(")content(IGNORE)delimiter(")>operator(\))
    ident(exec)operator(()string<delimiter(")content(sleep)delimiter(")>operator(,) string<delimiter(")content(10)delimiter(")>operator(\))
operator(})
ident(trap) operator(()string<delimiter(")content(SIGINT)delimiter(")>operator(\)) operator({)
    ident(puts) string<delimiter(")content(Tsk tsk, no process interruptus)delimiter(")>
operator(})
constant(Process)operator(.)ident(waitpid)operator(()ident(pid)operator(,) integer(0)operator(\))

comment(# Ruby doesn't permit to lie to the program called by a 'system'.)
comment(# (ie specify what return argv[0] in C, $0 in Perl/Ruby ...\))
comment(# A (dirty\) way is to create a link (under Unix\), run this link and)
comment(# erase it. Somebody has a best idea ?)


comment(# @@PLEAC@@_16.3)
ident(exec)operator(()string<delimiter(")content(archive *.data)delimiter(")>operator(\))

ident(exec)operator(()string<delimiter(")content(archive)delimiter(")>operator(,) string<delimiter(")content(accounting.data)delimiter(")>operator(\))

ident(exec)operator(()string<delimiter(")content(archive accounting.data)delimiter(")>operator(\))


comment(# @@PLEAC@@_16.4)
comment(# read the output of a program)
constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(ls)delimiter(")>operator(\)) operator({)operator(|)ident(readme)operator(|)
    reserved(while) ident(readme)operator(.)ident(gets) reserved(do)
        comment(# ...)
    reserved(end)
operator(})
comment(# or)
ident(readme) operator(=) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(ls)delimiter(")>operator(\))
reserved(while) ident(readme)operator(.)ident(gets) reserved(do)
    comment(# ...)
reserved(end)
ident(readme)operator(.)ident(close)

comment(# "write" in a program)
constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(cmd args)delimiter(")>operator(,)string<delimiter(")content(w)delimiter(")>operator(\)) operator({)operator(|)ident(pipe)operator(|)
    ident(pipe)operator(.)ident(puts)operator(()string<delimiter(")content(data)delimiter(")>operator(\))
    ident(pipe)operator(.)ident(puts)operator(()string<delimiter(")content(foo)delimiter(")>operator(\))
operator(})

comment(# close wait for the end of the process)
ident(read) operator(=) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(sleep 10000)delimiter(")>operator(\)) comment(# child goes to sleep)
ident(read)operator(.)ident(close)                     comment(# and the parent goes to lala land)

ident(writeme) operator(=) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(cmd args)delimiter(")>operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
ident(writeme)operator(.)ident(puts) string<delimiter(")content(hello)delimiter(")> comment(# program will get hello\\n on STDIN)
ident(writeme)operator(.)ident(close)        comment(# program will get EOF on STDIN)

comment(# send in a pager (eg less\) all output)
global_variable($stdout) operator(=) constant(IO)operator(.)ident(popen)operator(()string<delimiter(")content(/usr/bin/less)delimiter(")>operator(,)string<delimiter(")content(w)delimiter(")>operator(\))
ident(print) string<delimiter(")content(huge string)char(\\n)delimiter(")> operator(*) integer(10000)


comment(# @@PLEAC@@_16.5)
comment(#-----------------------------)
reserved(def) method(head)operator(()ident(lines) operator(=) integer(20)operator(\))
    ident(pid) operator(=) ident(open)operator(()string<delimiter(")content(|-)delimiter(")>operator(,)string<delimiter(")content(w)delimiter(")>operator(\))
    reserved(if) ident(pid) operator(==) pre_constant(nil)
        reserved(return)
    reserved(else)
        reserved(while) ident(gets)operator(()operator(\)) reserved(do)
            ident(pid)operator(.)ident(print)
            ident(lines) operator(-=) integer(1)
            reserved(break) reserved(if) ident(lines) operator(==) integer(0)
        reserved(end)
    reserved(end)
    ident(exit)
reserved(end)

ident(head)operator(()integer(100)operator(\))
reserved(while) ident(gets)operator(()operator(\)) reserved(do)
    ident(print)
reserved(end)
comment(#-----------------------------)
integer(1)operator(:) operator(>) constant(Welcome) ident(to) constant(Linux)operator(,) ident(version) float(2.0)operator(.)integer(33) ident(on) ident(a) ident(i686)

integer(2)operator(:) operator(>) 

integer(3)operator(:) operator(>)     string<delimiter(")content(The software required `Windows 95 or better', 

4: >      so I installed Linux.)delimiter(")>  
comment(#-----------------------------)
operator(>) integer(1)operator(:) constant(Welcome) ident(to) constant(Linux)operator(,) constant(Kernel) ident(version) float(2.0)operator(.)integer(33) ident(on) ident(a) ident(i686)

operator(>) integer(2)operator(:) 

operator(>) integer(3)operator(:)     string<delimiter(")content(The software required `Windows 95 or better', 

> 4:      so I installed Linux.)delimiter(")>  
comment(#-----------------------------)
comment(#!/usr/bin/ruby)
comment(# qnumcat - demo additive output filters)

reserved(def) method(number)operator(()operator(\))
    ident(pid) operator(=) ident(open)operator(()string<delimiter(")content(|-)delimiter(")>operator(,)string<delimiter(")content(w)delimiter(")>operator(\))
    reserved(if) ident(pid) operator(==) pre_constant(nil)
        reserved(return)
    reserved(else)
        reserved(while) ident(gets)operator(()operator(\)) reserved(do) ident(pid)operator(.)ident(printf)operator(()string<delimiter(")content(%d: %s)delimiter(")>operator(,) global_variable($.)operator(,) global_variable($_)operator(\))operator(;) reserved(end)
    reserved(end)
    ident(exit)
reserved(end)

reserved(def) method(quote)operator(()operator(\))
    ident(pid) operator(=) ident(open)operator(()string<delimiter(")content(|-)delimiter(")>operator(,)string<delimiter(")content(w)delimiter(")>operator(\))
    reserved(if) ident(pid) operator(==) pre_constant(nil)
        reserved(return)
    reserved(else)
        reserved(while) ident(gets)operator(()operator(\)) reserved(do) ident(pid)operator(.)ident(print) string<delimiter(")content(> )inline<delimiter(#{)global_variable($_)delimiter(})>delimiter(")> reserved(end)
    reserved(end)
    ident(exit)
reserved(end)

ident(number)operator(()operator(\))
ident(quote)operator(()operator(\))

reserved(while) ident(gets)operator(()operator(\)) reserved(do)
    ident(print)
reserved(end)
global_variable($stdout)operator(.)ident(close)
ident(exit)


comment(# @@PLEAC@@_16.6)
pre_constant(ARGV)operator(.)ident(map!) operator({) operator(|)ident(arg)operator(|)
    ident(arg) operator(=)operator(~) regexp<delimiter(/)char(\\.)content((gz|Z\)$)delimiter(/)> operator(?) string<delimiter(")content(|gzip -dc )inline<delimiter(#{)ident(arg)delimiter(})>delimiter(")> operator(:) ident(arg)
operator(})
reserved(for) ident(file) reserved(in) pre_constant(ARGV)
    ident(fh) operator(=) ident(open)operator(()ident(file)operator(\))
    reserved(while) ident(fh)operator(.)ident(gets)operator(()operator(\)) reserved(do)
        comment(# .......)
    reserved(end)
reserved(end)
comment(#-----------------------------)
pre_constant(ARGV)operator(.)ident(map!) operator({) operator(|)ident(arg)operator(|)
    ident(arg) operator(=)operator(~) regexp<delimiter(%r#)content(^)char(\\w)content(+://)delimiter(#)> operator(?) string<delimiter(")content(|GET )inline<delimiter(#{)ident(arg)delimiter(})>delimiter(")> operator(:) ident(arg)   comment(#)
operator(})
reserved(for) ident(file) reserved(in) pre_constant(ARGV)
    ident(fh) operator(=) ident(open)operator(()ident(file)operator(\))
    reserved(while) ident(fh)operator(.)ident(gets)operator(()operator(\)) reserved(do)
        comment(# .......)
    reserved(end)
reserved(end)
comment(#-----------------------------)
ident(pwdinfo) operator(=) operator(()shell<delimiter(`)content(domainname)delimiter(`)> operator(=)operator(~) regexp<delimiter(/)content(^()char(\\()content(none)char(\\\))content(\)?$)delimiter(/)>operator(\)) operator(?) string<delimiter(')content(/etc/passwd)delimiter(')> operator(:) string<delimiter(')content(|ypcat  passwd)delimiter(')>operator(;)
ident(pwd) operator(=) ident(open)operator(()ident(pwdinfo)operator(\))operator(;)
comment(#-----------------------------)
ident(puts) string<delimiter(")content(File, please? )delimiter(")>operator(;)
ident(file) operator(=) ident(gets)operator(()operator(\))operator(.)ident(chomp)operator(()operator(\))operator(;)
ident(fh) operator(=) ident(open)operator(()ident(file)operator(\))operator(;)


comment(# @@PLEAC@@_16.7)
ident(output) operator(=) shell<delimiter(`)content(cmd 2>&1)delimiter(`)>                            comment(# with backticks)
comment(# or)
ident(ph) operator(=) ident(open)operator(()string<delimiter(")content(|cmd 2>&1)delimiter(")>operator(\))                         comment(# with an open pipe)
reserved(while) ident(ph)operator(.)ident(gets)operator(()operator(\)) operator({) operator(})                            comment(# plus a read)
comment(#-----------------------------)
ident(output) operator(=) shell<delimiter(`)content(cmd 2>/dev/null)delimiter(`)>                     comment(# with backticks)
comment(# or)
ident(ph) operator(=) ident(open)operator(()string<delimiter(")content(|cmd 2>/dev/null)delimiter(")>operator(\))                  comment(# with an open pipe)
reserved(while) ident(ph)operator(.)ident(gets)operator(()operator(\)) operator({) operator(})                            comment(# plus a read)
comment(#-----------------------------)
ident(output) operator(=) shell<delimiter(`)content(cmd 2>&1 1>/dev/null)delimiter(`)>                comment(# with backticks)
comment(# or)
ident(ph) operator(=) ident(open)operator(()string<delimiter(")content(|cmd 2>&1 1>/dev/null)delimiter(")>operator(\))             comment(# with an open pipe)
reserved(while) ident(ph)operator(.)ident(gets)operator(()operator(\)) operator({) operator(})                            comment(# plus a read)
comment(#-----------------------------)
ident(output) operator(=) shell<delimiter(`)content(cmd 3>&1 1>&2 2>&3 3>&-)delimiter(`)>             comment(# with backticks)
comment(# or)
ident(ph) operator(=) ident(open)operator(()string<delimiter(")content(|cmd 3>&1 1>&2 2>&3 3>&-)delimiter(")>operator(\))          comment(# with an open pipe)
reserved(while) ident(ph)operator(.)ident(gets)operator(()operator(\)) operator({) operator(})                            comment(# plus a read)
comment(#-----------------------------)
ident(system)operator(()string<delimiter(")content(program args 1>/tmp/program.stdout 2>/tmp/program.stderr)delimiter(")>operator(\)) 
comment(#-----------------------------)
ident(output) operator(=) shell<delimiter(`)content(cmd 3>&1 1>&2 2>&3 3>&-)delimiter(`)>  
comment(#-----------------------------)
ident(fd3) operator(=) ident(fd1) 
ident(fd1) operator(=) ident(fd2) 
ident(fd2) operator(=) ident(fd3) 
ident(fd3) operator(=) pre_constant(nil) 
comment(#-----------------------------)
ident(system)operator(()string<delimiter(")content(prog args 1>tmpfile 2>&1)delimiter(")>operator(\)) 
ident(system)operator(()string<delimiter(")content(prog args 2>&1 1>tmpfile)delimiter(")>operator(\)) 
comment(#-----------------------------)
comment(# system ("prog args 1>tmpfile 2>&1"\) )
ident(fd1) operator(=) string<delimiter(")content(tmpfile)delimiter(")>          comment(# change stdout destination first)
ident(fd2) operator(=) ident(fd1)                comment(# now point stderr there, too)
comment(#-----------------------------)
comment(# system("prog args 2>&1 1>tmpfile"\) )
ident(fd2) operator(=) ident(fd1)                comment(# stderr same destination as stdout)
ident(fd1) operator(=) string<delimiter(")content(tmpfile)delimiter(")>          comment(# but change stdout destination )
comment(#-----------------------------)
comment(# It is often better not to rely on the shell, )
comment(# because of portability, possible security problems )
comment(# and bigger resource usage. So, it is often better to use the open3 library. )
comment(# See below for an example.)
comment(# opening stdin, stdout, stderr)
ident(require) string<delimiter(")content(open3)delimiter(")>
ident(stdin)operator(,) ident(stdout)operator(,) ident(stderr) operator(=) constant(Open3)operator(.)ident(popen)operator(()string<delimiter(')content(cmd)delimiter(')>operator(\))


comment(# @@PLEAC@@_16.8)
comment(#-----------------------------)
comment(# Contrary to perl, we don't need to use a module in Ruby)
ident(fh) operator(=) constant(Kernel)operator(.)ident(open)operator(()string<delimiter(")content(|)delimiter(")> operator(+) ident(program)operator(,) string<delimiter(")content(w+)delimiter(")>operator(\))
ident(fh)operator(.)ident(puts) string<delimiter(")content(here's your input)char(\\n)delimiter(")>
ident(output) operator(=) ident(fh)operator(.)ident(gets)operator(()operator(\))
ident(fh)operator(.)ident(close)operator(()operator(\))
comment(#-----------------------------)
constant(Kernel)operator(.)ident(open)operator(()string<delimiter(")content(|program)delimiter(")>operator(\))operator(,)string<delimiter(")content(w+)delimiter(")>operator(\))    comment(# RIGHT !)
comment(#-----------------------------)
comment(# Ruby has already object methods for I/O handles)
comment(#-----------------------------)
reserved(begin)
    ident(fh) operator(=) constant(Kernel)operator(.)ident(open)operator(()string<delimiter(")content(|)delimiter(")> operator(+) ident(program_and_options)operator(,) string<delimiter(")content(w+)delimiter(")>operator(\))
reserved(rescue)
    reserved(if) operator(()global_variable($@) operator(~=) regexp<delimiter(/)content(^open)delimiter(/)>operator(\))
        global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(open failed : )inline<delimiter(#{)global_variable($!)delimiter(})>content( )char(\\n)content( )inline<delimiter(#{)global_variable($@)delimiter(})>content( )char(\\n)delimiter(")>
        reserved(break)
    reserved(end)
    ident(raise)      comment(# reraise unforseen exception)
reserved(end)


comment(# @@PLEAC@@_16.13)
comment(#% kill -l)
comment(#HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE)
comment(#ALRM TERM CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM)
comment(#PROF WINCH POLL PWR)
comment(#-----------------------------)
comment(#% ruby -e 'puts Signal.list.keys.join(" "\)')
comment(#PWR USR1 BUS USR2 TERM SEGV KILL POLL STOP SYS TRAP IOT HUP INT                                                                          #)
comment(#WINCH XCPU TTIN CLD TSTP FPE IO TTOU PROF CHLD CONT PIPE ABRT)
comment(#VTALRM QUIT ILL XFSZ URG ALRM)
comment(#-----------------------------)
comment(# After that, the perl script create an hash equivalent to Signal.list, )
comment(# and an array. The array can be obtained by :)
ident(signame) operator(=) operator([)operator(])
constant(Signal)operator(.)ident(list)operator(.)ident(each) operator({) operator(|)ident(name)operator(,) ident(i)operator(|) ident(signame)operator([)ident(i)operator(]) operator(=) ident(name) operator(})


comment(# @@PLEAC@@_16.14)
constant(Process)operator(.)ident(kill)operator(()integer(9)operator(,) ident(pid)operator(\))                    comment(# send $pid a signal 9)
constant(Process)operator(.)ident(kill)operator(()integer(-1)operator(,) constant(Process)operator(.)ident(getpgrp)operator(()operator(\))operator(\))     comment(# send whole job a signal 1)
constant(Process)operator(.)ident(kill)operator(()string<delimiter(")content(USR1)delimiter(")>operator(,) global_variable($$)operator(\))                comment(# send myself a SIGUSR1)
constant(Process)operator(.)ident(kill)operator(()string<delimiter(")content(HUP)delimiter(")>operator(,) ident(pid1)operator(,) ident(pid2)operator(,) ident(pid3)operator(\))   comment(# send a SIGHUP to processes in @pids)
comment(#-----------------------------)
reserved(begin)
    constant(Process)operator(.)ident(kill)operator(()integer(0)operator(,) ident(minion)operator(\))
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(minion)delimiter(})>content( is alive!)delimiter(")>
reserved(rescue) constant(Errno)operator(::)constant(EPERM)                     comment(# changed uid)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(minion)delimiter(})>content( has escaped my control!)delimiter(")>operator(;)
reserved(rescue) constant(Errno)operator(::)constant(ESRCH)
    ident(puts) string<delimiter(")inline<delimiter(#{)ident(minion)delimiter(})>content( is deceased.)delimiter(")>operator(;)      comment(# or zombied)
reserved(rescue)
    ident(puts) string<delimiter(")content(Odd; I couldn't check the status of )inline<delimiter(#{)ident(minion)delimiter(})>content( : )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(end)


comment(# @@PLEAC@@_16.15)
constant(Kernel)operator(.)ident(trap)operator(()string<delimiter(")content(QUIT)delimiter(")>operator(,) ident(got_sig_quit)operator(\))       comment(# got_sig_quit = Proc.new { puts "Quit\\n" })
ident(trap)operator(()string<delimiter(")content(PIPE)delimiter(")>operator(,) string<delimiter(")content(got_sig_quit)delimiter(")>operator(\))            comment(# def got_sig_pipe ...)
ident(trap)operator(()string<delimiter(")content(INT)delimiter(")>operator(\)) operator({) ident(ouch)operator(+)operator(+) operator(})                  comment(# increment ouch for every SIGINT)
comment(#-----------------------------)
ident(trap)operator(()string<delimiter(")content(INT)delimiter(")>operator(,) string<delimiter(")content(IGNORE)delimiter(")>operator(\))                   comment(# ignore the signal INT)
comment(#-----------------------------)
ident(trap)operator(()string<delimiter(")content(STOP)delimiter(")>operator(,) string<delimiter(")content(DEFAULT)delimiter(")>operator(\))                 comment(# restore default STOP signal handling)


comment(# @@PLEAC@@_16.16)
comment(# the signal handler)
reserved(def) method(ding)
    ident(trap)operator(()string<delimiter(")content(INT)delimiter(")>operator(,) string<delimiter(")content(ding)delimiter(")>operator(\))
    ident(puts) string<delimiter(")char(\\a)content(Enter your name!)delimiter(")>
reserved(end)

comment(# prompt for name, overriding SIGINT)
reserved(def) method(get_name)
    ident(save) operator(=) ident(trap)operator(()string<delimiter(")content(INT)delimiter(")>operator(,) string<delimiter(")content(ding)delimiter(")>operator(\))

    ident(puts) string<delimiter(")content(Kindly Stranger, please enter your name: )delimiter(")>
    ident(name) operator(=) ident(gets)operator(()operator(\))operator(.)ident(chomp)operator(()operator(\))
    ident(trap)operator(()string<delimiter(")content(INT)delimiter(")>operator(,) ident(save)operator(\))
    ident(name)
reserved(end)


comment(# @@PLEAC@@_16.21)
comment(# implemented thanks to http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/1760)
ident(require) string<delimiter(')content(timeout)delimiter(')>

comment(# we'll do something vastly more useful than cookbook to demonstrate timeouts)
reserved(begin)
    ident(timeout)operator(()integer(5)operator(\)) operator({)
        ident(waitsec) operator(=) ident(rand)operator(()integer(10)operator(\))
        ident(puts) string<delimiter(")content(Let's see if a sleep of )inline<delimiter(#{)ident(waitsec)delimiter(})>content( seconds is longer than 5 seconds...)delimiter(")>
        ident(system)operator(()string<delimiter(")content(sleep )inline<delimiter(#{)ident(waitsec)delimiter(})>delimiter(")>operator(\))
    operator(})
    ident(puts) string<delimiter(")content(Timeout didn't occur)delimiter(")>
reserved(rescue) constant(Timeout)operator(::)constant(Error)    
    ident(puts) string<delimiter(")content(Timed out!)delimiter(")>
reserved(end)


comment(# @@PLEAC@@_17.1)
comment(# A basic TCP client connection)
ident(require) string<delimiter(')content(socket)delimiter(')>
reserved(begin)
    ident(t) operator(=) constant(TCPSocket)operator(.)ident(new)operator(()string<delimiter(')content(www.ruby-lang.org)delimiter(')>operator(,) string<delimiter(')content(www)delimiter(')>operator(\))
reserved(rescue)
    ident(puts) string<delimiter(")content(error: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(else)
    comment(# ... do something with the socket)
    ident(t)operator(.)ident(print) string<delimiter(")content(GET / HTTP/1.0)char(\\n)char(\\n)delimiter(")>
    ident(answer) operator(=) ident(t)operator(.)ident(gets)operator(()pre_constant(nil)operator(\))
    comment(# and terminate the connection when we're done)
    ident(t)operator(.)ident(close)
reserved(end)

comment(# Using the evil low level socket API)
ident(require) string<delimiter(')content(socket)delimiter(')>
comment(# create a socket)
ident(s) operator(=) constant(Socket)operator(.)ident(new)operator(()constant(Socket)operator(::)constant(AF_INET)operator(,) constant(Socket)operator(::)constant(SOCK_STREAM)operator(,) integer(0)operator(\))
comment(# build the address of the remote machine)
ident(sockaddr_server) operator(=) operator([)constant(Socket)operator(::)constant(AF_INET)operator(,) integer(80)operator(,)
    constant(Socket)operator(.)ident(gethostbyname)operator(()string<delimiter(')content(www.ruby-lang.org)delimiter(')>operator(\))operator([)integer(3)operator(])operator(,)
    integer(0)operator(,) integer(0)operator(])operator(.)ident(pack)operator(()string<delimiter(")content(snA4NN)delimiter(")>operator(\))
comment(# connect)
reserved(begin)
    ident(s)operator(.)ident(connect)operator(()ident(sockaddr_server)operator(\))
reserved(rescue)
    ident(puts) string<delimiter(")content(error: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(else)
    comment(# ... do something with the socket)
    ident(s)operator(.)ident(print) string<delimiter(")content(GET / HTTP/1.0)char(\\n)char(\\n)delimiter(")>
    comment(# and terminate the connection when we're done)
    ident(s)operator(.)ident(close)
reserved(end)

comment(# TCP connection with management of error (DNS\))
ident(require) string<delimiter(')content(socket)delimiter(')>
reserved(begin)
    ident(client) operator(=) constant(TCPSocket)operator(.)ident(new)operator(()string<delimiter(')content(does not exists)delimiter(')>operator(,) string<delimiter(')content(www)delimiter(')>operator(\))
reserved(rescue)
    ident(puts) string<delimiter(")content(error: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(end)

comment(# TCP connection with a time out)
ident(require) string<delimiter(')content(socket)delimiter(')>
ident(require) string<delimiter(')content(timeout)delimiter(')>
reserved(begin)
    ident(timeout)operator(()integer(1)operator(\)) reserved(do) comment(#the server has one second to answer)
        ident(client) operator(=) constant(TCPSocket)operator(.)ident(new)operator(()string<delimiter(')content(www.host.com)delimiter(')>operator(,) string<delimiter(')content(www)delimiter(')>operator(\))
    reserved(end)
reserved(rescue)
    ident(puts) string<delimiter(")content(error: )inline<delimiter(#{)global_variable($!)delimiter(})>delimiter(")>
reserved(end)


comment(# @@PLEAC@@_17.12)
ident(require) string<delimiter(')content(socket)delimiter(')>

reserved(class) class(Preforker) 
    ident(attr_reader) operator(()symbol(:child_count)operator(\))
    
    reserved(def) method(initialize)operator(()ident(prefork)operator(,) ident(max_clients_per_child)operator(,) ident(port)operator(,) ident(client_handler)operator(\))
        instance_variable(@prefork) operator(=) ident(prefork)
        instance_variable(@max_clients_per_child) operator(=) ident(max_clients_per_child)
        instance_variable(@port) operator(=) ident(port)
        instance_variable(@child_count) operator(=) integer(0)
        
        instance_variable(@reaper) operator(=) ident(proc) operator({)
            ident(trap)operator(()string<delimiter(')content(CHLD)delimiter(')>operator(,) instance_variable(@reaper)operator(\))
            ident(pid) operator(=) constant(Process)operator(.)ident(wait)
            instance_variable(@child_count) operator(-=) integer(1)
        operator(})
        
        instance_variable(@huntsman) operator(=) ident(proc) operator({)
            ident(trap)operator(()string<delimiter(')content(CHLD)delimiter(')>operator(,) string<delimiter(')content(IGNORE)delimiter(')>operator(\))
            ident(trap)operator(()string<delimiter(')content(INT)delimiter(')>operator(,) string<delimiter(')content(IGNORE)delimiter(')>operator(\))
            constant(Process)operator(.)ident(kill)operator(()string<delimiter(')content(INT)delimiter(')>operator(,) integer(0)operator(\))
            ident(exit)
        operator(})
        
        instance_variable(@client_handler)operator(=)ident(client_handler)
    reserved(end)
    
    reserved(def) method(child_handler)
        ident(trap)operator(()string<delimiter(')content(INT)delimiter(')>operator(,) string<delimiter(')content(EXIT)delimiter(')>operator(\))
        instance_variable(@client_handler)operator(.)ident(setUp)
        comment(# wish: sigprocmask UNblock SIGINT)
        instance_variable(@max_clients_per_child)operator(.)ident(times) operator({)
            ident(client) operator(=) instance_variable(@server)operator(.)ident(accept) reserved(or) reserved(break)
            instance_variable(@client_handler)operator(.)ident(handle_request)operator(()ident(client)operator(\))
            ident(client)operator(.)ident(close)
        operator(})
        instance_variable(@client_handler)operator(.)ident(tearDown)
    reserved(end)
    
    reserved(def) method(make_new_child)
        comment(# wish: sigprocmask block SIGINT)
        instance_variable(@child_count) operator(+=) integer(1)
        ident(pid) operator(=) ident(fork) reserved(do)
            ident(child_handler)
        reserved(end)
        comment(# wish: sigprocmask UNblock SIGINT)
    reserved(end)
    
    reserved(def) method(run)
        instance_variable(@server) operator(=) constant(TCPserver)operator(.)ident(open)operator(()instance_variable(@port)operator(\))
        ident(trap)operator(()string<delimiter(')content(CHLD)delimiter(')>operator(,) instance_variable(@reaper)operator(\))
        ident(trap)operator(()string<delimiter(')content(INT)delimiter(')>operator(,) instance_variable(@huntsman)operator(\))
        ident(loop) operator({)
            operator(()instance_variable(@prefork) operator(-) instance_variable(@child_count)operator(\))operator(.)ident(times) operator({) operator(|)ident(i)operator(|)
                ident(make_new_child)
            operator(})
            ident(sleep) operator(.)integer(1)
        operator(})
    reserved(end)
reserved(end)

comment(#-----------------------------)
comment(#!/usr/bin/ruby)

ident(require) string<delimiter(')content(Preforker)delimiter(')>

reserved(class) class(ClientHandler)
    reserved(def) method(setUp)
    reserved(end)
    
    reserved(def) method(tearDown)
    reserved(end)
    
    reserved(def) method(handle_request)operator(()ident(client)operator(\))
        comment(# do stuff)
    reserved(end)
reserved(end)

ident(server) operator(=) constant(Preforker)operator(.)ident(new)operator(()integer(1)operator(,) integer(100)operator(,) integer(3102)operator(,) constant(ClientHandler)operator(.)ident(new)operator(\))
ident(server)operator(.)ident(run)


comment(# @@PLEAC@@_18.2)
ident(require) string<delimiter(')content(net/ftp)delimiter(')>

reserved(begin)
    ident(ftp) operator(=) constant(Net)operator(::)constant(FTP)operator(::)ident(new)operator(()string<delimiter(")content(ftp.host.com)delimiter(")>operator(\))
    ident(ftp)operator(.)ident(login)operator(()ident(username)operator(,)ident(password)operator(\))
    ident(ftp)operator(.)ident(chdir)operator(()ident(directory)operator(\))
    ident(ftp)operator(.)ident(get)operator(()ident(filename)operator(\))
    ident(ftp)operator(.)ident(put)operator(()ident(filename)operator(\))
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(print) string<delimiter(")content(FTP failed: )delimiter(")> operator(+) global_variable($!)
reserved(ensure)
    ident(ftp)operator(.)ident(close)operator(()operator(\)) reserved(if) ident(ftp)
reserved(end)

comment(# A better solution for a local use could be :)
constant(Net)operator(::)constant(FTP)operator(::)ident(new)operator(()string<delimiter(")content(ftp.host.com)delimiter(")>operator(\)) reserved(do) operator(|)ident(ftp)operator(|)
    ident(ftp)operator(.)ident(login)operator(()ident(username)operator(,)ident(password)operator(\))
    ident(ftp)operator(.)ident(chdir)operator(()ident(directory)operator(\))
    ident(ftp)operator(.)ident(get)operator(()ident(filename)operator(\))
    ident(ftp)operator(.)ident(put)operator(()ident(filename)operator(\))
reserved(end)

comment(# If you have only one file to get, there is a simple solution :)
ident(require) string<delimiter(')content(open-uri)delimiter(')>
ident(open)operator(()string<delimiter(")content(ftp://www.ruby-lang.org/path/filename)delimiter(")>operator(\)) reserved(do) operator(|)ident(fh)operator(|)
    comment(# read from filehandle fh)
reserved(end) 
comment(#--------------------------------------------)
comment(# to wait a defined time for the connection, )
comment(# use the timeout module)
ident(require) string<delimiter(')content(timeout)delimiter(')>
reserved(begin) 
    ident(timeout)operator(()integer(30)operator(\))operator({)
        ident(ftp) operator(=) constant(Net)operator(::)constant(FTP)operator(::)ident(new)operator(()string<delimiter(")content(ftp.host.com)delimiter(")>operator(\))
        ident(ftp)operator(.)ident(debug_mode) operator(=) pre_constant(true)
    operator(})
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(Couldn't connect.)delimiter(")>
reserved(rescue) constant(Timeout)operator(::)constant(Error)
    global_variable($stderr)operator(.)ident(puts) string<delimiter(")content(Timeout while connecting to server.)delimiter(")>
reserved(end)

reserved(begin)
    ident(ftp)operator(.)ident(login)operator(()operator(\))
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(print) string<delimiter(")content(Couldn't authentificate.)char(\\n)delimiter(")>
reserved(end)

reserved(begin)
    ident(ftp)operator(.)ident(login)operator(()ident(username)operator(\))
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(print) string<delimiter(")content(Still couldn't authenticate.)char(\\n)delimiter(")>
reserved(end)

reserved(begin)
    ident(ftp)operator(.)ident(login)operator(()ident(username)operator(,) ident(password)operator(\))
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(print) string<delimiter(")content(Couldn't authenticate, even with explicit
    username and password.)char(\\n)delimiter(")>
reserved(end)

reserved(begin)
    ident(ftp)operator(.)ident(login)operator(()ident(username)operator(,) ident(password)operator(,) ident(account)operator(\))
reserved(rescue) constant(Net)operator(::)constant(FTPError)
    global_variable($stderr)operator(.)ident(print) string<delimiter(")content(No dice. It hates me.)char(\\n)delimiter(")>
reserved(end)
comment(#-----------------------------)
ident(ftp)operator(.)ident(put)operator(()ident(localfile)operator(,) ident(remotefile)operator(\))
comment(#-----------------------------)
comment(# Sending data from STDIN is not directly supported )
comment(# by the ftp library module. A possible way to do it is to use the )
comment(# storlines method directly to send raw commands to the ftp server.)
comment(#-----------------------------)
ident(ftp)operator(.)ident(get)operator(()ident(remotefile)operator(,) ident(localfile)operator(\))
comment(#-----------------------------)
ident(ftp)operator(.)ident(get)operator(()ident(remotefile)operator(\)) operator({) operator(|)ident(data)operator(|) ident(puts) ident(data) operator(})
comment(#-----------------------------)
ident(ftp)operator(.)ident(chdir)operator(()string<delimiter(")content(/pub/ruby)delimiter(")>operator(\)) 
ident(print) string<delimiter(")content(I'm in the directory )delimiter(")>operator(,) ident(ftp)operator(.)ident(pwd)operator(()operator(\))operator(,) string<delimiter(")char(\\n)delimiter(")>
comment(#-----------------------------)
ident(ftp)operator(.)ident(mkdir)operator(()string<delimiter(")content(/pub/ruby/new_dir)delimiter(")>operator(\))
comment(#-----------------------------)
ident(lines) operator(=) ident(ftp)operator(.)ident(ls)operator(()string<delimiter(")content(/pub/ruby/)delimiter(")>operator(\))
comment(# => ["drwxr-xr-x 2 matz users 4096 July 17 1998 1.0", ... ])

ident(latest) operator(=) ident(ftp)operator(.)ident(dir)operator(()string<delimiter(")content(/pub/ruby/*.tgz)delimiter(")>operator(\))operator(.)ident(sort)operator(.)ident(last)

ident(ftp)operator(.)ident(nlst)operator(()string<delimiter(")content(/pub/ruby)delimiter(")>operator(\))
comment(# => ["/pub/ruby/1.0", ... ])
comment(#-----------------------------)
ident(ftp)operator(.)ident(quit)operator(()operator(\))


comment(# @@PLEAC@@_18.6)
ident(require) string<delimiter(')content(net/telnet)delimiter(')>
ident(t) operator(=) constant(Net)operator(::)constant(Telnet)operator(::)ident(new)operator(() string<delimiter(")content(Timeout)delimiter(")> operator(=)operator(>) integer(10)operator(,)
                      string<delimiter(")content(Prompt)delimiter(")>  operator(=)operator(>) regexp<delimiter(/)content(%)delimiter(/)>operator(,)
                      string<delimiter(")content(Host)delimiter(")>    operator(=)operator(>) ident(host) operator(\))
ident(t)operator(.)ident(login)operator(()ident(username)operator(,) ident(password)operator(\))
ident(files) operator(=) ident(t)operator(.)ident(cmd)operator(()string<delimiter(")content(ls)delimiter(")>operator(\))
ident(t)operator(.)ident(print)operator(()string<delimiter(")content(top)delimiter(")>operator(\))
ident(process_string) operator(=) ident(t)operator(.)ident(waitfor)operator(()regexp<delimiter(/)char(\\d)content(+ processes)delimiter(/)>operator(\))
ident(t)operator(.)ident(close)
comment(#-----------------------------)
regexp<delimiter(/)content([$%#>] )char(\\z)delimiter(/)modifier(n)>
comment(#-----------------------------)
comment(# In case of an error, the telnet module throws an exception.)
comment(# For control of the behavior in case of an error,)
comment(# you just need to catch the exceptions and do your custom)
comment(# error handling.)
comment(#-----------------------------)
reserved(begin)
    ident(telnet)operator(.)ident(login)operator(()ident(username)operator(,) ident(password)operator(\))
reserved(rescue) constant(TimeoutError)
    ident(fail) string<delimiter(")content(Login failed !)char(\\n)delimiter(")>
reserved(end)
comment(#-----------------------------)
ident(telnet)operator(.)ident(waitfor)operator(()string<delimiter(')content(/--more--/)delimiter(')>operator(\))
comment(#-----------------------------)
ident(telnet)operator(.)ident(waitfor)operator(()constant(String) operator(=)operator(>) string<delimiter(')content(greasy smoke)delimiter(')>operator(,) constant(Timeout) operator(=)operator(>) integer(30)operator(\))


comment(# @@PLEAC@@_18.7)
ident(require) string<delimiter(')content(ping)delimiter(')>

ident(puts) string<delimiter(")inline<delimiter(#{)ident(host)delimiter(})>content( is alive.)char(\\n)delimiter(")> reserved(if) constant(Ping)operator(.)ident(pingecho)operator(()ident(host)operator(\))operator(;)
comment(#-----------------------------)
comment(# the ping module only use TCP ping, not ICMP even if we are root)
reserved(if) constant(Ping)operator(.)ident(pingecho)operator(()string<delimiter(")content(kingkong.com)delimiter(")>operator(\))
    ident(puts) string<delimiter(")content(The giant ape lives!)char(\\n)delimiter(")>operator(;)
reserved(else)
    ident(puts) string<delimiter(")content(All hail mighty Gamera, friend of children!)char(\\n)delimiter(")>operator(;)
reserved(end)


comment(# @@PLEAC@@_19.0)
comment(#-----------------------------)
comment(# http://www.perl.com/CPAN/)
comment(# http://www.perl.com:8001/bad/mojo.html)
comment(# ftp://gatekeeper.dec.com/pub/misc/netlib.tar.Z)
comment(# ftp://anonymous@myplace:gatekeeper.dec.com/pub/misc/netlib.tar.Z)
comment(# file:///etc/motd)
comment(#-----------------------------)
comment(# http://mox.perl.com/cgi-bin/program?name=Johann&born=1685)
comment(#-----------------------------)
comment(# http://mox.perl.com/cgi-bin/program)
comment(#-----------------------------)


comment(# @@PLEAC@@_19.1)
comment(#!/usr/local/bin/ruby -w)
comment(# hiweb - load CGI class to decode information given by web server)

ident(require) string<delimiter(')content(cgi)delimiter(')>

ident(cgi) operator(=) constant(CGI)operator(.)ident(new)operator(()string<delimiter(')content(html3)delimiter(')>operator(\))

comment(# get a parameter from a form)
ident(value) operator(=) ident(cgi)operator(.)ident(params)operator([)string<delimiter(')content(PARAM_NAME)delimiter(')>operator(])operator([)integer(0)operator(])

comment(# output a document)
ident(cgi)operator(.)ident(out) operator({)
    ident(cgi)operator(.)ident(html) operator({)
        ident(cgi)operator(.)ident(head) operator({) ident(cgi)operator(.)ident(title) operator({) string<delimiter(")content(Howdy there!)delimiter(")> operator(}) operator(}) operator(+)
            ident(cgi)operator(.)ident(body) operator({) ident(cgi)operator(.)ident(p) operator({) string<delimiter(")content(You typed: )delimiter(")> operator(+) ident(cgi)operator(.)ident(tt) operator({)
                    constant(CGI)operator(.)ident(escapeHTML)operator(()ident(value)operator(\)) operator(}) operator(}) operator(})
    operator(})
operator(})

ident(require) string<delimiter(')content(cgi)delimiter(')>
ident(cgi) operator(=) constant(CGI)operator(.)ident(new)
ident(who)   operator(=) ident(cgi)operator(.)ident(param)operator([)string<delimiter(")content(Name)delimiter(")>operator(])operator([)integer(0)operator(])     comment(# first param in list)
ident(phone) operator(=) ident(cgi)operator(.)ident(param)operator([)string<delimiter(")content(Number)delimiter(")>operator(])operator([)integer(0)operator(])
ident(picks) operator(=) ident(cgi)operator(.)ident(param)operator([)string<delimiter(")content(Choices)delimiter(")>operator(])     comment(# complete list)

ident(print) ident(cgi)operator(.)ident(header)operator(() string<delimiter(')content(type)delimiter(')> operator(=)operator(>) string<delimiter(')content(text/plain)delimiter(')>operator(,)
                  string<delimiter(')content(expires)delimiter(')> operator(=)operator(>) constant(Time)operator(.)ident(now) operator(+) operator(()integer(3) operator(*) integer(24) operator(*) integer(60) operator(*) integer(60)operator(\)) operator(\))


comment(# @@PLEAC@@_19.3)
comment(#!/usr/local/bin/ruby -w)
comment(# webwhoami - show web user's id)
ident(require) string<delimiter(')content(etc)delimiter(')>
ident(print) string<delimiter(")content(Content-Type: text/plain)char(\\n)char(\\n)delimiter(")>
ident(print) string<delimiter(")content(Running as )delimiter(")> operator(+) constant(Etc)operator(.)ident(getpwuid)operator(.)ident(name) operator(+) string<delimiter(")char(\\n)delimiter(")>

comment(# % ruby -wc cgi-script     # just check syntax)

comment(# % ruby -w  cgi-script     # params from stdin)
comment(# (offline mode: enter name=value pairs on standard input\))
comment(# name=joe)
comment(# number=10)
comment(# ^D)

comment(# % ruby -w  cgi-script name=joe number=10     # run with mock form input)
comment(# % ruby -d  cgi-script name=joe number=10     # ditto, under the debugger)

comment(# POST method script in csh)
comment(# % (setenv HTTP_METHOD POST; ruby -w cgi-script name=joe number=10\))
comment(# POST method script in sh)
comment(# % HTTP_METHOD=POST perl -w cgi-script name=joe number=10)


comment(# @@PLEAC@@_19.4)
comment(# ruby has several security levels, the level "1" is similar to perls taint mode.)
comment(# It can be switched on by providing the -T command line parameter)
comment(# or by setting $SAFE to 1. Setting $SAFE to 2,3 or 4 restricts possible)
comment(# harmful operations further.)

comment(#!/usr/bin/ruby -T)
global_variable($SAFE) operator(=) integer(1)
constant(File)operator(.)ident(open)operator(()pre_constant(ARGV)operator([)integer(0)operator(])operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
comment(# ruby warns with:)
comment(# taint1.rb:2:in `initialize': Insecure operation - initialize (SecurityError\))

global_variable($SAFE) operator(=) integer(1)
ident(file) operator(=) pre_constant(ARGV)operator([)integer(0)operator(])
reserved(unless) regexp<delimiter(/)content(^([)char(\\w)content(.-]+\)$)delimiter(/)>operator(.)ident(match)operator(()ident(file)operator(\))
    ident(raise) string<delimiter(")content(filename )inline<delimiter(#{)ident(file)delimiter(})>content( has invalid characters)delimiter(")>
reserved(end)
ident(file) operator(=) global_variable($1)
comment(# In ruby, even the back reference from a regular expression stays tainted.)
comment(# you need to explicitly untaint the variable:)
ident(file)operator(.)ident(untaint)
constant(File)operator(.)ident(open)operator(()ident(file)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))

comment(# Race condition exists like in perl:)
reserved(unless) constant(File)operator(.)ident(exists)operator(()ident(filename)operator(\))        comment(# Wrong because of race condition)
    constant(File)operator(.)ident(open)operator(()ident(filename)operator(,) string<delimiter(")content(w)delimiter(")>operator(\))
reserved(end)


comment(# @@PLEAC@@_19.8)
ident(url) operator(=) string<delimiter(")content(http://pleac.sourceforge.net/pleac_ruby/)delimiter(")>
ident(print) string<delimiter(")content(Location: )inline<delimiter(#{)ident(url)delimiter(})>char(\\r)char(\\n)char(\\r)char(\\n)delimiter(")>
ident(exit)

comment(#!/usr/bin/ruby)
ident(require) string<delimiter(')content(cgi)delimiter(')>

ident(cgi) operator(=) constant(CGI)operator(.)ident(new)
ident(oreo) operator(=) constant(CGI)operator(::)constant(Cookie)operator(.)ident(new)operator(()string<delimiter(')content(name)delimiter(')> operator(=)operator(>) string<delimiter(')content(filling)delimiter(')>operator(,)
                       string<delimiter(')content(value)delimiter(')> operator(=)operator(>) string<delimiter(')content(vanilla creme)delimiter(')>operator(,)
                       string<delimiter(')content(expires)delimiter(')> operator(=)operator(>) constant(Time)operator(.)ident(now) operator(+) operator(()integer(3) operator(*) integer(30) operator(*) integer(24) operator(*) integer(60) operator(*) integer(60)operator(\))operator(,)
                       string<delimiter(')content(domain)delimiter(')> operator(=)operator(>) string<delimiter(')content(.pleac.sourceforge.net)delimiter(')>operator(\))

ident(whither) operator(=) string<delimiter(')content(http://pleac.sourceforge.net/pleac_ruby/cgiprogramming.html)delimiter(')>

ident(cgi)operator(.)ident(out)operator(()string<delimiter(')content(cookie)delimiter(')> operator(=)operator(>) ident(oreo)operator(,)
        string<delimiter(')content(Location)delimiter(')> operator(=)operator(>) ident(whither)operator(\))operator({)string<delimiter(")delimiter(")>operator(})

comment(#!/usr/bin/ruby)
comment(# os_snipe - redirect to a Jargon File entry about current OS)
ident(dir) operator(=) string<delimiter(')content(http://www.elsewhere.org/jargon/html/entry)delimiter(')>

ident(agent) operator(=) constant(ENV)operator([)string<delimiter(')content(HTTP_USER_AGENT)delimiter(')>operator(])

ident(page) operator(=) reserved(case)
    reserved(when) ident(agent) operator(=)operator(~) regexp<delimiter(/)content(Mac)delimiter(/)>operator(:) string<delimiter(')content(Macintrash.html)delimiter(')>
    reserved(when) ident(agent) operator(=)operator(~) regexp<delimiter(/)content(Win(dows \)?NT)delimiter(/)>operator(:) string<delimiter(')content(evil_and_rude.html)delimiter(')>
    reserved(when) ident(agent) operator(=)operator(~) regexp<delimiter(/)content(Win|MSIE|WebTV)delimiter(/)>operator(:) string<delimiter(')content(Microsloth_Windows.html)delimiter(')>
    reserved(when) ident(agent) operator(=)operator(~) regexp<delimiter(/)content(Linux)delimiter(/)>operator(:) string<delimiter(')content(Linux.html)delimiter(')>
    reserved(when) ident(agent) operator(=)operator(~) regexp<delimiter(/)content(HP-UX)delimiter(/)>operator(:) string<delimiter(')content(HP-SUX.html)delimiter(')>
    reserved(when) ident(agent) operator(=)operator(~) regexp<delimiter(/)content(SunOS)delimiter(/)>operator(:) string<delimiter(')content(ScumOS.html)delimiter(')>
    reserved(else) string<delimiter(')content(Appendix_B.html)delimiter(')>
reserved(end)

ident(print) string<delimiter(")content(Location: )inline<delimiter(#{)ident(dir)delimiter(})>content(/)inline<delimiter(#{)ident(page)delimiter(})>char(\\n)char(\\n)delimiter(")>

ident(require) string<delimiter(')content(cgi)delimiter(')>
ident(cgi) operator(=) constant(CGI)operator(.)ident(new)
ident(cgi)operator(.)ident(out)operator(()string<delimiter(')content(status)delimiter(')> operator(=)operator(>) string<delimiter(')content(204 No response)delimiter(')>operator(\))operator({)string<delimiter(")delimiter(")>operator(})
comment(# this produces:)
comment(# Status: 204 No response)
comment(# Content-Type: text/html)
comment(# Content-Length: 0)
comment(# <blank line here>)


comment(# @@PLEAC@@_19.10)
ident(preference_value) operator(=) ident(cgi)operator(.)ident(cookies)operator([)string<delimiter(")content(preference name)delimiter(")>operator(])operator([)integer(0)operator(])

ident(packed_cookie) operator(=) constant(CGI)operator(::)constant(Cookie)operator(.)ident(new)operator(()string<delimiter(")content(name)delimiter(")> operator(=)operator(>) string<delimiter(")content(preference name)delimiter(")>operator(,)
                                string<delimiter(")content(value)delimiter(")> operator(=)operator(>) string<delimiter(")content(whatever you'd like)delimiter(")>operator(,)
                                string<delimiter(")content(expires)delimiter(")> operator(=)operator(>) constant(Time)operator(.)ident(local)operator(()constant(Time)operator(.)ident(now)operator(.)ident(year) operator(+) integer(2)operator(,)
    constant(Time)operator(.)ident(now)operator(.)ident(mon)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(day)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(hour)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(min)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(sec)operator(\)) operator(\))

ident(cgi)operator(.)ident(header)operator(()string<delimiter(")content(cookie)delimiter(")> operator(=)operator(>) operator([)ident(packed_cookie)operator(])operator(\))

comment(#!/usr/local/bin/ruby -w)
comment(# ic_cookies - sample CGI script that uses a cookie)
ident(require) string<delimiter(')content(cgi)delimiter(')>

ident(cgi) operator(=) constant(CGI)operator(.)ident(new)operator(()string<delimiter(')content(html3)delimiter(')>operator(\))

ident(cookname) operator(=) string<delimiter(")content(favorite ice cream)delimiter(")>
ident(favorite) operator(=) ident(cgi)operator(.)ident(params)operator([)string<delimiter(")content(flavor)delimiter(")>operator(])operator([)integer(0)operator(])
ident(tasty)    operator(=) ident(cgi)operator(.)ident(cookies)operator([)ident(cookname)operator(])operator([)integer(0)operator(]) operator(||) string<delimiter(')content(mint)delimiter(')>

reserved(unless) ident(favorite)
    ident(cgi)operator(.)ident(out) operator({)
        ident(cgi)operator(.)ident(html) operator({)
            ident(cgi)operator(.)ident(head) operator({) ident(cgi)operator(.)ident(title) operator({) string<delimiter(")content(Ice Cookies)delimiter(")> operator(}) operator(}) operator(+)
            ident(cgi)operator(.)ident(body) operator({)
                ident(cgi)operator(.)ident(h1) operator({) string<delimiter(")content(Hello Ice Cream)delimiter(")> operator(}) operator(+)
                ident(cgi)operator(.)ident(hr) operator(+)
                ident(cgi)operator(.)ident(form) operator({)
                    ident(cgi)operator(.)ident(p) operator({) string<delimiter(")content(Please select a flavor: )delimiter(")> operator(+)
                            ident(cgi)operator(.)ident(text_field)operator(()string<delimiter(")content(flavor)delimiter(")>operator(,) ident(tasty) operator(\)) operator(})
                operator(}) operator(+)
                ident(cgi)operator(.)ident(hr)
            operator(})
        operator(})
    operator(})
reserved(else)
    ident(cookie) operator(=) constant(CGI)operator(::)constant(Cookie)operator(.)ident(new)operator(() string<delimiter(")content(name)delimiter(")>    operator(=)operator(>) ident(cookname)operator(,)
                              string<delimiter(")content(value)delimiter(")>   operator(=)operator(>) ident(favorite)operator(,)
                              string<delimiter(")content(expires)delimiter(")> operator(=)operator(>) constant(Time)operator(.)ident(local)operator(()constant(Time)operator(.)ident(now)operator(.)ident(year) operator(+) integer(2)operator(,)
constant(Time)operator(.)ident(now)operator(.)ident(mon)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(day)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(hour)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(min)operator(,) constant(Time)operator(.)ident(now)operator(.)ident(sec)operator(\)) operator(\))
    ident(cgi)operator(.)ident(out)operator(()string<delimiter(")content(cookie)delimiter(")> operator(=)operator(>) operator([)ident(cookie)operator(])operator(\)) operator({)
        ident(cgi)operator(.)ident(html) operator({)
            ident(cgi)operator(.)ident(head) operator({) ident(cgi)operator(.)ident(title) operator({) string<delimiter(")content(Ice Cookies)delimiter(")> operator(}) operator(}) operator(+)
            ident(cgi)operator(.)ident(body) operator({)
                ident(cgi)operator(.)ident(h1) operator({) string<delimiter(")content(Hello Ice Cream)delimiter(")> operator(}) operator(+)
                ident(cgi)operator(.)ident(p) operator({) string<delimiter(")content(You chose as your favorite flavor `)inline<delimiter(#{)ident(favorite)delimiter(})>content('.)delimiter(")> operator(})
            operator(})
        operator(})
    operator(})
reserved(end)


comment(# @@PLEAC@@_20.9)
reserved(def) method(templatefile)operator(()ident(filename)operator(,) ident(fillings)operator(\))
    ident(aFile) operator(=) constant(File)operator(.)ident(new)operator(()ident(filename)operator(,) string<delimiter(")content(r)delimiter(")>operator(\))
    ident(text) operator(=) ident(aFile)operator(.)ident(read)operator(()operator(\))
    ident(aFile)operator(.)ident(close)operator(()operator(\))
    ident(pattern) operator(=) constant(Regexp)operator(.)ident(new)operator(()string<delimiter(')content(%%(.*?\)%%)delimiter(')>operator(\))
    ident(text)operator(.)ident(gsub!)operator(()ident(pattern)operator(\)) operator({)
        ident(fillings)operator([)global_variable($1)operator(]) operator(||) string<delimiter(")delimiter(")>
    operator(})
    ident(text)
reserved(end)

ident(fields) operator(=) operator({)
    string<delimiter(')content(username)delimiter(')> operator(=)operator(>) ident(whats_his_name)operator(,)
    string<delimiter(')content(count)delimiter(')> operator(=)operator(>) ident(login_count)operator(,)
    string<delimiter(')content(total)delimiter(')> operator(=)operator(>) ident(minutes_used)
operator(})
ident(puts) ident(templatefile)operator(()string<delimiter(')content(simple.template)delimiter(')>operator(,) ident(fields)operator(\))

comment(# @@INCOMPLETE@@)
comment(# An example using databases is missing)


